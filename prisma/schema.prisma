datasource db {
  provider = "mysql"
  url      = env("DATABASE_URL")
}

generator client {
  provider = "prisma-client-js"
}

enum Role {
  ADMIN
  STUDENT
  USER
}

model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String? @db.Text
  access_token      String? @db.Text
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String? @db.Text
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model User {
  id              String      @id @default(cuid())
  name            String?
  email           String?     @unique
  emailVerified   DateTime?
  image           String?
  hashedPassword  String?
  phoneNumber     String?
  role            Role        @default(USER)
  createdAt       DateTime    @default(now())
  updatedAt       DateTime    @updatedAt
  accounts        Account[]
  sessions        Session[]
  participatedExams LiveExamParticipant[]
  wonExams         LiveExamWinner[]
  createdLiveExams LiveExam[]
  wallet           Float    @default(0)
  transactions     Transaction[]
  createdPracticeExams PracticeExam[]
  participatedPracticeExams PracticeExamParticipant[]
  createdQuestionsOfTheDay QuestionOfTheDay[]
  questionOfTheDayAttempts QuestionOfTheDayAttempt[]
  timetables      Timetable[]
  timetableSlots  TimetableSlot[]
  
  // Battle Quiz Relations
  createdBattleQuizzes BattleQuiz[]
  battleQuizParticipations BattleQuizParticipant[]
  battleQuizWins BattleQuizWinner[]
  player1Matches BattleQuizMatch[] @relation("Player1Matches")
  player2Matches BattleQuizMatch[] @relation("Player2Matches")
  wonMatches BattleQuizMatch[] @relation("WonMatches")
  battleQuizLeaderboard BattleQuizLeaderboard?
  battleStats UserBattleStats?
  
  // Question Bank Relations
  createdQuestionCategories QuestionCategory[]
  createdQuestionBankItems QuestionBankItem[]
  
  // Social Media Features
  profilePhoto    String?
  course          String?
  year            String?
  bio             String?     @db.Text
  isPrivate       Boolean     @default(false)
  
  // Posts
  posts           Post[]
  
  // Follow System
  followers       Follow[]    @relation("UserFollowers")
  following       Follow[]    @relation("UserFollowing")
  
  // Follow Requests
  sentRequests    FollowRequest[] @relation("RequestSender")
  receivedRequests FollowRequest[] @relation("RequestReceiver")
  
  // Engagement
  likes           Like[]
  comments        Comment[]
  savedPosts      SavedPost[]
  
  // Groups
  groupMemberships GroupMember[]
  createdGroups   Group[]
  
  // Group Posts & Messages
  groupPosts      GroupPost[]
  groupMessages   GroupMessage[]
  groupPostLikes  GroupPostLike[]
  groupPostComments GroupPostComment[]
  
  // Group Events
  createdEvents   GroupEvent[]
  eventParticipations GroupEventParticipant[]
  
  // Group Quizzes & Polls
  createdQuizzes  GroupQuiz[]
  quizAttempts    GroupQuizAttempt[]
  createdPolls    GroupPoll[]
  pollVotes       GroupPollVote[]
  
  // Direct Messages
  sentMessages    DirectMessage[] @relation("MessageSender")
  receivedMessages DirectMessage[] @relation("MessageReceiver")
  
  // Message Requests
  sentMessageRequests MessageRequest[] @relation("MessageRequestSender")
  receivedMessageRequests MessageRequest[] @relation("MessageRequestReceiver")
  
  // Stories
  stories        Story[]
  storyViews     StoryView[]
  storyLikes     StoryLike[]
  
  // Referral System
  referralCode   String?     @unique
  referredBy     String?     // Referral code of the user who referred this user
  referralCount  Int         @default(0)
  totalReferralEarnings Float @default(0)
  
  // Referral Relations
  referrals      Referral[]  @relation("ReferrerReferrals")
  referredByUser Referral[]  @relation("ReferredUserReferrals")
  
  // Support Ticket Relations
  supportTickets SupportTicket[]
  assignedTickets SupportTicket[] @relation("AssignedTickets")
  ticketReplies  SupportTicketReply[]
}

model LiveExam {
  id          String      @id @default(cuid())
  title       String
  description String?
  instructions String?    @db.Text
  category    String?
  imageUrl    String?     // URL for exam logo/image
  duration    Int         // in minutes
  spots       Int
  spotsLeft   Int
  entryFee    Float
  totalCollection Float
  prizePool   Float
  startTime   DateTime
  endTime     DateTime?
  isLive      Boolean    @default(false)
  winningsDistributed Boolean @default(false)
  createdAt   DateTime   @default(now())
  updatedAt   DateTime   @updatedAt
  createdBy   User       @relation(fields: [createdById], references: [id])
  createdById String
  questions   Question[]
  participants LiveExamParticipant[]
  winners     LiveExamWinner[]
}

model LiveExamParticipant {
  id          String    @id @default(cuid())
  exam        LiveExam  @relation(fields: [examId], references: [id])
  examId      String
  user        User      @relation(fields: [userId], references: [id])
  userId      String
  score       Int?
  answers     Json?     // Store answers as JSON
  startedAt   DateTime  @default(now())
  completedAt DateTime?
  paid        Boolean   @default(false)
  paymentId   String?   // Reference to payment transaction
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  @@unique([examId, userId])
}

model LiveExamWinner {
  id          String    @id @default(cuid())
  exam        LiveExam  @relation(fields: [examId], references: [id])
  examId      String
  user        User      @relation(fields: [userId], references: [id])
  userId      String
  rank        Int
  prizeAmount Float
  paid        Boolean   @default(false)
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  @@unique([examId, rank])
}

model Question {
  id          String    @id @default(cuid())
  text        String?   @db.Text
  options     Json?     // Array of options
  correct     Int?      // Index of correct option
  exam        LiveExam? @relation(fields: [examId], references: [id])
  examId      String?
}

model Transaction {
  id        String    @id @default(cuid())
  userId    String
  amount    Float
  type      String
  status    String
  createdAt DateTime  @default(now())
  user      User      @relation(fields: [userId], references: [id])
}

model PracticeExam {
  id          String      @id @default(cuid())
  title       String
  description String?
  instructions String?    @db.Text
  duration    Int         // in minutes
  spots       Int
  spotsLeft   Int
  startTime   DateTime
  endTime     DateTime?
  createdAt   DateTime   @default(now())
  updatedAt   DateTime   @updatedAt
  createdBy   User       @relation(fields: [createdById], references: [id])
  createdById String
  questions   PracticeExamQuestion[]
  participants PracticeExamParticipant[]
  category    String
  subcategory String
}

model PracticeExamParticipant {
  id          String    @id @default(cuid())
  exam        PracticeExam  @relation(fields: [examId], references: [id])
  examId      String
  user        User      @relation(fields: [userId], references: [id])
  userId      String
  score       Int?
  answers     Json?     // Store answers as JSON
  startedAt   DateTime  @default(now())
  completedAt DateTime?
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  @@unique([examId, userId])
}

model PracticeExamQuestion {
  id          String    @id @default(cuid())
  text        String?   @db.Text
  options     Json?     // Array of options
  correct     Int?      // Index of correct option
  marks       Int       @default(1) // Marks for this question
  exam        PracticeExam? @relation(fields: [examId], references: [id])
  examId      String?
}

model GovtExamNotification {
  id            String   @id @default(cuid())
  title         String
  description   String   @db.Text
  year          Int
  month         Int
  applyLastDate DateTime
  applyLink     String
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
}

model QuestionOfTheDay {
  id          String    @id @default(cuid())
  question    String    @db.Text
  options     Json      // Array of options
  correct     Int       // Index of correct option
  timeLimit   Int       @default(10) // Time limit in seconds
  isActive    Boolean   @default(true)
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  createdBy   User      @relation(fields: [createdById], references: [id])
  createdById String
  attempts    QuestionOfTheDayAttempt[]
}

model QuestionOfTheDayAttempt {
  id          String    @id @default(cuid())
  question    QuestionOfTheDay @relation(fields: [questionId], references: [id])
  questionId  String
  user        User      @relation(fields: [userId], references: [id])
  userId      String
  selected    Int       // Index of selected option
  isCorrect   Boolean
  timeTaken   Int       // Time taken in seconds
  createdAt   DateTime  @default(now())

  @@unique([questionId, userId])
}

model Timetable {
  id          String    @id @default(cuid())
  name        String
  description String?
  isWeekly    Boolean   @default(false)
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  user        User      @relation(fields: [userId], references: [id])
  userId      String
  slots       TimetableSlot[]
}

model TimetableSlot {
  id          String    @id @default(cuid())
  day         Int       // 0-6 for Sunday-Saturday
  startTime   DateTime
  endTime     DateTime
  subject     String
  topic       String?
  notes       String?   @db.Text
  isCompleted Boolean   @default(false)
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  timetable   Timetable @relation(fields: [timetableId], references: [id], onDelete: Cascade)
  timetableId String
  user        User      @relation(fields: [userId], references: [id])
  userId      String
  reminder    Boolean   @default(true)
  reminderSent Boolean  @default(false)

  @@index([userId, day, startTime])
}

model Post {
  id          String    @id @default(cuid())
  content     String    @db.Text
  imageUrl    String?
  videoUrl    String?
  hashtags    Json?     // Array of hashtags
  isPrivate   Boolean   @default(false)
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  
  // Relations
  author      User      @relation(fields: [authorId], references: [id], onDelete: Cascade)
  authorId    String
  
  // Engagement
  likes       Like[]
  comments    Comment[]
  savedBy     SavedPost[]
  
  // Tags
  taggedUsers Json?     // Array of tagged user IDs
  
  @@index([authorId, createdAt])
}

model Follow {
  id          String    @id @default(cuid())
  follower    User      @relation("UserFollowers", fields: [followerId], references: [id], onDelete: Cascade)
  followerId  String
  following   User      @relation("UserFollowing", fields: [followingId], references: [id], onDelete: Cascade)
  followingId String
  createdAt   DateTime  @default(now())

  @@unique([followerId, followingId])
}

model FollowRequest {
  id          String    @id @default(cuid())
  sender      User      @relation("RequestSender", fields: [senderId], references: [id], onDelete: Cascade)
  senderId    String
  receiver    User      @relation("RequestReceiver", fields: [receiverId], references: [id], onDelete: Cascade)
  receiverId  String
  status      RequestStatus @default(PENDING)
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  @@unique([senderId, receiverId])
}

model Like {
  id          String    @id @default(cuid())
  user        User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId      String
  post        Post      @relation(fields: [postId], references: [id], onDelete: Cascade)
  postId      String
  createdAt   DateTime  @default(now())

  @@unique([userId, postId])
}

model Comment {
  id          String    @id @default(cuid())
  content     String    @db.Text
  user        User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId      String
  post        Post      @relation(fields: [postId], references: [id], onDelete: Cascade)
  postId      String
  parentId    String?   // For replies
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  @@index([postId, createdAt])
}

model SavedPost {
  id          String    @id @default(cuid())
  user        User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId      String
  post        Post      @relation(fields: [postId], references: [id], onDelete: Cascade)
  postId      String
  createdAt   DateTime  @default(now())

  @@unique([userId, postId])
}

model DirectMessage {
  id          String    @id @default(cuid())
  content     String    @db.Text
  messageType MessageType @default(TEXT)
  fileUrl     String?   // For file attachments
  isRead      Boolean   @default(false)
  createdAt   DateTime  @default(now())
  
  // Relations
  sender      User      @relation("MessageSender", fields: [senderId], references: [id], onDelete: Cascade)
  senderId    String
  receiver    User      @relation("MessageReceiver", fields: [receiverId], references: [id], onDelete: Cascade)
  receiverId  String
  
  @@index([senderId, receiverId, createdAt])
  @@index([receiverId, senderId, createdAt])
}

model MessageRequest {
  id          String    @id @default(cuid())
  content     String    @db.Text
  messageType MessageType @default(TEXT)
  fileUrl     String?   // For file attachments
  status      MessageRequestStatus @default(PENDING)
  createdAt   DateTime  @default(now())
  respondedAt DateTime?
  
  // Relations
  sender      User      @relation("MessageRequestSender", fields: [senderId], references: [id], onDelete: Cascade)
  senderId    String
  receiver    User      @relation("MessageRequestReceiver", fields: [receiverId], references: [id], onDelete: Cascade)
  receiverId  String
  
  @@index([senderId, receiverId, createdAt])
  @@index([receiverId, senderId, createdAt])
}

model Group {
  id          String    @id @default(cuid())
  name        String
  description String?   @db.Text
  imageUrl    String?
  isPrivate   Boolean   @default(false)
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  
  // Relations
  creator     User      @relation(fields: [creatorId], references: [id])
  creatorId   String
  members     GroupMember[]
  posts       GroupPost[]
  messages    GroupMessage[]
  events      GroupEvent[]
  quizzes     GroupQuiz[]
  polls       GroupPoll[]
}

model GroupMember {
  id          String    @id @default(cuid())
  user        User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId      String
  group       Group     @relation(fields: [groupId], references: [id], onDelete: Cascade)
  groupId     String
  role        GroupRole @default(MEMBER)
  joinedAt    DateTime  @default(now())

  @@unique([userId, groupId])
}

model GroupPost {
  id          String    @id @default(cuid())
  content     String    @db.Text
  imageUrl    String?
  videoUrl    String?
  fileUrl     String?   // For study materials
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  
  // Relations
  author      User      @relation(fields: [authorId], references: [id], onDelete: Cascade)
  authorId    String
  group       Group     @relation(fields: [groupId], references: [id], onDelete: Cascade)
  groupId     String
  
  // Engagement
  likes       GroupPostLike[]
  comments    GroupPostComment[]
  
  @@index([groupId, createdAt])
}

model GroupPostLike {
  id          String    @id @default(cuid())
  user        User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId      String
  post        GroupPost @relation(fields: [postId], references: [id], onDelete: Cascade)
  postId      String
  createdAt   DateTime  @default(now())

  @@unique([userId, postId])
}

model GroupPostComment {
  id          String    @id @default(cuid())
  content     String    @db.Text
  user        User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId      String
  post        GroupPost @relation(fields: [postId], references: [id], onDelete: Cascade)
  postId      String
  parentId    String?   // For replies
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  @@index([postId, createdAt])
}

model GroupMessage {
  id          String    @id @default(cuid())
  content     String    @db.Text
  messageType MessageType @default(TEXT)
  fileUrl     String?   // For file attachments
  createdAt   DateTime  @default(now())
  
  // Relations
  sender      User      @relation(fields: [senderId], references: [id], onDelete: Cascade)
  senderId    String
  group       Group     @relation(fields: [groupId], references: [id], onDelete: Cascade)
  groupId     String
  
  @@index([groupId, createdAt])
}

model GroupEvent {
  id          String    @id @default(cuid())
  title       String
  description String?   @db.Text
  startTime   DateTime
  endTime     DateTime
  location    String?   // Can be physical location or online meeting link
  eventType   EventType @default(STUDY_SESSION)
  maxParticipants Int?
  isRecurring Boolean   @default(false)
  recurrence  Json?     // Store recurrence pattern
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  
  // Relations
  group       Group     @relation(fields: [groupId], references: [id], onDelete: Cascade)
  groupId     String
  creator     User      @relation(fields: [creatorId], references: [id])
  creatorId   String
  participants GroupEventParticipant[]
  
  @@index([groupId, startTime])
}

model GroupEventParticipant {
  id          String    @id @default(cuid())
  user        User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId      String
  event       GroupEvent @relation(fields: [eventId], references: [id], onDelete: Cascade)
  eventId     String
  status      ParticipationStatus @default(ATTENDING)
  joinedAt    DateTime  @default(now())

  @@unique([userId, eventId])
}

model GroupQuiz {
  id          String    @id @default(cuid())
  title       String
  description String?   @db.Text
  questions   Json      // Array of questions with options and correct answers
  timeLimit   Int?      // Time limit in minutes
  isActive    Boolean   @default(true)
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  
  // Relations
  group       Group     @relation(fields: [groupId], references: [id], onDelete: Cascade)
  groupId     String
  creator     User      @relation(fields: [creatorId], references: [id])
  creatorId   String
  attempts    GroupQuizAttempt[]
  
  @@index([groupId, createdAt])
}

model GroupQuizAttempt {
  id          String    @id @default(cuid())
  user        User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId      String
  quiz        GroupQuiz @relation(fields: [quizId], references: [id], onDelete: Cascade)
  quizId      String
  answers     Json      // User's answers
  score       Int       // Score percentage
  timeTaken   Int       // Time taken in seconds
  completedAt DateTime  @default(now())

  @@unique([userId, quizId])
}

model GroupPoll {
  id          String    @id @default(cuid())
  question    String    @db.Text
  options     Json      // Array of poll options
  isMultiple  Boolean   @default(false) // Allow multiple selections
  isActive    Boolean   @default(true)
  expiresAt   DateTime?
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  
  // Relations
  group       Group     @relation(fields: [groupId], references: [id], onDelete: Cascade)
  groupId     String
  creator     User      @relation(fields: [creatorId], references: [id])
  creatorId   String
  votes       GroupPollVote[]
  
  @@index([groupId, createdAt])
}

model GroupPollVote {
  id          String    @id @default(cuid())
  user        User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId      String
  poll        GroupPoll @relation(fields: [pollId], references: [id], onDelete: Cascade)
  pollId      String
  selectedOptions Json  // Array of selected option indices
  createdAt   DateTime  @default(now())

  @@unique([userId, pollId])
}

enum RequestStatus {
  PENDING
  ACCEPTED
  DECLINED
}

enum GroupRole {
  ADMIN
  MODERATOR
  MEMBER
}

enum MessageType {
  TEXT
  IMAGE
  FILE
  SYSTEM
}

enum EventType {
  STUDY_SESSION
  QUIZ
  DISCUSSION
  PRESENTATION
  EXAM_PREP
  SOCIAL
}

enum ParticipationStatus {
  ATTENDING
  NOT_ATTENDING
  MAYBE
}

enum MessageRequestStatus {
  PENDING
  ACCEPTED
  REJECTED
}

// Battle Quiz Models
model BattleQuiz {
  id          String    @id @default(cuid())
  title       String
  description String?
  entryAmount Float
  categoryId  String?   // Reference to question category
  questionCount Int     @default(10) // Number of questions to pick randomly
  timePerQuestion Int   @default(15) // Time limit per question in seconds
  isActive    Boolean   @default(true)
  isPrivate   Boolean   @default(false) // For private room matches
  roomCode    String?   @unique // For private room invites
  maxPlayers  Int       @default(2) // For future expansion to team battles
  status      BattleQuizStatus @default(WAITING) // Quiz status
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  
  // Relations
  createdBy   User      @relation(fields: [createdById], references: [id])
  createdById String
  category    QuestionCategory? @relation(fields: [categoryId], references: [id])
  questions   BattleQuizQuestion[]
  participants BattleQuizParticipant[]
  winners     BattleQuizWinner[]
  matches     BattleQuizMatch[]
}

model BattleQuizQuestion {
  id          String    @id @default(cuid())
  text        String    @db.Text
  options     Json      // Array of options
  correct     Int       // Index of correct option
  marks       Int       @default(1)
  difficulty  QuestionDifficulty @default(MEDIUM)
  explanation String?   @db.Text
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  
  // Relations
  quiz        BattleQuiz @relation(fields: [quizId], references: [id], onDelete: Cascade)
  quizId      String
}

model BattleQuizParticipant {
  id        String    @id @default(cuid())
  quizId    String
  userId    String
  matchId   String?
  status    BattleParticipantStatus @default(WAITING)
  score     Int       @default(0)
  answers   Json      // Store answers with timestamps
  responseTimes Json? // Store response time for each question
  joinedAt  DateTime  @default(now())
  
  // Relations
  quiz      BattleQuiz @relation(fields: [quizId], references: [id], onDelete: Cascade)
  user      User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  match     BattleQuizMatch? @relation(fields: [matchId], references: [id])
}

model BattleQuizWinner {
  id          String    @id @default(cuid())
  rank        Int
  prizeAmount Float
  paid        Boolean   @default(false)
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  
  // Relations
  quiz        BattleQuiz @relation(fields: [quizId], references: [id], onDelete: Cascade)
  quizId      String
  user        User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId      String

  @@unique([quizId, rank])
}

// Real-time Battle Quiz Matches
model BattleQuizMatch {
  id            String    @id @default(cuid())
  quizId        String
  player1Id     String
  player2Id     String
  status        BattleMatchStatus @default(WAITING)
  currentRound  Int       @default(0)
  totalRounds   Int       @default(5)
  player1Score  Int       @default(0)
  player2Score  Int       @default(0)
  player1Answers Json?    // Store answers with timestamps
  player2Answers Json?    // Store answers with timestamps
  startTime     DateTime  @default(now())
  endTime       DateTime?
  winnerId      String?
  prizeAmount   Float?
  isPrivate     Boolean   @default(false)
  roomCode      String?   // For private matches
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt
  
  // Relations
  quiz          BattleQuiz @relation(fields: [quizId], references: [id], onDelete: Cascade)
  player1       User      @relation("Player1Matches", fields: [player1Id], references: [id])
  player2       User      @relation("Player2Matches", fields: [player2Id], references: [id])
  winner        User?     @relation("WonMatches", fields: [winnerId], references: [id])
  participants  BattleQuizParticipant[]
}

// Global Leaderboard System
model BattleQuizLeaderboard {
  id          String    @id @default(cuid())
  userId      String
  totalMatches Int      @default(0)
  wins        Int       @default(0)
  losses      Int       @default(0)
  draws       Int       @default(0)
  totalScore  Int       @default(0)
  averageScore Float    @default(0)
  winStreak   Int       @default(0)
  bestWinStreak Int     @default(0)
  totalPrizeMoney Float @default(0)
  level       Int       @default(1)
  experience  Int       @default(0)
  lastUpdated DateTime  @default(now())
  
  // Relations
  user        User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@unique([userId])
  @@index([totalScore])
  @@index([wins])
  @@index([level])
}

// User Stats for Battle Quiz
model UserBattleStats {
  id                String    @id @default(cuid())
  userId            String    @unique
  totalMatches      Int       @default(0)
  wins              Int       @default(0)
  losses            Int       @default(0)
  draws             Int       @default(0)
  winRate           Float     @default(0)
  totalScore        Int       @default(0)
  averageScore      Float     @default(0)
  fastestAnswer     Int?      // Fastest answer time in milliseconds
  totalPrizeMoney   Float     @default(0)
  currentStreak     Int       @default(0)
  bestStreak        Int       @default(0)
  level             Int       @default(1)
  experience        Int       @default(0)
  experienceToNext  Int       @default(100)
  favoriteCategory  String?
  createdAt         DateTime  @default(now())
  updatedAt         DateTime  @updatedAt
  
  // Relations
  user              User      @relation(fields: [userId], references: [id], onDelete: Cascade)
}

enum BattleMatchStatus {
  WAITING
  STARTING
  PLAYING
  FINISHED
  CANCELLED
  TIMEOUT
}

enum BattleParticipantStatus {
  WAITING
  READY
  PLAYING
  FINISHED
  DISCONNECTED
}

enum BattleQuizStatus {
  WAITING
  ACTIVE
  FINISHED
  CANCELLED
}

// Question Bank System
model QuestionCategory {
  id          String    @id @default(cuid())
  name        String    @unique
  description String?
  color       String?   // For UI styling
  isActive    Boolean   @default(true)
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  
  // Relations
  createdBy   User      @relation(fields: [createdById], references: [id])
  createdById String
  questions   QuestionBankItem[]
  battleQuizzes BattleQuiz[]
}

model QuestionBankItem {
  id          String    @id @default(cuid())
  text        String    @db.Text
  options     Json      // Array of options
  correct     Int       // Index of correct option
  explanation String?   @db.Text // Explanation for the correct answer
  difficulty  QuestionDifficulty @default(MEDIUM)
  tags        Json?     // Array of tags for better organization
  isActive    Boolean   @default(true)
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  
  // Relations
  category    QuestionCategory @relation(fields: [categoryId], references: [id], onDelete: Cascade)
  categoryId  String
  createdBy   User      @relation(fields: [createdById], references: [id])
  createdById String
}

enum QuestionDifficulty {
  EASY
  MEDIUM
  HARD
}

model Story {
  id          String    @id @default(cuid())
  mediaUrl    String    // URL to image/video
  mediaType   StoryMediaType @default(IMAGE)
  caption     String?   @db.Text
  createdAt   DateTime  @default(now())
  expiresAt   DateTime  // 24 hours from creation
  
  // Relations
  author      User      @relation(fields: [authorId], references: [id], onDelete: Cascade)
  authorId    String
  
  // Views
  views       StoryView[]
  
  // Likes
  likes       StoryLike[]
  
  @@index([authorId, createdAt])
  @@index([expiresAt])
}

model StoryView {
  id          String    @id @default(cuid())
  viewedAt    DateTime  @default(now())
  
  // Relations
  story       Story     @relation(fields: [storyId], references: [id], onDelete: Cascade)
  storyId     String
  viewer      User      @relation(fields: [viewerId], references: [id], onDelete: Cascade)
  viewerId    String
  
  @@unique([storyId, viewerId])
  @@index([storyId, viewedAt])
}

model StoryLike {
  id          String    @id @default(cuid())
  createdAt   DateTime  @default(now())
  
  // Relations
  story       Story     @relation(fields: [storyId], references: [id], onDelete: Cascade)
  storyId     String
  user        User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId      String
  
  @@unique([storyId, userId])
  @@index([storyId, createdAt])
}

enum StoryMediaType {
  IMAGE
  VIDEO
}

model Referral {
  id          String    @id @default(cuid())
  referrer    User      @relation("ReferrerReferrals", fields: [referrerId], references: [id], onDelete: Cascade)
  referrerId  String
  referred    User      @relation("ReferredUserReferrals", fields: [referredId], references: [id], onDelete: Cascade)
  referredId  String
  code        String    @unique
  joinedAt    DateTime  @default(now())

  @@unique([referrerId, referredId])
}

// Support Ticket System
model SupportTicket {
  id          String    @id @default(cuid())
  ticketId    String    @unique // Auto-generated ticket ID like "TKT-2024-001"
  title       String
  description String    @db.Text
  issueType   TicketIssueType
  priority    TicketPriority @default(MEDIUM)
  status      TicketStatus @default(OPEN)
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  resolvedAt  DateTime?
  
  // Relations
  user        User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId      String
  assignedTo  User?     @relation("AssignedTickets", fields: [assignedToId], references: [id])
  assignedToId String?
  replies     SupportTicketReply[]
  attachments SupportTicketAttachment[]
  
  @@index([userId, createdAt])
  @@index([status, priority])
  @@index([assignedToId])
}

model SupportTicketReply {
  id          String    @id @default(cuid())
  content     String    @db.Text
  isInternal  Boolean   @default(false) // Internal notes not visible to user
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  
  // Relations
  ticket      SupportTicket @relation(fields: [ticketId], references: [id], onDelete: Cascade)
  ticketId    String
  user        User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId      String
  attachments SupportTicketAttachment[]
  
  @@index([ticketId, createdAt])
}

model SupportTicketAttachment {
  id          String    @id @default(cuid())
  fileName    String
  fileUrl     String
  fileSize    Int       // File size in bytes
  mimeType    String
  createdAt   DateTime  @default(now())
  
  // Relations
  ticket      SupportTicket? @relation(fields: [ticketId], references: [id], onDelete: Cascade)
  ticketId    String?
  reply       SupportTicketReply? @relation(fields: [replyId], references: [id], onDelete: Cascade)
  replyId     String?
  
  @@index([ticketId])
  @@index([replyId])
}

enum TicketIssueType {
  TECHNICAL_ISSUE
  PAYMENT_PROBLEM
  EXAM_ACCESS
  ACCOUNT_ISSUE
  FEATURE_REQUEST
  BUG_REPORT
  GENERAL_INQUIRY
  OTHER
}

enum TicketPriority {
  LOW
  MEDIUM
  HIGH
  URGENT
}

enum TicketStatus {
  OPEN
  IN_PROGRESS
  WAITING_FOR_USER
  RESOLVED
  CLOSED
}