datasource db {
  provider = "mysql"
  url      = env("DATABASE_URL")
}

generator client {
  provider = "prisma-client-js"
}

enum Role {
  ADMIN
  STUDENT
  USER
}

model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String? @db.Text
  access_token      String? @db.Text
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String? @db.Text
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model User {
  id              String      @id @default(cuid())
  name            String?
  email           String?     @unique
  emailVerified   DateTime?
  image           String?
  hashedPassword  String?
  phoneNumber     String?
  role            Role        @default(USER)
  createdAt       DateTime    @default(now())
  updatedAt       DateTime    @updatedAt
  accounts        Account[]
  sessions        Session[]
  participatedExams LiveExamParticipant[]
  wonExams         LiveExamWinner[]
  createdLiveExams LiveExam[]
  wallet           Float    @default(0)
  transactions     Transaction[]
  createdPracticeExams PracticeExam[]
  participatedPracticeExams PracticeExamParticipant[]
  createdQuestionsOfTheDay QuestionOfTheDay[]
  questionOfTheDayAttempts QuestionOfTheDayAttempt[]
  timetables      Timetable[]
  timetableSlots  TimetableSlot[]
  
  // Social Media Features
  profilePhoto    String?
  course          String?
  year            String?
  bio             String?     @db.Text
  isPrivate       Boolean     @default(false)
  
  // Posts
  posts           Post[]
  
  // Follow System
  followers       Follow[]    @relation("UserFollowers")
  following       Follow[]    @relation("UserFollowing")
  
  // Follow Requests
  sentRequests    FollowRequest[] @relation("RequestSender")
  receivedRequests FollowRequest[] @relation("RequestReceiver")
  
  // Engagement
  likes           Like[]
  comments        Comment[]
  savedPosts      SavedPost[]
  
  // Groups
  groupMemberships GroupMember[]
  createdGroups   Group[]
  
  // Group Posts & Messages
  groupPosts      GroupPost[]
  groupMessages   GroupMessage[]
  groupPostLikes  GroupPostLike[]
  groupPostComments GroupPostComment[]
  
  // Group Events
  createdEvents   GroupEvent[]
  eventParticipations GroupEventParticipant[]
  
  // Group Quizzes & Polls
  createdQuizzes  GroupQuiz[]
  quizAttempts    GroupQuizAttempt[]
  createdPolls    GroupPoll[]
  pollVotes       GroupPollVote[]
  
  // Direct Messages
  sentMessages    DirectMessage[] @relation("MessageSender")
  receivedMessages DirectMessage[] @relation("MessageReceiver")
}

model LiveExam {
  id          String      @id @default(cuid())
  title       String
  description String?
  duration    Int         // in minutes
  spots       Int
  spotsLeft   Int
  entryFee    Float
  totalCollection Float
  prizePool   Float
  startTime   DateTime
  endTime     DateTime?
  isLive      Boolean    @default(false)
  winningsDistributed Boolean @default(false)
  createdAt   DateTime   @default(now())
  updatedAt   DateTime   @updatedAt
  createdBy   User       @relation(fields: [createdById], references: [id])
  createdById String
  questions   Question[]
  participants LiveExamParticipant[]
  winners     LiveExamWinner[]
}

model LiveExamParticipant {
  id          String    @id @default(cuid())
  exam        LiveExam  @relation(fields: [examId], references: [id])
  examId      String
  user        User      @relation(fields: [userId], references: [id])
  userId      String
  score       Int?
  answers     Json?     // Store answers as JSON
  startedAt   DateTime  @default(now())
  completedAt DateTime?
  paid        Boolean   @default(false)
  paymentId   String?   // Reference to payment transaction
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  @@unique([examId, userId])
}

model LiveExamWinner {
  id          String    @id @default(cuid())
  exam        LiveExam  @relation(fields: [examId], references: [id])
  examId      String
  user        User      @relation(fields: [userId], references: [id])
  userId      String
  rank        Int
  prizeAmount Float
  paid        Boolean   @default(false)
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  @@unique([examId, rank])
}

model Question {
  id          String    @id @default(cuid())
  text        String?   @db.Text
  options     Json?     // Array of options
  correct     Int?      // Index of correct option
  exam        LiveExam? @relation(fields: [examId], references: [id])
  examId      String?
}

model Transaction {
  id        String    @id @default(cuid())
  userId    String
  amount    Float
  type      String
  status    String
  createdAt DateTime  @default(now())
  user      User      @relation(fields: [userId], references: [id])
}

model PracticeExam {
  id          String      @id @default(cuid())
  title       String
  description String?
  duration    Int         // in minutes
  spots       Int
  spotsLeft   Int
  startTime   DateTime
  endTime     DateTime?
  createdAt   DateTime   @default(now())
  updatedAt   DateTime   @updatedAt
  createdBy   User       @relation(fields: [createdById], references: [id])
  createdById String
  questions   PracticeExamQuestion[]
  participants PracticeExamParticipant[]
  category    String
  subcategory String
}

model PracticeExamParticipant {
  id          String    @id @default(cuid())
  exam        PracticeExam  @relation(fields: [examId], references: [id])
  examId      String
  user        User      @relation(fields: [userId], references: [id])
  userId      String
  score       Int?
  answers     Json?     // Store answers as JSON
  startedAt   DateTime  @default(now())
  completedAt DateTime?
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  @@unique([examId, userId])
}

model PracticeExamQuestion {
  id          String    @id @default(cuid())
  text        String?   @db.Text
  options     Json?     // Array of options
  correct     Int?      // Index of correct option
  exam        PracticeExam? @relation(fields: [examId], references: [id])
  examId      String?
}

model GovtExamNotification {
  id            String   @id @default(cuid())
  title         String
  description   String   @db.Text
  year          Int
  month         Int
  applyLastDate DateTime
  applyLink     String
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
}

model QuestionOfTheDay {
  id          String    @id @default(cuid())
  question    String    @db.Text
  options     Json      // Array of options
  correct     Int       // Index of correct option
  timeLimit   Int       @default(10) // Time limit in seconds
  isActive    Boolean   @default(true)
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  createdBy   User      @relation(fields: [createdById], references: [id])
  createdById String
  attempts    QuestionOfTheDayAttempt[]
}

model QuestionOfTheDayAttempt {
  id          String    @id @default(cuid())
  question    QuestionOfTheDay @relation(fields: [questionId], references: [id])
  questionId  String
  user        User      @relation(fields: [userId], references: [id])
  userId      String
  selected    Int       // Index of selected option
  isCorrect   Boolean
  timeTaken   Int       // Time taken in seconds
  createdAt   DateTime  @default(now())

  @@unique([questionId, userId])
}

model Timetable {
  id          String    @id @default(cuid())
  name        String
  description String?
  isWeekly    Boolean   @default(false)
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  user        User      @relation(fields: [userId], references: [id])
  userId      String
  slots       TimetableSlot[]
}

model TimetableSlot {
  id          String    @id @default(cuid())
  day         Int       // 0-6 for Sunday-Saturday
  startTime   DateTime
  endTime     DateTime
  subject     String
  topic       String?
  notes       String?   @db.Text
  isCompleted Boolean   @default(false)
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  timetable   Timetable @relation(fields: [timetableId], references: [id], onDelete: Cascade)
  timetableId String
  user        User      @relation(fields: [userId], references: [id])
  userId      String
  reminder    Boolean   @default(true)
  reminderSent Boolean  @default(false)

  @@index([userId, day, startTime])
}

model Post {
  id          String    @id @default(cuid())
  content     String    @db.Text
  imageUrl    String?
  videoUrl    String?
  hashtags    Json?     // Array of hashtags
  isPrivate   Boolean   @default(false)
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  
  // Relations
  author      User      @relation(fields: [authorId], references: [id], onDelete: Cascade)
  authorId    String
  
  // Engagement
  likes       Like[]
  comments    Comment[]
  savedBy     SavedPost[]
  
  // Tags
  taggedUsers Json?     // Array of tagged user IDs
  
  @@index([authorId, createdAt])
}

model Follow {
  id          String    @id @default(cuid())
  follower    User      @relation("UserFollowers", fields: [followerId], references: [id], onDelete: Cascade)
  followerId  String
  following   User      @relation("UserFollowing", fields: [followingId], references: [id], onDelete: Cascade)
  followingId String
  createdAt   DateTime  @default(now())

  @@unique([followerId, followingId])
}

model FollowRequest {
  id          String    @id @default(cuid())
  sender      User      @relation("RequestSender", fields: [senderId], references: [id], onDelete: Cascade)
  senderId    String
  receiver    User      @relation("RequestReceiver", fields: [receiverId], references: [id], onDelete: Cascade)
  receiverId  String
  status      RequestStatus @default(PENDING)
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  @@unique([senderId, receiverId])
}

model Like {
  id          String    @id @default(cuid())
  user        User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId      String
  post        Post      @relation(fields: [postId], references: [id], onDelete: Cascade)
  postId      String
  createdAt   DateTime  @default(now())

  @@unique([userId, postId])
}

model Comment {
  id          String    @id @default(cuid())
  content     String    @db.Text
  user        User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId      String
  post        Post      @relation(fields: [postId], references: [id], onDelete: Cascade)
  postId      String
  parentId    String?   // For replies
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  @@index([postId, createdAt])
}

model SavedPost {
  id          String    @id @default(cuid())
  user        User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId      String
  post        Post      @relation(fields: [postId], references: [id], onDelete: Cascade)
  postId      String
  createdAt   DateTime  @default(now())

  @@unique([userId, postId])
}

model DirectMessage {
  id          String    @id @default(cuid())
  content     String    @db.Text
  messageType MessageType @default(TEXT)
  fileUrl     String?   // For file attachments
  isRead      Boolean   @default(false)
  createdAt   DateTime  @default(now())
  
  // Relations
  sender      User      @relation("MessageSender", fields: [senderId], references: [id], onDelete: Cascade)
  senderId    String
  receiver    User      @relation("MessageReceiver", fields: [receiverId], references: [id], onDelete: Cascade)
  receiverId  String
  
  @@index([senderId, receiverId, createdAt])
  @@index([receiverId, senderId, createdAt])
}

model Group {
  id          String    @id @default(cuid())
  name        String
  description String?   @db.Text
  imageUrl    String?
  isPrivate   Boolean   @default(false)
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  
  // Relations
  creator     User      @relation(fields: [creatorId], references: [id])
  creatorId   String
  members     GroupMember[]
  posts       GroupPost[]
  messages    GroupMessage[]
  events      GroupEvent[]
  quizzes     GroupQuiz[]
  polls       GroupPoll[]
}

model GroupMember {
  id          String    @id @default(cuid())
  user        User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId      String
  group       Group     @relation(fields: [groupId], references: [id], onDelete: Cascade)
  groupId     String
  role        GroupRole @default(MEMBER)
  joinedAt    DateTime  @default(now())

  @@unique([userId, groupId])
}

model GroupPost {
  id          String    @id @default(cuid())
  content     String    @db.Text
  imageUrl    String?
  videoUrl    String?
  fileUrl     String?   // For study materials
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  
  // Relations
  author      User      @relation(fields: [authorId], references: [id], onDelete: Cascade)
  authorId    String
  group       Group     @relation(fields: [groupId], references: [id], onDelete: Cascade)
  groupId     String
  
  // Engagement
  likes       GroupPostLike[]
  comments    GroupPostComment[]
  
  @@index([groupId, createdAt])
}

model GroupPostLike {
  id          String    @id @default(cuid())
  user        User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId      String
  post        GroupPost @relation(fields: [postId], references: [id], onDelete: Cascade)
  postId      String
  createdAt   DateTime  @default(now())

  @@unique([userId, postId])
}

model GroupPostComment {
  id          String    @id @default(cuid())
  content     String    @db.Text
  user        User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId      String
  post        GroupPost @relation(fields: [postId], references: [id], onDelete: Cascade)
  postId      String
  parentId    String?   // For replies
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  @@index([postId, createdAt])
}

model GroupMessage {
  id          String    @id @default(cuid())
  content     String    @db.Text
  messageType MessageType @default(TEXT)
  fileUrl     String?   // For file attachments
  createdAt   DateTime  @default(now())
  
  // Relations
  sender      User      @relation(fields: [senderId], references: [id], onDelete: Cascade)
  senderId    String
  group       Group     @relation(fields: [groupId], references: [id], onDelete: Cascade)
  groupId     String
  
  @@index([groupId, createdAt])
}

model GroupEvent {
  id          String    @id @default(cuid())
  title       String
  description String?   @db.Text
  startTime   DateTime
  endTime     DateTime
  location    String?   // Can be physical location or online meeting link
  eventType   EventType @default(STUDY_SESSION)
  maxParticipants Int?
  isRecurring Boolean   @default(false)
  recurrence  Json?     // Store recurrence pattern
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  
  // Relations
  group       Group     @relation(fields: [groupId], references: [id], onDelete: Cascade)
  groupId     String
  creator     User      @relation(fields: [creatorId], references: [id])
  creatorId   String
  participants GroupEventParticipant[]
  
  @@index([groupId, startTime])
}

model GroupEventParticipant {
  id          String    @id @default(cuid())
  user        User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId      String
  event       GroupEvent @relation(fields: [eventId], references: [id], onDelete: Cascade)
  eventId     String
  status      ParticipationStatus @default(ATTENDING)
  joinedAt    DateTime  @default(now())

  @@unique([userId, eventId])
}

model GroupQuiz {
  id          String    @id @default(cuid())
  title       String
  description String?   @db.Text
  questions   Json      // Array of questions with options and correct answers
  timeLimit   Int?      // Time limit in minutes
  isActive    Boolean   @default(true)
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  
  // Relations
  group       Group     @relation(fields: [groupId], references: [id], onDelete: Cascade)
  groupId     String
  creator     User      @relation(fields: [creatorId], references: [id])
  creatorId   String
  attempts    GroupQuizAttempt[]
  
  @@index([groupId, createdAt])
}

model GroupQuizAttempt {
  id          String    @id @default(cuid())
  user        User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId      String
  quiz        GroupQuiz @relation(fields: [quizId], references: [id], onDelete: Cascade)
  quizId      String
  answers     Json      // User's answers
  score       Int       // Score percentage
  timeTaken   Int       // Time taken in seconds
  completedAt DateTime  @default(now())

  @@unique([userId, quizId])
}

model GroupPoll {
  id          String    @id @default(cuid())
  question    String    @db.Text
  options     Json      // Array of poll options
  isMultiple  Boolean   @default(false) // Allow multiple selections
  isActive    Boolean   @default(true)
  expiresAt   DateTime?
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  
  // Relations
  group       Group     @relation(fields: [groupId], references: [id], onDelete: Cascade)
  groupId     String
  creator     User      @relation(fields: [creatorId], references: [id])
  creatorId   String
  votes       GroupPollVote[]
  
  @@index([groupId, createdAt])
}

model GroupPollVote {
  id          String    @id @default(cuid())
  user        User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId      String
  poll        GroupPoll @relation(fields: [pollId], references: [id], onDelete: Cascade)
  pollId      String
  selectedOptions Json  // Array of selected option indices
  createdAt   DateTime  @default(now())

  @@unique([userId, pollId])
}

enum RequestStatus {
  PENDING
  ACCEPTED
  DECLINED
}

enum GroupRole {
  ADMIN
  MODERATOR
  MEMBER
}

enum MessageType {
  TEXT
  IMAGE
  FILE
  SYSTEM
}

enum EventType {
  STUDY_SESSION
  QUIZ
  DISCUSSION
  PRESENTATION
  EXAM_PREP
  SOCIAL
}

enum ParticipationStatus {
  ATTENDING
  MAYBE
  DECLINED
  NOT_RESPONDED
}