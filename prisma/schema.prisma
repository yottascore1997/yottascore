datasource db {
  provider = "mysql"
  url      = env("DATABASE_URL")
}

generator client {
  provider = "prisma-client-js"
}

enum Role {
  ADMIN
  STUDENT
  USER
}

model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String? @db.Text
  access_token      String? @db.Text
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String? @db.Text
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
  @@map("Account")
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@map("Session")
}

// Refresh token for JWT rotation; invalidate on logout
model RefreshToken {
  id        String   @id @default(cuid())
  userId    String
  tokenHash String   // Hash of token (e.g. SHA256) for lookup
  expiresAt DateTime
  createdAt DateTime @default(now())
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  @@index([tokenHash])
  @@index([userId])
  @@index([expiresAt])
  @@map("RefreshToken")
}

model Blog {
  id          String   @id @default(cuid())
  title       String
  content     String   @db.Text
  excerpt     String?  @db.Text
  imageUrl    String?
  author      String
  published   Boolean  @default(false)
  publishedAt DateTime?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  tags        String   // Comma-separated tags
  views       Int      @default(0)
  likes       Int      @default(0)
  
  @@map("Blog")
}

// Admin-curated success stories (video/image) shown on student app
model SuccessStory {
  id          String   @id @default(cuid())
  title       String?
  description String?  @db.Text
  mediaUrl    String   // Video or image URL
  mediaType   String   // VIDEO | IMAGE
  order       Int      @default(0) // Display order
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  createdById String
  createdBy   User     @relation(fields: [createdById], references: [id], onDelete: Cascade)
  @@index([createdById])
  @@index([order])
  @@map("SuccessStory")
}

model User {
  id              String      @id @default(cuid())
  name            String?
  email           String?     @unique
  username        String?     @unique
  emailVerified   DateTime?
  image           String?
  hashedPassword  String?
  phoneNumber     String?
  role            Role        @default(USER)
  createdAt       DateTime    @default(now())
  updatedAt       DateTime    @updatedAt
  
  // Login lockout (N failed attempts -> temporary lock)
  failedLoginAttempts Int     @default(0)
  lockedUntil          DateTime?
  
  // KYC Fields
  kycStatus       KYCStatus   @default(NOT_SUBMITTED)
  kycVerifiedAt   DateTime?
  kycRejectedAt   DateTime?
  kycRejectionReason String?
  
  accounts        Account[]
  sessions        Session[]
  refreshTokens   RefreshToken[]
  participatedExams LiveExamParticipant[]
  wonExams         LiveExamWinner[]
  createdLiveExams LiveExam[]
  wallet           Float    @default(0)
  transactions     Transaction[]
  createdPracticeExams PracticeExam[]
  participatedPracticeExams PracticeExamParticipant[]
  createdQuestionsOfTheDay QuestionOfTheDay[]
  questionOfTheDayAttempts QuestionOfTheDayAttempt[]
  timetables      Timetable[]
  timetableSlots  TimetableSlot[]
  
  // Battle Quiz Relations
  createdBattleQuizzes BattleQuiz[]
  battleQuizParticipations BattleQuizParticipant[]
  battleQuizWins BattleQuizWinner[]
  player1Matches BattleQuizMatch[] @relation("Player1Matches")
  player2Matches BattleQuizMatch[] @relation("Player2Matches")
  wonMatches BattleQuizMatch[] @relation("WonMatches")
  battleQuizLeaderboard BattleQuizLeaderboard?
  battleStats UserBattleStats?
  
  // New Battle Room Relations
  createdBattleRooms BattleRoom[] @relation("BattleRoomCreator")
  battlePlayers BattlePlayer[]
  battleAnswers BattleAnswer[]
  
  // Question Bank Relations
  createdQuestionCategories QuestionCategory[]
  createdQuestionBankItems QuestionBankItem[]
  
  // Social Media Features
  profilePhoto    String?
  course          String?
  year            String?
  bio             String?     @db.Text
  isPrivate       Boolean     @default(false)
  
  // Posts
  posts           Post[]
  
  // Follow System
  followers       Follow[]    @relation("UserFollowers")
  following       Follow[]    @relation("UserFollowing")
  
  // Follow Requests
  sentRequests    FollowRequest[] @relation("RequestSender")
  receivedRequests FollowRequest[] @relation("RequestReceiver")
  
  // Engagement
  likes           Like[]
  comments        Comment[]
  savedPosts      SavedPost[]
  reports         PostReport[]
  deletedMessages UserMessageDelete[]
  blockedUsers    UserBlock[] @relation("UserBlocker")
  blockedBy       UserBlock[] @relation("UserBlocked")
  
  // Groups
  groupMemberships GroupMember[]
  createdGroups   Group[]
  
  // Group Posts & Messages
  groupPosts      GroupPost[]
  groupMessages   GroupMessage[]
  groupPostLikes  GroupPostLike[]
  groupPostComments GroupPostComment[]
  
  // Group Events
  createdEvents   GroupEvent[]
  eventParticipations GroupEventParticipant[]
  
  // Group Quizzes & Polls
  createdQuizzes  GroupQuiz[]
  quizAttempts    GroupQuizAttempt[]
  createdPolls    GroupPoll[]
  groupPollVotes  GroupPollVote[]
  
  // KYC Documents
  kycDocuments   KYCDocument[]
  
  // Support Tickets
  supportTickets SupportTicket[]
  
  // Push Notifications
  pushNotifications PushNotification[]
  sentNotifications PushNotification[] @relation("NotificationSender")
  supportTicketReplies SupportTicketReply[]
  
  // Stories
  stories        Story[]
  storyViews     StoryView[]
  
  // Spy Game Relations
  hostedSpyGames SpyGame[] @relation("SpyGameHost")
  spyGamePlayers SpyGamePlayer[]
  spyGameVotes   SpyGameVote[] @relation("VotedFor")
  spyGameVotesAsVoter SpyGameVote[] @relation("SpyGameVoter")
  
  // Story Relations
  storyLikes     StoryLike[]

  // Admin: Success Stories (curated for app)
  createdSuccessStories SuccessStory[]

  // Chat Relations
  sentMessages     DirectMessage[] @relation("MessageSender")
  receivedMessages DirectMessage[] @relation("MessageReceiver")
  sentMessageRequests MessageRequest[] @relation("MessageRequestSender")
  receivedMessageRequests MessageRequest[] @relation("MessageRequestReceiver")
  
  // Advanced Chat Features
  messageReactions MessageReaction[]
  forwardedMessages DirectMessage[] @relation("ForwardedMessageSender")
  
  // Referral System
  referralCode   String?   @unique
  referralCount  Int       @default(0)
  referredBy     String?   // Referral code of the user who referred this user
  totalReferralEarnings Float @default(0)
  
  // Referral Relations
  referrerReferrals Referral[] @relation("ReferrerReferrals")
  referredUserReferrals Referral[] @relation("ReferredUserReferrals")
  
  // Poll and Question Relations
  pollVotes PollVote[]
  questionAnswers QuestionAnswer[]
  
  // Book Listing Relations
  bookListings      BookListing[]
  bookProfile       UserBookProfile?
  bookTransactionsAsBuyer BookTransaction[] @relation("BookBuyer")
  bookTransactionsAsSeller BookTransaction[] @relation("BookSeller")
  bookTransactionMessages BookTransactionMessage[]
  bookLikes         BookLike[]
  bookReviews       BookReview[]
  bookWishlists     BookWishlist[]
  bookCarts         BookCart[]
  bookReports       BookReport[]
  
  // Spy Game - Commented out for now
  // spyGamePlayers SpyGamePlayer[]
  
  @@map("User")
}

model LiveExam {
  id          String      @id @default(cuid())
  title       String
  description String?
  instructions String?    @db.Text
  category    String?
  imageUrl    String?     // URL for exam logo/image
  duration    Int         // in minutes
  spots       Int
  spotsLeft   Int
  entryFee    Float
  totalCollection Float
  prizePool   Float
  startTime   DateTime
  endTime     DateTime?
  isLive      Boolean    @default(false)
  winningsDistributed Boolean @default(false)
  createdAt   DateTime   @default(now())
  updatedAt   DateTime   @updatedAt
  createdBy   User       @relation(fields: [createdById], references: [id])
  createdById String
  questions   Question[]
  participants LiveExamParticipant[]
  winners     LiveExamWinner[]
  
  @@map("LiveExam")
}

model LiveExamParticipant {
  id          String    @id @default(cuid())
  exam        LiveExam  @relation(fields: [examId], references: [id])
  examId      String
  user        User      @relation(fields: [userId], references: [id])
  userId      String
  score       Int?
  answers     Json?     // Store answers as JSON
  startedAt   DateTime  @default(now())
  completedAt DateTime?
  paid        Boolean   @default(false)
  paymentId   String?   // Reference to payment transaction
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  @@unique([examId, userId])
  @@map("LiveExamParticipant")
}

model LiveExamWinner {
  id          String    @id @default(cuid())
  exam        LiveExam  @relation(fields: [examId], references: [id])
  examId      String
  user        User      @relation(fields: [userId], references: [id])
  userId      String
  rank        Int
  prizeAmount Float
  paid        Boolean   @default(false)
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  @@unique([examId, rank])
  @@map("LiveExamWinner")
}

model Question {
  id          String    @id @default(cuid())
  text        String?   @db.Text
  type        String    @default("MCQ") // "MCQ" or "TRUE_FALSE"
  options     Json?     // Array of options
  correctAnswer Int?    // Index of correct option
  exam        LiveExam? @relation(fields: [examId], references: [id])
  examId      String?
  categoryId  String?
  category    QuestionCategory? @relation(fields: [categoryId], references: [id])
  
  // Battle relations
  battleQuestions BattleQuestion[]
  battleAnswers BattleAnswer[]
  
  @@map("Question")
}

model Transaction {
  id        String    @id @default(cuid())
  userId    String
  amount    Float
  type      String
  status    String
  description String?
  requestId String?   @unique
  razorpayOrderId String?
  razorpayPaymentId String?
  razorpaySignature String?
  createdAt DateTime  @default(now())
  user      User      @relation(fields: [userId], references: [id])
  
  @@map("Transaction")
}

model PracticeExam {
  id              String      @id @default(cuid())
  title           String
  description     String?
  instructions    String?     @db.Text
  duration        Int         // in minutes
  spots           Int
  spotsLeft       Int
  startTime       DateTime
  endTime         DateTime?
  logoUrl         String?     // URL for subcategory logo/image
  categoryLogoUrl String?     // URL for category logo/image
  createdAt       DateTime    @default(now())
  updatedAt        DateTime    @updatedAt
  createdBy       User        @relation(fields: [createdById], references: [id])
  createdById     String
  questions       PracticeExamQuestion[]
  participants    PracticeExamParticipant[]
  category        String
  subcategory     String
  
  @@map("PracticeExam")
}

model PracticeExamParticipant {
  id          String    @id @default(cuid())
  exam        PracticeExam  @relation(fields: [examId], references: [id])
  examId      String
  user        User      @relation(fields: [userId], references: [id])
  userId      String
  score       Int?
  answers     Json?     // Store answers as JSON
  startedAt   DateTime  @default(now())
  completedAt DateTime?
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  @@unique([examId, userId])
  @@map("PracticeExamParticipant")
}

model PracticeExamQuestion {
  id          String    @id @default(cuid())
  text        String?   @db.Text
  options     Json?     // Array of options
  correct     Int?      // Index of correct option
  marks       Int       @default(1) // Marks for this question
  exam        PracticeExam? @relation(fields: [examId], references: [id])
  examId      String?
  
  @@map("PracticeExamQuestion")
}

model GovtExamNotification {
  id            String   @id @default(cuid())
  title         String
  description   String   @db.Text
  year          Int
  month         Int
  applyLastDate DateTime
  applyLink     String
  category      String?  // Category (matches LiveExam categories)
  logoUrl       String?  // URL for exam logo/image
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  
  @@map("GovtExamNotification")
}

model QuestionOfTheDay {
  id          String    @id @default(cuid())
  question    String    @db.Text
  options     Json      // Array of options
  correct     Int       // Index of correct option
  timeLimit   Int       @default(10) // Time limit in seconds
  isActive    Boolean   @default(true)
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  createdBy   User      @relation(fields: [createdById], references: [id])
  createdById String
  attempts    QuestionOfTheDayAttempt[]
  
  @@map("QuestionOfTheDay")
}

model QuestionOfTheDayAttempt {
  id          String    @id @default(cuid())
  question    QuestionOfTheDay @relation(fields: [questionId], references: [id])
  questionId  String
  user        User      @relation(fields: [userId], references: [id])
  userId      String
  selected    Int       // Index of selected option
  isCorrect   Boolean
  timeTaken   Int       // Time taken in seconds
  createdAt   DateTime  @default(now())

  @@unique([questionId, userId])
  @@map("QuestionOfTheDayAttempt")
}

model Timetable {
  id          String    @id @default(cuid())
  name        String
  description String?
  isWeekly    Boolean   @default(false)
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  user        User      @relation(fields: [userId], references: [id])
  userId      String
  slots       TimetableSlot[]
  
  @@map("Timetable")
}

model TimetableSlot {
  id          String    @id @default(cuid())
  day         Int       // 0-6 for Sunday-Saturday
  startTime   DateTime
  endTime     DateTime
  subject     String
  topic       String?
  notes       String?   @db.Text
  isCompleted Boolean   @default(false)
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  timetable   Timetable @relation(fields: [timetableId], references: [id], onDelete: Cascade)
  timetableId String
  user        User      @relation(fields: [userId], references: [id])
  userId      String
  reminder    Boolean   @default(true)
  reminderSent Boolean  @default(false)

  @@index([userId, day, startTime])
  @@map("TimetableSlot")
}

model Post {
  id          String    @id @default(cuid())
  content     String    @db.Text
  imageUrl    String?
  videoUrl    String?
  hashtags    Json?     // Array of hashtags
  isPrivate   Boolean   @default(false)
  status      PostStatus @default(PENDING) // PENDING, APPROVED, REJECTED, FLAGGED
  rejectionReason String? // Reason if post is rejected
  reviewedBy  String?   // Admin ID who reviewed the post
  reviewedAt  DateTime? // When the post was reviewed
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  
  // Post Type
  postType    PostType  @default(TEXT) // TEXT, POLL, QUESTION
  
  // Poll specific fields
  pollOptions Json?     // Array of poll options
  pollEndTime DateTime? // When poll ends
  allowMultipleVotes Boolean @default(false) // Allow multiple option voting
  
  // Question specific fields
  questionType QuestionType? // MCQ, TRUE_FALSE, OPEN_ENDED
  questionOptions Json? // Array of options for MCQ questions
  
  // Relations
  author      User      @relation(fields: [authorId], references: [id], onDelete: Cascade)
  authorId    String
  
  // Engagement
  likes       Like[]
  comments    Comment[]
  savedBy     SavedPost[]
  pollVotes   PollVote[]
  questionAnswers QuestionAnswer[]
  reports     PostReport[]
  
  // Tags
  taggedUsers Json?     // Array of tagged user IDs
  
  @@index([authorId, createdAt])
  @@index([status, createdAt]) // For efficient review queue queries
  @@map("Post")
}

model Follow {
  id          String    @id @default(cuid())
  follower    User      @relation("UserFollowers", fields: [followerId], references: [id], onDelete: Cascade)
  followerId  String
  following   User      @relation("UserFollowing", fields: [followingId], references: [id], onDelete: Cascade)
  followingId String
  createdAt   DateTime  @default(now())

  @@unique([followerId, followingId])
  @@map("Follow")
}

model FollowRequest {
  id          String    @id @default(cuid())
  sender      User      @relation("RequestSender", fields: [senderId], references: [id], onDelete: Cascade)
  senderId    String
  receiver    User      @relation("RequestReceiver", fields: [receiverId], references: [id], onDelete: Cascade)
  receiverId  String
  status      RequestStatus @default(PENDING)
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  @@unique([senderId, receiverId])
  @@map("FollowRequest")
}

model Like {
  id          String    @id @default(cuid())
  user        User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId      String
  post        Post      @relation(fields: [postId], references: [id], onDelete: Cascade)
  postId      String
  createdAt   DateTime  @default(now())

  @@unique([userId, postId])
  @@map("Like")
}

model Comment {
  id          String    @id @default(cuid())
  content     String    @db.Text
  user        User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId      String
  post        Post      @relation(fields: [postId], references: [id], onDelete: Cascade)
  postId      String
  parentId    String?   // For replies
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  @@index([postId, createdAt])
  @@map("Comment")
}

model SavedPost {
  id          String    @id @default(cuid())
  user        User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId      String
  post        Post      @relation(fields: [postId], references: [id], onDelete: Cascade)
  postId      String
  createdAt   DateTime  @default(now())

  @@unique([userId, postId])
  @@map("SavedPost")
}

model PostReport {
  id          String    @id @default(cuid())
  user        User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId      String
  post        Post      @relation(fields: [postId], references: [id], onDelete: Cascade)
  postId      String
  reason      String    // Report reason
  description String?   // Additional details
  status      ReportStatus @default(PENDING) // PENDING, REVIEWED, RESOLVED
  reviewedBy  String?   // Admin ID who reviewed
  reviewedAt  DateTime? // When reviewed
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  @@unique([userId, postId]) // One report per user per post
  @@map("PostReport")
}

model UserMessageDelete {
  id        String    @id @default(cuid())
  user      User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId    String
  message   DirectMessage @relation(fields: [messageId], references: [id], onDelete: Cascade)
  messageId String
  deletedAt DateTime  @default(now())

  @@unique([userId, messageId]) // One delete record per user per message
  @@map("UserMessageDelete")
}

model UserBlock {
  id          String    @id @default(cuid())
  blocker     User      @relation("UserBlocker", fields: [blockerId], references: [id], onDelete: Cascade)
  blockerId   String
  blocked     User      @relation("UserBlocked", fields: [blockedId], references: [id], onDelete: Cascade)
  blockedId   String
  reason      String?   // Optional reason for blocking
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  @@unique([blockerId, blockedId]) // One block record per blocker-blocked pair
  @@map("UserBlock")
}

// DirectMessage model
model DirectMessage {
  id          String    @id @default(cuid())
  content     String    @db.Text
  messageType MessageType @default(TEXT)
  fileUrl     String?   // For file attachments
  fileName    String?   // Original filename
  fileSize    Int?      // File size in bytes
  fileType    String?   // MIME type
  
  // Advanced Features
  isRead      Boolean   @default(false)
  readAt      DateTime? // When message was read
  isEdited    Boolean   @default(false)
  editedAt    DateTime? // When message was last edited
  isDeleted   Boolean   @default(false)
  deletedAt   DateTime? // When message was deleted
  isPinned    Boolean   @default(false)
  pinnedAt    DateTime? // When message was pinned
  
  // Message Threading & Replies
  replyToId   String?   // ID of message this is replying to
  replyTo     DirectMessage? @relation("MessageReplies", fields: [replyToId], references: [id])
  replies     DirectMessage[] @relation("MessageReplies")
  
  // Message Reactions
  reactions   MessageReaction[]
  
  // Message Forwarding
  isForwarded Boolean   @default(false)
  originalSenderId String? // ID of original sender if forwarded
  originalSender User? @relation("ForwardedMessageSender", fields: [originalSenderId], references: [id])
  
  // User-specific deletions
  userDeletions UserMessageDelete[]
  
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @default(now())
  
  // Relations
  sender      User      @relation("MessageSender", fields: [senderId], references: [id], onDelete: Cascade)
  senderId    String
  receiver    User      @relation("MessageReceiver", fields: [receiverId], references: [id], onDelete: Cascade)
  receiverId  String
  
  @@index([senderId, receiverId, createdAt])
  @@index([receiverId, senderId, createdAt])
  @@index([replyToId])
  @@index([isPinned])
  @@map("DirectMessage")
}

// Message Reactions Model
model MessageReaction {
  id          String    @id @default(cuid())
  reactionType ReactionType
  createdAt   DateTime  @default(now())
  
  // Relations
  message     DirectMessage @relation(fields: [messageId], references: [id], onDelete: Cascade)
  messageId   String
  user        User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId      String
  
  @@unique([messageId, userId, reactionType])
  @@index([messageId])
  @@index([userId])
  @@map("MessageReaction")
}

// MessageRequest model
model MessageRequest {
  id          String    @id @default(cuid())
  content     String    @db.Text
  messageType MessageType @default(TEXT)
  fileUrl     String?   // For file attachments
  status      MessageRequestStatus @default(PENDING)
  createdAt   DateTime  @default(now())
  respondedAt DateTime?
  
  // Relations
  sender      User      @relation("MessageRequestSender", fields: [senderId], references: [id], onDelete: Cascade)
  senderId    String
  receiver    User      @relation("MessageRequestReceiver", fields: [receiverId], references: [id], onDelete: Cascade)
  receiverId  String
  
  @@index([senderId, receiverId, createdAt])
  @@index([receiverId, senderId, createdAt])
  @@map("MessageRequest")
}

model Group {
  id          String    @id @default(cuid())
  name        String
  description String?   @db.Text
  imageUrl    String?
  isPrivate   Boolean   @default(false)
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  
  // Relations
  creator     User      @relation(fields: [creatorId], references: [id])
  creatorId   String
  members     GroupMember[]
  posts       GroupPost[]
  messages    GroupMessage[]
  events      GroupEvent[]
  quizzes     GroupQuiz[]
  polls       GroupPoll[]
}

model GroupMember {
  id          String    @id @default(cuid())
  user        User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId      String
  group       Group     @relation(fields: [groupId], references: [id], onDelete: Cascade)
  groupId     String
  role        GroupRole @default(MEMBER)
  joinedAt    DateTime  @default(now())

  @@unique([userId, groupId])
}

model GroupPost {
  id          String    @id @default(cuid())
  content     String    @db.Text
  imageUrl    String?
  videoUrl    String?
  fileUrl     String?   // For study materials
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  
  // Relations
  author      User      @relation(fields: [authorId], references: [id], onDelete: Cascade)
  authorId    String
  group       Group     @relation(fields: [groupId], references: [id], onDelete: Cascade)
  groupId     String
  
  // Engagement
  likes       GroupPostLike[]
  comments    GroupPostComment[]
  
  @@index([groupId, createdAt])
}

model GroupPostLike {
  id          String    @id @default(cuid())
  user        User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId      String
  post        GroupPost @relation(fields: [postId], references: [id], onDelete: Cascade)
  postId      String
  createdAt   DateTime  @default(now())

  @@unique([userId, postId])
}

model GroupPostComment {
  id          String    @id @default(cuid())
  content     String    @db.Text
  user        User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId      String
  post        GroupPost @relation(fields: [postId], references: [id], onDelete: Cascade)
  postId      String
  parentId    String?   // For replies
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  @@index([postId, createdAt])
}

model GroupMessage {
  id          String    @id @default(cuid())
  content     String    @db.Text
  messageType MessageType @default(TEXT)
  fileUrl     String?   // For file attachments
  createdAt   DateTime  @default(now())
  
  // Relations
  sender      User      @relation(fields: [senderId], references: [id], onDelete: Cascade)
  senderId    String
  group       Group     @relation(fields: [groupId], references: [id], onDelete: Cascade)
  groupId     String
  
  @@index([groupId, createdAt])
}

model GroupEvent {
  id          String    @id @default(cuid())
  title       String
  description String?   @db.Text
  startTime   DateTime
  endTime     DateTime
  location    String?   // Can be physical location or online meeting link
  eventType   EventType @default(STUDY_SESSION)
  maxParticipants Int?
  isRecurring Boolean   @default(false)
  recurrence  Json?     // Store recurrence pattern
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  
  // Relations
  group       Group     @relation(fields: [groupId], references: [id], onDelete: Cascade)
  groupId     String
  creator     User      @relation(fields: [creatorId], references: [id])
  creatorId   String
  participants GroupEventParticipant[]
  
  @@index([groupId, startTime])
}

model GroupEventParticipant {
  id          String    @id @default(cuid())
  user        User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId      String
  event       GroupEvent @relation(fields: [eventId], references: [id], onDelete: Cascade)
  eventId     String
  status      ParticipationStatus @default(ATTENDING)
  joinedAt    DateTime  @default(now())

  @@unique([userId, eventId])
}

model GroupQuiz {
  id          String    @id @default(cuid())
  title       String
  description String?   @db.Text
  questions   Json      // Array of questions with options and correct answers
  timeLimit   Int?      // Time limit in minutes
  isActive    Boolean   @default(true)
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  
  // Relations
  group       Group     @relation(fields: [groupId], references: [id], onDelete: Cascade)
  groupId     String
  creator     User      @relation(fields: [creatorId], references: [id])
  creatorId   String
  attempts    GroupQuizAttempt[]
  
  @@index([groupId, createdAt])
}

model GroupQuizAttempt {
  id          String    @id @default(cuid())
  user        User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId      String
  quiz        GroupQuiz @relation(fields: [quizId], references: [id], onDelete: Cascade)
  quizId      String
  answers     Json      // User's answers
  score       Int       // Score percentage
  timeTaken   Int       // Time taken in seconds
  completedAt DateTime  @default(now())

  @@unique([userId, quizId])
}

model GroupPoll {
  id          String    @id @default(cuid())
  question    String    @db.Text
  options     Json      // Array of poll options
  isMultiple  Boolean   @default(false) // Allow multiple selections
  isActive    Boolean   @default(true)
  expiresAt   DateTime?
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  
  // Relations
  group       Group     @relation(fields: [groupId], references: [id], onDelete: Cascade)
  groupId     String
  creator     User      @relation(fields: [creatorId], references: [id])
  creatorId   String
  votes       GroupPollVote[]
  
  @@index([groupId, createdAt])
}

model GroupPollVote {
  id          String    @id @default(cuid())
  user        User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId      String
  poll        GroupPoll @relation(fields: [pollId], references: [id], onDelete: Cascade)
  pollId      String
  selectedOptions Json  // Array of selected option indices
  createdAt   DateTime  @default(now())

  @@unique([userId, pollId])
}

enum RequestStatus {
  PENDING
  ACCEPTED
  DECLINED
}

enum GroupRole {
  ADMIN
  MODERATOR
  MEMBER
}

enum MessageType {
  TEXT
  IMAGE
  VIDEO
  AUDIO
  FILE
  DOCUMENT
  LOCATION
  VOICE_NOTE
  STICKER
  SYSTEM
}

enum ReactionType {
  LIKE
  LOVE
  LAUGH
  WOW
  SAD
  ANGRY
  THUMBS_UP
  THUMBS_DOWN
  HEART
  CLAP
  CELEBRATE
}

enum EventType {
  STUDY_SESSION
  QUIZ
  DISCUSSION
  PRESENTATION
  EXAM_PREP
  SOCIAL
}

enum ParticipationStatus {
  ATTENDING
  NOT_ATTENDING
  MAYBE
}

enum MessageRequestStatus {
  PENDING
  ACCEPTED
  REJECTED
}

// Battle Quiz Models
model BattleQuiz {
  id          String    @id @default(cuid())
  title       String
  description String?
  entryAmount Float
  categoryId  String?   // Reference to question category
  questionCount Int     @default(10) // Number of questions to pick randomly
  timePerQuestion Int   @default(15) // Time limit per question in seconds
  isActive    Boolean   @default(true)
  isPrivate   Boolean   @default(false) // For private room matches
  roomCode    String?   @unique // For private room invites
  maxPlayers  Int       @default(2) // For future expansion to team battles
  status      BattleQuizStatus @default(WAITING) // Quiz status
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  
  // Relations
  createdBy   User      @relation(fields: [createdById], references: [id])
  createdById String
  category    QuestionCategory? @relation(fields: [categoryId], references: [id])
  questions   BattleQuizQuestion[]
  participants BattleQuizParticipant[]
  winners     BattleQuizWinner[]
  matches     BattleQuizMatch[]
}

model BattleQuizQuestion {
  id          String    @id @default(cuid())
  text        String    @db.Text
  options     Json      // Array of options
  correct     Int       // Index of correct option
  marks       Int       @default(1)
  difficulty  QuestionDifficulty @default(MEDIUM)
  explanation String?   @db.Text
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  
  // Relations
  quiz        BattleQuiz @relation(fields: [quizId], references: [id], onDelete: Cascade)
  quizId      String
}

model BattleQuizParticipant {
  id        String    @id @default(cuid())
  quizId    String
  userId    String
  matchId   String?
  status    BattleParticipantStatus @default(WAITING)
  score     Int       @default(0)
  answers   Json      // Store answers with timestamps
  responseTimes Json? // Store response time for each question
  joinedAt  DateTime  @default(now())
  
  // Relations
  quiz      BattleQuiz @relation(fields: [quizId], references: [id], onDelete: Cascade)
  user      User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  match     BattleQuizMatch? @relation(fields: [matchId], references: [id])
}

model BattleQuizWinner {
  id          String    @id @default(cuid())
  rank        Int
  prizeAmount Float
  paid        Boolean   @default(false)
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  
  // Relations
  quiz        BattleQuiz @relation(fields: [quizId], references: [id], onDelete: Cascade)
  quizId      String
  user        User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId      String

  @@unique([quizId, rank])
}

// Real-time Battle Quiz Matches
model BattleQuizMatch {
  id            String    @id @default(cuid())
  quizId        String
  player1Id     String
  player2Id     String
  status        BattleMatchStatus @default(WAITING)
  currentRound  Int       @default(0)
  totalRounds   Int       @default(5)
  player1Score  Int       @default(0)
  player2Score  Int       @default(0)
  player1Answers Json?    // Store answers with timestamps
  player2Answers Json?    // Store answers with timestamps
  startTime     DateTime  @default(now())
  endTime       DateTime?
  winnerId      String?
  prizeAmount   Float?
  isPrivate     Boolean   @default(false)
  roomCode      String?   // For private matches
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt
  
  // Relations
  quiz          BattleQuiz @relation(fields: [quizId], references: [id], onDelete: Cascade)
  player1       User      @relation("Player1Matches", fields: [player1Id], references: [id])
  player2       User      @relation("Player2Matches", fields: [player2Id], references: [id])
  winner        User?     @relation("WonMatches", fields: [winnerId], references: [id])
  participants  BattleQuizParticipant[]
}

// Global Leaderboard System
model BattleQuizLeaderboard {
  id          String    @id @default(cuid())
  userId      String
  totalMatches Int      @default(0)
  wins        Int       @default(0)
  losses      Int       @default(0)
  draws       Int       @default(0)
  totalScore  Int       @default(0)
  averageScore Float    @default(0)
  winStreak   Int       @default(0)
  bestWinStreak Int     @default(0)
  totalPrizeMoney Float @default(0)
  level       Int       @default(1)
  experience  Int       @default(0)
  lastUpdated DateTime  @default(now())
  
  // Relations
  user        User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@unique([userId])
  @@index([totalScore])
  @@index([wins])
  @@index([level])
}

// User Stats for Battle Quiz
model UserBattleStats {
  id                String    @id @default(cuid())
  userId            String    @unique
  totalMatches      Int       @default(0)
  wins              Int       @default(0)
  losses            Int       @default(0)
  draws             Int       @default(0)
  winRate           Float     @default(0)
  totalScore        Int       @default(0)
  averageScore      Float     @default(0)
  fastestAnswer     Int?      // Fastest answer time in milliseconds
  totalPrizeMoney   Float     @default(0)
  currentStreak     Int       @default(0)
  bestStreak        Int       @default(0)
  level             Int       @default(1)
  experience        Int       @default(0)
  experienceToNext  Int       @default(100)
  favoriteCategory  String?
  createdAt         DateTime  @default(now())
  updatedAt         DateTime  @updatedAt
  
  // Relations
  user              User      @relation(fields: [userId], references: [id], onDelete: Cascade)
}

enum BattleMatchStatus {
  WAITING
  STARTING
  PLAYING
  FINISHED
  CANCELLED
  TIMEOUT
}

enum BattleParticipantStatus {
  WAITING
  READY
  PLAYING
  FINISHED
  DISCONNECTED
}

enum BattleQuizStatus {
  WAITING
  ACTIVE
  FINISHED
  CANCELLED
}

// Question Bank System
model QuestionCategory {
  id          String    @id @default(cuid())
  name        String    @unique
  description String?
  color       String?   // For UI styling
  isActive    Boolean   @default(true)
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  
  // Relations
  createdBy   User      @relation(fields: [createdById], references: [id])
  createdById String
  questions   QuestionBankItem[]
  battleQuizzes BattleQuiz[]
  battleRooms BattleRoom[]
  quizQuestions Question[]
  battleQuizAmounts BattleQuizAmount[]
}

model QuestionBankItem {
  id          String    @id @default(cuid())
  text        String    @db.Text
  options     Json      // Array of options
  correct     Int       // Index of correct option
  explanation String?   @db.Text // Explanation for the correct answer
  difficulty  QuestionDifficulty @default(MEDIUM)
  tags        Json?     // Array of tags for better organization
  isActive    Boolean   @default(true)
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  
  // Relations
  category    QuestionCategory @relation(fields: [categoryId], references: [id], onDelete: Cascade)
  categoryId  String
  createdBy   User      @relation(fields: [createdById], references: [id])
  createdById String
}

enum QuestionDifficulty {
  EASY
  MEDIUM
  HARD
}

model Story {
  id          String    @id @default(cuid())
  mediaUrl    String    // URL to image/video
  mediaType   StoryMediaType @default(IMAGE)
  caption     String?   @db.Text
  createdAt   DateTime  @default(now())
  expiresAt   DateTime  // 24 hours from creation
  
  // Relations
  author      User      @relation(fields: [authorId], references: [id], onDelete: Cascade)
  authorId    String
  
  // Views
  views       StoryView[]
  
  // Likes
  likes       StoryLike[]
  
  @@index([authorId, createdAt])
  @@index([expiresAt])
}

model StoryView {
  id          String    @id @default(cuid())
  viewedAt    DateTime  @default(now())
  
  // Relations
  story       Story     @relation(fields: [storyId], references: [id], onDelete: Cascade)
  storyId     String
  viewer      User      @relation(fields: [viewerId], references: [id], onDelete: Cascade)
  viewerId    String
  
  @@unique([storyId, viewerId])
  @@index([storyId, viewedAt])
}

model StoryLike {
  id          String    @id @default(cuid())
  createdAt   DateTime  @default(now())
  
  // Relations
  story       Story     @relation(fields: [storyId], references: [id], onDelete: Cascade)
  storyId     String
  user        User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId      String
  
  @@unique([storyId, userId])
  @@index([storyId, createdAt])
}

enum StoryMediaType {
  IMAGE
  VIDEO
}

// Referral model
model Referral {
  id          String    @id @default(cuid())
  referrer    User      @relation("ReferrerReferrals", fields: [referrerId], references: [id], onDelete: Cascade)
  referrerId  String
  referred    User      @relation("ReferredUserReferrals", fields: [referredId], references: [id], onDelete: Cascade)
  referredId  String
  code        String    @unique
  joinedAt    DateTime  @default(now())

  @@unique([referrerId, referredId])
}

// Support Ticket System
model SupportTicket {
  id          String    @id @default(cuid())
  ticketId    String    @unique // Auto-generated ticket ID like "TKT-2024-001"
  title       String
  description String    @db.Text
  issueType   TicketIssueType
  priority    TicketPriority @default(MEDIUM)
  status      TicketStatus @default(OPEN)
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  resolvedAt  DateTime?
  
  // Relations
  user        User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId      String
  // assignedTo relation - Commented out for now
  // assignedTo  User?     @relation("AssignedTickets", fields: [assignedToId], references: [id])
  // assignedToId String?
  replies     SupportTicketReply[]
  attachments SupportTicketAttachment[]
  
  @@index([userId, createdAt])
  @@index([status, priority])
  // @@index([assignedToId]) // Commented out as assignedToId is commented
}

model SupportTicketReply {
  id          String    @id @default(cuid())
  content     String    @db.Text
  isInternal  Boolean   @default(false) // Internal notes not visible to user
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  
  // Relations
  ticket      SupportTicket @relation(fields: [ticketId], references: [id], onDelete: Cascade)
  ticketId    String
  user        User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId      String
  attachments SupportTicketAttachment[]
  
  @@index([ticketId, createdAt])
}

model SupportTicketAttachment {
  id          String    @id @default(cuid())
  fileName    String
  fileUrl     String
  fileSize    Int       // File size in bytes
  mimeType    String
  createdAt   DateTime  @default(now())
  
  // Relations
  ticket      SupportTicket? @relation(fields: [ticketId], references: [id], onDelete: Cascade)
  ticketId    String?
  reply       SupportTicketReply? @relation(fields: [replyId], references: [id], onDelete: Cascade)
  replyId     String?
  
  @@index([ticketId])
  @@index([replyId])
}

enum TicketIssueType {
  TECHNICAL_ISSUE
  PAYMENT_PROBLEM
  EXAM_ACCESS
  ACCOUNT_ISSUE
  FEATURE_REQUEST
  BUG_REPORT
  GENERAL_INQUIRY
  OTHER
}

enum TicketPriority {
  LOW
  MEDIUM
  HIGH
  URGENT
}

enum TicketStatus {
  OPEN
  IN_PROGRESS
  WAITING_FOR_USER
  RESOLVED
  CLOSED
}

// Spy Game Models
model SpyGame {
  id          String   @id @default(cuid())
  roomCode    String   @unique
  hostId      String
  host        User     @relation("SpyGameHost", fields: [hostId], references: [id])
  status      GameStatus @default(WAITING)
  maxPlayers  Int      @default(6)
  minPlayers  Int      @default(4)
  wordPack    String   @default("default")
  currentTurn Int      @default(0)
  currentPhase GamePhase @default(LOBBY)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  players     SpyGamePlayer[]
  words       SpyGameWord[]
  votes       SpyGameVote[]
  
  @@map("spy_games")
}

model SpyGamePlayer {
  id        String   @id @default(cuid())
  gameId    String
  game      SpyGame  @relation(fields: [gameId], references: [id], onDelete: Cascade)
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  isSpy     Boolean  @default(false)
  isHost    Boolean  @default(false)
  isAlive   Boolean  @default(true)
  joinedAt  DateTime @default(now())
  
  @@unique([gameId, userId])
  @@map("spy_game_players")
}

model SpyGameWord {
  id        String   @id @default(cuid())
  gameId    String
  game      SpyGame  @relation(fields: [gameId], references: [id], onDelete: Cascade)
  word      String
  isSpyWord Boolean  @default(false)
  createdAt DateTime @default(now())
  
  @@map("spy_game_words")
}

model SpyGameVote {
  id          String   @id @default(cuid())
  gameId      String
  game        SpyGame  @relation(fields: [gameId], references: [id], onDelete: Cascade)
  voterId     String
  voter       User     @relation("SpyGameVoter", fields: [voterId], references: [id], onDelete: Cascade)
  votedForId  String
  votedFor    User     @relation("VotedFor", fields: [votedForId], references: [id], onDelete: Cascade)
  createdAt   DateTime @default(now())
  
  @@unique([gameId, voterId])
  @@map("spy_game_votes")
}

enum GameStatus {
  WAITING
  PLAYING
  VOTING
  FINISHED
}

enum GamePhase {
  LOBBY
  WORD_ASSIGNMENT
  DESCRIBING
  VOTING
  REVEAL
}

// New Battle Room Models
model BattleRoom {
  id          String   @id @default(cuid())
  name        String
  categoryId  String?
  category    QuestionCategory? @relation(fields: [categoryId], references: [id])
  maxPlayers  Int      @default(2)
  status      BattleRoomStatus @default(WAITING)
  createdById String
  createdBy   User     @relation("BattleRoomCreator", fields: [createdById], references: [id])
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  players     BattlePlayer[]
  questions   BattleQuestion[]
  answers     BattleAnswer[]
  
  @@map("battle_rooms")
}

model BattlePlayer {
  id        String   @id @default(cuid())
  roomId    String
  room      BattleRoom @relation(fields: [roomId], references: [id], onDelete: Cascade)
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  score     Int      @default(0)
  isReady   Boolean  @default(false)
  isOnline  Boolean  @default(true)
  joinedAt  DateTime @default(now())
  
  @@unique([roomId, userId])
  @@map("battle_players")
}

model BattleQuestion {
  id            String   @id @default(cuid())
  roomId        String
  room          BattleRoom @relation(fields: [roomId], references: [id], onDelete: Cascade)
  questionId    String
  question      Question @relation(fields: [questionId], references: [id])
  questionIndex Int
  startedAt     DateTime @default(now())
  
  @@unique([roomId, questionIndex])
  @@map("battle_questions")
}

model BattleAnswer {
  id            String   @id @default(cuid())
  roomId        String
  room          BattleRoom @relation(fields: [roomId], references: [id], onDelete: Cascade)
  userId        String
  user          User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  questionId    String
  question      Question @relation(fields: [questionId], references: [id])
  questionIndex Int
  answerIndex   Int
  isCorrect     Boolean
  timeSpent     Int      // in seconds
  score         Int      @default(0)
  answeredAt    DateTime @default(now())
  
  @@unique([roomId, userId, questionIndex])
  @@map("battle_answers")
}

enum BattleRoomStatus {
  WAITING
  PLAYING
  FINISHED
}

enum KYCStatus {
  PENDING
  VERIFIED
  REJECTED
  NOT_SUBMITTED
}

enum KYCDocumentType {
  AADHAR_CARD
  PAN_CARD
  DRIVING_LICENSE
  PASSPORT
  VOTER_ID
  BANK_PASSBOOK
  OTHER
}

model KYCDocument {
  id          String           @id @default(cuid())
  userId      String
  documentType KYCDocumentType
  documentNumber String?
  documentImage String         @db.LongText // Base64 data or URL - LONGTEXT for large images
  isVerified  Boolean          @default(false)
  verifiedAt  DateTime?
  verifiedBy  String?          // Admin ID who verified
  rejectionReason String?
  createdAt   DateTime         @default(now())
  updatedAt   DateTime         @updatedAt
  
  user        User             @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@map("kyc_documents")
}

// Battle Quiz Amount Management
model BattleQuizAmount {
  id          String    @id @default(cuid())
  categoryId  String
  amount      Float
  isActive    Boolean   @default(true)
  maxPlayers  Int       @default(1000)
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  
  // Relations
  category    QuestionCategory @relation(fields: [categoryId], references: [id], onDelete: Cascade)
  
  @@unique([categoryId, amount])
  @@index([categoryId, isActive])
}

// Push Notifications
model PushNotification {
  id        String   @id @default(cuid())
  userId    String
  title     String
  message   String   @db.Text
  type      String   @default("GENERAL") // GENERAL, EXAM, ANNOUNCEMENT, REMINDER
  isRead    Boolean  @default(false)
  sentBy    String   // Admin ID who sent the notification
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  // Relations
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  sentByUser  User     @relation("NotificationSender", fields: [sentBy], references: [id])
  
  @@index([userId, isRead])
  @@index([type])
  @@index([createdAt])
}

enum PostStatus {
  PENDING
  APPROVED
  REJECTED
  FLAGGED
}

enum ReportStatus {
  PENDING
  REVIEWED
  RESOLVED
}

enum PostType {
  TEXT
  POLL
  QUESTION
}

enum QuestionType {
  MCQ
  TRUE_FALSE
  OPEN_ENDED
}

model PollVote {
  id        String    @id @default(cuid())
  post      Post      @relation(fields: [postId], references: [id], onDelete: Cascade)
  postId    String
  user      User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId    String
  optionIndex Int     // Which option user voted for (0, 1, 2, etc.)
  createdAt DateTime  @default(now())

  @@unique([postId, userId]) // One vote per user per poll
}

model QuestionAnswer {
  id        String    @id @default(cuid())
  post      Post      @relation(fields: [postId], references: [id], onDelete: Cascade)
  postId    String
  user      User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId    String
  answer    String    @db.Text // User's answer
  createdAt DateTime  @default(now())

  @@unique([postId, userId]) // One answer per user per question
}

// Book Listing System Models
model BookListing {
  id              String        @id @default(cuid())
  title           String
  author          String
  isbn            String?       @unique
  description     String?       @db.Text
  price           Float?        // For selling
  rentPrice       Float?        // For renting (per day/week/month)
  listingType     BookListingType
  condition       BookCondition
  category        String        // Subject, Class, Exam prep, Novel, etc.
  subcategory     String?       // More specific categorization
  class           String?       // For academic books
  subject         String?       // For academic books
  examType        String?       // For exam preparation books
  language        String        @default("English")
  pages           Int?
  publisher       String?
  publishedYear   Int?
  edition         String?
  
  // Location and availability
  location        String        // City, State
  latitude        Float?        // For distance calculations
  longitude       Float?        // For distance calculations
  isAvailable     Boolean       @default(true)
  availableFrom   DateTime?     // For rental listings
  availableUntil DateTime?      // For rental listings
  
  // Images
  coverImage      String?       // Main cover image
  additionalImages Json?        // Array of additional image URLs
  
  // Status and metadata
  status          BookListingStatus @default(ACTIVE)
  views           Int           @default(0)
  likes           Int           @default(0)
  createdAt       DateTime      @default(now())
  updatedAt       DateTime      @updatedAt
  
  // Relations
  seller          User          @relation(fields: [sellerId], references: [id], onDelete: Cascade)
  sellerId        String
  
  // Engagement
  bookLikes       BookLike[]
  bookReviews     BookReview[]
  bookWishlists   BookWishlist[]
  bookCarts       BookCart[]
  bookReports     BookReport[]
  
  // Transactions
  transactions    BookTransaction[]
  
  @@index([sellerId, createdAt])
  @@index([category, subcategory])
  @@index([listingType, status])
  @@index([location])
  @@index([latitude, longitude])
  @@index([isAvailable, status])
}

model BookLike {
  id        String    @id @default(cuid())
  user      User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId    String
  book      BookListing @relation(fields: [bookId], references: [id], onDelete: Cascade)
  bookId    String
  createdAt DateTime  @default(now())

  @@unique([userId, bookId])
  @@index([bookId, createdAt])
}

model BookReview {
  id          String    @id @default(cuid())
  rating      Int       // 1-5 stars
  comment     String?   @db.Text
  isVerified  Boolean   @default(false) // Verified purchase/review
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  
  // Relations
  user        User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId      String
  book        BookListing @relation(fields: [bookId], references: [id], onDelete: Cascade)
  bookId      String
  
  @@unique([userId, bookId]) // One review per user per book
  @@index([bookId, rating])
  @@index([userId, createdAt])
}

model BookWishlist {
  id        String    @id @default(cuid())
  user      User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId    String
  book      BookListing @relation(fields: [bookId], references: [id], onDelete: Cascade)
  bookId    String
  createdAt DateTime  @default(now())
  
  // Notification settings
  notifyOnPriceDrop Boolean @default(true)
  notifyOnAvailability Boolean @default(true)
  maxPrice Float? // Notify if price drops below this
  maxDistance Float? // Notify if book becomes available within this distance (km)

  @@unique([userId, bookId])
  @@index([userId, createdAt])
  @@index([bookId])
}

model BookCart {
  id        String      @id @default(cuid())
  user      User        @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId    String
  book      BookListing @relation(fields: [bookId], references: [id], onDelete: Cascade)
  bookId    String
  quantity  Int         @default(1) // For future use
  createdAt DateTime    @default(now())
  updatedAt DateTime    @updatedAt
  
  @@unique([userId, bookId])
  @@index([userId])
  @@index([bookId])
}

model BookReport {
  id          String    @id @default(cuid())
  reason      String    // Report reason
  description String?   @db.Text
  status      ReportStatus @default(PENDING)
  reviewedBy  String?   // Admin ID who reviewed
  reviewedAt  DateTime?
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  
  // Relations
  user        User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId      String
  book        BookListing @relation(fields: [bookId], references: [id], onDelete: Cascade)
  bookId      String
  
  @@unique([userId, bookId]) // One report per user per book
  @@index([bookId, status])
}

model BookTransaction {
  id              String              @id @default(cuid())
  transactionType BookTransactionType
  status          BookTransactionStatus @default(PENDING)
  amount          Float?
  currency        String              @default("INR")
  paymentMethod   String?             // Cash, UPI, Bank Transfer, etc.
  paymentId       String?             // External payment reference
  
  // Transaction details
  startDate       DateTime?           // For rentals
  endDate         DateTime?           // For rentals
  returnDate      DateTime?           // For rentals
  isReturned      Boolean             @default(false)
  
  // Location details
  meetingLocation String?             // Where to meet for exchange
  meetingTime     DateTime?           // When to meet
  
  // Communication
  sellerNotes     String?             @db.Text
  buyerNotes      String?             @db.Text
  
  createdAt       DateTime            @default(now())
  updatedAt       DateTime            @updatedAt
  
  // Relations
  book            BookListing         @relation(fields: [bookId], references: [id])
  bookId          String
  buyer           User                @relation("BookBuyer", fields: [buyerId], references: [id])
  buyerId         String
  seller          User                @relation("BookSeller", fields: [sellerId], references: [id])
  sellerId        String
  
  // Messages
  messages        BookTransactionMessage[]
  
  @@index([buyerId, createdAt])
  @@index([sellerId, createdAt])
  @@index([bookId, status])
}

model BookTransactionMessage {
  id            String    @id @default(cuid())
  content       String    @db.Text
  messageType   MessageType @default(TEXT)
  fileUrl       String?   // For file attachments
  isRead        Boolean   @default(false)
  readAt        DateTime?
  createdAt     DateTime  @default(now())
  
  // Relations
  transaction   BookTransaction @relation(fields: [transactionId], references: [id], onDelete: Cascade)
  transactionId String
  sender        User      @relation(fields: [senderId], references: [id], onDelete: Cascade)
  senderId      String
  
  @@index([transactionId, createdAt])
}

// User Profile Enhancements for Book System
model UserBookProfile {
  id                String    @id @default(cuid())
  userId            String    @unique
  user              User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  // Verification
  isVerified        Boolean   @default(false)
  verificationType  UserVerificationType?
  collegeEmail      String?   @unique
  studentId         String?
  collegeName       String?
  graduationYear    Int?
  
  // Location
  city              String?
  state             String?
  pincode           String?
  latitude          Float?
  longitude         Float?
  
  // Preferences
  preferredLanguage String    @default("English")
  maxDistance       Float     @default(10) // km
  notificationSettings Json?   // Store notification preferences
  
  // Stats
  totalListings     Int       @default(0)
  totalSales        Int       @default(0)
  totalRentals      Int       @default(0)
  totalDonations    Int       @default(0)
  averageRating     Float     @default(0)
  totalReviews      Int       @default(0)
  
  // Badges
  badges            Json?     // Array of earned badges
  
  createdAt         DateTime  @default(now())
  updatedAt         DateTime  @updatedAt
  
  @@index([city, state])
  @@index([latitude, longitude])
}

// Enums for Book System
enum BookListingType {
  SELL
  RENT
  DONATE
}

enum BookCondition {
  NEW
  EXCELLENT
  LIKE_NEW
  GOOD
  FAIR
  POOR
}

enum BookListingStatus {
  ACTIVE
  SOLD
  RENTED
  DONATED
  INACTIVE
  REMOVED
}

enum BookTransactionType {
  SALE
  RENTAL
  DONATION
}

enum BookTransactionStatus {
  PENDING
  CONFIRMED
  IN_PROGRESS
  COMPLETED
  CANCELLED
  DISPUTED
}

enum UserVerificationType {
  COLLEGE_EMAIL
  STUDENT_ID
  COLLEGE_ID
  AADHAR_VERIFIED
}

// Add relations to User model
// Add these to the existing User model relations:
// bookListings      BookListing[]
// bookProfile       UserBookProfile?
// bookTransactionsAsBuyer BookTransaction[] @relation("BookBuyer")
// bookTransactionsAsSeller BookTransaction[] @relation("BookSeller")
// bookTransactionMessages BookTransactionMessage[]