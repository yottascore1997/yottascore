"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/socket.io-adapter";
exports.ids = ["vendor-chunks/socket.io-adapter"];
exports.modules = {

/***/ "(rsc)/./node_modules/socket.io-adapter/dist/cluster-adapter.js":
/*!****************************************************************!*\
  !*** ./node_modules/socket.io-adapter/dist/cluster-adapter.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nvar __rest = (void 0) && (void 0).__rest || function(s, e) {\n    var t = {};\n    for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for(var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++){\n        if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n    }\n    return t;\n};\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.ClusterAdapterWithHeartbeat = exports.ClusterAdapter = exports.MessageType = void 0;\nconst in_memory_adapter_1 = __webpack_require__(/*! ./in-memory-adapter */ \"(rsc)/./node_modules/socket.io-adapter/dist/in-memory-adapter.js\");\nconst debug_1 = __webpack_require__(/*! debug */ \"(rsc)/./node_modules/socket.io-adapter/node_modules/debug/src/index.js\");\nconst crypto_1 = __webpack_require__(/*! crypto */ \"crypto\");\nconst debug = (0, debug_1.debug)(\"socket.io-adapter\");\nconst EMITTER_UID = \"emitter\";\nconst DEFAULT_TIMEOUT = 5000;\nfunction randomId() {\n    return (0, crypto_1.randomBytes)(8).toString(\"hex\");\n}\nvar MessageType;\n(function(MessageType) {\n    MessageType[MessageType[\"INITIAL_HEARTBEAT\"] = 1] = \"INITIAL_HEARTBEAT\";\n    MessageType[MessageType[\"HEARTBEAT\"] = 2] = \"HEARTBEAT\";\n    MessageType[MessageType[\"BROADCAST\"] = 3] = \"BROADCAST\";\n    MessageType[MessageType[\"SOCKETS_JOIN\"] = 4] = \"SOCKETS_JOIN\";\n    MessageType[MessageType[\"SOCKETS_LEAVE\"] = 5] = \"SOCKETS_LEAVE\";\n    MessageType[MessageType[\"DISCONNECT_SOCKETS\"] = 6] = \"DISCONNECT_SOCKETS\";\n    MessageType[MessageType[\"FETCH_SOCKETS\"] = 7] = \"FETCH_SOCKETS\";\n    MessageType[MessageType[\"FETCH_SOCKETS_RESPONSE\"] = 8] = \"FETCH_SOCKETS_RESPONSE\";\n    MessageType[MessageType[\"SERVER_SIDE_EMIT\"] = 9] = \"SERVER_SIDE_EMIT\";\n    MessageType[MessageType[\"SERVER_SIDE_EMIT_RESPONSE\"] = 10] = \"SERVER_SIDE_EMIT_RESPONSE\";\n    MessageType[MessageType[\"BROADCAST_CLIENT_COUNT\"] = 11] = \"BROADCAST_CLIENT_COUNT\";\n    MessageType[MessageType[\"BROADCAST_ACK\"] = 12] = \"BROADCAST_ACK\";\n    MessageType[MessageType[\"ADAPTER_CLOSE\"] = 13] = \"ADAPTER_CLOSE\";\n})(MessageType = exports.MessageType || (exports.MessageType = {}));\nfunction encodeOptions(opts) {\n    return {\n        rooms: [\n            ...opts.rooms\n        ],\n        except: [\n            ...opts.except\n        ],\n        flags: opts.flags\n    };\n}\nfunction decodeOptions(opts) {\n    return {\n        rooms: new Set(opts.rooms),\n        except: new Set(opts.except),\n        flags: opts.flags\n    };\n}\n/**\n * A cluster-ready adapter. Any extending class must:\n *\n * - implement {@link ClusterAdapter#doPublish} and {@link ClusterAdapter#doPublishResponse}\n * - call {@link ClusterAdapter#onMessage} and {@link ClusterAdapter#onResponse}\n */ class ClusterAdapter extends in_memory_adapter_1.Adapter {\n    constructor(nsp){\n        super(nsp);\n        this.requests = new Map();\n        this.ackRequests = new Map();\n        this.uid = randomId();\n    }\n    /**\n     * Called when receiving a message from another member of the cluster.\n     *\n     * @param message\n     * @param offset\n     * @protected\n     */ onMessage(message, offset) {\n        if (message.uid === this.uid) {\n            return debug(\"[%s] ignore message from self\", this.uid);\n        }\n        debug(\"[%s] new event of type %d from %s\", this.uid, message.type, message.uid);\n        switch(message.type){\n            case MessageType.BROADCAST:\n                {\n                    const withAck = message.data.requestId !== undefined;\n                    if (withAck) {\n                        super.broadcastWithAck(message.data.packet, decodeOptions(message.data.opts), (clientCount)=>{\n                            debug(\"[%s] waiting for %d client acknowledgements\", this.uid, clientCount);\n                            this.publishResponse(message.uid, {\n                                type: MessageType.BROADCAST_CLIENT_COUNT,\n                                data: {\n                                    requestId: message.data.requestId,\n                                    clientCount\n                                }\n                            });\n                        }, (arg)=>{\n                            debug(\"[%s] received acknowledgement with value %j\", this.uid, arg);\n                            this.publishResponse(message.uid, {\n                                type: MessageType.BROADCAST_ACK,\n                                data: {\n                                    requestId: message.data.requestId,\n                                    packet: arg\n                                }\n                            });\n                        });\n                    } else {\n                        const packet = message.data.packet;\n                        const opts = decodeOptions(message.data.opts);\n                        this.addOffsetIfNecessary(packet, opts, offset);\n                        super.broadcast(packet, opts);\n                    }\n                    break;\n                }\n            case MessageType.SOCKETS_JOIN:\n                super.addSockets(decodeOptions(message.data.opts), message.data.rooms);\n                break;\n            case MessageType.SOCKETS_LEAVE:\n                super.delSockets(decodeOptions(message.data.opts), message.data.rooms);\n                break;\n            case MessageType.DISCONNECT_SOCKETS:\n                super.disconnectSockets(decodeOptions(message.data.opts), message.data.close);\n                break;\n            case MessageType.FETCH_SOCKETS:\n                {\n                    debug(\"[%s] calling fetchSockets with opts %j\", this.uid, message.data.opts);\n                    super.fetchSockets(decodeOptions(message.data.opts)).then((localSockets)=>{\n                        this.publishResponse(message.uid, {\n                            type: MessageType.FETCH_SOCKETS_RESPONSE,\n                            data: {\n                                requestId: message.data.requestId,\n                                sockets: localSockets.map((socket)=>{\n                                    // remove sessionStore from handshake, as it may contain circular references\n                                    const _a = socket.handshake, { sessionStore } = _a, handshake = __rest(_a, [\n                                        \"sessionStore\"\n                                    ]);\n                                    return {\n                                        id: socket.id,\n                                        handshake,\n                                        rooms: [\n                                            ...socket.rooms\n                                        ],\n                                        data: socket.data\n                                    };\n                                })\n                            }\n                        });\n                    });\n                    break;\n                }\n            case MessageType.SERVER_SIDE_EMIT:\n                {\n                    const packet = message.data.packet;\n                    const withAck = message.data.requestId !== undefined;\n                    if (!withAck) {\n                        this.nsp._onServerSideEmit(packet);\n                        return;\n                    }\n                    let called = false;\n                    const callback = (arg)=>{\n                        // only one argument is expected\n                        if (called) {\n                            return;\n                        }\n                        called = true;\n                        debug(\"[%s] calling acknowledgement with %j\", this.uid, arg);\n                        this.publishResponse(message.uid, {\n                            type: MessageType.SERVER_SIDE_EMIT_RESPONSE,\n                            data: {\n                                requestId: message.data.requestId,\n                                packet: arg\n                            }\n                        });\n                    };\n                    this.nsp._onServerSideEmit([\n                        ...packet,\n                        callback\n                    ]);\n                    break;\n                }\n            // @ts-ignore\n            case MessageType.BROADCAST_CLIENT_COUNT:\n            // @ts-ignore\n            case MessageType.BROADCAST_ACK:\n            // @ts-ignore\n            case MessageType.FETCH_SOCKETS_RESPONSE:\n            // @ts-ignore\n            case MessageType.SERVER_SIDE_EMIT_RESPONSE:\n                // extending classes may not make a distinction between a ClusterMessage and a ClusterResponse payload and may\n                // always call the onMessage() method\n                this.onResponse(message);\n                break;\n            default:\n                debug(\"[%s] unknown message type: %s\", this.uid, message.type);\n        }\n    }\n    /**\n     * Called when receiving a response from another member of the cluster.\n     *\n     * @param response\n     * @protected\n     */ onResponse(response) {\n        var _a, _b;\n        const requestId = response.data.requestId;\n        debug(\"[%s] received response %s to request %s\", this.uid, response.type, requestId);\n        switch(response.type){\n            case MessageType.BROADCAST_CLIENT_COUNT:\n                {\n                    (_a = this.ackRequests.get(requestId)) === null || _a === void 0 ? void 0 : _a.clientCountCallback(response.data.clientCount);\n                    break;\n                }\n            case MessageType.BROADCAST_ACK:\n                {\n                    (_b = this.ackRequests.get(requestId)) === null || _b === void 0 ? void 0 : _b.ack(response.data.packet);\n                    break;\n                }\n            case MessageType.FETCH_SOCKETS_RESPONSE:\n                {\n                    const request = this.requests.get(requestId);\n                    if (!request) {\n                        return;\n                    }\n                    request.current++;\n                    response.data.sockets.forEach((socket)=>request.responses.push(socket));\n                    if (request.current === request.expected) {\n                        clearTimeout(request.timeout);\n                        request.resolve(request.responses);\n                        this.requests.delete(requestId);\n                    }\n                    break;\n                }\n            case MessageType.SERVER_SIDE_EMIT_RESPONSE:\n                {\n                    const request = this.requests.get(requestId);\n                    if (!request) {\n                        return;\n                    }\n                    request.current++;\n                    request.responses.push(response.data.packet);\n                    if (request.current === request.expected) {\n                        clearTimeout(request.timeout);\n                        request.resolve(null, request.responses);\n                        this.requests.delete(requestId);\n                    }\n                    break;\n                }\n            default:\n                // @ts-ignore\n                debug(\"[%s] unknown response type: %s\", this.uid, response.type);\n        }\n    }\n    async broadcast(packet, opts) {\n        var _a;\n        const onlyLocal = (_a = opts.flags) === null || _a === void 0 ? void 0 : _a.local;\n        if (!onlyLocal) {\n            try {\n                const offset = await this.publishAndReturnOffset({\n                    type: MessageType.BROADCAST,\n                    data: {\n                        packet,\n                        opts: encodeOptions(opts)\n                    }\n                });\n                this.addOffsetIfNecessary(packet, opts, offset);\n            } catch (e) {\n                return debug(\"[%s] error while broadcasting message: %s\", this.uid, e.message);\n            }\n        }\n        super.broadcast(packet, opts);\n    }\n    /**\n     * Adds an offset at the end of the data array in order to allow the client to receive any missed packets when it\n     * reconnects after a temporary disconnection.\n     *\n     * @param packet\n     * @param opts\n     * @param offset\n     * @private\n     */ addOffsetIfNecessary(packet, opts, offset) {\n        var _a;\n        if (!this.nsp.server.opts.connectionStateRecovery) {\n            return;\n        }\n        const isEventPacket = packet.type === 2;\n        // packets with acknowledgement are not stored because the acknowledgement function cannot be serialized and\n        // restored on another server upon reconnection\n        const withoutAcknowledgement = packet.id === undefined;\n        const notVolatile = ((_a = opts.flags) === null || _a === void 0 ? void 0 : _a.volatile) === undefined;\n        if (isEventPacket && withoutAcknowledgement && notVolatile) {\n            packet.data.push(offset);\n        }\n    }\n    broadcastWithAck(packet, opts, clientCountCallback, ack) {\n        var _a;\n        const onlyLocal = (_a = opts === null || opts === void 0 ? void 0 : opts.flags) === null || _a === void 0 ? void 0 : _a.local;\n        if (!onlyLocal) {\n            const requestId = randomId();\n            this.ackRequests.set(requestId, {\n                clientCountCallback,\n                ack\n            });\n            this.publish({\n                type: MessageType.BROADCAST,\n                data: {\n                    packet,\n                    requestId,\n                    opts: encodeOptions(opts)\n                }\n            });\n            // we have no way to know at this level whether the server has received an acknowledgement from each client, so we\n            // will simply clean up the ackRequests map after the given delay\n            setTimeout(()=>{\n                this.ackRequests.delete(requestId);\n            }, opts.flags.timeout);\n        }\n        super.broadcastWithAck(packet, opts, clientCountCallback, ack);\n    }\n    async addSockets(opts, rooms) {\n        var _a;\n        const onlyLocal = (_a = opts.flags) === null || _a === void 0 ? void 0 : _a.local;\n        if (!onlyLocal) {\n            try {\n                await this.publishAndReturnOffset({\n                    type: MessageType.SOCKETS_JOIN,\n                    data: {\n                        opts: encodeOptions(opts),\n                        rooms\n                    }\n                });\n            } catch (e) {\n                debug(\"[%s] error while publishing message: %s\", this.uid, e.message);\n            }\n        }\n        super.addSockets(opts, rooms);\n    }\n    async delSockets(opts, rooms) {\n        var _a;\n        const onlyLocal = (_a = opts.flags) === null || _a === void 0 ? void 0 : _a.local;\n        if (!onlyLocal) {\n            try {\n                await this.publishAndReturnOffset({\n                    type: MessageType.SOCKETS_LEAVE,\n                    data: {\n                        opts: encodeOptions(opts),\n                        rooms\n                    }\n                });\n            } catch (e) {\n                debug(\"[%s] error while publishing message: %s\", this.uid, e.message);\n            }\n        }\n        super.delSockets(opts, rooms);\n    }\n    async disconnectSockets(opts, close) {\n        var _a;\n        const onlyLocal = (_a = opts.flags) === null || _a === void 0 ? void 0 : _a.local;\n        if (!onlyLocal) {\n            try {\n                await this.publishAndReturnOffset({\n                    type: MessageType.DISCONNECT_SOCKETS,\n                    data: {\n                        opts: encodeOptions(opts),\n                        close\n                    }\n                });\n            } catch (e) {\n                debug(\"[%s] error while publishing message: %s\", this.uid, e.message);\n            }\n        }\n        super.disconnectSockets(opts, close);\n    }\n    async fetchSockets(opts) {\n        var _a;\n        const [localSockets, serverCount] = await Promise.all([\n            super.fetchSockets(opts),\n            this.serverCount()\n        ]);\n        const expectedResponseCount = serverCount - 1;\n        if (((_a = opts.flags) === null || _a === void 0 ? void 0 : _a.local) || expectedResponseCount <= 0) {\n            return localSockets;\n        }\n        const requestId = randomId();\n        return new Promise((resolve, reject)=>{\n            const timeout = setTimeout(()=>{\n                const storedRequest = this.requests.get(requestId);\n                if (storedRequest) {\n                    reject(new Error(`timeout reached: only ${storedRequest.current} responses received out of ${storedRequest.expected}`));\n                    this.requests.delete(requestId);\n                }\n            }, opts.flags.timeout || DEFAULT_TIMEOUT);\n            const storedRequest = {\n                type: MessageType.FETCH_SOCKETS,\n                resolve,\n                timeout,\n                current: 0,\n                expected: expectedResponseCount,\n                responses: localSockets\n            };\n            this.requests.set(requestId, storedRequest);\n            this.publish({\n                type: MessageType.FETCH_SOCKETS,\n                data: {\n                    opts: encodeOptions(opts),\n                    requestId\n                }\n            });\n        });\n    }\n    async serverSideEmit(packet) {\n        const withAck = typeof packet[packet.length - 1] === \"function\";\n        if (!withAck) {\n            return this.publish({\n                type: MessageType.SERVER_SIDE_EMIT,\n                data: {\n                    packet\n                }\n            });\n        }\n        const ack = packet.pop();\n        const expectedResponseCount = await this.serverCount() - 1;\n        debug('[%s] waiting for %d responses to \"serverSideEmit\" request', this.uid, expectedResponseCount);\n        if (expectedResponseCount <= 0) {\n            return ack(null, []);\n        }\n        const requestId = randomId();\n        const timeout = setTimeout(()=>{\n            const storedRequest = this.requests.get(requestId);\n            if (storedRequest) {\n                ack(new Error(`timeout reached: only ${storedRequest.current} responses received out of ${storedRequest.expected}`), storedRequest.responses);\n                this.requests.delete(requestId);\n            }\n        }, DEFAULT_TIMEOUT);\n        const storedRequest = {\n            type: MessageType.SERVER_SIDE_EMIT,\n            resolve: ack,\n            timeout,\n            current: 0,\n            expected: expectedResponseCount,\n            responses: []\n        };\n        this.requests.set(requestId, storedRequest);\n        this.publish({\n            type: MessageType.SERVER_SIDE_EMIT,\n            data: {\n                requestId,\n                packet\n            }\n        });\n    }\n    publish(message) {\n        this.publishAndReturnOffset(message).catch((err)=>{\n            debug(\"[%s] error while publishing message: %s\", this.uid, err);\n        });\n    }\n    publishAndReturnOffset(message) {\n        message.uid = this.uid;\n        message.nsp = this.nsp.name;\n        return this.doPublish(message);\n    }\n    publishResponse(requesterUid, response) {\n        response.uid = this.uid;\n        response.nsp = this.nsp.name;\n        this.doPublishResponse(requesterUid, response).catch((err)=>{\n            debug(\"[%s] error while publishing response: %s\", this.uid, err);\n        });\n    }\n}\nexports.ClusterAdapter = ClusterAdapter;\nclass ClusterAdapterWithHeartbeat extends ClusterAdapter {\n    constructor(nsp, opts){\n        super(nsp);\n        this.nodesMap = new Map(); // uid => timestamp of last message\n        this.customRequests = new Map();\n        this._opts = Object.assign({\n            heartbeatInterval: 5000,\n            heartbeatTimeout: 10000\n        }, opts);\n        this.cleanupTimer = setInterval(()=>{\n            const now = Date.now();\n            this.nodesMap.forEach((lastSeen, uid)=>{\n                const nodeSeemsDown = now - lastSeen > this._opts.heartbeatTimeout;\n                if (nodeSeemsDown) {\n                    debug(\"[%s] node %s seems down\", this.uid, uid);\n                    this.removeNode(uid);\n                }\n            });\n        }, 1000);\n    }\n    init() {\n        this.publish({\n            type: MessageType.INITIAL_HEARTBEAT\n        });\n    }\n    scheduleHeartbeat() {\n        if (this.heartbeatTimer) {\n            this.heartbeatTimer.refresh();\n        } else {\n            this.heartbeatTimer = setTimeout(()=>{\n                this.publish({\n                    type: MessageType.HEARTBEAT\n                });\n            }, this._opts.heartbeatInterval);\n        }\n    }\n    close() {\n        this.publish({\n            type: MessageType.ADAPTER_CLOSE\n        });\n        clearTimeout(this.heartbeatTimer);\n        if (this.cleanupTimer) {\n            clearInterval(this.cleanupTimer);\n        }\n    }\n    onMessage(message, offset) {\n        if (message.uid === this.uid) {\n            return debug(\"[%s] ignore message from self\", this.uid);\n        }\n        if (message.uid && message.uid !== EMITTER_UID) {\n            // we track the UID of each sender, in order to know how many servers there are in the cluster\n            this.nodesMap.set(message.uid, Date.now());\n        }\n        debug(\"[%s] new event of type %d from %s\", this.uid, message.type, message.uid);\n        switch(message.type){\n            case MessageType.INITIAL_HEARTBEAT:\n                this.publish({\n                    type: MessageType.HEARTBEAT\n                });\n                break;\n            case MessageType.HEARTBEAT:\n                break;\n            case MessageType.ADAPTER_CLOSE:\n                this.removeNode(message.uid);\n                break;\n            default:\n                super.onMessage(message, offset);\n        }\n    }\n    serverCount() {\n        return Promise.resolve(1 + this.nodesMap.size);\n    }\n    publish(message) {\n        this.scheduleHeartbeat();\n        return super.publish(message);\n    }\n    async serverSideEmit(packet) {\n        const withAck = typeof packet[packet.length - 1] === \"function\";\n        if (!withAck) {\n            return this.publish({\n                type: MessageType.SERVER_SIDE_EMIT,\n                data: {\n                    packet\n                }\n            });\n        }\n        const ack = packet.pop();\n        const expectedResponseCount = this.nodesMap.size;\n        debug('[%s] waiting for %d responses to \"serverSideEmit\" request', this.uid, expectedResponseCount);\n        if (expectedResponseCount <= 0) {\n            return ack(null, []);\n        }\n        const requestId = randomId();\n        const timeout = setTimeout(()=>{\n            const storedRequest = this.customRequests.get(requestId);\n            if (storedRequest) {\n                ack(new Error(`timeout reached: missing ${storedRequest.missingUids.size} responses`), storedRequest.responses);\n                this.customRequests.delete(requestId);\n            }\n        }, DEFAULT_TIMEOUT);\n        const storedRequest = {\n            type: MessageType.SERVER_SIDE_EMIT,\n            resolve: ack,\n            timeout,\n            missingUids: new Set([\n                ...this.nodesMap.keys()\n            ]),\n            responses: []\n        };\n        this.customRequests.set(requestId, storedRequest);\n        this.publish({\n            type: MessageType.SERVER_SIDE_EMIT,\n            data: {\n                requestId,\n                packet\n            }\n        });\n    }\n    async fetchSockets(opts) {\n        var _a;\n        const [localSockets, serverCount] = await Promise.all([\n            super.fetchSockets({\n                rooms: opts.rooms,\n                except: opts.except,\n                flags: {\n                    local: true\n                }\n            }),\n            this.serverCount()\n        ]);\n        const expectedResponseCount = serverCount - 1;\n        if (((_a = opts.flags) === null || _a === void 0 ? void 0 : _a.local) || expectedResponseCount <= 0) {\n            return localSockets;\n        }\n        const requestId = randomId();\n        return new Promise((resolve, reject)=>{\n            const timeout = setTimeout(()=>{\n                const storedRequest = this.customRequests.get(requestId);\n                if (storedRequest) {\n                    reject(new Error(`timeout reached: missing ${storedRequest.missingUids.size} responses`));\n                    this.customRequests.delete(requestId);\n                }\n            }, opts.flags.timeout || DEFAULT_TIMEOUT);\n            const storedRequest = {\n                type: MessageType.FETCH_SOCKETS,\n                resolve,\n                timeout,\n                missingUids: new Set([\n                    ...this.nodesMap.keys()\n                ]),\n                responses: localSockets\n            };\n            this.customRequests.set(requestId, storedRequest);\n            this.publish({\n                type: MessageType.FETCH_SOCKETS,\n                data: {\n                    opts: encodeOptions(opts),\n                    requestId\n                }\n            });\n        });\n    }\n    onResponse(response) {\n        const requestId = response.data.requestId;\n        debug(\"[%s] received response %s to request %s\", this.uid, response.type, requestId);\n        switch(response.type){\n            case MessageType.FETCH_SOCKETS_RESPONSE:\n                {\n                    const request = this.customRequests.get(requestId);\n                    if (!request) {\n                        return;\n                    }\n                    response.data.sockets.forEach((socket)=>request.responses.push(socket));\n                    request.missingUids.delete(response.uid);\n                    if (request.missingUids.size === 0) {\n                        clearTimeout(request.timeout);\n                        request.resolve(request.responses);\n                        this.customRequests.delete(requestId);\n                    }\n                    break;\n                }\n            case MessageType.SERVER_SIDE_EMIT_RESPONSE:\n                {\n                    const request = this.customRequests.get(requestId);\n                    if (!request) {\n                        return;\n                    }\n                    request.responses.push(response.data.packet);\n                    request.missingUids.delete(response.uid);\n                    if (request.missingUids.size === 0) {\n                        clearTimeout(request.timeout);\n                        request.resolve(null, request.responses);\n                        this.customRequests.delete(requestId);\n                    }\n                    break;\n                }\n            default:\n                super.onResponse(response);\n        }\n    }\n    removeNode(uid) {\n        this.customRequests.forEach((request, requestId)=>{\n            request.missingUids.delete(uid);\n            if (request.missingUids.size === 0) {\n                clearTimeout(request.timeout);\n                if (request.type === MessageType.FETCH_SOCKETS) {\n                    request.resolve(request.responses);\n                } else if (request.type === MessageType.SERVER_SIDE_EMIT) {\n                    request.resolve(null, request.responses);\n                }\n                this.customRequests.delete(requestId);\n            }\n        });\n        this.nodesMap.delete(uid);\n    }\n}\nexports.ClusterAdapterWithHeartbeat = ClusterAdapterWithHeartbeat;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc29ja2V0LmlvLWFkYXB0ZXIvZGlzdC9jbHVzdGVyLWFkYXB0ZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYixJQUFJQSxTQUFTLENBQUMsTUFBRyxLQUFLLE9BQUcsRUFBRUEsTUFBTSxJQUFLLFNBQVVDLENBQUMsRUFBRUMsQ0FBQztJQUNoRCxJQUFJQyxJQUFJLENBQUM7SUFDVCxJQUFLLElBQUlDLEtBQUtILEVBQUcsSUFBSUksT0FBT0MsU0FBUyxDQUFDQyxjQUFjLENBQUNDLElBQUksQ0FBQ1AsR0FBR0csTUFBTUYsRUFBRU8sT0FBTyxDQUFDTCxLQUFLLEdBQzlFRCxDQUFDLENBQUNDLEVBQUUsR0FBR0gsQ0FBQyxDQUFDRyxFQUFFO0lBQ2YsSUFBSUgsS0FBSyxRQUFRLE9BQU9JLE9BQU9LLHFCQUFxQixLQUFLLFlBQ3JELElBQUssSUFBSUMsSUFBSSxHQUFHUCxJQUFJQyxPQUFPSyxxQkFBcUIsQ0FBQ1QsSUFBSVUsSUFBSVAsRUFBRVEsTUFBTSxFQUFFRCxJQUFLO1FBQ3BFLElBQUlULEVBQUVPLE9BQU8sQ0FBQ0wsQ0FBQyxDQUFDTyxFQUFFLElBQUksS0FBS04sT0FBT0MsU0FBUyxDQUFDTyxvQkFBb0IsQ0FBQ0wsSUFBSSxDQUFDUCxHQUFHRyxDQUFDLENBQUNPLEVBQUUsR0FDekVSLENBQUMsQ0FBQ0MsQ0FBQyxDQUFDTyxFQUFFLENBQUMsR0FBR1YsQ0FBQyxDQUFDRyxDQUFDLENBQUNPLEVBQUUsQ0FBQztJQUN6QjtJQUNKLE9BQU9SO0FBQ1g7QUFDQUUsOENBQTZDO0lBQUVXLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELG1DQUFtQyxHQUFHQSxzQkFBc0IsR0FBR0EsbUJBQW1CLEdBQUcsS0FBSztBQUMxRixNQUFNSyxzQkFBc0JDLG1CQUFPQSxDQUFDLDZGQUFxQjtBQUN6RCxNQUFNQyxVQUFVRCxtQkFBT0EsQ0FBQyxxRkFBTztBQUMvQixNQUFNRSxXQUFXRixtQkFBT0EsQ0FBQyxzQkFBUTtB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SUFBSSxDQUFDVCxTQUFTckMsSUFBSSxDQUFDSSxNQUFNO29CQUMzQ3NDLFFBQVEyRCxXQUFXLENBQUNsRCxNQUFNLENBQUNkLFNBQVM1QyxHQUFHO29CQUN2QyxJQUFJaUQsUUFBUTJELFdBQVcsQ0FBQ0QsSUFBSSxLQUFLLEdBQUc7d0JBQ2hDcEQsYUFBYU4sUUFBUU8sT0FBTzt3QkFDNUJQLFFBQVFRLE9BQU8sQ0FBQyxNQUFNUixRQUFRRyxTQUFTO3dCQUN2QyxJQUFJLENBQUNtQyxjQUFjLENBQUM3QixNQUFNLENBQUNsRDtvQkFDL0I7b0JBQ0E7Z0JBQ0o7WUFDQTtnQkFDSSxLQUFLLENBQUNtQyxXQUFXQztRQUN6QjtJQUNKO0lBQ0FzRCxXQUFXbEcsR0FBRyxFQUFFO1FBQ1osSUFBSSxDQUFDdUYsY0FBYyxDQUFDcEMsT0FBTyxDQUFDLENBQUNGLFNBQVN6QztZQUNsQ3lDLFFBQVEyRCxXQUFXLENBQUNsRCxNQUFNLENBQUMxRDtZQUMzQixJQUFJaUQsUUFBUTJELFdBQVcsQ0FBQ0QsSUFBSSxLQUFLLEdBQUc7Z0JBQ2hDcEQsYUFBYU4sUUFBUU8sT0FBTztnQkFDNUIsSUFBSVAsUUFBUTdDLElBQUksS0FBSzVCLFlBQVlrRCxhQUFhLEVBQUU7b0JBQzVDdUIsUUFBUVEsT0FBTyxDQUFDUixRQUFRRyxTQUFTO2dCQUNyQyxPQUNLLElBQUlILFFBQVE3QyxJQUFJLEtBQUs1QixZQUFZOEQsZ0JBQWdCLEVBQUU7b0JBQ3BEVyxRQUFRUSxPQUFPLENBQUMsTUFBTVIsUUFBUUcsU0FBUztnQkFDM0M7Z0JBQ0EsSUFBSSxDQUFDbUMsY0FBYyxDQUFDN0IsTUFBTSxDQUFDbEQ7WUFDL0I7UUFDSjtRQUNBLElBQUksQ0FBQzhFLFFBQVEsQ0FBQzVCLE1BQU0sQ0FBQzFEO0lBQ3pCO0FBQ0o7QUFDQTVCLG1DQUFtQyxHQUFHRSIsInNvdXJjZXMiOlsid2VicGFjazovL2V4YW1yb3NoLy4vbm9kZV9tb2R1bGVzL3NvY2tldC5pby1hZGFwdGVyL2Rpc3QvY2x1c3Rlci1hZGFwdGVyLmpzP2FhMjAiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19yZXN0ID0gKHRoaXMgJiYgdGhpcy5fX3Jlc3QpIHx8IGZ1bmN0aW9uIChzLCBlKSB7XG4gICAgdmFyIHQgPSB7fTtcbiAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkgJiYgZS5pbmRleE9mKHApIDwgMClcbiAgICAgICAgdFtwXSA9IHNbcF07XG4gICAgaWYgKHMgIT0gbnVsbCAmJiB0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyA9PT0gXCJmdW5jdGlvblwiKVxuICAgICAgICBmb3IgKHZhciBpID0gMCwgcCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMocyk7IGkgPCBwLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoZS5pbmRleE9mKHBbaV0pIDwgMCAmJiBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwocywgcFtpXSkpXG4gICAgICAgICAgICAgICAgdFtwW2ldXSA9IHNbcFtpXV07XG4gICAgICAgIH1cbiAgICByZXR1cm4gdDtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkNsdXN0ZXJBZGFwdGVyV2l0aEhlYXJ0YmVhdCA9IGV4cG9ydHMuQ2x1c3RlckFkYXB0ZXIgPSBleHBvcnRzLk1lc3NhZ2VUeXBlID0gdm9pZCAwO1xuY29uc3QgaW5fbWVtb3J5X2FkYXB0ZXJfMSA9IHJlcXVpcmUoXCIuL2luLW1lbW9yeS1hZGFwdGVyXCIpO1xuY29uc3QgZGVidWdfMSA9IHJlcXVpcmUoXCJkZWJ1Z1wiKTtcbmNvbnN0IGNyeXB0b18xID0gcmVxdWlyZShcImNyeXB0b1wiKTtcbmNvbnN0IGRlYnVnID0gKDAsIGRlYnVnXzEuZGVidWcpKFwic29ja2V0LmlvLWFkYXB0ZXJcIik7XG5jb25zdCBFTUlUVEVSX1VJRCA9IFwiZW1pdHRlclwiO1xuY29uc3QgREVGQVVMVF9USU1FT1VUID0gNTAwMDtcbmZ1bmN0aW9uIHJhbmRvbUlkKCkge1xuICAgIHJldHVybiAoMCwgY3J5cHRvXzEucmFuZG9tQnl0ZXMpKDgpLnRvU3RyaW5nKFwiaGV4XCIpO1xufVxudmFyIE1lc3NhZ2VUeXBlO1xuKGZ1bmN0aW9uIChNZXNzYWdlVHlwZSkge1xuICAgIE1lc3NhZ2VUeXBlW01lc3NhZ2VUeXBlW1wiSU5JVElBTF9IRUFSVEJFQVRcIl0gPSAxXSA9IFwiSU5JVElBTF9IRUFSVEJFQVRcIjtcbiAgICBNZXNzYWdlVHlwZVtNZXNzYWdlVHlwZVtcIkhFQVJUQkVBVFwiXSA9IDJdID0gXCJIRUFSVEJFQVRcIjtcbiAgICBNZXNzYWdlVHlwZVtNZXNzYWdlVHlwZVtcIkJST0FEQ0FTVFwiXSA9IDNdID0gXCJCUk9BRENBU1RcIjtcbiAgICBNZXNzYWdlVHlwZVtNZXNzYWdlVHlwZVtcIlNPQ0tFVFNfSk9JTlwiXSA9IDRdID0gXCJTT0NLRVRTX0pPSU5cIjtcbiAgICBNZXNzYWdlVHlwZVtNZXNzYWdlVHlwZVtcIlNPQ0tFVFNfTEVBVkVcIl0gPSA1XSA9IFwiU09DS0VUU19MRUFWRVwiO1xuICAgIE1lc3NhZ2VUeXBlW01lc3NhZ2VUeXBlW1wiRElTQ09OTkVDVF9TT0NLRVRTXCJdID0gNl0gPSBcIkRJU0NPTk5FQ1RfU09DS0VUU1wiO1xuICAgIE1lc3NhZ2VUeXBlW01lc3NhZ2VUeXBlW1wiRkVUQ0hfU09DS0VUU1wiXSA9IDddID0gXCJGRVRDSF9TT0NLRVRTXCI7XG4gICAgTWVzc2FnZVR5cGVbTWVzc2FnZVR5cGVbXCJGRVRDSF9TT0NLRVRTX1JFU1BPTlNFXCJdID0gOF0gPSBcIkZFVENIX1NPQ0tFVFNfUkVTUE9OU0VcIjtcbiAgICBNZXNzYWdlVHlwZVtNZXNzYWdlVHlwZVtcIlNFUlZFUl9TSURFX0VNSVRcIl0gPSA5XSA9IFwiU0VSVkVSX1NJREVfRU1JVFwiO1xuICAgIE1lc3NhZ2VUeXBlW01lc3NhZ2VUeXBlW1wiU0VSVkVSX1NJREVfRU1JVF9SRVNQT05TRVwiXSA9IDEwXSA9IFwiU0VSVkVSX1NJREVfRU1JVF9SRVNQT05TRVwiO1xuICAgIE1lc3NhZ2VUeXBlW01lc3NhZ2VUeXBlW1wiQlJPQURDQVNUX0NMSUVOVF9DT1VOVFwiXSA9IDExXSA9IFwiQlJPQURDQVNUX0NMSUVOVF9DT1VOVFwiO1xuICAgIE1lc3NhZ2VUeXBlW01lc3NhZ2VUeXBlW1wiQlJPQURDQVNUX0FDS1wiXSA9IDEyXSA9IFwiQlJPQURDQVNUX0FDS1wiO1xuICAgIE1lc3NhZ2VUeXBlW01lc3NhZ2VUeXBlW1wiQURBUFRFUl9DTE9TRVwiXSA9IDEzXSA9IFwiQURBUFRFUl9DTE9TRVwiO1xufSkoTWVzc2FnZVR5cGUgPSBleHBvcnRzLk1lc3NhZ2VUeXBlIHx8IChleHBvcnRzLk1lc3NhZ2VUeXBlID0ge30pKTtcbmZ1bmN0aW9uIGVuY29kZU9wdGlvbnMob3B0cykge1xuICAgIHJldHVybiB7XG4gICAgICAgIHJvb21zOiBbLi4ub3B0cy5yb29tc10sXG4gICAgICAgIGV4Y2VwdDogWy4uLm9wdHMuZXhjZXB0XSxcbiAgICAgICAgZmxhZ3M6IG9wdHMuZmxhZ3MsXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGRlY29kZU9wdGlvbnMob3B0cykge1xuICAgIHJldHVybiB7XG4gICAgICAgIHJvb21zOiBuZXcgU2V0KG9wdHMucm9vbXMpLFxuICAgICAgICBleGNlcHQ6IG5ldyBTZXQob3B0cy5leGNlcHQpLFxuICAgICAgICBmbGFnczogb3B0cy5mbGFncyxcbiAgICB9O1xufVxuLyoqXG4gKiBBIGNsdXN0ZXItcmVhZHkgYWRhcHRlci4gQW55IGV4dGVuZGluZyBjbGFzcyBtdXN0OlxuICpcbiAqIC0gaW1wbGVtZW50IHtAbGluayBDbHVzdGVyQWRhcHRlciNkb1B1Ymxpc2h9IGFuZCB7QGxpbmsgQ2x1c3RlckFkYXB0ZXIjZG9QdWJsaXNoUmVzcG9uc2V9XG4gKiAtIGNhbGwge0BsaW5rIENsdXN0ZXJBZGFwdGVyI29uTWVzc2FnZX0gYW5kIHtAbGluayBDbHVzdGVyQWRhcHRlciNvblJlc3BvbnNlfVxuICovXG5jbGFzcyBDbHVzdGVyQWRhcHRlciBleHRlbmRzIGluX21lbW9yeV9hZGFwdGVyXzEuQWRhcHRlciB7XG4gICAgY29uc3RydWN0b3IobnNwKSB7XG4gICAgICAgIHN1cGVyKG5zcCk7XG4gICAgICAgIHRoaXMucmVxdWVzdHMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuYWNrUmVxdWVzdHMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMudWlkID0gcmFuZG9tSWQoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHdoZW4gcmVjZWl2aW5nIGEgbWVzc2FnZSBmcm9tIGFub3RoZXIgbWVtYmVyIG9mIHRoZSBjbHVzdGVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIG1lc3NhZ2VcbiAgICAgKiBAcGFyYW0gb2Zmc2V0XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIG9uTWVzc2FnZShtZXNzYWdlLCBvZmZzZXQpIHtcbiAgICAgICAgaWYgKG1lc3NhZ2UudWlkID09PSB0aGlzLnVpZCkge1xuICAgICAgICAgICAgcmV0dXJuIGRlYnVnKFwiWyVzXSBpZ25vcmUgbWVzc2FnZSBmcm9tIHNlbGZcIiwgdGhpcy51aWQpO1xuICAgICAgICB9XG4gICAgICAgIGRlYnVnKFwiWyVzXSBuZXcgZXZlbnQgb2YgdHlwZSAlZCBmcm9tICVzXCIsIHRoaXMudWlkLCBtZXNzYWdlLnR5cGUsIG1lc3NhZ2UudWlkKTtcbiAgICAgICAgc3dpdGNoIChtZXNzYWdlLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgTWVzc2FnZVR5cGUuQlJPQURDQVNUOiB7XG4gICAgICAgICAgICAgICAgY29uc3Qgd2l0aEFjayA9IG1lc3NhZ2UuZGF0YS5yZXF1ZXN0SWQgIT09IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICBpZiAod2l0aEFjaykge1xuICAgICAgICAgICAgICAgICAgICBzdXBlci5icm9hZGNhc3RXaXRoQWNrKG1lc3NhZ2UuZGF0YS5wYWNrZXQsIGRlY29kZU9wdGlvbnMobWVzc2FnZS5kYXRhLm9wdHMpLCAoY2xpZW50Q291bnQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlYnVnKFwiWyVzXSB3YWl0aW5nIGZvciAlZCBjbGllbnQgYWNrbm93bGVkZ2VtZW50c1wiLCB0aGlzLnVpZCwgY2xpZW50Q291bnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wdWJsaXNoUmVzcG9uc2UobWVzc2FnZS51aWQsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBNZXNzYWdlVHlwZS5CUk9BRENBU1RfQ0xJRU5UX0NPVU5ULFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdElkOiBtZXNzYWdlLmRhdGEucmVxdWVzdElkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGllbnRDb3VudCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0sIChhcmcpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlYnVnKFwiWyVzXSByZWNlaXZlZCBhY2tub3dsZWRnZW1lbnQgd2l0aCB2YWx1ZSAlalwiLCB0aGlzLnVpZCwgYXJnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucHVibGlzaFJlc3BvbnNlKG1lc3NhZ2UudWlkLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogTWVzc2FnZVR5cGUuQlJPQURDQVNUX0FDSyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3RJZDogbWVzc2FnZS5kYXRhLnJlcXVlc3RJZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFja2V0OiBhcmcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBhY2tldCA9IG1lc3NhZ2UuZGF0YS5wYWNrZXQ7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG9wdHMgPSBkZWNvZGVPcHRpb25zKG1lc3NhZ2UuZGF0YS5vcHRzKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGRPZmZzZXRJZk5lY2Vzc2FyeShwYWNrZXQsIG9wdHMsIG9mZnNldCk7XG4gICAgICAgICAgICAgICAgICAgIHN1cGVyLmJyb2FkY2FzdChwYWNrZXQsIG9wdHMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgTWVzc2FnZVR5cGUuU09DS0VUU19KT0lOOlxuICAgICAgICAgICAgICAgIHN1cGVyLmFkZFNvY2tldHMoZGVjb2RlT3B0aW9ucyhtZXNzYWdlLmRhdGEub3B0cyksIG1lc3NhZ2UuZGF0YS5yb29tcyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIE1lc3NhZ2VUeXBlLlNPQ0tFVFNfTEVBVkU6XG4gICAgICAgICAgICAgICAgc3VwZXIuZGVsU29ja2V0cyhkZWNvZGVPcHRpb25zKG1lc3NhZ2UuZGF0YS5vcHRzKSwgbWVzc2FnZS5kYXRhLnJvb21zKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgTWVzc2FnZVR5cGUuRElTQ09OTkVDVF9TT0NLRVRTOlxuICAgICAgICAgICAgICAgIHN1cGVyLmRpc2Nvbm5lY3RTb2NrZXRzKGRlY29kZU9wdGlvbnMobWVzc2FnZS5kYXRhLm9wdHMpLCBtZXNzYWdlLmRhdGEuY2xvc2UpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBNZXNzYWdlVHlwZS5GRVRDSF9TT0NLRVRTOiB7XG4gICAgICAgICAgICAgICAgZGVidWcoXCJbJXNdIGNhbGxpbmcgZmV0Y2hTb2NrZXRzIHdpdGggb3B0cyAlalwiLCB0aGlzLnVpZCwgbWVzc2FnZS5kYXRhLm9wdHMpO1xuICAgICAgICAgICAgICAgIHN1cGVyXG4gICAgICAgICAgICAgICAgICAgIC5mZXRjaFNvY2tldHMoZGVjb2RlT3B0aW9ucyhtZXNzYWdlLmRhdGEub3B0cykpXG4gICAgICAgICAgICAgICAgICAgIC50aGVuKChsb2NhbFNvY2tldHMpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wdWJsaXNoUmVzcG9uc2UobWVzc2FnZS51aWQsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IE1lc3NhZ2VUeXBlLkZFVENIX1NPQ0tFVFNfUkVTUE9OU0UsXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdElkOiBtZXNzYWdlLmRhdGEucmVxdWVzdElkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNvY2tldHM6IGxvY2FsU29ja2V0cy5tYXAoKHNvY2tldCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyByZW1vdmUgc2Vzc2lvblN0b3JlIGZyb20gaGFuZHNoYWtlLCBhcyBpdCBtYXkgY29udGFpbiBjaXJjdWxhciByZWZlcmVuY2VzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IF9hID0gc29ja2V0LmhhbmRzaGFrZSwgeyBzZXNzaW9uU3RvcmUgfSA9IF9hLCBoYW5kc2hha2UgPSBfX3Jlc3QoX2EsIFtcInNlc3Npb25TdG9yZVwiXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDogc29ja2V0LmlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGFuZHNoYWtlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcm9vbXM6IFsuLi5zb2NrZXQucm9vbXNdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogc29ja2V0LmRhdGEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgTWVzc2FnZVR5cGUuU0VSVkVSX1NJREVfRU1JVDoge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhY2tldCA9IG1lc3NhZ2UuZGF0YS5wYWNrZXQ7XG4gICAgICAgICAgICAgICAgY29uc3Qgd2l0aEFjayA9IG1lc3NhZ2UuZGF0YS5yZXF1ZXN0SWQgIT09IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICBpZiAoIXdpdGhBY2spIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5uc3AuX29uU2VydmVyU2lkZUVtaXQocGFja2V0KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgY2FsbGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgY29uc3QgY2FsbGJhY2sgPSAoYXJnKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIC8vIG9ubHkgb25lIGFyZ3VtZW50IGlzIGV4cGVjdGVkXG4gICAgICAgICAgICAgICAgICAgIGlmIChjYWxsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYWxsZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBkZWJ1ZyhcIlslc10gY2FsbGluZyBhY2tub3dsZWRnZW1lbnQgd2l0aCAlalwiLCB0aGlzLnVpZCwgYXJnKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wdWJsaXNoUmVzcG9uc2UobWVzc2FnZS51aWQsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IE1lc3NhZ2VUeXBlLlNFUlZFUl9TSURFX0VNSVRfUkVTUE9OU0UsXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdElkOiBtZXNzYWdlLmRhdGEucmVxdWVzdElkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhY2tldDogYXJnLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB0aGlzLm5zcC5fb25TZXJ2ZXJTaWRlRW1pdChbLi4ucGFja2V0LCBjYWxsYmFja10pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgY2FzZSBNZXNzYWdlVHlwZS5CUk9BRENBU1RfQ0xJRU5UX0NPVU5UOlxuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgY2FzZSBNZXNzYWdlVHlwZS5CUk9BRENBU1RfQUNLOlxuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgY2FzZSBNZXNzYWdlVHlwZS5GRVRDSF9TT0NLRVRTX1JFU1BPTlNFOlxuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgY2FzZSBNZXNzYWdlVHlwZS5TRVJWRVJfU0lERV9FTUlUX1JFU1BPTlNFOlxuICAgICAgICAgICAgICAgIC8vIGV4dGVuZGluZyBjbGFzc2VzIG1heSBub3QgbWFrZSBhIGRpc3RpbmN0aW9uIGJldHdlZW4gYSBDbHVzdGVyTWVzc2FnZSBhbmQgYSBDbHVzdGVyUmVzcG9uc2UgcGF5bG9hZCBhbmQgbWF5XG4gICAgICAgICAgICAgICAgLy8gYWx3YXlzIGNhbGwgdGhlIG9uTWVzc2FnZSgpIG1ldGhvZFxuICAgICAgICAgICAgICAgIHRoaXMub25SZXNwb25zZShtZXNzYWdlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgZGVidWcoXCJbJXNdIHVua25vd24gbWVzc2FnZSB0eXBlOiAlc1wiLCB0aGlzLnVpZCwgbWVzc2FnZS50eXBlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgd2hlbiByZWNlaXZpbmcgYSByZXNwb25zZSBmcm9tIGFub3RoZXIgbWVtYmVyIG9mIHRoZSBjbHVzdGVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHJlc3BvbnNlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIG9uUmVzcG9uc2UocmVzcG9uc2UpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgY29uc3QgcmVxdWVzdElkID0gcmVzcG9uc2UuZGF0YS5yZXF1ZXN0SWQ7XG4gICAgICAgIGRlYnVnKFwiWyVzXSByZWNlaXZlZCByZXNwb25zZSAlcyB0byByZXF1ZXN0ICVzXCIsIHRoaXMudWlkLCByZXNwb25zZS50eXBlLCByZXF1ZXN0SWQpO1xuICAgICAgICBzd2l0Y2ggKHJlc3BvbnNlLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgTWVzc2FnZVR5cGUuQlJPQURDQVNUX0NMSUVOVF9DT1VOVDoge1xuICAgICAgICAgICAgICAgIChfYSA9IHRoaXMuYWNrUmVxdWVzdHNcbiAgICAgICAgICAgICAgICAgICAgLmdldChyZXF1ZXN0SWQpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2xpZW50Q291bnRDYWxsYmFjayhyZXNwb25zZS5kYXRhLmNsaWVudENvdW50KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgTWVzc2FnZVR5cGUuQlJPQURDQVNUX0FDSzoge1xuICAgICAgICAgICAgICAgIChfYiA9IHRoaXMuYWNrUmVxdWVzdHMuZ2V0KHJlcXVlc3RJZCkpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5hY2socmVzcG9uc2UuZGF0YS5wYWNrZXQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBNZXNzYWdlVHlwZS5GRVRDSF9TT0NLRVRTX1JFU1BPTlNFOiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVxdWVzdCA9IHRoaXMucmVxdWVzdHMuZ2V0KHJlcXVlc3RJZCk7XG4gICAgICAgICAgICAgICAgaWYgKCFyZXF1ZXN0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVxdWVzdC5jdXJyZW50Kys7XG4gICAgICAgICAgICAgICAgcmVzcG9uc2UuZGF0YS5zb2NrZXRzLmZvckVhY2goKHNvY2tldCkgPT4gcmVxdWVzdC5yZXNwb25zZXMucHVzaChzb2NrZXQpKTtcbiAgICAgICAgICAgICAgICBpZiAocmVxdWVzdC5jdXJyZW50ID09PSByZXF1ZXN0LmV4cGVjdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dChyZXF1ZXN0LnRpbWVvdXQpO1xuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0LnJlc29sdmUocmVxdWVzdC5yZXNwb25zZXMpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlcXVlc3RzLmRlbGV0ZShyZXF1ZXN0SWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgTWVzc2FnZVR5cGUuU0VSVkVSX1NJREVfRU1JVF9SRVNQT05TRToge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlcXVlc3QgPSB0aGlzLnJlcXVlc3RzLmdldChyZXF1ZXN0SWQpO1xuICAgICAgICAgICAgICAgIGlmICghcmVxdWVzdCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlcXVlc3QuY3VycmVudCsrO1xuICAgICAgICAgICAgICAgIHJlcXVlc3QucmVzcG9uc2VzLnB1c2gocmVzcG9uc2UuZGF0YS5wYWNrZXQpO1xuICAgICAgICAgICAgICAgIGlmIChyZXF1ZXN0LmN1cnJlbnQgPT09IHJlcXVlc3QuZXhwZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHJlcXVlc3QudGltZW91dCk7XG4gICAgICAgICAgICAgICAgICAgIHJlcXVlc3QucmVzb2x2ZShudWxsLCByZXF1ZXN0LnJlc3BvbnNlcyk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVxdWVzdHMuZGVsZXRlKHJlcXVlc3RJZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICAgICAgZGVidWcoXCJbJXNdIHVua25vd24gcmVzcG9uc2UgdHlwZTogJXNcIiwgdGhpcy51aWQsIHJlc3BvbnNlLnR5cGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGJyb2FkY2FzdChwYWNrZXQsIG9wdHMpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCBvbmx5TG9jYWwgPSAoX2EgPSBvcHRzLmZsYWdzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubG9jYWw7XG4gICAgICAgIGlmICghb25seUxvY2FsKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG9mZnNldCA9IGF3YWl0IHRoaXMucHVibGlzaEFuZFJldHVybk9mZnNldCh7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IE1lc3NhZ2VUeXBlLkJST0FEQ0FTVCxcbiAgICAgICAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFja2V0LFxuICAgICAgICAgICAgICAgICAgICAgICAgb3B0czogZW5jb2RlT3B0aW9ucyhvcHRzKSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLmFkZE9mZnNldElmTmVjZXNzYXJ5KHBhY2tldCwgb3B0cywgb2Zmc2V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRlYnVnKFwiWyVzXSBlcnJvciB3aGlsZSBicm9hZGNhc3RpbmcgbWVzc2FnZTogJXNcIiwgdGhpcy51aWQsIGUubWVzc2FnZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc3VwZXIuYnJvYWRjYXN0KHBhY2tldCwgb3B0cyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZHMgYW4gb2Zmc2V0IGF0IHRoZSBlbmQgb2YgdGhlIGRhdGEgYXJyYXkgaW4gb3JkZXIgdG8gYWxsb3cgdGhlIGNsaWVudCB0byByZWNlaXZlIGFueSBtaXNzZWQgcGFja2V0cyB3aGVuIGl0XG4gICAgICogcmVjb25uZWN0cyBhZnRlciBhIHRlbXBvcmFyeSBkaXNjb25uZWN0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIHBhY2tldFxuICAgICAqIEBwYXJhbSBvcHRzXG4gICAgICogQHBhcmFtIG9mZnNldFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgYWRkT2Zmc2V0SWZOZWNlc3NhcnkocGFja2V0LCBvcHRzLCBvZmZzZXQpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAoIXRoaXMubnNwLnNlcnZlci5vcHRzLmNvbm5lY3Rpb25TdGF0ZVJlY292ZXJ5KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaXNFdmVudFBhY2tldCA9IHBhY2tldC50eXBlID09PSAyO1xuICAgICAgICAvLyBwYWNrZXRzIHdpdGggYWNrbm93bGVkZ2VtZW50IGFyZSBub3Qgc3RvcmVkIGJlY2F1c2UgdGhlIGFja25vd2xlZGdlbWVudCBmdW5jdGlvbiBjYW5ub3QgYmUgc2VyaWFsaXplZCBhbmRcbiAgICAgICAgLy8gcmVzdG9yZWQgb24gYW5vdGhlciBzZXJ2ZXIgdXBvbiByZWNvbm5lY3Rpb25cbiAgICAgICAgY29uc3Qgd2l0aG91dEFja25vd2xlZGdlbWVudCA9IHBhY2tldC5pZCA9PT0gdW5kZWZpbmVkO1xuICAgICAgICBjb25zdCBub3RWb2xhdGlsZSA9ICgoX2EgPSBvcHRzLmZsYWdzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Eudm9sYXRpbGUpID09PSB1bmRlZmluZWQ7XG4gICAgICAgIGlmIChpc0V2ZW50UGFja2V0ICYmIHdpdGhvdXRBY2tub3dsZWRnZW1lbnQgJiYgbm90Vm9sYXRpbGUpIHtcbiAgICAgICAgICAgIHBhY2tldC5kYXRhLnB1c2gob2Zmc2V0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBicm9hZGNhc3RXaXRoQWNrKHBhY2tldCwgb3B0cywgY2xpZW50Q291bnRDYWxsYmFjaywgYWNrKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3Qgb25seUxvY2FsID0gKF9hID0gb3B0cyA9PT0gbnVsbCB8fCBvcHRzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRzLmZsYWdzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubG9jYWw7XG4gICAgICAgIGlmICghb25seUxvY2FsKSB7XG4gICAgICAgICAgICBjb25zdCByZXF1ZXN0SWQgPSByYW5kb21JZCgpO1xuICAgICAgICAgICAgdGhpcy5hY2tSZXF1ZXN0cy5zZXQocmVxdWVzdElkLCB7XG4gICAgICAgICAgICAgICAgY2xpZW50Q291bnRDYWxsYmFjayxcbiAgICAgICAgICAgICAgICBhY2ssXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMucHVibGlzaCh7XG4gICAgICAgICAgICAgICAgdHlwZTogTWVzc2FnZVR5cGUuQlJPQURDQVNULFxuICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgcGFja2V0LFxuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0SWQsXG4gICAgICAgICAgICAgICAgICAgIG9wdHM6IGVuY29kZU9wdGlvbnMob3B0cyksXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gd2UgaGF2ZSBubyB3YXkgdG8ga25vdyBhdCB0aGlzIGxldmVsIHdoZXRoZXIgdGhlIHNlcnZlciBoYXMgcmVjZWl2ZWQgYW4gYWNrbm93bGVkZ2VtZW50IGZyb20gZWFjaCBjbGllbnQsIHNvIHdlXG4gICAgICAgICAgICAvLyB3aWxsIHNpbXBseSBjbGVhbiB1cCB0aGUgYWNrUmVxdWVzdHMgbWFwIGFmdGVyIHRoZSBnaXZlbiBkZWxheVxuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5hY2tSZXF1ZXN0cy5kZWxldGUocmVxdWVzdElkKTtcbiAgICAgICAgICAgIH0sIG9wdHMuZmxhZ3MudGltZW91dCk7XG4gICAgICAgIH1cbiAgICAgICAgc3VwZXIuYnJvYWRjYXN0V2l0aEFjayhwYWNrZXQsIG9wdHMsIGNsaWVudENvdW50Q2FsbGJhY2ssIGFjayk7XG4gICAgfVxuICAgIGFzeW5jIGFkZFNvY2tldHMob3B0cywgcm9vbXMpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCBvbmx5TG9jYWwgPSAoX2EgPSBvcHRzLmZsYWdzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubG9jYWw7XG4gICAgICAgIGlmICghb25seUxvY2FsKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucHVibGlzaEFuZFJldHVybk9mZnNldCh7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IE1lc3NhZ2VUeXBlLlNPQ0tFVFNfSk9JTixcbiAgICAgICAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3B0czogZW5jb2RlT3B0aW9ucyhvcHRzKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvb21zLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBkZWJ1ZyhcIlslc10gZXJyb3Igd2hpbGUgcHVibGlzaGluZyBtZXNzYWdlOiAlc1wiLCB0aGlzLnVpZCwgZS5tZXNzYWdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzdXBlci5hZGRTb2NrZXRzKG9wdHMsIHJvb21zKTtcbiAgICB9XG4gICAgYXN5bmMgZGVsU29ja2V0cyhvcHRzLCByb29tcykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IG9ubHlMb2NhbCA9IChfYSA9IG9wdHMuZmxhZ3MpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5sb2NhbDtcbiAgICAgICAgaWYgKCFvbmx5TG9jYWwpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5wdWJsaXNoQW5kUmV0dXJuT2Zmc2V0KHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogTWVzc2FnZVR5cGUuU09DS0VUU19MRUFWRSxcbiAgICAgICAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3B0czogZW5jb2RlT3B0aW9ucyhvcHRzKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvb21zLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBkZWJ1ZyhcIlslc10gZXJyb3Igd2hpbGUgcHVibGlzaGluZyBtZXNzYWdlOiAlc1wiLCB0aGlzLnVpZCwgZS5tZXNzYWdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzdXBlci5kZWxTb2NrZXRzKG9wdHMsIHJvb21zKTtcbiAgICB9XG4gICAgYXN5bmMgZGlzY29ubmVjdFNvY2tldHMob3B0cywgY2xvc2UpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCBvbmx5TG9jYWwgPSAoX2EgPSBvcHRzLmZsYWdzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubG9jYWw7XG4gICAgICAgIGlmICghb25seUxvY2FsKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucHVibGlzaEFuZFJldHVybk9mZnNldCh7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IE1lc3NhZ2VUeXBlLkRJU0NPTk5FQ1RfU09DS0VUUyxcbiAgICAgICAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3B0czogZW5jb2RlT3B0aW9ucyhvcHRzKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsb3NlLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBkZWJ1ZyhcIlslc10gZXJyb3Igd2hpbGUgcHVibGlzaGluZyBtZXNzYWdlOiAlc1wiLCB0aGlzLnVpZCwgZS5tZXNzYWdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzdXBlci5kaXNjb25uZWN0U29ja2V0cyhvcHRzLCBjbG9zZSk7XG4gICAgfVxuICAgIGFzeW5jIGZldGNoU29ja2V0cyhvcHRzKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3QgW2xvY2FsU29ja2V0cywgc2VydmVyQ291bnRdID0gYXdhaXQgUHJvbWlzZS5hbGwoW1xuICAgICAgICAgICAgc3VwZXIuZmV0Y2hTb2NrZXRzKG9wdHMpLFxuICAgICAgICAgICAgdGhpcy5zZXJ2ZXJDb3VudCgpLFxuICAgICAgICBdKTtcbiAgICAgICAgY29uc3QgZXhwZWN0ZWRSZXNwb25zZUNvdW50ID0gc2VydmVyQ291bnQgLSAxO1xuICAgICAgICBpZiAoKChfYSA9IG9wdHMuZmxhZ3MpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5sb2NhbCkgfHwgZXhwZWN0ZWRSZXNwb25zZUNvdW50IDw9IDApIHtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbFNvY2tldHM7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVxdWVzdElkID0gcmFuZG9tSWQoKTtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBzdG9yZWRSZXF1ZXN0ID0gdGhpcy5yZXF1ZXN0cy5nZXQocmVxdWVzdElkKTtcbiAgICAgICAgICAgICAgICBpZiAoc3RvcmVkUmVxdWVzdCkge1xuICAgICAgICAgICAgICAgICAgICByZWplY3QobmV3IEVycm9yKGB0aW1lb3V0IHJlYWNoZWQ6IG9ubHkgJHtzdG9yZWRSZXF1ZXN0LmN1cnJlbnR9IHJlc3BvbnNlcyByZWNlaXZlZCBvdXQgb2YgJHtzdG9yZWRSZXF1ZXN0LmV4cGVjdGVkfWApKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXF1ZXN0cy5kZWxldGUocmVxdWVzdElkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBvcHRzLmZsYWdzLnRpbWVvdXQgfHwgREVGQVVMVF9USU1FT1VUKTtcbiAgICAgICAgICAgIGNvbnN0IHN0b3JlZFJlcXVlc3QgPSB7XG4gICAgICAgICAgICAgICAgdHlwZTogTWVzc2FnZVR5cGUuRkVUQ0hfU09DS0VUUyxcbiAgICAgICAgICAgICAgICByZXNvbHZlLFxuICAgICAgICAgICAgICAgIHRpbWVvdXQsXG4gICAgICAgICAgICAgICAgY3VycmVudDogMCxcbiAgICAgICAgICAgICAgICBleHBlY3RlZDogZXhwZWN0ZWRSZXNwb25zZUNvdW50LFxuICAgICAgICAgICAgICAgIHJlc3BvbnNlczogbG9jYWxTb2NrZXRzLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMucmVxdWVzdHMuc2V0KHJlcXVlc3RJZCwgc3RvcmVkUmVxdWVzdCk7XG4gICAgICAgICAgICB0aGlzLnB1Ymxpc2goe1xuICAgICAgICAgICAgICAgIHR5cGU6IE1lc3NhZ2VUeXBlLkZFVENIX1NPQ0tFVFMsXG4gICAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgICAgICBvcHRzOiBlbmNvZGVPcHRpb25zKG9wdHMpLFxuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0SWQsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgYXN5bmMgc2VydmVyU2lkZUVtaXQocGFja2V0KSB7XG4gICAgICAgIGNvbnN0IHdpdGhBY2sgPSB0eXBlb2YgcGFja2V0W3BhY2tldC5sZW5ndGggLSAxXSA9PT0gXCJmdW5jdGlvblwiO1xuICAgICAgICBpZiAoIXdpdGhBY2spIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnB1Ymxpc2goe1xuICAgICAgICAgICAgICAgIHR5cGU6IE1lc3NhZ2VUeXBlLlNFUlZFUl9TSURFX0VNSVQsXG4gICAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgICAgICBwYWNrZXQsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFjayA9IHBhY2tldC5wb3AoKTtcbiAgICAgICAgY29uc3QgZXhwZWN0ZWRSZXNwb25zZUNvdW50ID0gKGF3YWl0IHRoaXMuc2VydmVyQ291bnQoKSkgLSAxO1xuICAgICAgICBkZWJ1ZygnWyVzXSB3YWl0aW5nIGZvciAlZCByZXNwb25zZXMgdG8gXCJzZXJ2ZXJTaWRlRW1pdFwiIHJlcXVlc3QnLCB0aGlzLnVpZCwgZXhwZWN0ZWRSZXNwb25zZUNvdW50KTtcbiAgICAgICAgaWYgKGV4cGVjdGVkUmVzcG9uc2VDb3VudCA8PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gYWNrKG51bGwsIFtdKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXF1ZXN0SWQgPSByYW5kb21JZCgpO1xuICAgICAgICBjb25zdCB0aW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBzdG9yZWRSZXF1ZXN0ID0gdGhpcy5yZXF1ZXN0cy5nZXQocmVxdWVzdElkKTtcbiAgICAgICAgICAgIGlmIChzdG9yZWRSZXF1ZXN0KSB7XG4gICAgICAgICAgICAgICAgYWNrKG5ldyBFcnJvcihgdGltZW91dCByZWFjaGVkOiBvbmx5ICR7c3RvcmVkUmVxdWVzdC5jdXJyZW50fSByZXNwb25zZXMgcmVjZWl2ZWQgb3V0IG9mICR7c3RvcmVkUmVxdWVzdC5leHBlY3RlZH1gKSwgc3RvcmVkUmVxdWVzdC5yZXNwb25zZXMpO1xuICAgICAgICAgICAgICAgIHRoaXMucmVxdWVzdHMuZGVsZXRlKHJlcXVlc3RJZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIERFRkFVTFRfVElNRU9VVCk7XG4gICAgICAgIGNvbnN0IHN0b3JlZFJlcXVlc3QgPSB7XG4gICAgICAgICAgICB0eXBlOiBNZXNzYWdlVHlwZS5TRVJWRVJfU0lERV9FTUlULFxuICAgICAgICAgICAgcmVzb2x2ZTogYWNrLFxuICAgICAgICAgICAgdGltZW91dCxcbiAgICAgICAgICAgIGN1cnJlbnQ6IDAsXG4gICAgICAgICAgICBleHBlY3RlZDogZXhwZWN0ZWRSZXNwb25zZUNvdW50LFxuICAgICAgICAgICAgcmVzcG9uc2VzOiBbXSxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5yZXF1ZXN0cy5zZXQocmVxdWVzdElkLCBzdG9yZWRSZXF1ZXN0KTtcbiAgICAgICAgdGhpcy5wdWJsaXNoKHtcbiAgICAgICAgICAgIHR5cGU6IE1lc3NhZ2VUeXBlLlNFUlZFUl9TSURFX0VNSVQsXG4gICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgcmVxdWVzdElkLFxuICAgICAgICAgICAgICAgIHBhY2tldCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBwdWJsaXNoKG1lc3NhZ2UpIHtcbiAgICAgICAgdGhpcy5wdWJsaXNoQW5kUmV0dXJuT2Zmc2V0KG1lc3NhZ2UpLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgICAgIGRlYnVnKFwiWyVzXSBlcnJvciB3aGlsZSBwdWJsaXNoaW5nIG1lc3NhZ2U6ICVzXCIsIHRoaXMudWlkLCBlcnIpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcHVibGlzaEFuZFJldHVybk9mZnNldChtZXNzYWdlKSB7XG4gICAgICAgIG1lc3NhZ2UudWlkID0gdGhpcy51aWQ7XG4gICAgICAgIG1lc3NhZ2UubnNwID0gdGhpcy5uc3AubmFtZTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZG9QdWJsaXNoKG1lc3NhZ2UpO1xuICAgIH1cbiAgICBwdWJsaXNoUmVzcG9uc2UocmVxdWVzdGVyVWlkLCByZXNwb25zZSkge1xuICAgICAgICByZXNwb25zZS51aWQgPSB0aGlzLnVpZDtcbiAgICAgICAgcmVzcG9uc2UubnNwID0gdGhpcy5uc3AubmFtZTtcbiAgICAgICAgdGhpcy5kb1B1Ymxpc2hSZXNwb25zZShyZXF1ZXN0ZXJVaWQsIHJlc3BvbnNlKS5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgICAgICBkZWJ1ZyhcIlslc10gZXJyb3Igd2hpbGUgcHVibGlzaGluZyByZXNwb25zZTogJXNcIiwgdGhpcy51aWQsIGVycik7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmV4cG9ydHMuQ2x1c3RlckFkYXB0ZXIgPSBDbHVzdGVyQWRhcHRlcjtcbmNsYXNzIENsdXN0ZXJBZGFwdGVyV2l0aEhlYXJ0YmVhdCBleHRlbmRzIENsdXN0ZXJBZGFwdGVyIHtcbiAgICBjb25zdHJ1Y3Rvcihuc3AsIG9wdHMpIHtcbiAgICAgICAgc3VwZXIobnNwKTtcbiAgICAgICAgdGhpcy5ub2Rlc01hcCA9IG5ldyBNYXAoKTsgLy8gdWlkID0+IHRpbWVzdGFtcCBvZiBsYXN0IG1lc3NhZ2VcbiAgICAgICAgdGhpcy5jdXN0b21SZXF1ZXN0cyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5fb3B0cyA9IE9iamVjdC5hc3NpZ24oe1xuICAgICAgICAgICAgaGVhcnRiZWF0SW50ZXJ2YWw6IDUwMDAsXG4gICAgICAgICAgICBoZWFydGJlYXRUaW1lb3V0OiAxMDAwMCxcbiAgICAgICAgfSwgb3B0cyk7XG4gICAgICAgIHRoaXMuY2xlYW51cFRpbWVyID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcbiAgICAgICAgICAgIHRoaXMubm9kZXNNYXAuZm9yRWFjaCgobGFzdFNlZW4sIHVpZCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5vZGVTZWVtc0Rvd24gPSBub3cgLSBsYXN0U2VlbiA+IHRoaXMuX29wdHMuaGVhcnRiZWF0VGltZW91dDtcbiAgICAgICAgICAgICAgICBpZiAobm9kZVNlZW1zRG93bikge1xuICAgICAgICAgICAgICAgICAgICBkZWJ1ZyhcIlslc10gbm9kZSAlcyBzZWVtcyBkb3duXCIsIHRoaXMudWlkLCB1aWQpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZU5vZGUodWlkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSwgMTAwMCk7XG4gICAgfVxuICAgIGluaXQoKSB7XG4gICAgICAgIHRoaXMucHVibGlzaCh7XG4gICAgICAgICAgICB0eXBlOiBNZXNzYWdlVHlwZS5JTklUSUFMX0hFQVJUQkVBVCxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHNjaGVkdWxlSGVhcnRiZWF0KCkge1xuICAgICAgICBpZiAodGhpcy5oZWFydGJlYXRUaW1lcikge1xuICAgICAgICAgICAgdGhpcy5oZWFydGJlYXRUaW1lci5yZWZyZXNoKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmhlYXJ0YmVhdFRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5wdWJsaXNoKHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogTWVzc2FnZVR5cGUuSEVBUlRCRUFULFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSwgdGhpcy5fb3B0cy5oZWFydGJlYXRJbnRlcnZhbCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2xvc2UoKSB7XG4gICAgICAgIHRoaXMucHVibGlzaCh7XG4gICAgICAgICAgICB0eXBlOiBNZXNzYWdlVHlwZS5BREFQVEVSX0NMT1NFLFxuICAgICAgICB9KTtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuaGVhcnRiZWF0VGltZXIpO1xuICAgICAgICBpZiAodGhpcy5jbGVhbnVwVGltZXIpIHtcbiAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5jbGVhbnVwVGltZXIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIG9uTWVzc2FnZShtZXNzYWdlLCBvZmZzZXQpIHtcbiAgICAgICAgaWYgKG1lc3NhZ2UudWlkID09PSB0aGlzLnVpZCkge1xuICAgICAgICAgICAgcmV0dXJuIGRlYnVnKFwiWyVzXSBpZ25vcmUgbWVzc2FnZSBmcm9tIHNlbGZcIiwgdGhpcy51aWQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLnVpZCAmJiBtZXNzYWdlLnVpZCAhPT0gRU1JVFRFUl9VSUQpIHtcbiAgICAgICAgICAgIC8vIHdlIHRyYWNrIHRoZSBVSUQgb2YgZWFjaCBzZW5kZXIsIGluIG9yZGVyIHRvIGtub3cgaG93IG1hbnkgc2VydmVycyB0aGVyZSBhcmUgaW4gdGhlIGNsdXN0ZXJcbiAgICAgICAgICAgIHRoaXMubm9kZXNNYXAuc2V0KG1lc3NhZ2UudWlkLCBEYXRlLm5vdygpKTtcbiAgICAgICAgfVxuICAgICAgICBkZWJ1ZyhcIlslc10gbmV3IGV2ZW50IG9mIHR5cGUgJWQgZnJvbSAlc1wiLCB0aGlzLnVpZCwgbWVzc2FnZS50eXBlLCBtZXNzYWdlLnVpZCk7XG4gICAgICAgIHN3aXRjaCAobWVzc2FnZS50eXBlKSB7XG4gICAgICAgICAgICBjYXNlIE1lc3NhZ2VUeXBlLklOSVRJQUxfSEVBUlRCRUFUOlxuICAgICAgICAgICAgICAgIHRoaXMucHVibGlzaCh7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IE1lc3NhZ2VUeXBlLkhFQVJUQkVBVCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgTWVzc2FnZVR5cGUuSEVBUlRCRUFUOlxuICAgICAgICAgICAgICAgIC8vIG5vdGhpbmcgdG8gZG9cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgTWVzc2FnZVR5cGUuQURBUFRFUl9DTE9TRTpcbiAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZU5vZGUobWVzc2FnZS51aWQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBzdXBlci5vbk1lc3NhZ2UobWVzc2FnZSwgb2Zmc2V0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzZXJ2ZXJDb3VudCgpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgxICsgdGhpcy5ub2Rlc01hcC5zaXplKTtcbiAgICB9XG4gICAgcHVibGlzaChtZXNzYWdlKSB7XG4gICAgICAgIHRoaXMuc2NoZWR1bGVIZWFydGJlYXQoKTtcbiAgICAgICAgcmV0dXJuIHN1cGVyLnB1Ymxpc2gobWVzc2FnZSk7XG4gICAgfVxuICAgIGFzeW5jIHNlcnZlclNpZGVFbWl0KHBhY2tldCkge1xuICAgICAgICBjb25zdCB3aXRoQWNrID0gdHlwZW9mIHBhY2tldFtwYWNrZXQubGVuZ3RoIC0gMV0gPT09IFwiZnVuY3Rpb25cIjtcbiAgICAgICAgaWYgKCF3aXRoQWNrKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wdWJsaXNoKHtcbiAgICAgICAgICAgICAgICB0eXBlOiBNZXNzYWdlVHlwZS5TRVJWRVJfU0lERV9FTUlULFxuICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgcGFja2V0LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhY2sgPSBwYWNrZXQucG9wKCk7XG4gICAgICAgIGNvbnN0IGV4cGVjdGVkUmVzcG9uc2VDb3VudCA9IHRoaXMubm9kZXNNYXAuc2l6ZTtcbiAgICAgICAgZGVidWcoJ1slc10gd2FpdGluZyBmb3IgJWQgcmVzcG9uc2VzIHRvIFwic2VydmVyU2lkZUVtaXRcIiByZXF1ZXN0JywgdGhpcy51aWQsIGV4cGVjdGVkUmVzcG9uc2VDb3VudCk7XG4gICAgICAgIGlmIChleHBlY3RlZFJlc3BvbnNlQ291bnQgPD0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIGFjayhudWxsLCBbXSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVxdWVzdElkID0gcmFuZG9tSWQoKTtcbiAgICAgICAgY29uc3QgdGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgc3RvcmVkUmVxdWVzdCA9IHRoaXMuY3VzdG9tUmVxdWVzdHMuZ2V0KHJlcXVlc3RJZCk7XG4gICAgICAgICAgICBpZiAoc3RvcmVkUmVxdWVzdCkge1xuICAgICAgICAgICAgICAgIGFjayhuZXcgRXJyb3IoYHRpbWVvdXQgcmVhY2hlZDogbWlzc2luZyAke3N0b3JlZFJlcXVlc3QubWlzc2luZ1VpZHMuc2l6ZX0gcmVzcG9uc2VzYCksIHN0b3JlZFJlcXVlc3QucmVzcG9uc2VzKTtcbiAgICAgICAgICAgICAgICB0aGlzLmN1c3RvbVJlcXVlc3RzLmRlbGV0ZShyZXF1ZXN0SWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCBERUZBVUxUX1RJTUVPVVQpO1xuICAgICAgICBjb25zdCBzdG9yZWRSZXF1ZXN0ID0ge1xuICAgICAgICAgICAgdHlwZTogTWVzc2FnZVR5cGUuU0VSVkVSX1NJREVfRU1JVCxcbiAgICAgICAgICAgIHJlc29sdmU6IGFjayxcbiAgICAgICAgICAgIHRpbWVvdXQsXG4gICAgICAgICAgICBtaXNzaW5nVWlkczogbmV3IFNldChbLi4udGhpcy5ub2Rlc01hcC5rZXlzKCldKSxcbiAgICAgICAgICAgIHJlc3BvbnNlczogW10sXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuY3VzdG9tUmVxdWVzdHMuc2V0KHJlcXVlc3RJZCwgc3RvcmVkUmVxdWVzdCk7XG4gICAgICAgIHRoaXMucHVibGlzaCh7XG4gICAgICAgICAgICB0eXBlOiBNZXNzYWdlVHlwZS5TRVJWRVJfU0lERV9FTUlULFxuICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgIHJlcXVlc3RJZCxcbiAgICAgICAgICAgICAgICBwYWNrZXQsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgYXN5bmMgZmV0Y2hTb2NrZXRzKG9wdHMpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCBbbG9jYWxTb2NrZXRzLCBzZXJ2ZXJDb3VudF0gPSBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgICAgICAgICBzdXBlci5mZXRjaFNvY2tldHMoe1xuICAgICAgICAgICAgICAgIHJvb21zOiBvcHRzLnJvb21zLFxuICAgICAgICAgICAgICAgIGV4Y2VwdDogb3B0cy5leGNlcHQsXG4gICAgICAgICAgICAgICAgZmxhZ3M6IHtcbiAgICAgICAgICAgICAgICAgICAgbG9jYWw6IHRydWUsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgdGhpcy5zZXJ2ZXJDb3VudCgpLFxuICAgICAgICBdKTtcbiAgICAgICAgY29uc3QgZXhwZWN0ZWRSZXNwb25zZUNvdW50ID0gc2VydmVyQ291bnQgLSAxO1xuICAgICAgICBpZiAoKChfYSA9IG9wdHMuZmxhZ3MpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5sb2NhbCkgfHwgZXhwZWN0ZWRSZXNwb25zZUNvdW50IDw9IDApIHtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbFNvY2tldHM7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVxdWVzdElkID0gcmFuZG9tSWQoKTtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBzdG9yZWRSZXF1ZXN0ID0gdGhpcy5jdXN0b21SZXF1ZXN0cy5nZXQocmVxdWVzdElkKTtcbiAgICAgICAgICAgICAgICBpZiAoc3RvcmVkUmVxdWVzdCkge1xuICAgICAgICAgICAgICAgICAgICByZWplY3QobmV3IEVycm9yKGB0aW1lb3V0IHJlYWNoZWQ6IG1pc3NpbmcgJHtzdG9yZWRSZXF1ZXN0Lm1pc3NpbmdVaWRzLnNpemV9IHJlc3BvbnNlc2ApKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jdXN0b21SZXF1ZXN0cy5kZWxldGUocmVxdWVzdElkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBvcHRzLmZsYWdzLnRpbWVvdXQgfHwgREVGQVVMVF9USU1FT1VUKTtcbiAgICAgICAgICAgIGNvbnN0IHN0b3JlZFJlcXVlc3QgPSB7XG4gICAgICAgICAgICAgICAgdHlwZTogTWVzc2FnZVR5cGUuRkVUQ0hfU09DS0VUUyxcbiAgICAgICAgICAgICAgICByZXNvbHZlLFxuICAgICAgICAgICAgICAgIHRpbWVvdXQsXG4gICAgICAgICAgICAgICAgbWlzc2luZ1VpZHM6IG5ldyBTZXQoWy4uLnRoaXMubm9kZXNNYXAua2V5cygpXSksXG4gICAgICAgICAgICAgICAgcmVzcG9uc2VzOiBsb2NhbFNvY2tldHMsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy5jdXN0b21SZXF1ZXN0cy5zZXQocmVxdWVzdElkLCBzdG9yZWRSZXF1ZXN0KTtcbiAgICAgICAgICAgIHRoaXMucHVibGlzaCh7XG4gICAgICAgICAgICAgICAgdHlwZTogTWVzc2FnZVR5cGUuRkVUQ0hfU09DS0VUUyxcbiAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgIG9wdHM6IGVuY29kZU9wdGlvbnMob3B0cyksXG4gICAgICAgICAgICAgICAgICAgIHJlcXVlc3RJZCxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBvblJlc3BvbnNlKHJlc3BvbnNlKSB7XG4gICAgICAgIGNvbnN0IHJlcXVlc3RJZCA9IHJlc3BvbnNlLmRhdGEucmVxdWVzdElkO1xuICAgICAgICBkZWJ1ZyhcIlslc10gcmVjZWl2ZWQgcmVzcG9uc2UgJXMgdG8gcmVxdWVzdCAlc1wiLCB0aGlzLnVpZCwgcmVzcG9uc2UudHlwZSwgcmVxdWVzdElkKTtcbiAgICAgICAgc3dpdGNoIChyZXNwb25zZS50eXBlKSB7XG4gICAgICAgICAgICBjYXNlIE1lc3NhZ2VUeXBlLkZFVENIX1NPQ0tFVFNfUkVTUE9OU0U6IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXF1ZXN0ID0gdGhpcy5jdXN0b21SZXF1ZXN0cy5nZXQocmVxdWVzdElkKTtcbiAgICAgICAgICAgICAgICBpZiAoIXJlcXVlc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXNwb25zZS5kYXRhLnNvY2tldHMuZm9yRWFjaCgoc29ja2V0KSA9PiByZXF1ZXN0LnJlc3BvbnNlcy5wdXNoKHNvY2tldCkpO1xuICAgICAgICAgICAgICAgIHJlcXVlc3QubWlzc2luZ1VpZHMuZGVsZXRlKHJlc3BvbnNlLnVpZCk7XG4gICAgICAgICAgICAgICAgaWYgKHJlcXVlc3QubWlzc2luZ1VpZHMuc2l6ZSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQocmVxdWVzdC50aW1lb3V0KTtcbiAgICAgICAgICAgICAgICAgICAgcmVxdWVzdC5yZXNvbHZlKHJlcXVlc3QucmVzcG9uc2VzKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jdXN0b21SZXF1ZXN0cy5kZWxldGUocmVxdWVzdElkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIE1lc3NhZ2VUeXBlLlNFUlZFUl9TSURFX0VNSVRfUkVTUE9OU0U6IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXF1ZXN0ID0gdGhpcy5jdXN0b21SZXF1ZXN0cy5nZXQocmVxdWVzdElkKTtcbiAgICAgICAgICAgICAgICBpZiAoIXJlcXVlc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXF1ZXN0LnJlc3BvbnNlcy5wdXNoKHJlc3BvbnNlLmRhdGEucGFja2V0KTtcbiAgICAgICAgICAgICAgICByZXF1ZXN0Lm1pc3NpbmdVaWRzLmRlbGV0ZShyZXNwb25zZS51aWQpO1xuICAgICAgICAgICAgICAgIGlmIChyZXF1ZXN0Lm1pc3NpbmdVaWRzLnNpemUgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHJlcXVlc3QudGltZW91dCk7XG4gICAgICAgICAgICAgICAgICAgIHJlcXVlc3QucmVzb2x2ZShudWxsLCByZXF1ZXN0LnJlc3BvbnNlcyk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY3VzdG9tUmVxdWVzdHMuZGVsZXRlKHJlcXVlc3RJZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBzdXBlci5vblJlc3BvbnNlKHJlc3BvbnNlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZW1vdmVOb2RlKHVpZCkge1xuICAgICAgICB0aGlzLmN1c3RvbVJlcXVlc3RzLmZvckVhY2goKHJlcXVlc3QsIHJlcXVlc3RJZCkgPT4ge1xuICAgICAgICAgICAgcmVxdWVzdC5taXNzaW5nVWlkcy5kZWxldGUodWlkKTtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0Lm1pc3NpbmdVaWRzLnNpemUgPT09IDApIHtcbiAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQocmVxdWVzdC50aW1lb3V0KTtcbiAgICAgICAgICAgICAgICBpZiAocmVxdWVzdC50eXBlID09PSBNZXNzYWdlVHlwZS5GRVRDSF9TT0NLRVRTKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlcXVlc3QucmVzb2x2ZShyZXF1ZXN0LnJlc3BvbnNlcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHJlcXVlc3QudHlwZSA9PT0gTWVzc2FnZVR5cGUuU0VSVkVSX1NJREVfRU1JVCkge1xuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0LnJlc29sdmUobnVsbCwgcmVxdWVzdC5yZXNwb25zZXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmN1c3RvbVJlcXVlc3RzLmRlbGV0ZShyZXF1ZXN0SWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5ub2Rlc01hcC5kZWxldGUodWlkKTtcbiAgICB9XG59XG5leHBvcnRzLkNsdXN0ZXJBZGFwdGVyV2l0aEhlYXJ0YmVhdCA9IENsdXN0ZXJBZGFwdGVyV2l0aEhlYXJ0YmVhdDtcbiJdLCJuYW1lcyI6WyJfX3Jlc3QiLCJzIiwiZSIsInQiLCJwIiwiT2JqZWN0IiwicHJvdG90eXBlIiwiaGFzT3duUHJvcGVydHkiLCJjYWxsIiwiaW5kZXhPZiIsImdldE93blByb3BlcnR5U3ltYm9scyIsImkiLCJsZW5ndGgiLCJwcm9wZXJ0eUlzRW51bWVyYWJsZSIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiQ2x1c3RlckFkYXB0ZXJXaXRoSGVhcnRiZWF0IiwiQ2x1c3RlckFkYXB0ZXIiLCJNZXNzYWdlVHlwZSIsImluX21lbW9yeV9hZGFwdGVyXzEiLCJyZXF1aXJlIiwiZGVidWdfMSIsImNyeXB0b18xIiwiZGVidWciLCJFTUlUVEVSX1VJRCIsIkRFRkFVTFRfVElNRU9VVCIsInJhbmRvbUlkIiwicmFuZG9tQnl0ZXMiLCJ0b1N0cmluZyIsImVuY29kZU9wdGlvbnMiLCJvcHRzIiwicm9vbXMiLCJleGNlcHQiLCJmbGFncyIsImRlY29kZU9wdGlvbnMiLCJTZXQiLCJBZGFwdGVyIiwiY29uc3RydWN0b3IiLCJuc3AiLCJyZXF1ZXN0cyIsIk1hcCIsImFja1JlcXVlc3RzIiwidWlkIiwib25NZXNzYWdlIiwibWVzc2FnZSIsIm9mZnNldCIsInR5cGUiLCJCUk9BRENBU1QiLCJ3aXRoQWNrIiwiZGF0YSIsInJlcXVlc3RJZCIsInVuZGVmaW5lZCIsImJyb2FkY2FzdFdpdGhBY2siLCJwYWNrZXQiLCJjbGllbnRDb3VudCIsInB1Ymxpc2hSZXNwb25zZSIsIkJST0FEQ0FTVF9DTElFTlRfQ09VTlQiLCJhcmciLCJCUk9BRENBU1RfQUNLIiwiYWRkT2Zmc2V0SWZOZWNlc3NhcnkiLCJicm9hZGNhc3QiLCJTT0NLRVRTX0pPSU4iLCJhZGRTb2NrZXRzIiwiU09DS0VUU19MRUFWRSIsImRlbFNvY2tldHMiLCJESVNDT05ORUNUX1NPQ0tFVFMiLCJkaXNjb25uZWN0U29ja2V0cyIsImNsb3NlIiwiRkVUQ0hfU09DS0VUUyIsImZldGNoU29ja2V0cyIsInRoZW4iLCJsb2NhbFNvY2tldHMiLCJGRVRDSF9TT0NLRVRTX1JFU1BPTlNFIiwic29ja2V0cyIsIm1hcCIsInNvY2tldCIsIl9hIiwiaGFuZHNoYWtlIiwic2Vzc2lvblN0b3JlIiwiaWQiLCJTRVJWRVJfU0lERV9FTUlUIiwiX29uU2VydmVyU2lkZUVtaXQiLCJjYWxsZWQiLCJjYWxsYmFjayIsIlNFUlZFUl9TSURFX0VNSVRfUkVTUE9OU0UiLCJvblJlc3BvbnNlIiwicmVzcG9uc2UiLCJfYiIsImdldCIsImNsaWVudENvdW50Q2FsbGJhY2siLCJhY2siLCJyZXF1ZXN0IiwiY3VycmVudCIsImZvckVhY2giLCJyZXNwb25zZXMiLCJwdXNoIiwiZXhwZWN0ZWQiLCJjbGVhclRpbWVvdXQiLCJ0aW1lb3V0IiwicmVzb2x2ZSIsImRlbGV0ZSIsIm9ubHlMb2NhbCIsImxvY2FsIiwicHVibGlzaEFuZFJldHVybk9mZnNldCIsInNlcnZlciIsImNvbm5lY3Rpb25TdGF0ZVJlY292ZXJ5IiwiaXNFdmVudFBhY2tldCIsIndpdGhvdXRBY2tub3dsZWRnZW1lbnQiLCJub3RWb2xhdGlsZSIsInZvbGF0aWxlIiwic2V0IiwicHVibGlzaCIsInNldFRpbWVvdXQiLCJzZXJ2ZXJDb3VudCIsIlByb21pc2UiLCJhbGwiLCJleHBlY3RlZFJlc3BvbnNlQ291bnQiLCJyZWplY3QiLCJzdG9yZWRSZXF1ZXN0IiwiRXJyb3IiLCJzZXJ2ZXJTaWRlRW1pdCIsInBvcCIsImNhdGNoIiwiZXJyIiwibmFtZSIsImRvUHVibGlzaCIsInJlcXVlc3RlclVpZCIsImRvUHVibGlzaFJlc3BvbnNlIiwibm9kZXNNYXAiLCJjdXN0b21SZXF1ZXN0cyIsIl9vcHRzIiwiYXNzaWduIiwiaGVhcnRiZWF0SW50ZXJ2YWwiLCJoZWFydGJlYXRUaW1lb3V0IiwiY2xlYW51cFRpbWVyIiwic2V0SW50ZXJ2YWwiLCJub3ciLCJEYXRlIiwibGFzdFNlZW4iLCJub2RlU2VlbXNEb3duIiwicmVtb3ZlTm9kZSIsImluaXQiLCJJTklUSUFMX0hFQVJUQkVBVCIsInNjaGVkdWxlSGVhcnRiZWF0IiwiaGVhcnRiZWF0VGltZXIiLCJyZWZyZXNoIiwiSEVBUlRCRUFUIiwiQURBUFRFUl9DTE9TRSIsImNsZWFySW50ZXJ2YWwiLCJzaXplIiwibWlzc2luZ1VpZHMiLCJrZXlzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/socket.io-adapter/dist/cluster-adapter.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/socket.io-adapter/dist/contrib/yeast.js":
/*!**************************************************************!*\
  !*** ./node_modules/socket.io-adapter/dist/contrib/yeast.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("// imported from https://github.com/unshiftio/yeast\n\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.yeast = exports.decode = exports.encode = void 0;\nconst alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_\".split(\"\"), length = 64, map = {};\nlet seed = 0, i = 0, prev;\n/**\n * Return a string representing the specified number.\n *\n * @param {Number} num The number to convert.\n * @returns {String} The string representation of the number.\n * @api public\n */ function encode(num) {\n    let encoded = \"\";\n    do {\n        encoded = alphabet[num % length] + encoded;\n        num = Math.floor(num / length);\n    }while (num > 0);\n    return encoded;\n}\nexports.encode = encode;\n/**\n * Return the integer value specified by the given string.\n *\n * @param {String} str The string to convert.\n * @returns {Number} The integer value represented by the string.\n * @api public\n */ function decode(str) {\n    let decoded = 0;\n    for(i = 0; i < str.length; i++){\n        decoded = decoded * length + map[str.charAt(i)];\n    }\n    return decoded;\n}\nexports.decode = decode;\n/**\n * Yeast: A tiny growing id generator.\n *\n * @returns {String} A unique id.\n * @api public\n */ function yeast() {\n    const now = encode(+new Date());\n    if (now !== prev) return seed = 0, prev = now;\n    return now + \".\" + encode(seed++);\n}\nexports.yeast = yeast;\n//\n// Map each character to its index.\n//\nfor(; i < length; i++)map[alphabet[i]] = i;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc29ja2V0LmlvLWFkYXB0ZXIvZGlzdC9jb250cmliL3llYXN0LmpzIiwibWFwcGluZ3MiOiJBQUFBLG1EQUFtRDtBQUN0QztBQUNiQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsYUFBYSxHQUFHQSxjQUFjLEdBQUdBLGNBQWMsR0FBRyxLQUFLO0FBQ3ZELE1BQU1LLFdBQVcsbUVBQW1FQyxLQUFLLENBQUMsS0FBS0MsU0FBUyxJQUFJQyxNQUFNLENBQUM7QUFDbkgsSUFBSUMsT0FBTyxHQUFHQyxJQUFJLEdBQUdDO0FBQ3JCOzs7Ozs7Q0FNQyxHQUNELFNBQVNQLE9BQU9RLEdBQUc7SUFDZixJQUFJQyxVQUFVO0lBQ2QsR0FBRztRQUNDQSxVQUFVUixRQUFRLENBQUNPLE1BQU1MLE9BQU8sR0FBR007UUFDbkNELE1BQU1FLEtBQUtDLEtBQUssQ0FBQ0gsTUFBTUw7SUFDM0IsUUFBU0ssTUFBTSxHQUFHO0lBQ2xCLE9BQU9DO0FBQ1g7QUFDQWIsY0FBYyxHQUFHSTtBQUNqQjs7Ozs7O0NBTUMsR0FDRCxTQUFTRCxPQUFPYSxHQUFHO0lBQ2YsSUFBSUMsVUFBVTtJQUNkLElBQUtQLElBQUksR0FBR0EsSUFBSU0sSUFBSVQsTUFBTSxFQUFFRyxJQUFLO1FBQzdCTyxVQUFVQSxVQUFVVixTQUFTQyxHQUFHLENBQUNRLElBQUlFLE1BQU0sQ0FBQ1IsR0FBRztJQUNuRDtJQUNBLE9BQU9PO0FBQ1g7QUFDQWpCLGNBQWMsR0FBR0c7QUFDakI7Ozs7O0NBS0MsR0FDRCxTQUFTRDtJQUNMLE1BQU1pQixNQUFNZixPQUFPLENBQUMsSUFBSWdCO0lBQ3hCLElBQUlELFFBQVFSLE1BQ1IsT0FBTyxPQUFRLEdBQUtBLE9BQU9RO0lBQy9CLE9BQU9BLE1BQU0sTUFBTWYsT0FBT0s7QUFDOUI7QUFDQVQsYUFBYSxHQUFHRTtBQUNoQixFQUFFO0FBQ0YsbUNBQW1DO0FBQ25DLEVBQUU7QUFDRixNQUFPUSxJQUFJSCxRQUFRRyxJQUNmRixHQUFHLENBQUNILFFBQVEsQ0FBQ0ssRUFBRSxDQUFDLEdBQUdBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZXhhbXJvc2gvLi9ub2RlX21vZHVsZXMvc29ja2V0LmlvLWFkYXB0ZXIvZGlzdC9jb250cmliL3llYXN0LmpzPzhkMmEiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gaW1wb3J0ZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vdW5zaGlmdGlvL3llYXN0XG5cInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMueWVhc3QgPSBleHBvcnRzLmRlY29kZSA9IGV4cG9ydHMuZW5jb2RlID0gdm9pZCAwO1xuY29uc3QgYWxwaGFiZXQgPSBcIjAxMjM0NTY3ODlBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6LV9cIi5zcGxpdChcIlwiKSwgbGVuZ3RoID0gNjQsIG1hcCA9IHt9O1xubGV0IHNlZWQgPSAwLCBpID0gMCwgcHJldjtcbi8qKlxuICogUmV0dXJuIGEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgc3BlY2lmaWVkIG51bWJlci5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gbnVtIFRoZSBudW1iZXIgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIG51bWJlci5cbiAqIEBhcGkgcHVibGljXG4gKi9cbmZ1bmN0aW9uIGVuY29kZShudW0pIHtcbiAgICBsZXQgZW5jb2RlZCA9IFwiXCI7XG4gICAgZG8ge1xuICAgICAgICBlbmNvZGVkID0gYWxwaGFiZXRbbnVtICUgbGVuZ3RoXSArIGVuY29kZWQ7XG4gICAgICAgIG51bSA9IE1hdGguZmxvb3IobnVtIC8gbGVuZ3RoKTtcbiAgICB9IHdoaWxlIChudW0gPiAwKTtcbiAgICByZXR1cm4gZW5jb2RlZDtcbn1cbmV4cG9ydHMuZW5jb2RlID0gZW5jb2RlO1xuLyoqXG4gKiBSZXR1cm4gdGhlIGludGVnZXIgdmFsdWUgc3BlY2lmaWVkIGJ5IHRoZSBnaXZlbiBzdHJpbmcuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0ciBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgaW50ZWdlciB2YWx1ZSByZXByZXNlbnRlZCBieSB0aGUgc3RyaW5nLlxuICogQGFwaSBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gZGVjb2RlKHN0cikge1xuICAgIGxldCBkZWNvZGVkID0gMDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGRlY29kZWQgPSBkZWNvZGVkICogbGVuZ3RoICsgbWFwW3N0ci5jaGFyQXQoaSldO1xuICAgIH1cbiAgICByZXR1cm4gZGVjb2RlZDtcbn1cbmV4cG9ydHMuZGVjb2RlID0gZGVjb2RlO1xuLyoqXG4gKiBZZWFzdDogQSB0aW55IGdyb3dpbmcgaWQgZ2VuZXJhdG9yLlxuICpcbiAqIEByZXR1cm5zIHtTdHJpbmd9IEEgdW5pcXVlIGlkLlxuICogQGFwaSBwdWJsaWNcbiAqL1xuZnVuY3Rpb24geWVhc3QoKSB7XG4gICAgY29uc3Qgbm93ID0gZW5jb2RlKCtuZXcgRGF0ZSgpKTtcbiAgICBpZiAobm93ICE9PSBwcmV2KVxuICAgICAgICByZXR1cm4gKHNlZWQgPSAwKSwgKHByZXYgPSBub3cpO1xuICAgIHJldHVybiBub3cgKyBcIi5cIiArIGVuY29kZShzZWVkKyspO1xufVxuZXhwb3J0cy55ZWFzdCA9IHllYXN0O1xuLy9cbi8vIE1hcCBlYWNoIGNoYXJhY3RlciB0byBpdHMgaW5kZXguXG4vL1xuZm9yICg7IGkgPCBsZW5ndGg7IGkrKylcbiAgICBtYXBbYWxwaGFiZXRbaV1dID0gaTtcbiJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsInllYXN0IiwiZGVjb2RlIiwiZW5jb2RlIiwiYWxwaGFiZXQiLCJzcGxpdCIsImxlbmd0aCIsIm1hcCIsInNlZWQiLCJpIiwicHJldiIsIm51bSIsImVuY29kZWQiLCJNYXRoIiwiZmxvb3IiLCJzdHIiLCJkZWNvZGVkIiwiY2hhckF0Iiwibm93IiwiRGF0ZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/socket.io-adapter/dist/contrib/yeast.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/socket.io-adapter/dist/in-memory-adapter.js":
/*!******************************************************************!*\
  !*** ./node_modules/socket.io-adapter/dist/in-memory-adapter.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nvar _a;\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.SessionAwareAdapter = exports.Adapter = void 0;\nconst events_1 = __webpack_require__(/*! events */ \"events\");\nconst yeast_1 = __webpack_require__(/*! ./contrib/yeast */ \"(rsc)/./node_modules/socket.io-adapter/dist/contrib/yeast.js\");\nconst WebSocket = __webpack_require__(/*! ws */ \"(rsc)/./node_modules/ws/index.js\");\nconst canPreComputeFrame = typeof ((_a = WebSocket === null || WebSocket === void 0 ? void 0 : WebSocket.Sender) === null || _a === void 0 ? void 0 : _a.frame) === \"function\";\nclass Adapter extends events_1.EventEmitter {\n    /**\n     * In-memory adapter constructor.\n     *\n     * @param {Namespace} nsp\n     */ constructor(nsp){\n        super();\n        this.nsp = nsp;\n        this.rooms = new Map();\n        this.sids = new Map();\n        this.encoder = nsp.server.encoder;\n    }\n    /**\n     * To be overridden\n     */ init() {}\n    /**\n     * To be overridden\n     */ close() {}\n    /**\n     * Returns the number of Socket.IO servers in the cluster\n     *\n     * @public\n     */ serverCount() {\n        return Promise.resolve(1);\n    }\n    /**\n     * Adds a socket to a list of room.\n     *\n     * @param {SocketId}  id      the socket id\n     * @param {Set<Room>} rooms   a set of rooms\n     * @public\n     */ addAll(id, rooms) {\n        if (!this.sids.has(id)) {\n            this.sids.set(id, new Set());\n        }\n        for (const room of rooms){\n            this.sids.get(id).add(room);\n            if (!this.rooms.has(room)) {\n                this.rooms.set(room, new Set());\n                this.emit(\"create-room\", room);\n            }\n            if (!this.rooms.get(room).has(id)) {\n                this.rooms.get(room).add(id);\n                this.emit(\"join-room\", room, id);\n            }\n        }\n    }\n    /**\n     * Removes a socket from a room.\n     *\n     * @param {SocketId} id     the socket id\n     * @param {Room}     room   the room name\n     */ del(id, room) {\n        if (this.sids.has(id)) {\n            this.sids.get(id).delete(room);\n        }\n        this._del(room, id);\n    }\n    _del(room, id) {\n        const _room = this.rooms.get(room);\n        if (_room != null) {\n            const deleted = _room.delete(id);\n            if (deleted) {\n                this.emit(\"leave-room\", room, id);\n            }\n            if (_room.size === 0 && this.rooms.delete(room)) {\n                this.emit(\"delete-room\", room);\n            }\n        }\n    }\n    /**\n     * Removes a socket from all rooms it's joined.\n     *\n     * @param {SocketId} id   the socket id\n     */ delAll(id) {\n        if (!this.sids.has(id)) {\n            return;\n        }\n        for (const room of this.sids.get(id)){\n            this._del(room, id);\n        }\n        this.sids.delete(id);\n    }\n    /**\n     * Broadcasts a packet.\n     *\n     * Options:\n     *  - `flags` {Object} flags for this packet\n     *  - `except` {Array} sids that should be excluded\n     *  - `rooms` {Array} list of rooms to broadcast to\n     *\n     * @param {Object} packet   the packet object\n     * @param {Object} opts     the options\n     * @public\n     */ broadcast(packet, opts) {\n        const flags = opts.flags || {};\n        const packetOpts = {\n            preEncoded: true,\n            volatile: flags.volatile,\n            compress: flags.compress\n        };\n        packet.nsp = this.nsp.name;\n        const encodedPackets = this._encode(packet, packetOpts);\n        this.apply(opts, (socket)=>{\n            if (typeof socket.notifyOutgoingListeners === \"function\") {\n                socket.notifyOutgoingListeners(packet);\n            }\n            socket.client.writeToEngine(encodedPackets, packetOpts);\n        });\n    }\n    /**\n     * Broadcasts a packet and expects multiple acknowledgements.\n     *\n     * Options:\n     *  - `flags` {Object} flags for this packet\n     *  - `except` {Array} sids that should be excluded\n     *  - `rooms` {Array} list of rooms to broadcast to\n     *\n     * @param {Object} packet   the packet object\n     * @param {Object} opts     the options\n     * @param clientCountCallback - the number of clients that received the packet\n     * @param ack                 - the callback that will be called for each client response\n     *\n     * @public\n     */ broadcastWithAck(packet, opts, clientCountCallback, ack) {\n        const flags = opts.flags || {};\n        const packetOpts = {\n            preEncoded: true,\n            volatile: flags.volatile,\n            compress: flags.compress\n        };\n        packet.nsp = this.nsp.name;\n        // we can use the same id for each packet, since the _ids counter is common (no duplicate)\n        packet.id = this.nsp._ids++;\n        const encodedPackets = this._encode(packet, packetOpts);\n        let clientCount = 0;\n        this.apply(opts, (socket)=>{\n            // track the total number of acknowledgements that are expected\n            clientCount++;\n            // call the ack callback for each client response\n            socket.acks.set(packet.id, ack);\n            if (typeof socket.notifyOutgoingListeners === \"function\") {\n                socket.notifyOutgoingListeners(packet);\n            }\n            socket.client.writeToEngine(encodedPackets, packetOpts);\n        });\n        clientCountCallback(clientCount);\n    }\n    _encode(packet, packetOpts) {\n        const encodedPackets = this.encoder.encode(packet);\n        if (canPreComputeFrame && encodedPackets.length === 1 && typeof encodedPackets[0] === \"string\") {\n            // \"4\" being the \"message\" packet type in the Engine.IO protocol\n            const data = Buffer.from(\"4\" + encodedPackets[0]);\n            // see https://github.com/websockets/ws/issues/617#issuecomment-283002469\n            packetOpts.wsPreEncodedFrame = WebSocket.Sender.frame(data, {\n                readOnly: false,\n                mask: false,\n                rsv1: false,\n                opcode: 1,\n                fin: true\n            });\n        }\n        return encodedPackets;\n    }\n    /**\n     * Gets a list of sockets by sid.\n     *\n     * @param {Set<Room>} rooms   the explicit set of rooms to check.\n     */ sockets(rooms) {\n        const sids = new Set();\n        this.apply({\n            rooms\n        }, (socket)=>{\n            sids.add(socket.id);\n        });\n        return Promise.resolve(sids);\n    }\n    /**\n     * Gets the list of rooms a given socket has joined.\n     *\n     * @param {SocketId} id   the socket id\n     */ socketRooms(id) {\n        return this.sids.get(id);\n    }\n    /**\n     * Returns the matching socket instances\n     *\n     * @param opts - the filters to apply\n     */ fetchSockets(opts) {\n        const sockets = [];\n        this.apply(opts, (socket)=>{\n            sockets.push(socket);\n        });\n        return Promise.resolve(sockets);\n    }\n    /**\n     * Makes the matching socket instances join the specified rooms\n     *\n     * @param opts - the filters to apply\n     * @param rooms - the rooms to join\n     */ addSockets(opts, rooms) {\n        this.apply(opts, (socket)=>{\n            socket.join(rooms);\n        });\n    }\n    /**\n     * Makes the matching socket instances leave the specified rooms\n     *\n     * @param opts - the filters to apply\n     * @param rooms - the rooms to leave\n     */ delSockets(opts, rooms) {\n        this.apply(opts, (socket)=>{\n            rooms.forEach((room)=>socket.leave(room));\n        });\n    }\n    /**\n     * Makes the matching socket instances disconnect\n     *\n     * @param opts - the filters to apply\n     * @param close - whether to close the underlying connection\n     */ disconnectSockets(opts, close) {\n        this.apply(opts, (socket)=>{\n            socket.disconnect(close);\n        });\n    }\n    apply(opts, callback) {\n        const rooms = opts.rooms;\n        const except = this.computeExceptSids(opts.except);\n        if (rooms.size) {\n            const ids = new Set();\n            for (const room of rooms){\n                if (!this.rooms.has(room)) continue;\n                for (const id of this.rooms.get(room)){\n                    if (ids.has(id) || except.has(id)) continue;\n                    const socket = this.nsp.sockets.get(id);\n                    if (socket) {\n                        callback(socket);\n                        ids.add(id);\n                    }\n                }\n            }\n        } else {\n            for (const [id] of this.sids){\n                if (except.has(id)) continue;\n                const socket = this.nsp.sockets.get(id);\n                if (socket) callback(socket);\n            }\n        }\n    }\n    computeExceptSids(exceptRooms) {\n        const exceptSids = new Set();\n        if (exceptRooms && exceptRooms.size > 0) {\n            for (const room of exceptRooms){\n                if (this.rooms.has(room)) {\n                    this.rooms.get(room).forEach((sid)=>exceptSids.add(sid));\n                }\n            }\n        }\n        return exceptSids;\n    }\n    /**\n     * Send a packet to the other Socket.IO servers in the cluster\n     * @param packet - an array of arguments, which may include an acknowledgement callback at the end\n     */ serverSideEmit(packet) {\n        console.warn(\"this adapter does not support the serverSideEmit() functionality\");\n    }\n    /**\n     * Save the client session in order to restore it upon reconnection.\n     */ persistSession(session) {}\n    /**\n     * Restore the session and find the packets that were missed by the client.\n     * @param pid\n     * @param offset\n     */ restoreSession(pid, offset) {\n        return null;\n    }\n}\nexports.Adapter = Adapter;\nclass SessionAwareAdapter extends Adapter {\n    constructor(nsp){\n        super(nsp);\n        this.nsp = nsp;\n        this.sessions = new Map();\n        this.packets = [];\n        this.maxDisconnectionDuration = nsp.server.opts.connectionStateRecovery.maxDisconnectionDuration;\n        const timer = setInterval(()=>{\n            const threshold = Date.now() - this.maxDisconnectionDuration;\n            this.sessions.forEach((session, sessionId)=>{\n                const hasExpired = session.disconnectedAt < threshold;\n                if (hasExpired) {\n                    this.sessions.delete(sessionId);\n                }\n            });\n            for(let i = this.packets.length - 1; i >= 0; i--){\n                const hasExpired = this.packets[i].emittedAt < threshold;\n                if (hasExpired) {\n                    this.packets.splice(0, i + 1);\n                    break;\n                }\n            }\n        }, 60 * 1000);\n        // prevents the timer from keeping the process alive\n        timer.unref();\n    }\n    persistSession(session) {\n        session.disconnectedAt = Date.now();\n        this.sessions.set(session.pid, session);\n    }\n    restoreSession(pid, offset) {\n        const session = this.sessions.get(pid);\n        if (!session) {\n            // the session may have expired\n            return null;\n        }\n        const hasExpired = session.disconnectedAt + this.maxDisconnectionDuration < Date.now();\n        if (hasExpired) {\n            // the session has expired\n            this.sessions.delete(pid);\n            return null;\n        }\n        const index = this.packets.findIndex((packet)=>packet.id === offset);\n        if (index === -1) {\n            // the offset may be too old\n            return null;\n        }\n        const missedPackets = [];\n        for(let i = index + 1; i < this.packets.length; i++){\n            const packet = this.packets[i];\n            if (shouldIncludePacket(session.rooms, packet.opts)) {\n                missedPackets.push(packet.data);\n            }\n        }\n        return Promise.resolve(Object.assign(Object.assign({}, session), {\n            missedPackets\n        }));\n    }\n    broadcast(packet, opts) {\n        var _a;\n        const isEventPacket = packet.type === 2;\n        // packets with acknowledgement are not stored because the acknowledgement function cannot be serialized and\n        // restored on another server upon reconnection\n        const withoutAcknowledgement = packet.id === undefined;\n        const notVolatile = ((_a = opts.flags) === null || _a === void 0 ? void 0 : _a.volatile) === undefined;\n        if (isEventPacket && withoutAcknowledgement && notVolatile) {\n            const id = (0, yeast_1.yeast)();\n            // the offset is stored at the end of the data array, so the client knows the ID of the last packet it has\n            // processed (and the format is backward-compatible)\n            packet.data.push(id);\n            this.packets.push({\n                id,\n                opts,\n                data: packet.data,\n                emittedAt: Date.now()\n            });\n        }\n        super.broadcast(packet, opts);\n    }\n}\nexports.SessionAwareAdapter = SessionAwareAdapter;\nfunction shouldIncludePacket(sessionRooms, opts) {\n    const included = opts.rooms.size === 0 || sessionRooms.some((room)=>opts.rooms.has(room));\n    const notExcluded = sessionRooms.every((room)=>!opts.except.has(room));\n    return included && notExcluded;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc29ja2V0LmlvLWFkYXB0ZXIvZGlzdC9pbi1tZW1vcnktYWRhcHRlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLElBQUlBO0FBQ0pDLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCwyQkFBMkIsR0FBR0EsZUFBZSxHQUFHLEtBQUs7QUFDckQsTUFBTUksV0FBV0MsbUJBQU9BLENBQUMsc0JBQVE7QUFDakMsTUFBTUMsVUFBVUQsbUJBQU9BLENBQUMscUZBQWlCO0FBQ3pDLE1BQU1FLFlBQVlGLG1CQUFPQSxDQUFDLDRDQUFJO0FBQzlCLE1BQU1HLHFCQUFxQixPQUFRLEVBQUNYLEtBQUtVLGNBQWMsUUFBUUEsY0FBYyxLQUFLLElBQUksS0FBSyxJQUFJQSxVQUFVRSxNQUFNLE1BQU0sUUFBUVosT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHYSxLQUFLLE1BQU07QUFDcEssTUFBTVAsZ0JBQWdCQyxTQUFTTyxZQUFZO0lBQ3ZDOzs7O0tBSUMsR0FDREMsWUFBWUMsR0FBRyxDQUFFO1FBQ2IsS0FBSztRQUNMLElBQUksQ0FBQ0EsR0FBRyxHQUFHQTtRQUNYLElBQUksQ0FBQ0MsS0FBSyxHQUFHLElBQUlDO1FBQ2pCLElBQUksQ0FBQ0MsSUFBSSxHQUFHLElBQUlEO1FBQ2hCLElBQUksQ0FBQ0UsT0FBTyxHQUFHSixJQUFJSyxNQUFNLENBQUNELE9BQU87SUFDckM7SUFDQTs7S0FFQyxHQUNERSxPQUFPLENBQUU7SUFDVDs7S0FFQyxHQUNEQyxRQUFRLENBQUU7SUFDVjs7OztLQUlDLEdBQ0RDLGNBQWM7UUFDVixPQUFPQyxRQUFRQyxPQUFPLENBQUM7SUFDM0I7SUFDQTs7Ozs7O0tBTUMsR0FDREMsT0FBT0MsRUFBRSxFQUFFWCxLQUFLLEVBQUU7UUFDZCxJQUFJLENBQUMsSUFBSSxDQUFDRSxJQUFJLENBQUNVLEdBQUcsQ0FBQ0QsS0FBSztZQUNwQixJQUFJLENBQUNULElBQUksQ0FBQ1cs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QUFDRztJQUNsRSxPQUFPa0csWUFBWUU7QUFDdkIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9leGFtcm9zaC8uL25vZGVfbW9kdWxlcy9zb2NrZXQuaW8tYWRhcHRlci9kaXN0L2luLW1lbW9yeS1hZGFwdGVyLmpzPzA4YzciXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX2E7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlNlc3Npb25Bd2FyZUFkYXB0ZXIgPSBleHBvcnRzLkFkYXB0ZXIgPSB2b2lkIDA7XG5jb25zdCBldmVudHNfMSA9IHJlcXVpcmUoXCJldmVudHNcIik7XG5jb25zdCB5ZWFzdF8xID0gcmVxdWlyZShcIi4vY29udHJpYi95ZWFzdFwiKTtcbmNvbnN0IFdlYlNvY2tldCA9IHJlcXVpcmUoXCJ3c1wiKTtcbmNvbnN0IGNhblByZUNvbXB1dGVGcmFtZSA9IHR5cGVvZiAoKF9hID0gV2ViU29ja2V0ID09PSBudWxsIHx8IFdlYlNvY2tldCA9PT0gdm9pZCAwID8gdm9pZCAwIDogV2ViU29ja2V0LlNlbmRlcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmZyYW1lKSA9PT0gXCJmdW5jdGlvblwiO1xuY2xhc3MgQWRhcHRlciBleHRlbmRzIGV2ZW50c18xLkV2ZW50RW1pdHRlciB7XG4gICAgLyoqXG4gICAgICogSW4tbWVtb3J5IGFkYXB0ZXIgY29uc3RydWN0b3IuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge05hbWVzcGFjZX0gbnNwXG4gICAgICovXG4gICAgY29uc3RydWN0b3IobnNwKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMubnNwID0gbnNwO1xuICAgICAgICB0aGlzLnJvb21zID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLnNpZHMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuZW5jb2RlciA9IG5zcC5zZXJ2ZXIuZW5jb2RlcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVG8gYmUgb3ZlcnJpZGRlblxuICAgICAqL1xuICAgIGluaXQoKSB7IH1cbiAgICAvKipcbiAgICAgKiBUbyBiZSBvdmVycmlkZGVuXG4gICAgICovXG4gICAgY2xvc2UoKSB7IH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBudW1iZXIgb2YgU29ja2V0LklPIHNlcnZlcnMgaW4gdGhlIGNsdXN0ZXJcbiAgICAgKlxuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICBzZXJ2ZXJDb3VudCgpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgxKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkcyBhIHNvY2tldCB0byBhIGxpc3Qgb2Ygcm9vbS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U29ja2V0SWR9ICBpZCAgICAgIHRoZSBzb2NrZXQgaWRcbiAgICAgKiBAcGFyYW0ge1NldDxSb29tPn0gcm9vbXMgICBhIHNldCBvZiByb29tc1xuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICBhZGRBbGwoaWQsIHJvb21zKSB7XG4gICAgICAgIGlmICghdGhpcy5zaWRzLmhhcyhpZCkpIHtcbiAgICAgICAgICAgIHRoaXMuc2lkcy5zZXQoaWQsIG5ldyBTZXQoKSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCByb29tIG9mIHJvb21zKSB7XG4gICAgICAgICAgICB0aGlzLnNpZHMuZ2V0KGlkKS5hZGQocm9vbSk7XG4gICAgICAgICAgICBpZiAoIXRoaXMucm9vbXMuaGFzKHJvb20pKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yb29tcy5zZXQocm9vbSwgbmV3IFNldCgpKTtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJjcmVhdGUtcm9vbVwiLCByb29tKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdGhpcy5yb29tcy5nZXQocm9vbSkuaGFzKGlkKSkge1xuICAgICAgICAgICAgICAgIHRoaXMucm9vbXMuZ2V0KHJvb20pLmFkZChpZCk7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwiam9pbi1yb29tXCIsIHJvb20sIGlkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGEgc29ja2V0IGZyb20gYSByb29tLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTb2NrZXRJZH0gaWQgICAgIHRoZSBzb2NrZXQgaWRcbiAgICAgKiBAcGFyYW0ge1Jvb219ICAgICByb29tICAgdGhlIHJvb20gbmFtZVxuICAgICAqL1xuICAgIGRlbChpZCwgcm9vbSkge1xuICAgICAgICBpZiAodGhpcy5zaWRzLmhhcyhpZCkpIHtcbiAgICAgICAgICAgIHRoaXMuc2lkcy5nZXQoaWQpLmRlbGV0ZShyb29tKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9kZWwocm9vbSwgaWQpO1xuICAgIH1cbiAgICBfZGVsKHJvb20sIGlkKSB7XG4gICAgICAgIGNvbnN0IF9yb29tID0gdGhpcy5yb29tcy5nZXQocm9vbSk7XG4gICAgICAgIGlmIChfcm9vbSAhPSBudWxsKSB7XG4gICAgICAgICAgICBjb25zdCBkZWxldGVkID0gX3Jvb20uZGVsZXRlKGlkKTtcbiAgICAgICAgICAgIGlmIChkZWxldGVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwibGVhdmUtcm9vbVwiLCByb29tLCBpZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoX3Jvb20uc2l6ZSA9PT0gMCAmJiB0aGlzLnJvb21zLmRlbGV0ZShyb29tKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcImRlbGV0ZS1yb29tXCIsIHJvb20pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYSBzb2NrZXQgZnJvbSBhbGwgcm9vbXMgaXQncyBqb2luZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1NvY2tldElkfSBpZCAgIHRoZSBzb2NrZXQgaWRcbiAgICAgKi9cbiAgICBkZWxBbGwoaWQpIHtcbiAgICAgICAgaWYgKCF0aGlzLnNpZHMuaGFzKGlkKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3Qgcm9vbSBvZiB0aGlzLnNpZHMuZ2V0KGlkKSkge1xuICAgICAgICAgICAgdGhpcy5fZGVsKHJvb20sIGlkKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNpZHMuZGVsZXRlKGlkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQnJvYWRjYXN0cyBhIHBhY2tldC5cbiAgICAgKlxuICAgICAqIE9wdGlvbnM6XG4gICAgICogIC0gYGZsYWdzYCB7T2JqZWN0fSBmbGFncyBmb3IgdGhpcyBwYWNrZXRcbiAgICAgKiAgLSBgZXhjZXB0YCB7QXJyYXl9IHNpZHMgdGhhdCBzaG91bGQgYmUgZXhjbHVkZWRcbiAgICAgKiAgLSBgcm9vbXNgIHtBcnJheX0gbGlzdCBvZiByb29tcyB0byBicm9hZGNhc3QgdG9cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwYWNrZXQgICB0aGUgcGFja2V0IG9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzICAgICB0aGUgb3B0aW9uc1xuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICBicm9hZGNhc3QocGFja2V0LCBvcHRzKSB7XG4gICAgICAgIGNvbnN0IGZsYWdzID0gb3B0cy5mbGFncyB8fCB7fTtcbiAgICAgICAgY29uc3QgcGFja2V0T3B0cyA9IHtcbiAgICAgICAgICAgIHByZUVuY29kZWQ6IHRydWUsXG4gICAgICAgICAgICB2b2xhdGlsZTogZmxhZ3Mudm9sYXRpbGUsXG4gICAgICAgICAgICBjb21wcmVzczogZmxhZ3MuY29tcHJlc3MsXG4gICAgICAgIH07XG4gICAgICAgIHBhY2tldC5uc3AgPSB0aGlzLm5zcC5uYW1lO1xuICAgICAgICBjb25zdCBlbmNvZGVkUGFja2V0cyA9IHRoaXMuX2VuY29kZShwYWNrZXQsIHBhY2tldE9wdHMpO1xuICAgICAgICB0aGlzLmFwcGx5KG9wdHMsIChzb2NrZXQpID0+IHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc29ja2V0Lm5vdGlmeU91dGdvaW5nTGlzdGVuZXJzID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICBzb2NrZXQubm90aWZ5T3V0Z29pbmdMaXN0ZW5lcnMocGFja2V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNvY2tldC5jbGllbnQud3JpdGVUb0VuZ2luZShlbmNvZGVkUGFja2V0cywgcGFja2V0T3B0cyk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBCcm9hZGNhc3RzIGEgcGFja2V0IGFuZCBleHBlY3RzIG11bHRpcGxlIGFja25vd2xlZGdlbWVudHMuXG4gICAgICpcbiAgICAgKiBPcHRpb25zOlxuICAgICAqICAtIGBmbGFnc2Age09iamVjdH0gZmxhZ3MgZm9yIHRoaXMgcGFja2V0XG4gICAgICogIC0gYGV4Y2VwdGAge0FycmF5fSBzaWRzIHRoYXQgc2hvdWxkIGJlIGV4Y2x1ZGVkXG4gICAgICogIC0gYHJvb21zYCB7QXJyYXl9IGxpc3Qgb2Ygcm9vbXMgdG8gYnJvYWRjYXN0IHRvXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcGFja2V0ICAgdGhlIHBhY2tldCBvYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAgICAgdGhlIG9wdGlvbnNcbiAgICAgKiBAcGFyYW0gY2xpZW50Q291bnRDYWxsYmFjayAtIHRoZSBudW1iZXIgb2YgY2xpZW50cyB0aGF0IHJlY2VpdmVkIHRoZSBwYWNrZXRcbiAgICAgKiBAcGFyYW0gYWNrICAgICAgICAgICAgICAgICAtIHRoZSBjYWxsYmFjayB0aGF0IHdpbGwgYmUgY2FsbGVkIGZvciBlYWNoIGNsaWVudCByZXNwb25zZVxuICAgICAqXG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIGJyb2FkY2FzdFdpdGhBY2socGFja2V0LCBvcHRzLCBjbGllbnRDb3VudENhbGxiYWNrLCBhY2spIHtcbiAgICAgICAgY29uc3QgZmxhZ3MgPSBvcHRzLmZsYWdzIHx8IHt9O1xuICAgICAgICBjb25zdCBwYWNrZXRPcHRzID0ge1xuICAgICAgICAgICAgcHJlRW5jb2RlZDogdHJ1ZSxcbiAgICAgICAgICAgIHZvbGF0aWxlOiBmbGFncy52b2xhdGlsZSxcbiAgICAgICAgICAgIGNvbXByZXNzOiBmbGFncy5jb21wcmVzcyxcbiAgICAgICAgfTtcbiAgICAgICAgcGFja2V0Lm5zcCA9IHRoaXMubnNwLm5hbWU7XG4gICAgICAgIC8vIHdlIGNhbiB1c2UgdGhlIHNhbWUgaWQgZm9yIGVhY2ggcGFja2V0LCBzaW5jZSB0aGUgX2lkcyBjb3VudGVyIGlzIGNvbW1vbiAobm8gZHVwbGljYXRlKVxuICAgICAgICBwYWNrZXQuaWQgPSB0aGlzLm5zcC5faWRzKys7XG4gICAgICAgIGNvbnN0IGVuY29kZWRQYWNrZXRzID0gdGhpcy5fZW5jb2RlKHBhY2tldCwgcGFja2V0T3B0cyk7XG4gICAgICAgIGxldCBjbGllbnRDb3VudCA9IDA7XG4gICAgICAgIHRoaXMuYXBwbHkob3B0cywgKHNvY2tldCkgPT4ge1xuICAgICAgICAgICAgLy8gdHJhY2sgdGhlIHRvdGFsIG51bWJlciBvZiBhY2tub3dsZWRnZW1lbnRzIHRoYXQgYXJlIGV4cGVjdGVkXG4gICAgICAgICAgICBjbGllbnRDb3VudCsrO1xuICAgICAgICAgICAgLy8gY2FsbCB0aGUgYWNrIGNhbGxiYWNrIGZvciBlYWNoIGNsaWVudCByZXNwb25zZVxuICAgICAgICAgICAgc29ja2V0LmFja3Muc2V0KHBhY2tldC5pZCwgYWNrKTtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc29ja2V0Lm5vdGlmeU91dGdvaW5nTGlzdGVuZXJzID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICBzb2NrZXQubm90aWZ5T3V0Z29pbmdMaXN0ZW5lcnMocGFja2V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNvY2tldC5jbGllbnQud3JpdGVUb0VuZ2luZShlbmNvZGVkUGFja2V0cywgcGFja2V0T3B0cyk7XG4gICAgICAgIH0pO1xuICAgICAgICBjbGllbnRDb3VudENhbGxiYWNrKGNsaWVudENvdW50KTtcbiAgICB9XG4gICAgX2VuY29kZShwYWNrZXQsIHBhY2tldE9wdHMpIHtcbiAgICAgICAgY29uc3QgZW5jb2RlZFBhY2tldHMgPSB0aGlzLmVuY29kZXIuZW5jb2RlKHBhY2tldCk7XG4gICAgICAgIGlmIChjYW5QcmVDb21wdXRlRnJhbWUgJiZcbiAgICAgICAgICAgIGVuY29kZWRQYWNrZXRzLmxlbmd0aCA9PT0gMSAmJlxuICAgICAgICAgICAgdHlwZW9mIGVuY29kZWRQYWNrZXRzWzBdID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAvLyBcIjRcIiBiZWluZyB0aGUgXCJtZXNzYWdlXCIgcGFja2V0IHR5cGUgaW4gdGhlIEVuZ2luZS5JTyBwcm90b2NvbFxuICAgICAgICAgICAgY29uc3QgZGF0YSA9IEJ1ZmZlci5mcm9tKFwiNFwiICsgZW5jb2RlZFBhY2tldHNbMF0pO1xuICAgICAgICAgICAgLy8gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS93ZWJzb2NrZXRzL3dzL2lzc3Vlcy82MTcjaXNzdWVjb21tZW50LTI4MzAwMjQ2OVxuICAgICAgICAgICAgcGFja2V0T3B0cy53c1ByZUVuY29kZWRGcmFtZSA9IFdlYlNvY2tldC5TZW5kZXIuZnJhbWUoZGF0YSwge1xuICAgICAgICAgICAgICAgIHJlYWRPbmx5OiBmYWxzZSxcbiAgICAgICAgICAgICAgICBtYXNrOiBmYWxzZSxcbiAgICAgICAgICAgICAgICByc3YxOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBvcGNvZGU6IDEsXG4gICAgICAgICAgICAgICAgZmluOiB0cnVlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVuY29kZWRQYWNrZXRzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIGEgbGlzdCBvZiBzb2NrZXRzIGJ5IHNpZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U2V0PFJvb20+fSByb29tcyAgIHRoZSBleHBsaWNpdCBzZXQgb2Ygcm9vbXMgdG8gY2hlY2suXG4gICAgICovXG4gICAgc29ja2V0cyhyb29tcykge1xuICAgICAgICBjb25zdCBzaWRzID0gbmV3IFNldCgpO1xuICAgICAgICB0aGlzLmFwcGx5KHsgcm9vbXMgfSwgKHNvY2tldCkgPT4ge1xuICAgICAgICAgICAgc2lkcy5hZGQoc29ja2V0LmlkKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoc2lkcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGxpc3Qgb2Ygcm9vbXMgYSBnaXZlbiBzb2NrZXQgaGFzIGpvaW5lZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U29ja2V0SWR9IGlkICAgdGhlIHNvY2tldCBpZFxuICAgICAqL1xuICAgIHNvY2tldFJvb21zKGlkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNpZHMuZ2V0KGlkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbWF0Y2hpbmcgc29ja2V0IGluc3RhbmNlc1xuICAgICAqXG4gICAgICogQHBhcmFtIG9wdHMgLSB0aGUgZmlsdGVycyB0byBhcHBseVxuICAgICAqL1xuICAgIGZldGNoU29ja2V0cyhvcHRzKSB7XG4gICAgICAgIGNvbnN0IHNvY2tldHMgPSBbXTtcbiAgICAgICAgdGhpcy5hcHBseShvcHRzLCAoc29ja2V0KSA9PiB7XG4gICAgICAgICAgICBzb2NrZXRzLnB1c2goc29ja2V0KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoc29ja2V0cyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1ha2VzIHRoZSBtYXRjaGluZyBzb2NrZXQgaW5zdGFuY2VzIGpvaW4gdGhlIHNwZWNpZmllZCByb29tc1xuICAgICAqXG4gICAgICogQHBhcmFtIG9wdHMgLSB0aGUgZmlsdGVycyB0byBhcHBseVxuICAgICAqIEBwYXJhbSByb29tcyAtIHRoZSByb29tcyB0byBqb2luXG4gICAgICovXG4gICAgYWRkU29ja2V0cyhvcHRzLCByb29tcykge1xuICAgICAgICB0aGlzLmFwcGx5KG9wdHMsIChzb2NrZXQpID0+IHtcbiAgICAgICAgICAgIHNvY2tldC5qb2luKHJvb21zKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1ha2VzIHRoZSBtYXRjaGluZyBzb2NrZXQgaW5zdGFuY2VzIGxlYXZlIHRoZSBzcGVjaWZpZWQgcm9vbXNcbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRzIC0gdGhlIGZpbHRlcnMgdG8gYXBwbHlcbiAgICAgKiBAcGFyYW0gcm9vbXMgLSB0aGUgcm9vbXMgdG8gbGVhdmVcbiAgICAgKi9cbiAgICBkZWxTb2NrZXRzKG9wdHMsIHJvb21zKSB7XG4gICAgICAgIHRoaXMuYXBwbHkob3B0cywgKHNvY2tldCkgPT4ge1xuICAgICAgICAgICAgcm9vbXMuZm9yRWFjaCgocm9vbSkgPT4gc29ja2V0LmxlYXZlKHJvb20pKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1ha2VzIHRoZSBtYXRjaGluZyBzb2NrZXQgaW5zdGFuY2VzIGRpc2Nvbm5lY3RcbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRzIC0gdGhlIGZpbHRlcnMgdG8gYXBwbHlcbiAgICAgKiBAcGFyYW0gY2xvc2UgLSB3aGV0aGVyIHRvIGNsb3NlIHRoZSB1bmRlcmx5aW5nIGNvbm5lY3Rpb25cbiAgICAgKi9cbiAgICBkaXNjb25uZWN0U29ja2V0cyhvcHRzLCBjbG9zZSkge1xuICAgICAgICB0aGlzLmFwcGx5KG9wdHMsIChzb2NrZXQpID0+IHtcbiAgICAgICAgICAgIHNvY2tldC5kaXNjb25uZWN0KGNsb3NlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFwcGx5KG9wdHMsIGNhbGxiYWNrKSB7XG4gICAgICAgIGNvbnN0IHJvb21zID0gb3B0cy5yb29tcztcbiAgICAgICAgY29uc3QgZXhjZXB0ID0gdGhpcy5jb21wdXRlRXhjZXB0U2lkcyhvcHRzLmV4Y2VwdCk7XG4gICAgICAgIGlmIChyb29tcy5zaXplKSB7XG4gICAgICAgICAgICBjb25zdCBpZHMgPSBuZXcgU2V0KCk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHJvb20gb2Ygcm9vbXMpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMucm9vbXMuaGFzKHJvb20pKVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGlkIG9mIHRoaXMucm9vbXMuZ2V0KHJvb20pKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpZHMuaGFzKGlkKSB8fCBleGNlcHQuaGFzKGlkKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzb2NrZXQgPSB0aGlzLm5zcC5zb2NrZXRzLmdldChpZCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzb2NrZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKHNvY2tldCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZHMuYWRkKGlkKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgW2lkXSBvZiB0aGlzLnNpZHMpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXhjZXB0LmhhcyhpZCkpXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNvbnN0IHNvY2tldCA9IHRoaXMubnNwLnNvY2tldHMuZ2V0KGlkKTtcbiAgICAgICAgICAgICAgICBpZiAoc29ja2V0KVxuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhzb2NrZXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGNvbXB1dGVFeGNlcHRTaWRzKGV4Y2VwdFJvb21zKSB7XG4gICAgICAgIGNvbnN0IGV4Y2VwdFNpZHMgPSBuZXcgU2V0KCk7XG4gICAgICAgIGlmIChleGNlcHRSb29tcyAmJiBleGNlcHRSb29tcy5zaXplID4gMCkge1xuICAgICAgICAgICAgZm9yIChjb25zdCByb29tIG9mIGV4Y2VwdFJvb21zKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucm9vbXMuaGFzKHJvb20pKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucm9vbXMuZ2V0KHJvb20pLmZvckVhY2goKHNpZCkgPT4gZXhjZXB0U2lkcy5hZGQoc2lkKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBleGNlcHRTaWRzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZW5kIGEgcGFja2V0IHRvIHRoZSBvdGhlciBTb2NrZXQuSU8gc2VydmVycyBpbiB0aGUgY2x1c3RlclxuICAgICAqIEBwYXJhbSBwYWNrZXQgLSBhbiBhcnJheSBvZiBhcmd1bWVudHMsIHdoaWNoIG1heSBpbmNsdWRlIGFuIGFja25vd2xlZGdlbWVudCBjYWxsYmFjayBhdCB0aGUgZW5kXG4gICAgICovXG4gICAgc2VydmVyU2lkZUVtaXQocGFja2V0KSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcInRoaXMgYWRhcHRlciBkb2VzIG5vdCBzdXBwb3J0IHRoZSBzZXJ2ZXJTaWRlRW1pdCgpIGZ1bmN0aW9uYWxpdHlcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNhdmUgdGhlIGNsaWVudCBzZXNzaW9uIGluIG9yZGVyIHRvIHJlc3RvcmUgaXQgdXBvbiByZWNvbm5lY3Rpb24uXG4gICAgICovXG4gICAgcGVyc2lzdFNlc3Npb24oc2Vzc2lvbikgeyB9XG4gICAgLyoqXG4gICAgICogUmVzdG9yZSB0aGUgc2Vzc2lvbiBhbmQgZmluZCB0aGUgcGFja2V0cyB0aGF0IHdlcmUgbWlzc2VkIGJ5IHRoZSBjbGllbnQuXG4gICAgICogQHBhcmFtIHBpZFxuICAgICAqIEBwYXJhbSBvZmZzZXRcbiAgICAgKi9cbiAgICByZXN0b3JlU2Vzc2lvbihwaWQsIG9mZnNldCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59XG5leHBvcnRzLkFkYXB0ZXIgPSBBZGFwdGVyO1xuY2xhc3MgU2Vzc2lvbkF3YXJlQWRhcHRlciBleHRlbmRzIEFkYXB0ZXIge1xuICAgIGNvbnN0cnVjdG9yKG5zcCkge1xuICAgICAgICBzdXBlcihuc3ApO1xuICAgICAgICB0aGlzLm5zcCA9IG5zcDtcbiAgICAgICAgdGhpcy5zZXNzaW9ucyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5wYWNrZXRzID0gW107XG4gICAgICAgIHRoaXMubWF4RGlzY29ubmVjdGlvbkR1cmF0aW9uID1cbiAgICAgICAgICAgIG5zcC5zZXJ2ZXIub3B0cy5jb25uZWN0aW9uU3RhdGVSZWNvdmVyeS5tYXhEaXNjb25uZWN0aW9uRHVyYXRpb247XG4gICAgICAgIGNvbnN0IHRpbWVyID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdGhyZXNob2xkID0gRGF0ZS5ub3coKSAtIHRoaXMubWF4RGlzY29ubmVjdGlvbkR1cmF0aW9uO1xuICAgICAgICAgICAgdGhpcy5zZXNzaW9ucy5mb3JFYWNoKChzZXNzaW9uLCBzZXNzaW9uSWQpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBoYXNFeHBpcmVkID0gc2Vzc2lvbi5kaXNjb25uZWN0ZWRBdCA8IHRocmVzaG9sZDtcbiAgICAgICAgICAgICAgICBpZiAoaGFzRXhwaXJlZCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNlc3Npb25zLmRlbGV0ZShzZXNzaW9uSWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IHRoaXMucGFja2V0cy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGhhc0V4cGlyZWQgPSB0aGlzLnBhY2tldHNbaV0uZW1pdHRlZEF0IDwgdGhyZXNob2xkO1xuICAgICAgICAgICAgICAgIGlmIChoYXNFeHBpcmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGFja2V0cy5zcGxpY2UoMCwgaSArIDEpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIDYwICogMTAwMCk7XG4gICAgICAgIC8vIHByZXZlbnRzIHRoZSB0aW1lciBmcm9tIGtlZXBpbmcgdGhlIHByb2Nlc3MgYWxpdmVcbiAgICAgICAgdGltZXIudW5yZWYoKTtcbiAgICB9XG4gICAgcGVyc2lzdFNlc3Npb24oc2Vzc2lvbikge1xuICAgICAgICBzZXNzaW9uLmRpc2Nvbm5lY3RlZEF0ID0gRGF0ZS5ub3coKTtcbiAgICAgICAgdGhpcy5zZXNzaW9ucy5zZXQoc2Vzc2lvbi5waWQsIHNlc3Npb24pO1xuICAgIH1cbiAgICByZXN0b3JlU2Vzc2lvbihwaWQsIG9mZnNldCkge1xuICAgICAgICBjb25zdCBzZXNzaW9uID0gdGhpcy5zZXNzaW9ucy5nZXQocGlkKTtcbiAgICAgICAgaWYgKCFzZXNzaW9uKSB7XG4gICAgICAgICAgICAvLyB0aGUgc2Vzc2lvbiBtYXkgaGF2ZSBleHBpcmVkXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBoYXNFeHBpcmVkID0gc2Vzc2lvbi5kaXNjb25uZWN0ZWRBdCArIHRoaXMubWF4RGlzY29ubmVjdGlvbkR1cmF0aW9uIDwgRGF0ZS5ub3coKTtcbiAgICAgICAgaWYgKGhhc0V4cGlyZWQpIHtcbiAgICAgICAgICAgIC8vIHRoZSBzZXNzaW9uIGhhcyBleHBpcmVkXG4gICAgICAgICAgICB0aGlzLnNlc3Npb25zLmRlbGV0ZShwaWQpO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaW5kZXggPSB0aGlzLnBhY2tldHMuZmluZEluZGV4KChwYWNrZXQpID0+IHBhY2tldC5pZCA9PT0gb2Zmc2V0KTtcbiAgICAgICAgaWYgKGluZGV4ID09PSAtMSkge1xuICAgICAgICAgICAgLy8gdGhlIG9mZnNldCBtYXkgYmUgdG9vIG9sZFxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWlzc2VkUGFja2V0cyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gaW5kZXggKyAxOyBpIDwgdGhpcy5wYWNrZXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBwYWNrZXQgPSB0aGlzLnBhY2tldHNbaV07XG4gICAgICAgICAgICBpZiAoc2hvdWxkSW5jbHVkZVBhY2tldChzZXNzaW9uLnJvb21zLCBwYWNrZXQub3B0cykpIHtcbiAgICAgICAgICAgICAgICBtaXNzZWRQYWNrZXRzLnB1c2gocGFja2V0LmRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBzZXNzaW9uKSwgeyBtaXNzZWRQYWNrZXRzIH0pKTtcbiAgICB9XG4gICAgYnJvYWRjYXN0KHBhY2tldCwgb3B0cykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IGlzRXZlbnRQYWNrZXQgPSBwYWNrZXQudHlwZSA9PT0gMjtcbiAgICAgICAgLy8gcGFja2V0cyB3aXRoIGFja25vd2xlZGdlbWVudCBhcmUgbm90IHN0b3JlZCBiZWNhdXNlIHRoZSBhY2tub3dsZWRnZW1lbnQgZnVuY3Rpb24gY2Fubm90IGJlIHNlcmlhbGl6ZWQgYW5kXG4gICAgICAgIC8vIHJlc3RvcmVkIG9uIGFub3RoZXIgc2VydmVyIHVwb24gcmVjb25uZWN0aW9uXG4gICAgICAgIGNvbnN0IHdpdGhvdXRBY2tub3dsZWRnZW1lbnQgPSBwYWNrZXQuaWQgPT09IHVuZGVmaW5lZDtcbiAgICAgICAgY29uc3Qgbm90Vm9sYXRpbGUgPSAoKF9hID0gb3B0cy5mbGFncykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnZvbGF0aWxlKSA9PT0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAoaXNFdmVudFBhY2tldCAmJiB3aXRob3V0QWNrbm93bGVkZ2VtZW50ICYmIG5vdFZvbGF0aWxlKSB7XG4gICAgICAgICAgICBjb25zdCBpZCA9ICgwLCB5ZWFzdF8xLnllYXN0KSgpO1xuICAgICAgICAgICAgLy8gdGhlIG9mZnNldCBpcyBzdG9yZWQgYXQgdGhlIGVuZCBvZiB0aGUgZGF0YSBhcnJheSwgc28gdGhlIGNsaWVudCBrbm93cyB0aGUgSUQgb2YgdGhlIGxhc3QgcGFja2V0IGl0IGhhc1xuICAgICAgICAgICAgLy8gcHJvY2Vzc2VkIChhbmQgdGhlIGZvcm1hdCBpcyBiYWNrd2FyZC1jb21wYXRpYmxlKVxuICAgICAgICAgICAgcGFja2V0LmRhdGEucHVzaChpZCk7XG4gICAgICAgICAgICB0aGlzLnBhY2tldHMucHVzaCh7XG4gICAgICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICAgICAgb3B0cyxcbiAgICAgICAgICAgICAgICBkYXRhOiBwYWNrZXQuZGF0YSxcbiAgICAgICAgICAgICAgICBlbWl0dGVkQXQ6IERhdGUubm93KCksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzdXBlci5icm9hZGNhc3QocGFja2V0LCBvcHRzKTtcbiAgICB9XG59XG5leHBvcnRzLlNlc3Npb25Bd2FyZUFkYXB0ZXIgPSBTZXNzaW9uQXdhcmVBZGFwdGVyO1xuZnVuY3Rpb24gc2hvdWxkSW5jbHVkZVBhY2tldChzZXNzaW9uUm9vbXMsIG9wdHMpIHtcbiAgICBjb25zdCBpbmNsdWRlZCA9IG9wdHMucm9vbXMuc2l6ZSA9PT0gMCB8fCBzZXNzaW9uUm9vbXMuc29tZSgocm9vbSkgPT4gb3B0cy5yb29tcy5oYXMocm9vbSkpO1xuICAgIGNvbnN0IG5vdEV4Y2x1ZGVkID0gc2Vzc2lvblJvb21zLmV2ZXJ5KChyb29tKSA9PiAhb3B0cy5leGNlcHQuaGFzKHJvb20pKTtcbiAgICByZXR1cm4gaW5jbHVkZWQgJiYgbm90RXhjbHVkZWQ7XG59XG4iXSwibmFtZXMiOlsiX2EiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIlNlc3Npb25Bd2FyZUFkYXB0ZXIiLCJBZGFwdGVyIiwiZXZlbnRzXzEiLCJyZXF1aXJlIiwieWVhc3RfMSIsIldlYlNvY2tldCIsImNhblByZUNvbXB1dGVGcmFtZSIsIlNlbmRlciIsImZyYW1lIiwiRXZlbnRFbWl0dGVyIiwiY29uc3RydWN0b3IiLCJuc3AiLCJyb29tcyIsIk1hcCIsInNpZHMiLCJlbmNvZGVyIiwic2VydmVyIiwiaW5pdCIsImNsb3NlIiwic2VydmVyQ291bnQiLCJQcm9taXNlIiwicmVzb2x2ZSIsImFkZEFsbCIsImlkIiwiaGFzIiwic2V0IiwiU2V0Iiwicm9vbSIsImdldCIsImFkZCIsImVtaXQiLCJkZWwiLCJkZWxldGUiLCJfZGVsIiwiX3Jvb20iLCJkZWxldGVkIiwic2l6ZSIsImRlbEFsbCIsImJyb2FkY2FzdCIsInBhY2tldCIsIm9wdHMiLCJmbGFncyIsInBhY2tldE9wdHMiLCJwcmVFbmNvZGVkIiwidm9sYXRpbGUiLCJjb21wcmVzcyIsIm5hbWUiLCJlbmNvZGVkUGFja2V0cyIsIl9lbmNvZGUiLCJhcHBseSIsInNvY2tldCIsIm5vdGlmeU91dGdvaW5nTGlzdGVuZXJzIiwiY2xpZW50Iiwid3JpdGVUb0VuZ2luZSIsImJyb2FkY2FzdFdpdGhBY2siLCJjbGllbnRDb3VudENhbGxiYWNrIiwiYWNrIiwiX2lkcyIsImNsaWVudENvdW50IiwiYWNrcyIsImVuY29kZSIsImxlbmd0aCIsImRhdGEiLCJCdWZmZXIiLCJmcm9tIiwid3NQcmVFbmNvZGVkRnJhbWUiLCJyZWFkT25seSIsIm1hc2siLCJyc3YxIiwib3Bjb2RlIiwiZmluIiwic29ja2V0cyIsInNvY2tldFJvb21zIiwiZmV0Y2hTb2NrZXRzIiwicHVzaCIsImFkZFNvY2tldHMiLCJqb2luIiwiZGVsU29ja2V0cyIsImZvckVhY2giLCJsZWF2ZSIsImRpc2Nvbm5lY3RTb2NrZXRzIiwiZGlzY29ubmVjdCIsImNhbGxiYWNrIiwiZXhjZXB0IiwiY29tcHV0ZUV4Y2VwdFNpZHMiLCJpZHMiLCJleGNlcHRSb29tcyIsImV4Y2VwdFNpZHMiLCJzaWQiLCJzZXJ2ZXJTaWRlRW1pdCIsImNvbnNvbGUiLCJ3YXJuIiwicGVyc2lzdFNlc3Npb24iLCJzZXNzaW9uIiwicmVzdG9yZVNlc3Npb24iLCJwaWQiLCJvZmZzZXQiLCJzZXNzaW9ucyIsInBhY2tldHMiLCJtYXhEaXNjb25uZWN0aW9uRHVyYXRpb24iLCJjb25uZWN0aW9uU3RhdGVSZWNvdmVyeSIsInRpbWVyIiwic2V0SW50ZXJ2YWwiLCJ0aHJlc2hvbGQiLCJEYXRlIiwibm93Iiwic2Vzc2lvbklkIiwiaGFzRXhwaXJlZCIsImRpc2Nvbm5lY3RlZEF0IiwiaSIsImVtaXR0ZWRBdCIsInNwbGljZSIsInVucmVmIiwiaW5kZXgiLCJmaW5kSW5kZXgiLCJtaXNzZWRQYWNrZXRzIiwic2hvdWxkSW5jbHVkZVBhY2tldCIsImFzc2lnbiIsImlzRXZlbnRQYWNrZXQiLCJ0eXBlIiwid2l0aG91dEFja25vd2xlZGdlbWVudCIsInVuZGVmaW5lZCIsIm5vdFZvbGF0aWxlIiwieWVhc3QiLCJzZXNzaW9uUm9vbXMiLCJpbmNsdWRlZCIsInNvbWUiLCJub3RFeGNsdWRlZCIsImV2ZXJ5Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/socket.io-adapter/dist/in-memory-adapter.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/socket.io-adapter/dist/index.js":
/*!******************************************************!*\
  !*** ./node_modules/socket.io-adapter/dist/index.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.MessageType = exports.ClusterAdapterWithHeartbeat = exports.ClusterAdapter = exports.SessionAwareAdapter = exports.Adapter = void 0;\nvar in_memory_adapter_1 = __webpack_require__(/*! ./in-memory-adapter */ \"(rsc)/./node_modules/socket.io-adapter/dist/in-memory-adapter.js\");\nObject.defineProperty(exports, \"Adapter\", ({\n    enumerable: true,\n    get: function() {\n        return in_memory_adapter_1.Adapter;\n    }\n}));\nObject.defineProperty(exports, \"SessionAwareAdapter\", ({\n    enumerable: true,\n    get: function() {\n        return in_memory_adapter_1.SessionAwareAdapter;\n    }\n}));\nvar cluster_adapter_1 = __webpack_require__(/*! ./cluster-adapter */ \"(rsc)/./node_modules/socket.io-adapter/dist/cluster-adapter.js\");\nObject.defineProperty(exports, \"ClusterAdapter\", ({\n    enumerable: true,\n    get: function() {\n        return cluster_adapter_1.ClusterAdapter;\n    }\n}));\nObject.defineProperty(exports, \"ClusterAdapterWithHeartbeat\", ({\n    enumerable: true,\n    get: function() {\n        return cluster_adapter_1.ClusterAdapterWithHeartbeat;\n    }\n}));\nObject.defineProperty(exports, \"MessageType\", ({\n    enumerable: true,\n    get: function() {\n        return cluster_adapter_1.MessageType;\n    }\n}));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc29ja2V0LmlvLWFkYXB0ZXIvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsbUJBQW1CLEdBQUdBLG1DQUFtQyxHQUFHQSxzQkFBc0IsR0FBR0EsMkJBQTJCLEdBQUdBLGVBQWUsR0FBRyxLQUFLO0FBQzFJLElBQUlPLHNCQUFzQkMsbUJBQU9BLENBQUMsNkZBQXFCO0FBQ3ZEViwyQ0FBMEM7SUFBRVcsWUFBWTtJQUFNQyxLQUFLO1FBQWMsT0FBT0gsb0JBQW9CRCxPQUFPO0lBQUU7QUFBRSxDQUFDLEVBQUM7QUFDekhSLHVEQUFzRDtJQUFFVyxZQUFZO0lBQU1DLEtBQUs7UUFBYyxPQUFPSCxvQkFBb0JGLG1CQUFtQjtJQUFFO0FBQUUsQ0FBQyxFQUFDO0FBQ2pKLElBQUlNLG9CQUFvQkgsbUJBQU9BLENBQUMseUZBQW1CO0FBQ25EVixrREFBaUQ7SUFBRVcsWUFBWTtJQUFNQyxLQUFLO1FBQWMsT0FBT0Msa0JBQWtCUCxjQUFjO0lBQUU7QUFBRSxDQUFDLEVBQUM7QUFDcklOLCtEQUE4RDtJQUFFVyxZQUFZO0lBQU1DLEtBQUs7UUFBYyxPQUFPQyxrQkFBa0JSLDJCQUEyQjtJQUFFO0FBQUUsQ0FBQyxFQUFDO0FBQy9KTCwrQ0FBOEM7SUFBRVcsWUFBWTtJQUFNQyxLQUFLO1FBQWMsT0FBT0Msa0JBQWtCVCxXQUFXO0lBQUU7QUFBRSxDQUFDLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9leGFtcm9zaC8uL25vZGVfbW9kdWxlcy9zb2NrZXQuaW8tYWRhcHRlci9kaXN0L2luZGV4LmpzPzJlNGMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLk1lc3NhZ2VUeXBlID0gZXhwb3J0cy5DbHVzdGVyQWRhcHRlcldpdGhIZWFydGJlYXQgPSBleHBvcnRzLkNsdXN0ZXJBZGFwdGVyID0gZXhwb3J0cy5TZXNzaW9uQXdhcmVBZGFwdGVyID0gZXhwb3J0cy5BZGFwdGVyID0gdm9pZCAwO1xudmFyIGluX21lbW9yeV9hZGFwdGVyXzEgPSByZXF1aXJlKFwiLi9pbi1tZW1vcnktYWRhcHRlclwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkFkYXB0ZXJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGluX21lbW9yeV9hZGFwdGVyXzEuQWRhcHRlcjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlNlc3Npb25Bd2FyZUFkYXB0ZXJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGluX21lbW9yeV9hZGFwdGVyXzEuU2Vzc2lvbkF3YXJlQWRhcHRlcjsgfSB9KTtcbnZhciBjbHVzdGVyX2FkYXB0ZXJfMSA9IHJlcXVpcmUoXCIuL2NsdXN0ZXItYWRhcHRlclwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkNsdXN0ZXJBZGFwdGVyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjbHVzdGVyX2FkYXB0ZXJfMS5DbHVzdGVyQWRhcHRlcjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkNsdXN0ZXJBZGFwdGVyV2l0aEhlYXJ0YmVhdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY2x1c3Rlcl9hZGFwdGVyXzEuQ2x1c3RlckFkYXB0ZXJXaXRoSGVhcnRiZWF0OyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTWVzc2FnZVR5cGVcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNsdXN0ZXJfYWRhcHRlcl8xLk1lc3NhZ2VUeXBlOyB9IH0pO1xuIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiTWVzc2FnZVR5cGUiLCJDbHVzdGVyQWRhcHRlcldpdGhIZWFydGJlYXQiLCJDbHVzdGVyQWRhcHRlciIsIlNlc3Npb25Bd2FyZUFkYXB0ZXIiLCJBZGFwdGVyIiwiaW5fbWVtb3J5X2FkYXB0ZXJfMSIsInJlcXVpcmUiLCJlbnVtZXJhYmxlIiwiZ2V0IiwiY2x1c3Rlcl9hZGFwdGVyXzEiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/socket.io-adapter/dist/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/socket.io-adapter/node_modules/debug/src/browser.js":
/*!**************************************************************************!*\
  !*** ./node_modules/socket.io-adapter/node_modules/debug/src/browser.js ***!
  \**************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("/* eslint-env browser */ /**\n * This is the web browser implementation of `debug()`.\n */ \nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\nexports.storage = localstorage();\nexports.destroy = (()=>{\n    let warned = false;\n    return ()=>{\n        if (!warned) {\n            warned = true;\n            console.warn(\"Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.\");\n        }\n    };\n})();\n/**\n * Colors.\n */ exports.colors = [\n    \"#0000CC\",\n    \"#0000FF\",\n    \"#0033CC\",\n    \"#0033FF\",\n    \"#0066CC\",\n    \"#0066FF\",\n    \"#0099CC\",\n    \"#0099FF\",\n    \"#00CC00\",\n    \"#00CC33\",\n    \"#00CC66\",\n    \"#00CC99\",\n    \"#00CCCC\",\n    \"#00CCFF\",\n    \"#3300CC\",\n    \"#3300FF\",\n    \"#3333CC\",\n    \"#3333FF\",\n    \"#3366CC\",\n    \"#3366FF\",\n    \"#3399CC\",\n    \"#3399FF\",\n    \"#33CC00\",\n    \"#33CC33\",\n    \"#33CC66\",\n    \"#33CC99\",\n    \"#33CCCC\",\n    \"#33CCFF\",\n    \"#6600CC\",\n    \"#6600FF\",\n    \"#6633CC\",\n    \"#6633FF\",\n    \"#66CC00\",\n    \"#66CC33\",\n    \"#9900CC\",\n    \"#9900FF\",\n    \"#9933CC\",\n    \"#9933FF\",\n    \"#99CC00\",\n    \"#99CC33\",\n    \"#CC0000\",\n    \"#CC0033\",\n    \"#CC0066\",\n    \"#CC0099\",\n    \"#CC00CC\",\n    \"#CC00FF\",\n    \"#CC3300\",\n    \"#CC3333\",\n    \"#CC3366\",\n    \"#CC3399\",\n    \"#CC33CC\",\n    \"#CC33FF\",\n    \"#CC6600\",\n    \"#CC6633\",\n    \"#CC9900\",\n    \"#CC9933\",\n    \"#CCCC00\",\n    \"#CCCC33\",\n    \"#FF0000\",\n    \"#FF0033\",\n    \"#FF0066\",\n    \"#FF0099\",\n    \"#FF00CC\",\n    \"#FF00FF\",\n    \"#FF3300\",\n    \"#FF3333\",\n    \"#FF3366\",\n    \"#FF3399\",\n    \"#FF33CC\",\n    \"#FF33FF\",\n    \"#FF6600\",\n    \"#FF6633\",\n    \"#FF9900\",\n    \"#FF9933\",\n    \"#FFCC00\",\n    \"#FFCC33\"\n];\n/**\n * Currently only WebKit-based Web Inspectors, Firefox >= v31,\n * and the Firebug extension (any Firefox version) are known\n * to support \"%c\" CSS customizations.\n *\n * TODO: add a `localStorage` variable to explicitly enable/disable colors\n */ // eslint-disable-next-line complexity\nfunction useColors() {\n    // NB: In an Electron preload script, document will be defined but not fully\n    // initialized. Since we know we're in Chrome, we'll just detect this case\n    // explicitly\n    if (false) {}\n    // Internet Explorer and Edge do not support colors.\n    if (typeof navigator !== \"undefined\" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\\/(\\d+)/)) {\n        return false;\n    }\n    let m;\n    // Is webkit? http://stackoverflow.com/a/16459606/376773\n    // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632\n    return typeof document !== \"undefined\" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773\n     false && (0) || // Is firefox >= v31?\n    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\n    typeof navigator !== \"undefined\" && navigator.userAgent && (m = navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/)) && parseInt(m[1], 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker\n    typeof navigator !== \"undefined\" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\\/(\\d+)/);\n}\n/**\n * Colorize log arguments if enabled.\n *\n * @api public\n */ function formatArgs(args) {\n    args[0] = (this.useColors ? \"%c\" : \"\") + this.namespace + (this.useColors ? \" %c\" : \" \") + args[0] + (this.useColors ? \"%c \" : \" \") + \"+\" + module.exports.humanize(this.diff);\n    if (!this.useColors) {\n        return;\n    }\n    const c = \"color: \" + this.color;\n    args.splice(1, 0, c, \"color: inherit\");\n    // The final \"%c\" is somewhat tricky, because there could be other\n    // arguments passed either before or after the %c, so we need to\n    // figure out the correct index to insert the CSS into\n    let index = 0;\n    let lastC = 0;\n    args[0].replace(/%[a-zA-Z%]/g, (match)=>{\n        if (match === \"%%\") {\n            return;\n        }\n        index++;\n        if (match === \"%c\") {\n            // We only are interested in the *last* %c\n            // (the user may have provided their own)\n            lastC = index;\n        }\n    });\n    args.splice(lastC, 0, c);\n}\n/**\n * Invokes `console.debug()` when available.\n * No-op when `console.debug` is not a \"function\".\n * If `console.debug` is not available, falls back\n * to `console.log`.\n *\n * @api public\n */ exports.log = console.debug || console.log || (()=>{});\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */ function save(namespaces) {\n    try {\n        if (namespaces) {\n            exports.storage.setItem(\"debug\", namespaces);\n        } else {\n            exports.storage.removeItem(\"debug\");\n        }\n    } catch (error) {\n    // Swallow\n    // XXX (@Qix-) should we be logging these?\n    }\n}\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */ function load() {\n    let r;\n    try {\n        r = exports.storage.getItem(\"debug\");\n    } catch (error) {\n    // Swallow\n    // XXX (@Qix-) should we be logging these?\n    }\n    // If debug isn't set in LS, and we're in Electron, try to load $DEBUG\n    if (!r && typeof process !== \"undefined\" && \"env\" in process) {\n        r = process.env.DEBUG;\n    }\n    return r;\n}\n/**\n * Localstorage attempts to return the localstorage.\n *\n * This is necessary because safari throws\n * when a user disables cookies/localstorage\n * and you attempt to access it.\n *\n * @return {LocalStorage}\n * @api private\n */ function localstorage() {\n    try {\n        // TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context\n        // The Browser also has localStorage in the global context.\n        return localStorage;\n    } catch (error) {\n    // Swallow\n    // XXX (@Qix-) should we be logging these?\n    }\n}\nmodule.exports = __webpack_require__(/*! ./common */ \"(rsc)/./node_modules/socket.io-adapter/node_modules/debug/src/common.js\")(exports);\nconst { formatters } = module.exports;\n/**\n * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\n */ formatters.j = function(v) {\n    try {\n        return JSON.stringify(v);\n    } catch (error) {\n        return \"[UnexpectedJSONParseError]: \" + error.message;\n    }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc29ja2V0LmlvLWFkYXB0ZXIvbm9kZV9tb2R1bGVzL2RlYnVnL3NyYy9icm93c2VyLmpzIiwibWFwcGluZ3MiOiJBQUFBLHNCQUFzQixHQUV0Qjs7Q0FFQztBQUVEQSxrQkFBa0IsR0FBR0M7QUFDckJELFlBQVksR0FBR0U7QUFDZkYsWUFBWSxHQUFHRztBQUNmSCxpQkFBaUIsR0FBR0k7QUFDcEJKLGVBQWUsR0FBR007QUFDbEJOLGVBQWUsR0FBRyxDQUFDO0lBQ2xCLElBQUlRLFNBQVM7SUFFYixPQUFPO1FBQ04sSUFBSSxDQUFDQSxRQUFRO1lBQ1pBLFNBQVM7WUFDVEMsUUFBUUMsSUFBSSxDQUFDO1FBQ2Q7SUFDRDtBQUNEO0FBRUE7O0NBRUMsR0FFRFYsY0FBYyxHQUFHO0lBQ2hCO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0NBQ0E7QUFFRDs7Ozs7O0NBTUMsR0FFRCxzQ0FBc0M7QUFDdEMsU0FBU0k7SUFDUiw0RUFBNEU7SUFDNUUsMEVBQTBFO0lBQzFFLGFBQWE7SUFDYixJQUFJLEtBQWdILEVBQUUsRUFFckg7SUFFRCxvREFBb0Q7SUFDcEQsSUFBSSxPQUFPWSxjQUFjLGVBQWVBLFVBQVVD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dkcsMkRBQTJEO1FBQzNELE9BQU80QztJQUNSLEVBQUUsT0FBT0wsT0FBTztJQUNmLFVBQVU7SUFDViwwQ0FBMEM7SUFDM0M7QUFDRDtBQUVBZCxPQUFPL0IsT0FBTyxHQUFHbUQsbUJBQU9BLENBQUMsMkZBQVluRDtBQUVyQyxNQUFNLEVBQUNvRCxVQUFVLEVBQUMsR0FBR3JCLE9BQU8vQixPQUFPO0FBRW5DOztDQUVDLEdBRURvRCxXQUFXQyxDQUFDLEdBQUcsU0FBVUMsQ0FBQztJQUN6QixJQUFJO1FBQ0gsT0FBT0MsS0FBS0MsU0FBUyxDQUFDRjtJQUN2QixFQUFFLE9BQU9ULE9BQU87UUFDZixPQUFPLGlDQUFpQ0EsTUFBTVksT0FBTztJQUN0RDtBQUNEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZXhhbXJvc2gvLi9ub2RlX21vZHVsZXMvc29ja2V0LmlvLWFkYXB0ZXIvbm9kZV9tb2R1bGVzL2RlYnVnL3NyYy9icm93c2VyLmpzPzJmNWYiXSwic291cmNlc0NvbnRlbnQiOlsiLyogZXNsaW50LWVudiBicm93c2VyICovXG5cbi8qKlxuICogVGhpcyBpcyB0aGUgd2ViIGJyb3dzZXIgaW1wbGVtZW50YXRpb24gb2YgYGRlYnVnKClgLlxuICovXG5cbmV4cG9ydHMuZm9ybWF0QXJncyA9IGZvcm1hdEFyZ3M7XG5leHBvcnRzLnNhdmUgPSBzYXZlO1xuZXhwb3J0cy5sb2FkID0gbG9hZDtcbmV4cG9ydHMudXNlQ29sb3JzID0gdXNlQ29sb3JzO1xuZXhwb3J0cy5zdG9yYWdlID0gbG9jYWxzdG9yYWdlKCk7XG5leHBvcnRzLmRlc3Ryb3kgPSAoKCkgPT4ge1xuXHRsZXQgd2FybmVkID0gZmFsc2U7XG5cblx0cmV0dXJuICgpID0+IHtcblx0XHRpZiAoIXdhcm5lZCkge1xuXHRcdFx0d2FybmVkID0gdHJ1ZTtcblx0XHRcdGNvbnNvbGUud2FybignSW5zdGFuY2UgbWV0aG9kIGBkZWJ1Zy5kZXN0cm95KClgIGlzIGRlcHJlY2F0ZWQgYW5kIG5vIGxvbmdlciBkb2VzIGFueXRoaW5nLiBJdCB3aWxsIGJlIHJlbW92ZWQgaW4gdGhlIG5leHQgbWFqb3IgdmVyc2lvbiBvZiBgZGVidWdgLicpO1xuXHRcdH1cblx0fTtcbn0pKCk7XG5cbi8qKlxuICogQ29sb3JzLlxuICovXG5cbmV4cG9ydHMuY29sb3JzID0gW1xuXHQnIzAwMDBDQycsXG5cdCcjMDAwMEZGJyxcblx0JyMwMDMzQ0MnLFxuXHQnIzAwMzNGRicsXG5cdCcjMDA2NkNDJyxcblx0JyMwMDY2RkYnLFxuXHQnIzAwOTlDQycsXG5cdCcjMDA5OUZGJyxcblx0JyMwMENDMDAnLFxuXHQnIzAwQ0MzMycsXG5cdCcjMDBDQzY2Jyxcblx0JyMwMENDOTknLFxuXHQnIzAwQ0NDQycsXG5cdCcjMDBDQ0ZGJyxcblx0JyMzMzAwQ0MnLFxuXHQnIzMzMDBGRicsXG5cdCcjMzMzM0NDJyxcblx0JyMzMzMzRkYnLFxuXHQnIzMzNjZDQycsXG5cdCcjMzM2NkZGJyxcblx0JyMzMzk5Q0MnLFxuXHQnIzMzOTlGRicsXG5cdCcjMzNDQzAwJyxcblx0JyMzM0NDMzMnLFxuXHQnIzMzQ0M2NicsXG5cdCcjMzNDQzk5Jyxcblx0JyMzM0NDQ0MnLFxuXHQnIzMzQ0NGRicsXG5cdCcjNjYwMENDJyxcblx0JyM2NjAwRkYnLFxuXHQnIzY2MzNDQycsXG5cdCcjNjYzM0ZGJyxcblx0JyM2NkNDMDAnLFxuXHQnIzY2Q0MzMycsXG5cdCcjOTkwMENDJyxcblx0JyM5OTAwRkYnLFxuXHQnIzk5MzNDQycsXG5cdCcjOTkzM0ZGJyxcblx0JyM5OUNDMDAnLFxuXHQnIzk5Q0MzMycsXG5cdCcjQ0MwMDAwJyxcblx0JyNDQzAwMzMnLFxuXHQnI0NDMDA2NicsXG5cdCcjQ0MwMDk5Jyxcblx0JyNDQzAwQ0MnLFxuXHQnI0NDMDBGRicsXG5cdCcjQ0MzMzAwJyxcblx0JyNDQzMzMzMnLFxuXHQnI0NDMzM2NicsXG5cdCcjQ0MzMzk5Jyxcblx0JyNDQzMzQ0MnLFxuXHQnI0NDMzNGRicsXG5cdCcjQ0M2NjAwJyxcblx0JyNDQzY2MzMnLFxuXHQnI0NDOTkwMCcsXG5cdCcjQ0M5OTMzJyxcblx0JyNDQ0NDMDAnLFxuXHQnI0NDQ0MzMycsXG5cdCcjRkYwMDAwJyxcblx0JyNGRjAwMzMnLFxuXHQnI0ZGMDA2NicsXG5cdCcjRkYwMDk5Jyxcblx0JyNGRjAwQ0MnLFxuXHQnI0ZGMDBGRicsXG5cdCcjRkYzMzAwJyxcblx0JyNGRjMzMzMnLFxuXHQnI0ZGMzM2NicsXG5cdCcjRkYzMzk5Jyxcblx0JyNGRjMzQ0MnLFxuXHQnI0ZGMzNGRicsXG5cdCcjRkY2NjAwJyxcblx0JyNGRjY2MzMnLFxuXHQnI0ZGOTkwMCcsXG5cdCcjRkY5OTMzJyxcblx0JyNGRkNDMDAnLFxuXHQnI0ZGQ0MzMydcbl07XG5cbi8qKlxuICogQ3VycmVudGx5IG9ubHkgV2ViS2l0LWJhc2VkIFdlYiBJbnNwZWN0b3JzLCBGaXJlZm94ID49IHYzMSxcbiAqIGFuZCB0aGUgRmlyZWJ1ZyBleHRlbnNpb24gKGFueSBGaXJlZm94IHZlcnNpb24pIGFyZSBrbm93blxuICogdG8gc3VwcG9ydCBcIiVjXCIgQ1NTIGN1c3RvbWl6YXRpb25zLlxuICpcbiAqIFRPRE86IGFkZCBhIGBsb2NhbFN0b3JhZ2VgIHZhcmlhYmxlIHRvIGV4cGxpY2l0bHkgZW5hYmxlL2Rpc2FibGUgY29sb3JzXG4gKi9cblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbXBsZXhpdHlcbmZ1bmN0aW9uIHVzZUNvbG9ycygpIHtcblx0Ly8gTkI6IEluIGFuIEVsZWN0cm9uIHByZWxvYWQgc2NyaXB0LCBkb2N1bWVudCB3aWxsIGJlIGRlZmluZWQgYnV0IG5vdCBmdWxseVxuXHQvLyBpbml0aWFsaXplZC4gU2luY2Ugd2Uga25vdyB3ZSdyZSBpbiBDaHJvbWUsIHdlJ2xsIGp1c3QgZGV0ZWN0IHRoaXMgY2FzZVxuXHQvLyBleHBsaWNpdGx5XG5cdGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cucHJvY2VzcyAmJiAod2luZG93LnByb2Nlc3MudHlwZSA9PT0gJ3JlbmRlcmVyJyB8fCB3aW5kb3cucHJvY2Vzcy5fX253anMpKSB7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblxuXHQvLyBJbnRlcm5ldCBFeHBsb3JlciBhbmQgRWRnZSBkbyBub3Qgc3VwcG9ydCBjb2xvcnMuXG5cdGlmICh0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiBuYXZpZ2F0b3IudXNlckFnZW50ICYmIG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5tYXRjaCgvKGVkZ2V8dHJpZGVudClcXC8oXFxkKykvKSkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdGxldCBtO1xuXG5cdC8vIElzIHdlYmtpdD8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMTY0NTk2MDYvMzc2NzczXG5cdC8vIGRvY3VtZW50IGlzIHVuZGVmaW5lZCBpbiByZWFjdC1uYXRpdmU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC1uYXRpdmUvcHVsbC8xNjMyXG5cdHJldHVybiAodHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZS5XZWJraXRBcHBlYXJhbmNlKSB8fFxuXHRcdC8vIElzIGZpcmVidWc/IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzM5ODEyMC8zNzY3NzNcblx0XHQodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LmNvbnNvbGUgJiYgKHdpbmRvdy5jb25zb2xlLmZpcmVidWcgfHwgKHdpbmRvdy5jb25zb2xlLmV4Y2VwdGlvbiAmJiB3aW5kb3cuY29uc29sZS50YWJsZSkpKSB8fFxuXHRcdC8vIElzIGZpcmVmb3ggPj0gdjMxP1xuXHRcdC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvVG9vbHMvV2ViX0NvbnNvbGUjU3R5bGluZ19tZXNzYWdlc1xuXHRcdCh0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiBuYXZpZ2F0b3IudXNlckFnZW50ICYmIChtID0gbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLm1hdGNoKC9maXJlZm94XFwvKFxcZCspLykpICYmIHBhcnNlSW50KG1bMV0sIDEwKSA+PSAzMSkgfHxcblx0XHQvLyBEb3VibGUgY2hlY2sgd2Via2l0IGluIHVzZXJBZ2VudCBqdXN0IGluIGNhc2Ugd2UgYXJlIGluIGEgd29ya2VyXG5cdFx0KHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIG5hdmlnYXRvci51c2VyQWdlbnQgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLm1hdGNoKC9hcHBsZXdlYmtpdFxcLyhcXGQrKS8pKTtcbn1cblxuLyoqXG4gKiBDb2xvcml6ZSBsb2cgYXJndW1lbnRzIGlmIGVuYWJsZWQuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBmb3JtYXRBcmdzKGFyZ3MpIHtcblx0YXJnc1swXSA9ICh0aGlzLnVzZUNvbG9ycyA/ICclYycgOiAnJykgK1xuXHRcdHRoaXMubmFtZXNwYWNlICtcblx0XHQodGhpcy51c2VDb2xvcnMgPyAnICVjJyA6ICcgJykgK1xuXHRcdGFyZ3NbMF0gK1xuXHRcdCh0aGlzLnVzZUNvbG9ycyA/ICclYyAnIDogJyAnKSArXG5cdFx0JysnICsgbW9kdWxlLmV4cG9ydHMuaHVtYW5pemUodGhpcy5kaWZmKTtcblxuXHRpZiAoIXRoaXMudXNlQ29sb3JzKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0Y29uc3QgYyA9ICdjb2xvcjogJyArIHRoaXMuY29sb3I7XG5cdGFyZ3Muc3BsaWNlKDEsIDAsIGMsICdjb2xvcjogaW5oZXJpdCcpO1xuXG5cdC8vIFRoZSBmaW5hbCBcIiVjXCIgaXMgc29tZXdoYXQgdHJpY2t5LCBiZWNhdXNlIHRoZXJlIGNvdWxkIGJlIG90aGVyXG5cdC8vIGFyZ3VtZW50cyBwYXNzZWQgZWl0aGVyIGJlZm9yZSBvciBhZnRlciB0aGUgJWMsIHNvIHdlIG5lZWQgdG9cblx0Ly8gZmlndXJlIG91dCB0aGUgY29ycmVjdCBpbmRleCB0byBpbnNlcnQgdGhlIENTUyBpbnRvXG5cdGxldCBpbmRleCA9IDA7XG5cdGxldCBsYXN0QyA9IDA7XG5cdGFyZ3NbMF0ucmVwbGFjZSgvJVthLXpBLVolXS9nLCBtYXRjaCA9PiB7XG5cdFx0aWYgKG1hdGNoID09PSAnJSUnKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdGluZGV4Kys7XG5cdFx0aWYgKG1hdGNoID09PSAnJWMnKSB7XG5cdFx0XHQvLyBXZSBvbmx5IGFyZSBpbnRlcmVzdGVkIGluIHRoZSAqbGFzdCogJWNcblx0XHRcdC8vICh0aGUgdXNlciBtYXkgaGF2ZSBwcm92aWRlZCB0aGVpciBvd24pXG5cdFx0XHRsYXN0QyA9IGluZGV4O1xuXHRcdH1cblx0fSk7XG5cblx0YXJncy5zcGxpY2UobGFzdEMsIDAsIGMpO1xufVxuXG4vKipcbiAqIEludm9rZXMgYGNvbnNvbGUuZGVidWcoKWAgd2hlbiBhdmFpbGFibGUuXG4gKiBOby1vcCB3aGVuIGBjb25zb2xlLmRlYnVnYCBpcyBub3QgYSBcImZ1bmN0aW9uXCIuXG4gKiBJZiBgY29uc29sZS5kZWJ1Z2AgaXMgbm90IGF2YWlsYWJsZSwgZmFsbHMgYmFja1xuICogdG8gYGNvbnNvbGUubG9nYC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5leHBvcnRzLmxvZyA9IGNvbnNvbGUuZGVidWcgfHwgY29uc29sZS5sb2cgfHwgKCgpID0+IHt9KTtcblxuLyoqXG4gKiBTYXZlIGBuYW1lc3BhY2VzYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlc1xuICogQGFwaSBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHNhdmUobmFtZXNwYWNlcykge1xuXHR0cnkge1xuXHRcdGlmIChuYW1lc3BhY2VzKSB7XG5cdFx0XHRleHBvcnRzLnN0b3JhZ2Uuc2V0SXRlbSgnZGVidWcnLCBuYW1lc3BhY2VzKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0ZXhwb3J0cy5zdG9yYWdlLnJlbW92ZUl0ZW0oJ2RlYnVnJyk7XG5cdFx0fVxuXHR9IGNhdGNoIChlcnJvcikge1xuXHRcdC8vIFN3YWxsb3dcblx0XHQvLyBYWFggKEBRaXgtKSBzaG91bGQgd2UgYmUgbG9nZ2luZyB0aGVzZT9cblx0fVxufVxuXG4vKipcbiAqIExvYWQgYG5hbWVzcGFjZXNgLlxuICpcbiAqIEByZXR1cm4ge1N0cmluZ30gcmV0dXJucyB0aGUgcHJldmlvdXNseSBwZXJzaXN0ZWQgZGVidWcgbW9kZXNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBsb2FkKCkge1xuXHRsZXQgcjtcblx0dHJ5IHtcblx0XHRyID0gZXhwb3J0cy5zdG9yYWdlLmdldEl0ZW0oJ2RlYnVnJyk7XG5cdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0Ly8gU3dhbGxvd1xuXHRcdC8vIFhYWCAoQFFpeC0pIHNob3VsZCB3ZSBiZSBsb2dnaW5nIHRoZXNlP1xuXHR9XG5cblx0Ly8gSWYgZGVidWcgaXNuJ3Qgc2V0IGluIExTLCBhbmQgd2UncmUgaW4gRWxlY3Ryb24sIHRyeSB0byBsb2FkICRERUJVR1xuXHRpZiAoIXIgJiYgdHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmICdlbnYnIGluIHByb2Nlc3MpIHtcblx0XHRyID0gcHJvY2Vzcy5lbnYuREVCVUc7XG5cdH1cblxuXHRyZXR1cm4gcjtcbn1cblxuLyoqXG4gKiBMb2NhbHN0b3JhZ2UgYXR0ZW1wdHMgdG8gcmV0dXJuIHRoZSBsb2NhbHN0b3JhZ2UuXG4gKlxuICogVGhpcyBpcyBuZWNlc3NhcnkgYmVjYXVzZSBzYWZhcmkgdGhyb3dzXG4gKiB3aGVuIGEgdXNlciBkaXNhYmxlcyBjb29raWVzL2xvY2Fsc3RvcmFnZVxuICogYW5kIHlvdSBhdHRlbXB0IHRvIGFjY2VzcyBpdC5cbiAqXG4gKiBAcmV0dXJuIHtMb2NhbFN0b3JhZ2V9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBsb2NhbHN0b3JhZ2UoKSB7XG5cdHRyeSB7XG5cdFx0Ly8gVFZNTEtpdCAoQXBwbGUgVFYgSlMgUnVudGltZSkgZG9lcyBub3QgaGF2ZSBhIHdpbmRvdyBvYmplY3QsIGp1c3QgbG9jYWxTdG9yYWdlIGluIHRoZSBnbG9iYWwgY29udGV4dFxuXHRcdC8vIFRoZSBCcm93c2VyIGFsc28gaGFzIGxvY2FsU3RvcmFnZSBpbiB0aGUgZ2xvYmFsIGNvbnRleHQuXG5cdFx0cmV0dXJuIGxvY2FsU3RvcmFnZTtcblx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHQvLyBTd2FsbG93XG5cdFx0Ly8gWFhYIChAUWl4LSkgc2hvdWxkIHdlIGJlIGxvZ2dpbmcgdGhlc2U/XG5cdH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2NvbW1vbicpKGV4cG9ydHMpO1xuXG5jb25zdCB7Zm9ybWF0dGVyc30gPSBtb2R1bGUuZXhwb3J0cztcblxuLyoqXG4gKiBNYXAgJWogdG8gYEpTT04uc3RyaW5naWZ5KClgLCBzaW5jZSBubyBXZWIgSW5zcGVjdG9ycyBkbyB0aGF0IGJ5IGRlZmF1bHQuXG4gKi9cblxuZm9ybWF0dGVycy5qID0gZnVuY3Rpb24gKHYpIHtcblx0dHJ5IHtcblx0XHRyZXR1cm4gSlNPTi5zdHJpbmdpZnkodik7XG5cdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0cmV0dXJuICdbVW5leHBlY3RlZEpTT05QYXJzZUVycm9yXTogJyArIGVycm9yLm1lc3NhZ2U7XG5cdH1cbn07XG4iXSwibmFtZXMiOlsiZXhwb3J0cyIsImZvcm1hdEFyZ3MiLCJzYXZlIiwibG9hZCIsInVzZUNvbG9ycyIsInN0b3JhZ2UiLCJsb2NhbHN0b3JhZ2UiLCJkZXN0cm95Iiwid2FybmVkIiwiY29uc29sZSIsIndhcm4iLCJjb2xvcnMiLCJ3aW5kb3ciLCJwcm9jZXNzIiwidHlwZSIsIl9fbndqcyIsIm5hdmlnYXRvciIsInVzZXJBZ2VudCIsInRvTG93ZXJDYXNlIiwibWF0Y2giLCJtIiwiZG9jdW1lbnQiLCJkb2N1bWVudEVsZW1lbnQiLCJzdHlsZSIsIldlYmtpdEFwcGVhcmFuY2UiLCJmaXJlYnVnIiwiZXhjZXB0aW9uIiwidGFibGUiLCJwYXJzZUludCIsImFyZ3MiLCJuYW1lc3BhY2UiLCJtb2R1bGUiLCJodW1hbml6ZSIsImRpZmYiLCJjIiwiY29sb3IiLCJzcGxpY2UiLCJpbmRleCIsImxhc3RDIiwicmVwbGFjZSIsImxvZyIsImRlYnVnIiwibmFtZXNwYWNlcyIsInNldEl0ZW0iLCJyZW1vdmVJdGVtIiwiZXJyb3IiLCJyIiwiZ2V0SXRlbSIsImVudiIsIkRFQlVHIiwibG9jYWxTdG9yYWdlIiwicmVxdWlyZSIsImZvcm1hdHRlcnMiLCJqIiwidiIsIkpTT04iLCJzdHJpbmdpZnkiLCJtZXNzYWdlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/socket.io-adapter/node_modules/debug/src/browser.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/socket.io-adapter/node_modules/debug/src/common.js":
/*!*************************************************************************!*\
  !*** ./node_modules/socket.io-adapter/node_modules/debug/src/common.js ***!
  \*************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * This is the common logic for both the Node.js and web browser\n * implementations of `debug()`.\n */ \nfunction setup(env) {\n    createDebug.debug = createDebug;\n    createDebug.default = createDebug;\n    createDebug.coerce = coerce;\n    createDebug.disable = disable;\n    createDebug.enable = enable;\n    createDebug.enabled = enabled;\n    createDebug.humanize = __webpack_require__(/*! ms */ \"(rsc)/./node_modules/ms/index.js\");\n    createDebug.destroy = destroy;\n    Object.keys(env).forEach((key)=>{\n        createDebug[key] = env[key];\n    });\n    /**\n\t* The currently active debug mode names, and names to skip.\n\t*/ createDebug.names = [];\n    createDebug.skips = [];\n    /**\n\t* Map of special \"%n\" handling functions, for the debug \"format\" argument.\n\t*\n\t* Valid key names are a single, lower or upper-case letter, i.e. \"n\" and \"N\".\n\t*/ createDebug.formatters = {};\n    /**\n\t* Selects a color for a debug namespace\n\t* @param {String} namespace The namespace string for the debug instance to be colored\n\t* @return {Number|String} An ANSI color code for the given namespace\n\t* @api private\n\t*/ function selectColor(namespace) {\n        let hash = 0;\n        for(let i = 0; i < namespace.length; i++){\n            hash = (hash << 5) - hash + namespace.charCodeAt(i);\n            hash |= 0; // Convert to 32bit integer\n        }\n        return createDebug.colors[Math.abs(hash) % createDebug.colors.length];\n    }\n    createDebug.selectColor = selectColor;\n    /**\n\t* Create a debugger with the given `namespace`.\n\t*\n\t* @param {String} namespace\n\t* @return {Function}\n\t* @api public\n\t*/ function createDebug(namespace) {\n        let prevTime;\n        let enableOverride = null;\n        let namespacesCache;\n        let enabledCache;\n        function debug(...args) {\n            // Disabled?\n            if (!debug.enabled) {\n                return;\n            }\n            const self = debug;\n            // Set `diff` timestamp\n            const curr = Number(new Date());\n            const ms = curr - (prevTime || curr);\n            self.diff = ms;\n            self.prev = prevTime;\n            self.curr = curr;\n            prevTime = curr;\n            args[0] = createDebug.coerce(args[0]);\n            if (typeof args[0] !== \"string\") {\n                // Anything else let's inspect with %O\n                args.unshift(\"%O\");\n            }\n            // Apply any `formatters` transformations\n            let index = 0;\n            args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format)=>{\n                // If we encounter an escaped % then don't increase the array index\n                if (match === \"%%\") {\n                    return \"%\";\n                }\n                index++;\n                const formatter = createDebug.formatters[format];\n                if (typeof formatter === \"function\") {\n                    const val = args[index];\n                    match = formatter.call(self, val);\n                    // Now we need to remove `args[index]` since it's inlined in the `format`\n                    args.splice(index, 1);\n                    index--;\n                }\n                return match;\n            });\n            // Apply env-specific formatting (colors, etc.)\n            createDebug.formatArgs.call(self, args);\n            const logFn = self.log || createDebug.log;\n            logFn.apply(self, args);\n        }\n        debug.namespace = namespace;\n        debug.useColors = createDebug.useColors();\n        debug.color = createDebug.selectColor(namespace);\n        debug.extend = extend;\n        debug.destroy = createDebug.destroy; // XXX Temporary. Will be removed in the next major release.\n        Object.defineProperty(debug, \"enabled\", {\n            enumerable: true,\n            configurable: false,\n            get: ()=>{\n                if (enableOverride !== null) {\n                    return enableOverride;\n                }\n                if (namespacesCache !== createDebug.namespaces) {\n                    namespacesCache = createDebug.namespaces;\n                    enabledCache = createDebug.enabled(namespace);\n                }\n                return enabledCache;\n            },\n            set: (v)=>{\n                enableOverride = v;\n            }\n        });\n        // Env-specific initialization logic for debug instances\n        if (typeof createDebug.init === \"function\") {\n            createDebug.init(debug);\n        }\n        return debug;\n    }\n    function extend(namespace, delimiter) {\n        const newDebug = createDebug(this.namespace + (typeof delimiter === \"undefined\" ? \":\" : delimiter) + namespace);\n        newDebug.log = this.log;\n        return newDebug;\n    }\n    /**\n\t* Enables a debug mode by namespaces. This can include modes\n\t* separated by a colon and wildcards.\n\t*\n\t* @param {String} namespaces\n\t* @api public\n\t*/ function enable(namespaces) {\n        createDebug.save(namespaces);\n        createDebug.namespaces = namespaces;\n        createDebug.names = [];\n        createDebug.skips = [];\n        let i;\n        const split = (typeof namespaces === \"string\" ? namespaces : \"\").split(/[\\s,]+/);\n        const len = split.length;\n        for(i = 0; i < len; i++){\n            if (!split[i]) {\n                continue;\n            }\n            namespaces = split[i].replace(/\\*/g, \".*?\");\n            if (namespaces[0] === \"-\") {\n                createDebug.skips.push(new RegExp(\"^\" + namespaces.slice(1) + \"$\"));\n            } else {\n                createDebug.names.push(new RegExp(\"^\" + namespaces + \"$\"));\n            }\n        }\n    }\n    /**\n\t* Disable debug output.\n\t*\n\t* @return {String} namespaces\n\t* @api public\n\t*/ function disable() {\n        const namespaces = [\n            ...createDebug.names.map(toNamespace),\n            ...createDebug.skips.map(toNamespace).map((namespace)=>\"-\" + namespace)\n        ].join(\",\");\n        createDebug.enable(\"\");\n        return namespaces;\n    }\n    /**\n\t* Returns true if the given mode name is enabled, false otherwise.\n\t*\n\t* @param {String} name\n\t* @return {Boolean}\n\t* @api public\n\t*/ function enabled(name) {\n        if (name[name.length - 1] === \"*\") {\n            return true;\n        }\n        let i;\n        let len;\n        for(i = 0, len = createDebug.skips.length; i < len; i++){\n            if (createDebug.skips[i].test(name)) {\n                return false;\n            }\n        }\n        for(i = 0, len = createDebug.names.length; i < len; i++){\n            if (createDebug.names[i].test(name)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    /**\n\t* Convert regexp to namespace\n\t*\n\t* @param {RegExp} regxep\n\t* @return {String} namespace\n\t* @api private\n\t*/ function toNamespace(regexp) {\n        return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\\.\\*\\?$/, \"*\");\n    }\n    /**\n\t* Coerce `val`.\n\t*\n\t* @param {Mixed} val\n\t* @return {Mixed}\n\t* @api private\n\t*/ function coerce(val) {\n        if (val instanceof Error) {\n            return val.stack || val.message;\n        }\n        return val;\n    }\n    /**\n\t* XXX DO NOT USE. This is a temporary stub function.\n\t* XXX It WILL be removed in the next major release.\n\t*/ function destroy() {\n        console.warn(\"Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.\");\n    }\n    createDebug.enable(createDebug.load());\n    return createDebug;\n}\nmodule.exports = setup;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc29ja2V0LmlvLWFkYXB0ZXIvbm9kZV9tb2R1bGVzL2RlYnVnL3NyYy9jb21tb24uanMiLCJtYXBwaW5ncyI6IkFBQ0E7OztDQUdDO0FBRUQsU0FBU0EsTUFBTUMsR0FBRztJQUNqQkMsWUFBWUMsS0FBSyxHQUFHRDtJQUNwQkEsWUFBWUUsT0FBTyxHQUFHRjtJQUN0QkEsWUFBWUcsTUFBTSxHQUFHQTtJQUNyQkgsWUFBWUksT0FBTyxHQUFHQTtJQUN0QkosWUFBWUssTUFBTSxHQUFHQTtJQUNyQkwsWUFBWU0sT0FBTyxHQUFHQTtJQUN0Qk4sWUFBWU8sUUFBUSxHQUFHQyxtQkFBT0EsQ0FBQztJQUMvQlIsWUFBWVMsT0FBTyxHQUFHQTtJQUV0QkMsT0FBT0MsSUFBSSxDQUFDWixLQUFLYSxPQUFPLENBQUNDLENBQUFBO1FBQ3hCYixXQUFXLENBQUNhLElBQUksR0FBR2QsR0FBRyxDQUFDYyxJQUFJO0lBQzVCO0lBRUE7O0NBRUEsR0FFQWIsWUFBWWMsS0FBSyxHQUFHLEVBQUU7SUFDdEJkLFlBQVllLEtBQUssR0FBRyxFQUFFO0lBRXRCOzs7O0NBSUEsR0FDQWYsWUFBWWdCLFVBQVUsR0FBRyxDQUFDO0lBRTFCOzs7OztDQUtBLEdBQ0EsU0FBU0MsWUFBWUMsU0FBUztRQUM3QixJQUFJQyxPQUFPO1FBRVgsSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUlGLFVBQVVHLE1BQU0sRUFBRUQsSUFBSztZQUMxQ0QsT0FBTyxDQUFFQSxRQUFRLEtBQUtBLE9BQVFELFVBQVVJLFVBQVUsQ0FBQ0Y7WUFDbkRELFFBQVEsR0FBRywyQkFBMkI7UUFDdkM7UUFFQSxPQUFPbkIsWUFBWXVCLE1BQU0sQ0FBQ0MsS0FBS0MsR0FBRyxDQUFDTixRQUFRbkIsWUFBWXVCLE1BQU0sQ0FBQ0YsTUFBTSxDQUFDO0lBQ3RFO0lBQ0FyQixZQUFZaUIsV0FBVyxHQUFHQTtJQUUxQjs7Ozs7O0NBTUEsR0FDQSxTQUFTakIsWUFBWWtCLFNBQVM7UUFDN0Is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QUFHOEMsTUFBTWxFLFlBQVllLEtBQUssQ0FBQ00sTUFBTSxFQUFFRCxJQUFJOEMsS0FBSzlDLElBQUs7WUFDekQsSUFBSXBCLFlBQVllLEtBQUssQ0FBQ0ssRUFBRSxDQUFDc0QsSUFBSSxDQUFDRCxPQUFPO2dCQUNwQyxPQUFPO1lBQ1I7UUFDRDtRQUVBLElBQUtyRCxJQUFJLEdBQUc4QyxNQUFNbEUsWUFBWWMsS0FBSyxDQUFDTyxNQUFNLEVBQUVELElBQUk4QyxLQUFLOUMsSUFBSztZQUN6RCxJQUFJcEIsWUFBWWMsS0FBSyxDQUFDTSxFQUFFLENBQUNzRCxJQUFJLENBQUNELE9BQU87Z0JBQ3BDLE9BQU87WUFDUjtRQUNEO1FBRUEsT0FBTztJQUNSO0lBRUE7Ozs7OztDQU1BLEdBQ0EsU0FBU0YsWUFBWUksTUFBTTtRQUMxQixPQUFPQSxPQUFPQyxRQUFRLEdBQ3BCQyxTQUFTLENBQUMsR0FBR0YsT0FBT0MsUUFBUSxHQUFHdkQsTUFBTSxHQUFHLEdBQ3hDbUIsT0FBTyxDQUFDLFdBQVc7SUFDdEI7SUFFQTs7Ozs7O0NBTUEsR0FDQSxTQUFTckMsT0FBT3lDLEdBQUc7UUFDbEIsSUFBSUEsZUFBZWtDLE9BQU87WUFDekIsT0FBT2xDLElBQUltQyxLQUFLLElBQUluQyxJQUFJb0MsT0FBTztRQUNoQztRQUNBLE9BQU9wQztJQUNSO0lBRUE7OztDQUdBLEdBQ0EsU0FBU25DO1FBQ1J3RSxRQUFRQyxJQUFJLENBQUM7SUFDZDtJQUVBbEYsWUFBWUssTUFBTSxDQUFDTCxZQUFZbUYsSUFBSTtJQUVuQyxPQUFPbkY7QUFDUjtBQUVBb0YsT0FBT0MsT0FBTyxHQUFHdkYiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9leGFtcm9zaC8uL25vZGVfbW9kdWxlcy9zb2NrZXQuaW8tYWRhcHRlci9ub2RlX21vZHVsZXMvZGVidWcvc3JjL2NvbW1vbi5qcz9hNjIzIl0sInNvdXJjZXNDb250ZW50IjpbIlxuLyoqXG4gKiBUaGlzIGlzIHRoZSBjb21tb24gbG9naWMgZm9yIGJvdGggdGhlIE5vZGUuanMgYW5kIHdlYiBicm93c2VyXG4gKiBpbXBsZW1lbnRhdGlvbnMgb2YgYGRlYnVnKClgLlxuICovXG5cbmZ1bmN0aW9uIHNldHVwKGVudikge1xuXHRjcmVhdGVEZWJ1Zy5kZWJ1ZyA9IGNyZWF0ZURlYnVnO1xuXHRjcmVhdGVEZWJ1Zy5kZWZhdWx0ID0gY3JlYXRlRGVidWc7XG5cdGNyZWF0ZURlYnVnLmNvZXJjZSA9IGNvZXJjZTtcblx0Y3JlYXRlRGVidWcuZGlzYWJsZSA9IGRpc2FibGU7XG5cdGNyZWF0ZURlYnVnLmVuYWJsZSA9IGVuYWJsZTtcblx0Y3JlYXRlRGVidWcuZW5hYmxlZCA9IGVuYWJsZWQ7XG5cdGNyZWF0ZURlYnVnLmh1bWFuaXplID0gcmVxdWlyZSgnbXMnKTtcblx0Y3JlYXRlRGVidWcuZGVzdHJveSA9IGRlc3Ryb3k7XG5cblx0T2JqZWN0LmtleXMoZW52KS5mb3JFYWNoKGtleSA9PiB7XG5cdFx0Y3JlYXRlRGVidWdba2V5XSA9IGVudltrZXldO1xuXHR9KTtcblxuXHQvKipcblx0KiBUaGUgY3VycmVudGx5IGFjdGl2ZSBkZWJ1ZyBtb2RlIG5hbWVzLCBhbmQgbmFtZXMgdG8gc2tpcC5cblx0Ki9cblxuXHRjcmVhdGVEZWJ1Zy5uYW1lcyA9IFtdO1xuXHRjcmVhdGVEZWJ1Zy5za2lwcyA9IFtdO1xuXG5cdC8qKlxuXHQqIE1hcCBvZiBzcGVjaWFsIFwiJW5cIiBoYW5kbGluZyBmdW5jdGlvbnMsIGZvciB0aGUgZGVidWcgXCJmb3JtYXRcIiBhcmd1bWVudC5cblx0KlxuXHQqIFZhbGlkIGtleSBuYW1lcyBhcmUgYSBzaW5nbGUsIGxvd2VyIG9yIHVwcGVyLWNhc2UgbGV0dGVyLCBpLmUuIFwiblwiIGFuZCBcIk5cIi5cblx0Ki9cblx0Y3JlYXRlRGVidWcuZm9ybWF0dGVycyA9IHt9O1xuXG5cdC8qKlxuXHQqIFNlbGVjdHMgYSBjb2xvciBmb3IgYSBkZWJ1ZyBuYW1lc3BhY2Vcblx0KiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlIFRoZSBuYW1lc3BhY2Ugc3RyaW5nIGZvciB0aGUgZGVidWcgaW5zdGFuY2UgdG8gYmUgY29sb3JlZFxuXHQqIEByZXR1cm4ge051bWJlcnxTdHJpbmd9IEFuIEFOU0kgY29sb3IgY29kZSBmb3IgdGhlIGdpdmVuIG5hbWVzcGFjZVxuXHQqIEBhcGkgcHJpdmF0ZVxuXHQqL1xuXHRmdW5jdGlvbiBzZWxlY3RDb2xvcihuYW1lc3BhY2UpIHtcblx0XHRsZXQgaGFzaCA9IDA7XG5cblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IG5hbWVzcGFjZS5sZW5ndGg7IGkrKykge1xuXHRcdFx0aGFzaCA9ICgoaGFzaCA8PCA1KSAtIGhhc2gpICsgbmFtZXNwYWNlLmNoYXJDb2RlQXQoaSk7XG5cdFx0XHRoYXNoIHw9IDA7IC8vIENvbnZlcnQgdG8gMzJiaXQgaW50ZWdlclxuXHRcdH1cblxuXHRcdHJldHVybiBjcmVhdGVEZWJ1Zy5jb2xvcnNbTWF0aC5hYnMoaGFzaCkgJSBjcmVhdGVEZWJ1Zy5jb2xvcnMubGVuZ3RoXTtcblx0fVxuXHRjcmVhdGVEZWJ1Zy5zZWxlY3RDb2xvciA9IHNlbGVjdENvbG9yO1xuXG5cdC8qKlxuXHQqIENyZWF0ZSBhIGRlYnVnZ2VyIHdpdGggdGhlIGdpdmVuIGBuYW1lc3BhY2VgLlxuXHQqXG5cdCogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZVxuXHQqIEByZXR1cm4ge0Z1bmN0aW9ufVxuXHQqIEBhcGkgcHVibGljXG5cdCovXG5cdGZ1bmN0aW9uIGNyZWF0ZURlYnVnKG5hbWVzcGFjZSkge1xuXHRcdGxldCBwcmV2VGltZTtcblx0XHRsZXQgZW5hYmxlT3ZlcnJpZGUgPSBudWxsO1xuXHRcdGxldCBuYW1lc3BhY2VzQ2FjaGU7XG5cdFx0bGV0IGVuYWJsZWRDYWNoZTtcblxuXHRcdGZ1bmN0aW9uIGRlYnVnKC4uLmFyZ3MpIHtcblx0XHRcdC8vIERpc2FibGVkP1xuXHRcdFx0aWYgKCFkZWJ1Zy5lbmFibGVkKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Y29uc3Qgc2VsZiA9IGRlYnVnO1xuXG5cdFx0XHQvLyBTZXQgYGRpZmZgIHRpbWVzdGFtcFxuXHRcdFx0Y29uc3QgY3VyciA9IE51bWJlcihuZXcgRGF0ZSgpKTtcblx0XHRcdGNvbnN0IG1zID0gY3VyciAtIChwcmV2VGltZSB8fCBjdXJyKTtcblx0XHRcdHNlbGYuZGlmZiA9IG1zO1xuXHRcdFx0c2VsZi5wcmV2ID0gcHJldlRpbWU7XG5cdFx0XHRzZWxmLmN1cnIgPSBjdXJyO1xuXHRcdFx0cHJldlRpbWUgPSBjdXJyO1xuXG5cdFx0XHRhcmdzWzBdID0gY3JlYXRlRGVidWcuY29lcmNlKGFyZ3NbMF0pO1xuXG5cdFx0XHRpZiAodHlwZW9mIGFyZ3NbMF0gIT09ICdzdHJpbmcnKSB7XG5cdFx0XHRcdC8vIEFueXRoaW5nIGVsc2UgbGV0J3MgaW5zcGVjdCB3aXRoICVPXG5cdFx0XHRcdGFyZ3MudW5zaGlmdCgnJU8nKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQXBwbHkgYW55IGBmb3JtYXR0ZXJzYCB0cmFuc2Zvcm1hdGlvbnNcblx0XHRcdGxldCBpbmRleCA9IDA7XG5cdFx0XHRhcmdzWzBdID0gYXJnc1swXS5yZXBsYWNlKC8lKFthLXpBLVolXSkvZywgKG1hdGNoLCBmb3JtYXQpID0+IHtcblx0XHRcdFx0Ly8gSWYgd2UgZW5jb3VudGVyIGFuIGVzY2FwZWQgJSB0aGVuIGRvbid0IGluY3JlYXNlIHRoZSBhcnJheSBpbmRleFxuXHRcdFx0XHRpZiAobWF0Y2ggPT09ICclJScpIHtcblx0XHRcdFx0XHRyZXR1cm4gJyUnO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGluZGV4Kys7XG5cdFx0XHRcdGNvbnN0IGZvcm1hdHRlciA9IGNyZWF0ZURlYnVnLmZvcm1hdHRlcnNbZm9ybWF0XTtcblx0XHRcdFx0aWYgKHR5cGVvZiBmb3JtYXR0ZXIgPT09ICdmdW5jdGlvbicpIHtcblx0XHRcdFx0XHRjb25zdCB2YWwgPSBhcmdzW2luZGV4XTtcblx0XHRcdFx0XHRtYXRjaCA9IGZvcm1hdHRlci5jYWxsKHNlbGYsIHZhbCk7XG5cblx0XHRcdFx0XHQvLyBOb3cgd2UgbmVlZCB0byByZW1vdmUgYGFyZ3NbaW5kZXhdYCBzaW5jZSBpdCdzIGlubGluZWQgaW4gdGhlIGBmb3JtYXRgXG5cdFx0XHRcdFx0YXJncy5zcGxpY2UoaW5kZXgsIDEpO1xuXHRcdFx0XHRcdGluZGV4LS07XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIG1hdGNoO1xuXHRcdFx0fSk7XG5cblx0XHRcdC8vIEFwcGx5IGVudi1zcGVjaWZpYyBmb3JtYXR0aW5nIChjb2xvcnMsIGV0Yy4pXG5cdFx0XHRjcmVhdGVEZWJ1Zy5mb3JtYXRBcmdzLmNhbGwoc2VsZiwgYXJncyk7XG5cblx0XHRcdGNvbnN0IGxvZ0ZuID0gc2VsZi5sb2cgfHwgY3JlYXRlRGVidWcubG9nO1xuXHRcdFx0bG9nRm4uYXBwbHkoc2VsZiwgYXJncyk7XG5cdFx0fVxuXG5cdFx0ZGVidWcubmFtZXNwYWNlID0gbmFtZXNwYWNlO1xuXHRcdGRlYnVnLnVzZUNvbG9ycyA9IGNyZWF0ZURlYnVnLnVzZUNvbG9ycygpO1xuXHRcdGRlYnVnLmNvbG9yID0gY3JlYXRlRGVidWcuc2VsZWN0Q29sb3IobmFtZXNwYWNlKTtcblx0XHRkZWJ1Zy5leHRlbmQgPSBleHRlbmQ7XG5cdFx0ZGVidWcuZGVzdHJveSA9IGNyZWF0ZURlYnVnLmRlc3Ryb3k7IC8vIFhYWCBUZW1wb3JhcnkuIFdpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgbmV4dCBtYWpvciByZWxlYXNlLlxuXG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGRlYnVnLCAnZW5hYmxlZCcsIHtcblx0XHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0XHRjb25maWd1cmFibGU6IGZhbHNlLFxuXHRcdFx0Z2V0OiAoKSA9PiB7XG5cdFx0XHRcdGlmIChlbmFibGVPdmVycmlkZSAhPT0gbnVsbCkge1xuXHRcdFx0XHRcdHJldHVybiBlbmFibGVPdmVycmlkZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAobmFtZXNwYWNlc0NhY2hlICE9PSBjcmVhdGVEZWJ1Zy5uYW1lc3BhY2VzKSB7XG5cdFx0XHRcdFx0bmFtZXNwYWNlc0NhY2hlID0gY3JlYXRlRGVidWcubmFtZXNwYWNlcztcblx0XHRcdFx0XHRlbmFibGVkQ2FjaGUgPSBjcmVhdGVEZWJ1Zy5lbmFibGVkKG5hbWVzcGFjZSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gZW5hYmxlZENhY2hlO1xuXHRcdFx0fSxcblx0XHRcdHNldDogdiA9PiB7XG5cdFx0XHRcdGVuYWJsZU92ZXJyaWRlID0gdjtcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdC8vIEVudi1zcGVjaWZpYyBpbml0aWFsaXphdGlvbiBsb2dpYyBmb3IgZGVidWcgaW5zdGFuY2VzXG5cdFx0aWYgKHR5cGVvZiBjcmVhdGVEZWJ1Zy5pbml0ID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRjcmVhdGVEZWJ1Zy5pbml0KGRlYnVnKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZGVidWc7XG5cdH1cblxuXHRmdW5jdGlvbiBleHRlbmQobmFtZXNwYWNlLCBkZWxpbWl0ZXIpIHtcblx0XHRjb25zdCBuZXdEZWJ1ZyA9IGNyZWF0ZURlYnVnKHRoaXMubmFtZXNwYWNlICsgKHR5cGVvZiBkZWxpbWl0ZXIgPT09ICd1bmRlZmluZWQnID8gJzonIDogZGVsaW1pdGVyKSArIG5hbWVzcGFjZSk7XG5cdFx0bmV3RGVidWcubG9nID0gdGhpcy5sb2c7XG5cdFx0cmV0dXJuIG5ld0RlYnVnO1xuXHR9XG5cblx0LyoqXG5cdCogRW5hYmxlcyBhIGRlYnVnIG1vZGUgYnkgbmFtZXNwYWNlcy4gVGhpcyBjYW4gaW5jbHVkZSBtb2Rlc1xuXHQqIHNlcGFyYXRlZCBieSBhIGNvbG9uIGFuZCB3aWxkY2FyZHMuXG5cdCpcblx0KiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlc1xuXHQqIEBhcGkgcHVibGljXG5cdCovXG5cdGZ1bmN0aW9uIGVuYWJsZShuYW1lc3BhY2VzKSB7XG5cdFx0Y3JlYXRlRGVidWcuc2F2ZShuYW1lc3BhY2VzKTtcblx0XHRjcmVhdGVEZWJ1Zy5uYW1lc3BhY2VzID0gbmFtZXNwYWNlcztcblxuXHRcdGNyZWF0ZURlYnVnLm5hbWVzID0gW107XG5cdFx0Y3JlYXRlRGVidWcuc2tpcHMgPSBbXTtcblxuXHRcdGxldCBpO1xuXHRcdGNvbnN0IHNwbGl0ID0gKHR5cGVvZiBuYW1lc3BhY2VzID09PSAnc3RyaW5nJyA/IG5hbWVzcGFjZXMgOiAnJykuc3BsaXQoL1tcXHMsXSsvKTtcblx0XHRjb25zdCBsZW4gPSBzcGxpdC5sZW5ndGg7XG5cblx0XHRmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdGlmICghc3BsaXRbaV0pIHtcblx0XHRcdFx0Ly8gaWdub3JlIGVtcHR5IHN0cmluZ3Ncblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cblx0XHRcdG5hbWVzcGFjZXMgPSBzcGxpdFtpXS5yZXBsYWNlKC9cXCovZywgJy4qPycpO1xuXG5cdFx0XHRpZiAobmFtZXNwYWNlc1swXSA9PT0gJy0nKSB7XG5cdFx0XHRcdGNyZWF0ZURlYnVnLnNraXBzLnB1c2gobmV3IFJlZ0V4cCgnXicgKyBuYW1lc3BhY2VzLnNsaWNlKDEpICsgJyQnKSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRjcmVhdGVEZWJ1Zy5uYW1lcy5wdXNoKG5ldyBSZWdFeHAoJ14nICsgbmFtZXNwYWNlcyArICckJykpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQqIERpc2FibGUgZGVidWcgb3V0cHV0LlxuXHQqXG5cdCogQHJldHVybiB7U3RyaW5nfSBuYW1lc3BhY2VzXG5cdCogQGFwaSBwdWJsaWNcblx0Ki9cblx0ZnVuY3Rpb24gZGlzYWJsZSgpIHtcblx0XHRjb25zdCBuYW1lc3BhY2VzID0gW1xuXHRcdFx0Li4uY3JlYXRlRGVidWcubmFtZXMubWFwKHRvTmFtZXNwYWNlKSxcblx0XHRcdC4uLmNyZWF0ZURlYnVnLnNraXBzLm1hcCh0b05hbWVzcGFjZSkubWFwKG5hbWVzcGFjZSA9PiAnLScgKyBuYW1lc3BhY2UpXG5cdFx0XS5qb2luKCcsJyk7XG5cdFx0Y3JlYXRlRGVidWcuZW5hYmxlKCcnKTtcblx0XHRyZXR1cm4gbmFtZXNwYWNlcztcblx0fVxuXG5cdC8qKlxuXHQqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gbW9kZSBuYW1lIGlzIGVuYWJsZWQsIGZhbHNlIG90aGVyd2lzZS5cblx0KlxuXHQqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG5cdCogQHJldHVybiB7Qm9vbGVhbn1cblx0KiBAYXBpIHB1YmxpY1xuXHQqL1xuXHRmdW5jdGlvbiBlbmFibGVkKG5hbWUpIHtcblx0XHRpZiAobmFtZVtuYW1lLmxlbmd0aCAtIDFdID09PSAnKicpIHtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblxuXHRcdGxldCBpO1xuXHRcdGxldCBsZW47XG5cblx0XHRmb3IgKGkgPSAwLCBsZW4gPSBjcmVhdGVEZWJ1Zy5za2lwcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0aWYgKGNyZWF0ZURlYnVnLnNraXBzW2ldLnRlc3QobmFtZSkpIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZvciAoaSA9IDAsIGxlbiA9IGNyZWF0ZURlYnVnLm5hbWVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRpZiAoY3JlYXRlRGVidWcubmFtZXNbaV0udGVzdChuYW1lKSkge1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblxuXHQvKipcblx0KiBDb252ZXJ0IHJlZ2V4cCB0byBuYW1lc3BhY2Vcblx0KlxuXHQqIEBwYXJhbSB7UmVnRXhwfSByZWd4ZXBcblx0KiBAcmV0dXJuIHtTdHJpbmd9IG5hbWVzcGFjZVxuXHQqIEBhcGkgcHJpdmF0ZVxuXHQqL1xuXHRmdW5jdGlvbiB0b05hbWVzcGFjZShyZWdleHApIHtcblx0XHRyZXR1cm4gcmVnZXhwLnRvU3RyaW5nKClcblx0XHRcdC5zdWJzdHJpbmcoMiwgcmVnZXhwLnRvU3RyaW5nKCkubGVuZ3RoIC0gMilcblx0XHRcdC5yZXBsYWNlKC9cXC5cXCpcXD8kLywgJyonKTtcblx0fVxuXG5cdC8qKlxuXHQqIENvZXJjZSBgdmFsYC5cblx0KlxuXHQqIEBwYXJhbSB7TWl4ZWR9IHZhbFxuXHQqIEByZXR1cm4ge01peGVkfVxuXHQqIEBhcGkgcHJpdmF0ZVxuXHQqL1xuXHRmdW5jdGlvbiBjb2VyY2UodmFsKSB7XG5cdFx0aWYgKHZhbCBpbnN0YW5jZW9mIEVycm9yKSB7XG5cdFx0XHRyZXR1cm4gdmFsLnN0YWNrIHx8IHZhbC5tZXNzYWdlO1xuXHRcdH1cblx0XHRyZXR1cm4gdmFsO1xuXHR9XG5cblx0LyoqXG5cdCogWFhYIERPIE5PVCBVU0UuIFRoaXMgaXMgYSB0ZW1wb3Jhcnkgc3R1YiBmdW5jdGlvbi5cblx0KiBYWFggSXQgV0lMTCBiZSByZW1vdmVkIGluIHRoZSBuZXh0IG1ham9yIHJlbGVhc2UuXG5cdCovXG5cdGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG5cdFx0Y29uc29sZS53YXJuKCdJbnN0YW5jZSBtZXRob2QgYGRlYnVnLmRlc3Ryb3koKWAgaXMgZGVwcmVjYXRlZCBhbmQgbm8gbG9uZ2VyIGRvZXMgYW55dGhpbmcuIEl0IHdpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgbmV4dCBtYWpvciB2ZXJzaW9uIG9mIGBkZWJ1Z2AuJyk7XG5cdH1cblxuXHRjcmVhdGVEZWJ1Zy5lbmFibGUoY3JlYXRlRGVidWcubG9hZCgpKTtcblxuXHRyZXR1cm4gY3JlYXRlRGVidWc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc2V0dXA7XG4iXSwibmFtZXMiOlsic2V0dXAiLCJlbnYiLCJjcmVhdGVEZWJ1ZyIsImRlYnVnIiwiZGVmYXVsdCIsImNvZXJjZSIsImRpc2FibGUiLCJlbmFibGUiLCJlbmFibGVkIiwiaHVtYW5pemUiLCJyZXF1aXJlIiwiZGVzdHJveSIsIk9iamVjdCIsImtleXMiLCJmb3JFYWNoIiwia2V5IiwibmFtZXMiLCJza2lwcyIsImZvcm1hdHRlcnMiLCJzZWxlY3RDb2xvciIsIm5hbWVzcGFjZSIsImhhc2giLCJpIiwibGVuZ3RoIiwiY2hhckNvZGVBdCIsImNvbG9ycyIsIk1hdGgiLCJhYnMiLCJwcmV2VGltZSIsImVuYWJsZU92ZXJyaWRlIiwibmFtZXNwYWNlc0NhY2hlIiwiZW5hYmxlZENhY2hlIiwiYXJncyIsInNlbGYiLCJjdXJyIiwiTnVtYmVyIiwiRGF0ZSIsIm1zIiwiZGlmZiIsInByZXYiLCJ1bnNoaWZ0IiwiaW5kZXgiLCJyZXBsYWNlIiwibWF0Y2giLCJmb3JtYXQiLCJmb3JtYXR0ZXIiLCJ2YWwiLCJjYWxsIiwic3BsaWNlIiwiZm9ybWF0QXJncyIsImxvZ0ZuIiwibG9nIiwiYXBwbHkiLCJ1c2VDb2xvcnMiLCJjb2xvciIsImV4dGVuZCIsImRlZmluZVByb3BlcnR5IiwiZW51bWVyYWJsZSIsImNvbmZpZ3VyYWJsZSIsImdldCIsIm5hbWVzcGFjZXMiLCJzZXQiLCJ2IiwiaW5pdCIsImRlbGltaXRlciIsIm5ld0RlYnVnIiwic2F2ZSIsInNwbGl0IiwibGVuIiwicHVzaCIsIlJlZ0V4cCIsInNsaWNlIiwibWFwIiwidG9OYW1lc3BhY2UiLCJqb2luIiwibmFtZSIsInRlc3QiLCJyZWdleHAiLCJ0b1N0cmluZyIsInN1YnN0cmluZyIsIkVycm9yIiwic3RhY2siLCJtZXNzYWdlIiwiY29uc29sZSIsIndhcm4iLCJsb2FkIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/socket.io-adapter/node_modules/debug/src/common.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/socket.io-adapter/node_modules/debug/src/index.js":
/*!************************************************************************!*\
  !*** ./node_modules/socket.io-adapter/node_modules/debug/src/index.js ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * Detect Electron renderer / nwjs process, which is node, but we should\n * treat as a browser.\n */ \nif (typeof process === \"undefined\" || process.type === \"renderer\" || false === true || process.__nwjs) {\n    module.exports = __webpack_require__(/*! ./browser.js */ \"(rsc)/./node_modules/socket.io-adapter/node_modules/debug/src/browser.js\");\n} else {\n    module.exports = __webpack_require__(/*! ./node.js */ \"(rsc)/./node_modules/socket.io-adapter/node_modules/debug/src/node.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc29ja2V0LmlvLWFkYXB0ZXIvbm9kZV9tb2R1bGVzL2RlYnVnL3NyYy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7O0NBR0M7QUFFRCxJQUFJLE9BQU9BLFlBQVksZUFBZUEsUUFBUUMsSUFBSSxLQUFLLGNBQWNELEtBQWUsS0FBSyxRQUFRQSxRQUFRRyxNQUFNLEVBQUU7SUFDaEhDLG9JQUF5QjtBQUMxQixPQUFPO0lBQ05BLDhIQUF5QjtBQUMxQiIsInNvdXJjZXMiOlsid2VicGFjazovL2V4YW1yb3NoLy4vbm9kZV9tb2R1bGVzL3NvY2tldC5pby1hZGFwdGVyL25vZGVfbW9kdWxlcy9kZWJ1Zy9zcmMvaW5kZXguanM/YzdlYyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIERldGVjdCBFbGVjdHJvbiByZW5kZXJlciAvIG53anMgcHJvY2Vzcywgd2hpY2ggaXMgbm9kZSwgYnV0IHdlIHNob3VsZFxuICogdHJlYXQgYXMgYSBicm93c2VyLlxuICovXG5cbmlmICh0eXBlb2YgcHJvY2VzcyA9PT0gJ3VuZGVmaW5lZCcgfHwgcHJvY2Vzcy50eXBlID09PSAncmVuZGVyZXInIHx8IHByb2Nlc3MuYnJvd3NlciA9PT0gdHJ1ZSB8fCBwcm9jZXNzLl9fbndqcykge1xuXHRtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vYnJvd3Nlci5qcycpO1xufSBlbHNlIHtcblx0bW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL25vZGUuanMnKTtcbn1cbiJdLCJuYW1lcyI6WyJwcm9jZXNzIiwidHlwZSIsImJyb3dzZXIiLCJfX253anMiLCJtb2R1bGUiLCJleHBvcnRzIiwicmVxdWlyZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/socket.io-adapter/node_modules/debug/src/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/socket.io-adapter/node_modules/debug/src/node.js":
/*!***********************************************************************!*\
  !*** ./node_modules/socket.io-adapter/node_modules/debug/src/node.js ***!
  \***********************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("/**\n * Module dependencies.\n */ \nconst tty = __webpack_require__(/*! tty */ \"tty\");\nconst util = __webpack_require__(/*! util */ \"util\");\n/**\n * This is the Node.js implementation of `debug()`.\n */ exports.init = init;\nexports.log = log;\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\nexports.destroy = util.deprecate(()=>{}, \"Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.\");\n/**\n * Colors.\n */ exports.colors = [\n    6,\n    2,\n    3,\n    4,\n    5,\n    1\n];\ntry {\n    // Optional dependency (as in, doesn't need to be installed, NOT like optionalDependencies in package.json)\n    // eslint-disable-next-line import/no-extraneous-dependencies\n    const supportsColor = __webpack_require__(/*! supports-color */ \"(rsc)/./node_modules/supports-color/index.js\");\n    if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {\n        exports.colors = [\n            20,\n            21,\n            26,\n            27,\n            32,\n            33,\n            38,\n            39,\n            40,\n            41,\n            42,\n            43,\n            44,\n            45,\n            56,\n            57,\n            62,\n            63,\n            68,\n            69,\n            74,\n            75,\n            76,\n            77,\n            78,\n            79,\n            80,\n            81,\n            92,\n            93,\n            98,\n            99,\n            112,\n            113,\n            128,\n            129,\n            134,\n            135,\n            148,\n            149,\n            160,\n            161,\n            162,\n            163,\n            164,\n            165,\n            166,\n            167,\n            168,\n            169,\n            170,\n            171,\n            172,\n            173,\n            178,\n            179,\n            184,\n            185,\n            196,\n            197,\n            198,\n            199,\n            200,\n            201,\n            202,\n            203,\n            204,\n            205,\n            206,\n            207,\n            208,\n            209,\n            214,\n            215,\n            220,\n            221\n        ];\n    }\n} catch (error) {\n// Swallow - we only care if `supports-color` is available; it doesn't have to be.\n}\n/**\n * Build up the default `inspectOpts` object from the environment variables.\n *\n *   $ DEBUG_COLORS=no DEBUG_DEPTH=10 DEBUG_SHOW_HIDDEN=enabled node script.js\n */ exports.inspectOpts = Object.keys(process.env).filter((key)=>{\n    return /^debug_/i.test(key);\n}).reduce((obj, key)=>{\n    // Camel-case\n    const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_, k)=>{\n        return k.toUpperCase();\n    });\n    // Coerce string value into JS value\n    let val = process.env[key];\n    if (/^(yes|on|true|enabled)$/i.test(val)) {\n        val = true;\n    } else if (/^(no|off|false|disabled)$/i.test(val)) {\n        val = false;\n    } else if (val === \"null\") {\n        val = null;\n    } else {\n        val = Number(val);\n    }\n    obj[prop] = val;\n    return obj;\n}, {});\n/**\n * Is stdout a TTY? Colored output is enabled when `true`.\n */ function useColors() {\n    return \"colors\" in exports.inspectOpts ? Boolean(exports.inspectOpts.colors) : tty.isatty(process.stderr.fd);\n}\n/**\n * Adds ANSI color escape codes if enabled.\n *\n * @api public\n */ function formatArgs(args) {\n    const { namespace: name, useColors } = this;\n    if (useColors) {\n        const c = this.color;\n        const colorCode = \"\\x1b[3\" + (c < 8 ? c : \"8;5;\" + c);\n        const prefix = `  ${colorCode};1m${name} \\u001B[0m`;\n        args[0] = prefix + args[0].split(\"\\n\").join(\"\\n\" + prefix);\n        args.push(colorCode + \"m+\" + module.exports.humanize(this.diff) + \"\\x1b[0m\");\n    } else {\n        args[0] = getDate() + name + \" \" + args[0];\n    }\n}\nfunction getDate() {\n    if (exports.inspectOpts.hideDate) {\n        return \"\";\n    }\n    return new Date().toISOString() + \" \";\n}\n/**\n * Invokes `util.formatWithOptions()` with the specified arguments and writes to stderr.\n */ function log(...args) {\n    return process.stderr.write(util.formatWithOptions(exports.inspectOpts, ...args) + \"\\n\");\n}\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */ function save(namespaces) {\n    if (namespaces) {\n        process.env.DEBUG = namespaces;\n    } else {\n        // If you set a process.env field to null or undefined, it gets cast to the\n        // string 'null' or 'undefined'. Just delete instead.\n        delete process.env.DEBUG;\n    }\n}\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */ function load() {\n    return process.env.DEBUG;\n}\n/**\n * Init logic for `debug` instances.\n *\n * Create a new `inspectOpts` object in case `useColors` is set\n * differently for a particular `debug` instance.\n */ function init(debug) {\n    debug.inspectOpts = {};\n    const keys = Object.keys(exports.inspectOpts);\n    for(let i = 0; i < keys.length; i++){\n        debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];\n    }\n}\nmodule.exports = __webpack_require__(/*! ./common */ \"(rsc)/./node_modules/socket.io-adapter/node_modules/debug/src/common.js\")(exports);\nconst { formatters } = module.exports;\n/**\n * Map %o to `util.inspect()`, all on a single line.\n */ formatters.o = function(v) {\n    this.inspectOpts.colors = this.useColors;\n    return util.inspect(v, this.inspectOpts).split(\"\\n\").map((str)=>str.trim()).join(\" \");\n};\n/**\n * Map %O to `util.inspect()`, allowing multiple lines if needed.\n */ formatters.O = function(v) {\n    this.inspectOpts.colors = this.useColors;\n    return util.inspect(v, this.inspectOpts);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc29ja2V0LmlvLWFkYXB0ZXIvbm9kZV9tb2R1bGVzL2RlYnVnL3NyYy9ub2RlLmpzIiwibWFwcGluZ3MiOiJBQUFBOztDQUVDO0FBRUQsTUFBTUEsTUFBTUMsbUJBQU9BLENBQUM7QUFDcEIsTUFBTUMsT0FBT0QsbUJBQU9BLENBQUM7QUFFckI7O0NBRUMsR0FFREUsWUFBWSxHQUFHQztBQUNmRCxXQUFXLEdBQUdFO0FBQ2RGLGtCQUFrQixHQUFHRztBQUNyQkgsWUFBWSxHQUFHSTtBQUNmSixZQUFZLEdBQUdLO0FBQ2ZMLGlCQUFpQixHQUFHTTtBQUNwQk4sZUFBZSxHQUFHRCxLQUFLUyxTQUFTLENBQy9CLEtBQU8sR0FDUDtBQUdEOztDQUVDLEdBRURSLGNBQWMsR0FBRztJQUFDO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztDQUFFO0FBRW5DLElBQUk7SUFDSCwyR0FBMkc7SUFDM0csNkRBQTZEO0lBQzdELE1BQU1VLGdCQUFnQlosbUJBQU9BLENBQUM7SUFFOUIsSUFBSVksaUJBQWlCLENBQUNBLGNBQWNDLE1BQU0sSUFBSUQsYUFBWSxFQUFHRSxLQUFLLElBQUksR0FBRztRQUN4RVosY0FBYyxHQUFHO1lBQ2hCO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZ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TUFBTTNDLFdBQVcsR0FBRyxDQUFDO0lBRXJCLE1BQU1FLE9BQU9ELE9BQU9DLElBQUksQ0FBQ2hCLFFBQVFjLFdBQVc7SUFDNUMsSUFBSyxJQUFJNEMsSUFBSSxHQUFHQSxJQUFJMUMsS0FBSzJDLE1BQU0sRUFBRUQsSUFBSztRQUNyQ0QsTUFBTTNDLFdBQVcsQ0FBQ0UsSUFBSSxDQUFDMEMsRUFBRSxDQUFDLEdBQUcxRCxRQUFRYyxXQUFXLENBQUNFLElBQUksQ0FBQzBDLEVBQUUsQ0FBQztJQUMxRDtBQUNEO0FBRUFaLE9BQU85QyxPQUFPLEdBQUdGLG1CQUFPQSxDQUFDLDJGQUFZRTtBQUVyQyxNQUFNLEVBQUM0RCxVQUFVLEVBQUMsR0FBR2QsT0FBTzlDLE9BQU87QUFFbkM7O0NBRUMsR0FFRDRELFdBQVdDLENBQUMsR0FBRyxTQUFVQyxDQUFDO0lBQ3pCLElBQUksQ0FBQ2hELFdBQVcsQ0FBQ0wsTUFBTSxHQUFHLElBQUksQ0FBQ0gsU0FBUztJQUN4QyxPQUFPUCxLQUFLZ0UsT0FBTyxDQUFDRCxHQUFHLElBQUksQ0FBQ2hELFdBQVcsRUFDckM2QixLQUFLLENBQUMsTUFDTnFCLEdBQUcsQ0FBQ0MsQ0FBQUEsTUFBT0EsSUFBSUMsSUFBSSxJQUNuQnRCLElBQUksQ0FBQztBQUNSO0FBRUE7O0NBRUMsR0FFRGdCLFdBQVdPLENBQUMsR0FBRyxTQUFVTCxDQUFDO0lBQ3pCLElBQUksQ0FBQ2hELFdBQVcsQ0FBQ0wsTUFBTSxHQUFHLElBQUksQ0FBQ0gsU0FBUztJQUN4QyxPQUFPUCxLQUFLZ0UsT0FBTyxDQUFDRCxHQUFHLElBQUksQ0FBQ2hELFdBQVc7QUFDeEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9leGFtcm9zaC8uL25vZGVfbW9kdWxlcy9zb2NrZXQuaW8tYWRhcHRlci9ub2RlX21vZHVsZXMvZGVidWcvc3JjL25vZGUuanM/NDU2OCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxuY29uc3QgdHR5ID0gcmVxdWlyZSgndHR5Jyk7XG5jb25zdCB1dGlsID0gcmVxdWlyZSgndXRpbCcpO1xuXG4vKipcbiAqIFRoaXMgaXMgdGhlIE5vZGUuanMgaW1wbGVtZW50YXRpb24gb2YgYGRlYnVnKClgLlxuICovXG5cbmV4cG9ydHMuaW5pdCA9IGluaXQ7XG5leHBvcnRzLmxvZyA9IGxvZztcbmV4cG9ydHMuZm9ybWF0QXJncyA9IGZvcm1hdEFyZ3M7XG5leHBvcnRzLnNhdmUgPSBzYXZlO1xuZXhwb3J0cy5sb2FkID0gbG9hZDtcbmV4cG9ydHMudXNlQ29sb3JzID0gdXNlQ29sb3JzO1xuZXhwb3J0cy5kZXN0cm95ID0gdXRpbC5kZXByZWNhdGUoXG5cdCgpID0+IHt9LFxuXHQnSW5zdGFuY2UgbWV0aG9kIGBkZWJ1Zy5kZXN0cm95KClgIGlzIGRlcHJlY2F0ZWQgYW5kIG5vIGxvbmdlciBkb2VzIGFueXRoaW5nLiBJdCB3aWxsIGJlIHJlbW92ZWQgaW4gdGhlIG5leHQgbWFqb3IgdmVyc2lvbiBvZiBgZGVidWdgLidcbik7XG5cbi8qKlxuICogQ29sb3JzLlxuICovXG5cbmV4cG9ydHMuY29sb3JzID0gWzYsIDIsIDMsIDQsIDUsIDFdO1xuXG50cnkge1xuXHQvLyBPcHRpb25hbCBkZXBlbmRlbmN5IChhcyBpbiwgZG9lc24ndCBuZWVkIHRvIGJlIGluc3RhbGxlZCwgTk9UIGxpa2Ugb3B0aW9uYWxEZXBlbmRlbmNpZXMgaW4gcGFja2FnZS5qc29uKVxuXHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLWV4dHJhbmVvdXMtZGVwZW5kZW5jaWVzXG5cdGNvbnN0IHN1cHBvcnRzQ29sb3IgPSByZXF1aXJlKCdzdXBwb3J0cy1jb2xvcicpO1xuXG5cdGlmIChzdXBwb3J0c0NvbG9yICYmIChzdXBwb3J0c0NvbG9yLnN0ZGVyciB8fCBzdXBwb3J0c0NvbG9yKS5sZXZlbCA+PSAyKSB7XG5cdFx0ZXhwb3J0cy5jb2xvcnMgPSBbXG5cdFx0XHQyMCxcblx0XHRcdDIxLFxuXHRcdFx0MjYsXG5cdFx0XHQyNyxcblx0XHRcdDMyLFxuXHRcdFx0MzMsXG5cdFx0XHQzOCxcblx0XHRcdDM5LFxuXHRcdFx0NDAsXG5cdFx0XHQ0MSxcblx0XHRcdDQyLFxuXHRcdFx0NDMsXG5cdFx0XHQ0NCxcblx0XHRcdDQ1LFxuXHRcdFx0NTYsXG5cdFx0XHQ1Nyxcblx0XHRcdDYyLFxuXHRcdFx0NjMsXG5cdFx0XHQ2OCxcblx0XHRcdDY5LFxuXHRcdFx0NzQsXG5cdFx0XHQ3NSxcblx0XHRcdDc2LFxuXHRcdFx0NzcsXG5cdFx0XHQ3OCxcblx0XHRcdDc5LFxuXHRcdFx0ODAsXG5cdFx0XHQ4MSxcblx0XHRcdDkyLFxuXHRcdFx0OTMsXG5cdFx0XHQ5OCxcblx0XHRcdDk5LFxuXHRcdFx0MTEyLFxuXHRcdFx0MTEzLFxuXHRcdFx0MTI4LFxuXHRcdFx0MTI5LFxuXHRcdFx0MTM0LFxuXHRcdFx0MTM1LFxuXHRcdFx0MTQ4LFxuXHRcdFx0MTQ5LFxuXHRcdFx0MTYwLFxuXHRcdFx0MTYxLFxuXHRcdFx0MTYyLFxuXHRcdFx0MTYzLFxuXHRcdFx0MTY0LFxuXHRcdFx0MTY1LFxuXHRcdFx0MTY2LFxuXHRcdFx0MTY3LFxuXHRcdFx0MTY4LFxuXHRcdFx0MTY5LFxuXHRcdFx0MTcwLFxuXHRcdFx0MTcxLFxuXHRcdFx0MTcyLFxuXHRcdFx0MTczLFxuXHRcdFx0MTc4LFxuXHRcdFx0MTc5LFxuXHRcdFx0MTg0LFxuXHRcdFx0MTg1LFxuXHRcdFx0MTk2LFxuXHRcdFx0MTk3LFxuXHRcdFx0MTk4LFxuXHRcdFx0MTk5LFxuXHRcdFx0MjAwLFxuXHRcdFx0MjAxLFxuXHRcdFx0MjAyLFxuXHRcdFx0MjAzLFxuXHRcdFx0MjA0LFxuXHRcdFx0MjA1LFxuXHRcdFx0MjA2LFxuXHRcdFx0MjA3LFxuXHRcdFx0MjA4LFxuXHRcdFx0MjA5LFxuXHRcdFx0MjE0LFxuXHRcdFx0MjE1LFxuXHRcdFx0MjIwLFxuXHRcdFx0MjIxXG5cdFx0XTtcblx0fVxufSBjYXRjaCAoZXJyb3IpIHtcblx0Ly8gU3dhbGxvdyAtIHdlIG9ubHkgY2FyZSBpZiBgc3VwcG9ydHMtY29sb3JgIGlzIGF2YWlsYWJsZTsgaXQgZG9lc24ndCBoYXZlIHRvIGJlLlxufVxuXG4vKipcbiAqIEJ1aWxkIHVwIHRoZSBkZWZhdWx0IGBpbnNwZWN0T3B0c2Agb2JqZWN0IGZyb20gdGhlIGVudmlyb25tZW50IHZhcmlhYmxlcy5cbiAqXG4gKiAgICQgREVCVUdfQ09MT1JTPW5vIERFQlVHX0RFUFRIPTEwIERFQlVHX1NIT1dfSElEREVOPWVuYWJsZWQgbm9kZSBzY3JpcHQuanNcbiAqL1xuXG5leHBvcnRzLmluc3BlY3RPcHRzID0gT2JqZWN0LmtleXMocHJvY2Vzcy5lbnYpLmZpbHRlcihrZXkgPT4ge1xuXHRyZXR1cm4gL15kZWJ1Z18vaS50ZXN0KGtleSk7XG59KS5yZWR1Y2UoKG9iaiwga2V5KSA9PiB7XG5cdC8vIENhbWVsLWNhc2Vcblx0Y29uc3QgcHJvcCA9IGtleVxuXHRcdC5zdWJzdHJpbmcoNilcblx0XHQudG9Mb3dlckNhc2UoKVxuXHRcdC5yZXBsYWNlKC9fKFthLXpdKS9nLCAoXywgaykgPT4ge1xuXHRcdFx0cmV0dXJuIGsudG9VcHBlckNhc2UoKTtcblx0XHR9KTtcblxuXHQvLyBDb2VyY2Ugc3RyaW5nIHZhbHVlIGludG8gSlMgdmFsdWVcblx0bGV0IHZhbCA9IHByb2Nlc3MuZW52W2tleV07XG5cdGlmICgvXih5ZXN8b258dHJ1ZXxlbmFibGVkKSQvaS50ZXN0KHZhbCkpIHtcblx0XHR2YWwgPSB0cnVlO1xuXHR9IGVsc2UgaWYgKC9eKG5vfG9mZnxmYWxzZXxkaXNhYmxlZCkkL2kudGVzdCh2YWwpKSB7XG5cdFx0dmFsID0gZmFsc2U7XG5cdH0gZWxzZSBpZiAodmFsID09PSAnbnVsbCcpIHtcblx0XHR2YWwgPSBudWxsO1xuXHR9IGVsc2Uge1xuXHRcdHZhbCA9IE51bWJlcih2YWwpO1xuXHR9XG5cblx0b2JqW3Byb3BdID0gdmFsO1xuXHRyZXR1cm4gb2JqO1xufSwge30pO1xuXG4vKipcbiAqIElzIHN0ZG91dCBhIFRUWT8gQ29sb3JlZCBvdXRwdXQgaXMgZW5hYmxlZCB3aGVuIGB0cnVlYC5cbiAqL1xuXG5mdW5jdGlvbiB1c2VDb2xvcnMoKSB7XG5cdHJldHVybiAnY29sb3JzJyBpbiBleHBvcnRzLmluc3BlY3RPcHRzID9cblx0XHRCb29sZWFuKGV4cG9ydHMuaW5zcGVjdE9wdHMuY29sb3JzKSA6XG5cdFx0dHR5LmlzYXR0eShwcm9jZXNzLnN0ZGVyci5mZCk7XG59XG5cbi8qKlxuICogQWRkcyBBTlNJIGNvbG9yIGVzY2FwZSBjb2RlcyBpZiBlbmFibGVkLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZm9ybWF0QXJncyhhcmdzKSB7XG5cdGNvbnN0IHtuYW1lc3BhY2U6IG5hbWUsIHVzZUNvbG9yc30gPSB0aGlzO1xuXG5cdGlmICh1c2VDb2xvcnMpIHtcblx0XHRjb25zdCBjID0gdGhpcy5jb2xvcjtcblx0XHRjb25zdCBjb2xvckNvZGUgPSAnXFx1MDAxQlszJyArIChjIDwgOCA/IGMgOiAnODs1OycgKyBjKTtcblx0XHRjb25zdCBwcmVmaXggPSBgICAke2NvbG9yQ29kZX07MW0ke25hbWV9IFxcdTAwMUJbMG1gO1xuXG5cdFx0YXJnc1swXSA9IHByZWZpeCArIGFyZ3NbMF0uc3BsaXQoJ1xcbicpLmpvaW4oJ1xcbicgKyBwcmVmaXgpO1xuXHRcdGFyZ3MucHVzaChjb2xvckNvZGUgKyAnbSsnICsgbW9kdWxlLmV4cG9ydHMuaHVtYW5pemUodGhpcy5kaWZmKSArICdcXHUwMDFCWzBtJyk7XG5cdH0gZWxzZSB7XG5cdFx0YXJnc1swXSA9IGdldERhdGUoKSArIG5hbWUgKyAnICcgKyBhcmdzWzBdO1xuXHR9XG59XG5cbmZ1bmN0aW9uIGdldERhdGUoKSB7XG5cdGlmIChleHBvcnRzLmluc3BlY3RPcHRzLmhpZGVEYXRlKSB7XG5cdFx0cmV0dXJuICcnO1xuXHR9XG5cdHJldHVybiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCkgKyAnICc7XG59XG5cbi8qKlxuICogSW52b2tlcyBgdXRpbC5mb3JtYXRXaXRoT3B0aW9ucygpYCB3aXRoIHRoZSBzcGVjaWZpZWQgYXJndW1lbnRzIGFuZCB3cml0ZXMgdG8gc3RkZXJyLlxuICovXG5cbmZ1bmN0aW9uIGxvZyguLi5hcmdzKSB7XG5cdHJldHVybiBwcm9jZXNzLnN0ZGVyci53cml0ZSh1dGlsLmZvcm1hdFdpdGhPcHRpb25zKGV4cG9ydHMuaW5zcGVjdE9wdHMsIC4uLmFyZ3MpICsgJ1xcbicpO1xufVxuXG4vKipcbiAqIFNhdmUgYG5hbWVzcGFjZXNgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gc2F2ZShuYW1lc3BhY2VzKSB7XG5cdGlmIChuYW1lc3BhY2VzKSB7XG5cdFx0cHJvY2Vzcy5lbnYuREVCVUcgPSBuYW1lc3BhY2VzO1xuXHR9IGVsc2Uge1xuXHRcdC8vIElmIHlvdSBzZXQgYSBwcm9jZXNzLmVudiBmaWVsZCB0byBudWxsIG9yIHVuZGVmaW5lZCwgaXQgZ2V0cyBjYXN0IHRvIHRoZVxuXHRcdC8vIHN0cmluZyAnbnVsbCcgb3IgJ3VuZGVmaW5lZCcuIEp1c3QgZGVsZXRlIGluc3RlYWQuXG5cdFx0ZGVsZXRlIHByb2Nlc3MuZW52LkRFQlVHO1xuXHR9XG59XG5cbi8qKlxuICogTG9hZCBgbmFtZXNwYWNlc2AuXG4gKlxuICogQHJldHVybiB7U3RyaW5nfSByZXR1cm5zIHRoZSBwcmV2aW91c2x5IHBlcnNpc3RlZCBkZWJ1ZyBtb2Rlc1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gbG9hZCgpIHtcblx0cmV0dXJuIHByb2Nlc3MuZW52LkRFQlVHO1xufVxuXG4vKipcbiAqIEluaXQgbG9naWMgZm9yIGBkZWJ1Z2AgaW5zdGFuY2VzLlxuICpcbiAqIENyZWF0ZSBhIG5ldyBgaW5zcGVjdE9wdHNgIG9iamVjdCBpbiBjYXNlIGB1c2VDb2xvcnNgIGlzIHNldFxuICogZGlmZmVyZW50bHkgZm9yIGEgcGFydGljdWxhciBgZGVidWdgIGluc3RhbmNlLlxuICovXG5cbmZ1bmN0aW9uIGluaXQoZGVidWcpIHtcblx0ZGVidWcuaW5zcGVjdE9wdHMgPSB7fTtcblxuXHRjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoZXhwb3J0cy5pbnNwZWN0T3B0cyk7XG5cdGZvciAobGV0IGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuXHRcdGRlYnVnLmluc3BlY3RPcHRzW2tleXNbaV1dID0gZXhwb3J0cy5pbnNwZWN0T3B0c1trZXlzW2ldXTtcblx0fVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY29tbW9uJykoZXhwb3J0cyk7XG5cbmNvbnN0IHtmb3JtYXR0ZXJzfSA9IG1vZHVsZS5leHBvcnRzO1xuXG4vKipcbiAqIE1hcCAlbyB0byBgdXRpbC5pbnNwZWN0KClgLCBhbGwgb24gYSBzaW5nbGUgbGluZS5cbiAqL1xuXG5mb3JtYXR0ZXJzLm8gPSBmdW5jdGlvbiAodikge1xuXHR0aGlzLmluc3BlY3RPcHRzLmNvbG9ycyA9IHRoaXMudXNlQ29sb3JzO1xuXHRyZXR1cm4gdXRpbC5pbnNwZWN0KHYsIHRoaXMuaW5zcGVjdE9wdHMpXG5cdFx0LnNwbGl0KCdcXG4nKVxuXHRcdC5tYXAoc3RyID0+IHN0ci50cmltKCkpXG5cdFx0LmpvaW4oJyAnKTtcbn07XG5cbi8qKlxuICogTWFwICVPIHRvIGB1dGlsLmluc3BlY3QoKWAsIGFsbG93aW5nIG11bHRpcGxlIGxpbmVzIGlmIG5lZWRlZC5cbiAqL1xuXG5mb3JtYXR0ZXJzLk8gPSBmdW5jdGlvbiAodikge1xuXHR0aGlzLmluc3BlY3RPcHRzLmNvbG9ycyA9IHRoaXMudXNlQ29sb3JzO1xuXHRyZXR1cm4gdXRpbC5pbnNwZWN0KHYsIHRoaXMuaW5zcGVjdE9wdHMpO1xufTtcbiJdLCJuYW1lcyI6WyJ0dHkiLCJyZXF1aXJlIiwidXRpbCIsImV4cG9ydHMiLCJpbml0IiwibG9nIiwiZm9ybWF0QXJncyIsInNhdmUiLCJsb2FkIiwidXNlQ29sb3JzIiwiZGVzdHJveSIsImRlcHJlY2F0ZSIsImNvbG9ycyIsInN1cHBvcnRzQ29sb3IiLCJzdGRlcnIiLCJsZXZlbCIsImVycm9yIiwiaW5zcGVjdE9wdHMiLCJPYmplY3QiLCJrZXlzIiwicHJvY2VzcyIsImVudiIsImZpbHRlciIsImtleSIsInRlc3QiLCJyZWR1Y2UiLCJvYmoiLCJwcm9wIiwic3Vic3RyaW5nIiwidG9Mb3dlckNhc2UiLCJyZXBsYWNlIiwiXyIsImsiLCJ0b1VwcGVyQ2FzZSIsInZhbCIsIk51bWJlciIsIkJvb2xlYW4iLCJpc2F0dHkiLCJmZCIsImFyZ3MiLCJuYW1lc3BhY2UiLCJuYW1lIiwiYyIsImNvbG9yIiwiY29sb3JDb2RlIiwicHJlZml4Iiwic3BsaXQiLCJqb2luIiwicHVzaCIsIm1vZHVsZSIsImh1bWFuaXplIiwiZGlmZiIsImdldERhdGUiLCJoaWRlRGF0ZSIsIkRhdGUiLCJ0b0lTT1N0cmluZyIsIndyaXRlIiwiZm9ybWF0V2l0aE9wdGlvbnMiLCJuYW1lc3BhY2VzIiwiREVCVUciLCJkZWJ1ZyIsImkiLCJsZW5ndGgiLCJmb3JtYXR0ZXJzIiwibyIsInYiLCJpbnNwZWN0IiwibWFwIiwic3RyIiwidHJpbSIsIk8iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/socket.io-adapter/node_modules/debug/src/node.js\n");

/***/ })

};
;