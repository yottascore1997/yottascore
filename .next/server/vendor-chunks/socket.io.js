"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/socket.io";
exports.ids = ["vendor-chunks/socket.io"];
exports.modules = {

/***/ "(rsc)/./node_modules/socket.io/node_modules/debug/src/browser.js":
/*!******************************************************************!*\
  !*** ./node_modules/socket.io/node_modules/debug/src/browser.js ***!
  \******************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("/* eslint-env browser */ /**\n * This is the web browser implementation of `debug()`.\n */ \nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\nexports.storage = localstorage();\nexports.destroy = (()=>{\n    let warned = false;\n    return ()=>{\n        if (!warned) {\n            warned = true;\n            console.warn(\"Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.\");\n        }\n    };\n})();\n/**\n * Colors.\n */ exports.colors = [\n    \"#0000CC\",\n    \"#0000FF\",\n    \"#0033CC\",\n    \"#0033FF\",\n    \"#0066CC\",\n    \"#0066FF\",\n    \"#0099CC\",\n    \"#0099FF\",\n    \"#00CC00\",\n    \"#00CC33\",\n    \"#00CC66\",\n    \"#00CC99\",\n    \"#00CCCC\",\n    \"#00CCFF\",\n    \"#3300CC\",\n    \"#3300FF\",\n    \"#3333CC\",\n    \"#3333FF\",\n    \"#3366CC\",\n    \"#3366FF\",\n    \"#3399CC\",\n    \"#3399FF\",\n    \"#33CC00\",\n    \"#33CC33\",\n    \"#33CC66\",\n    \"#33CC99\",\n    \"#33CCCC\",\n    \"#33CCFF\",\n    \"#6600CC\",\n    \"#6600FF\",\n    \"#6633CC\",\n    \"#6633FF\",\n    \"#66CC00\",\n    \"#66CC33\",\n    \"#9900CC\",\n    \"#9900FF\",\n    \"#9933CC\",\n    \"#9933FF\",\n    \"#99CC00\",\n    \"#99CC33\",\n    \"#CC0000\",\n    \"#CC0033\",\n    \"#CC0066\",\n    \"#CC0099\",\n    \"#CC00CC\",\n    \"#CC00FF\",\n    \"#CC3300\",\n    \"#CC3333\",\n    \"#CC3366\",\n    \"#CC3399\",\n    \"#CC33CC\",\n    \"#CC33FF\",\n    \"#CC6600\",\n    \"#CC6633\",\n    \"#CC9900\",\n    \"#CC9933\",\n    \"#CCCC00\",\n    \"#CCCC33\",\n    \"#FF0000\",\n    \"#FF0033\",\n    \"#FF0066\",\n    \"#FF0099\",\n    \"#FF00CC\",\n    \"#FF00FF\",\n    \"#FF3300\",\n    \"#FF3333\",\n    \"#FF3366\",\n    \"#FF3399\",\n    \"#FF33CC\",\n    \"#FF33FF\",\n    \"#FF6600\",\n    \"#FF6633\",\n    \"#FF9900\",\n    \"#FF9933\",\n    \"#FFCC00\",\n    \"#FFCC33\"\n];\n/**\n * Currently only WebKit-based Web Inspectors, Firefox >= v31,\n * and the Firebug extension (any Firefox version) are known\n * to support \"%c\" CSS customizations.\n *\n * TODO: add a `localStorage` variable to explicitly enable/disable colors\n */ // eslint-disable-next-line complexity\nfunction useColors() {\n    // NB: In an Electron preload script, document will be defined but not fully\n    // initialized. Since we know we're in Chrome, we'll just detect this case\n    // explicitly\n    if (false) {}\n    // Internet Explorer and Edge do not support colors.\n    if (typeof navigator !== \"undefined\" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\\/(\\d+)/)) {\n        return false;\n    }\n    let m;\n    // Is webkit? http://stackoverflow.com/a/16459606/376773\n    // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632\n    return typeof document !== \"undefined\" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773\n     false && (0) || // Is firefox >= v31?\n    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\n    typeof navigator !== \"undefined\" && navigator.userAgent && (m = navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/)) && parseInt(m[1], 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker\n    typeof navigator !== \"undefined\" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\\/(\\d+)/);\n}\n/**\n * Colorize log arguments if enabled.\n *\n * @api public\n */ function formatArgs(args) {\n    args[0] = (this.useColors ? \"%c\" : \"\") + this.namespace + (this.useColors ? \" %c\" : \" \") + args[0] + (this.useColors ? \"%c \" : \" \") + \"+\" + module.exports.humanize(this.diff);\n    if (!this.useColors) {\n        return;\n    }\n    const c = \"color: \" + this.color;\n    args.splice(1, 0, c, \"color: inherit\");\n    // The final \"%c\" is somewhat tricky, because there could be other\n    // arguments passed either before or after the %c, so we need to\n    // figure out the correct index to insert the CSS into\n    let index = 0;\n    let lastC = 0;\n    args[0].replace(/%[a-zA-Z%]/g, (match)=>{\n        if (match === \"%%\") {\n            return;\n        }\n        index++;\n        if (match === \"%c\") {\n            // We only are interested in the *last* %c\n            // (the user may have provided their own)\n            lastC = index;\n        }\n    });\n    args.splice(lastC, 0, c);\n}\n/**\n * Invokes `console.debug()` when available.\n * No-op when `console.debug` is not a \"function\".\n * If `console.debug` is not available, falls back\n * to `console.log`.\n *\n * @api public\n */ exports.log = console.debug || console.log || (()=>{});\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */ function save(namespaces) {\n    try {\n        if (namespaces) {\n            exports.storage.setItem(\"debug\", namespaces);\n        } else {\n            exports.storage.removeItem(\"debug\");\n        }\n    } catch (error) {\n    // Swallow\n    // XXX (@Qix-) should we be logging these?\n    }\n}\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */ function load() {\n    let r;\n    try {\n        r = exports.storage.getItem(\"debug\");\n    } catch (error) {\n    // Swallow\n    // XXX (@Qix-) should we be logging these?\n    }\n    // If debug isn't set in LS, and we're in Electron, try to load $DEBUG\n    if (!r && typeof process !== \"undefined\" && \"env\" in process) {\n        r = process.env.DEBUG;\n    }\n    return r;\n}\n/**\n * Localstorage attempts to return the localstorage.\n *\n * This is necessary because safari throws\n * when a user disables cookies/localstorage\n * and you attempt to access it.\n *\n * @return {LocalStorage}\n * @api private\n */ function localstorage() {\n    try {\n        // TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context\n        // The Browser also has localStorage in the global context.\n        return localStorage;\n    } catch (error) {\n    // Swallow\n    // XXX (@Qix-) should we be logging these?\n    }\n}\nmodule.exports = __webpack_require__(/*! ./common */ \"(rsc)/./node_modules/socket.io/node_modules/debug/src/common.js\")(exports);\nconst { formatters } = module.exports;\n/**\n * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\n */ formatters.j = function(v) {\n    try {\n        return JSON.stringify(v);\n    } catch (error) {\n        return \"[UnexpectedJSONParseError]: \" + error.message;\n    }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc29ja2V0LmlvL25vZGVfbW9kdWxlcy9kZWJ1Zy9zcmMvYnJvd3Nlci5qcyIsIm1hcHBpbmdzIjoiQUFBQSxzQkFBc0IsR0FFdEI7O0NBRUM7QUFFREEsa0JBQWtCLEdBQUdDO0FBQ3JCRCxZQUFZLEdBQUdFO0FBQ2ZGLFlBQVksR0FBR0c7QUFDZkgsaUJBQWlCLEdBQUdJO0FBQ3BCSixlQUFlLEdBQUdNO0FBQ2xCTixlQUFlLEdBQUcsQ0FBQztJQUNsQixJQUFJUSxTQUFTO0lBRWIsT0FBTztRQUNOLElBQUksQ0FBQ0EsUUFBUTtZQUNaQSxTQUFTO1lBQ1RDLFFBQVFDLElBQUksQ0FBQztRQUNkO0lBQ0Q7QUFDRDtBQUVBOztDQUVDLEdBRURWLGNBQWMsR0FBRztJQUNoQjtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtDQUNBO0FBRUQ7Ozs7OztDQU1DLEdBRUQsc0NBQXNDO0FBQ3RDLFNBQVNJO0lBQ1IsNEVBQTRFO0lBQzVFLDBFQUEwRTtJQUMxRSxhQUFhO0lBQ2IsSUFBSSxLQUFnSCxFQUFFLEVBRXJIO0lBRUQsb0RBQW9EO0lBQ3BELElBQUksT0FBT1ksY0FBYyxlQUFlQSxVQUFVQyxTQUFTLElB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RDtRQUMzRCxPQUFPNEM7SUFDUixFQUFFLE9BQU9MLE9BQU87SUFDZixVQUFVO0lBQ1YsMENBQTBDO0lBQzNDO0FBQ0Q7QUFFQWQsT0FBTy9CLE9BQU8sR0FBR21ELG1CQUFPQSxDQUFDLG1GQUFZbkQ7QUFFckMsTUFBTSxFQUFDb0QsVUFBVSxFQUFDLEdBQUdyQixPQUFPL0IsT0FBTztBQUVuQzs7Q0FFQyxHQUVEb0QsV0FBV0MsQ0FBQyxHQUFHLFNBQVVDLENBQUM7SUFDekIsSUFBSTtRQUNILE9BQU9DLEtBQUtDLFNBQVMsQ0FBQ0Y7SUFDdkIsRUFBRSxPQUFPVCxPQUFPO1FBQ2YsT0FBTyxpQ0FBaUNBLE1BQU1ZLE9BQU87SUFDdEQ7QUFDRCIsInNvdXJjZXMiOlsid2VicGFjazovL2V4YW1yb3NoLy4vbm9kZV9tb2R1bGVzL3NvY2tldC5pby9ub2RlX21vZHVsZXMvZGVidWcvc3JjL2Jyb3dzZXIuanM/ODA1NiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiBlc2xpbnQtZW52IGJyb3dzZXIgKi9cblxuLyoqXG4gKiBUaGlzIGlzIHRoZSB3ZWIgYnJvd3NlciBpbXBsZW1lbnRhdGlvbiBvZiBgZGVidWcoKWAuXG4gKi9cblxuZXhwb3J0cy5mb3JtYXRBcmdzID0gZm9ybWF0QXJncztcbmV4cG9ydHMuc2F2ZSA9IHNhdmU7XG5leHBvcnRzLmxvYWQgPSBsb2FkO1xuZXhwb3J0cy51c2VDb2xvcnMgPSB1c2VDb2xvcnM7XG5leHBvcnRzLnN0b3JhZ2UgPSBsb2NhbHN0b3JhZ2UoKTtcbmV4cG9ydHMuZGVzdHJveSA9ICgoKSA9PiB7XG5cdGxldCB3YXJuZWQgPSBmYWxzZTtcblxuXHRyZXR1cm4gKCkgPT4ge1xuXHRcdGlmICghd2FybmVkKSB7XG5cdFx0XHR3YXJuZWQgPSB0cnVlO1xuXHRcdFx0Y29uc29sZS53YXJuKCdJbnN0YW5jZSBtZXRob2QgYGRlYnVnLmRlc3Ryb3koKWAgaXMgZGVwcmVjYXRlZCBhbmQgbm8gbG9uZ2VyIGRvZXMgYW55dGhpbmcuIEl0IHdpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgbmV4dCBtYWpvciB2ZXJzaW9uIG9mIGBkZWJ1Z2AuJyk7XG5cdFx0fVxuXHR9O1xufSkoKTtcblxuLyoqXG4gKiBDb2xvcnMuXG4gKi9cblxuZXhwb3J0cy5jb2xvcnMgPSBbXG5cdCcjMDAwMENDJyxcblx0JyMwMDAwRkYnLFxuXHQnIzAwMzNDQycsXG5cdCcjMDAzM0ZGJyxcblx0JyMwMDY2Q0MnLFxuXHQnIzAwNjZGRicsXG5cdCcjMDA5OUNDJyxcblx0JyMwMDk5RkYnLFxuXHQnIzAwQ0MwMCcsXG5cdCcjMDBDQzMzJyxcblx0JyMwMENDNjYnLFxuXHQnIzAwQ0M5OScsXG5cdCcjMDBDQ0NDJyxcblx0JyMwMENDRkYnLFxuXHQnIzMzMDBDQycsXG5cdCcjMzMwMEZGJyxcblx0JyMzMzMzQ0MnLFxuXHQnIzMzMzNGRicsXG5cdCcjMzM2NkNDJyxcblx0JyMzMzY2RkYnLFxuXHQnIzMzOTlDQycsXG5cdCcjMzM5OUZGJyxcblx0JyMzM0NDMDAnLFxuXHQnIzMzQ0MzMycsXG5cdCcjMzNDQzY2Jyxcblx0JyMzM0NDOTknLFxuXHQnIzMzQ0NDQycsXG5cdCcjMzNDQ0ZGJyxcblx0JyM2NjAwQ0MnLFxuXHQnIzY2MDBGRicsXG5cdCcjNjYzM0NDJyxcblx0JyM2NjMzRkYnLFxuXHQnIzY2Q0MwMCcsXG5cdCcjNjZDQzMzJyxcblx0JyM5OTAwQ0MnLFxuXHQnIzk5MDBGRicsXG5cdCcjOTkzM0NDJyxcblx0JyM5OTMzRkYnLFxuXHQnIzk5Q0MwMCcsXG5cdCcjOTlDQzMzJyxcblx0JyNDQzAwMDAnLFxuXHQnI0NDMDAzMycsXG5cdCcjQ0MwMDY2Jyxcblx0JyNDQzAwOTknLFxuXHQnI0NDMDBDQycsXG5cdCcjQ0MwMEZGJyxcblx0JyNDQzMzMDAnLFxuXHQnI0NDMzMzMycsXG5cdCcjQ0MzMzY2Jyxcblx0JyNDQzMzOTknLFxuXHQnI0NDMzNDQycsXG5cdCcjQ0MzM0ZGJyxcblx0JyNDQzY2MDAnLFxuXHQnI0NDNjYzMycsXG5cdCcjQ0M5OTAwJyxcblx0JyNDQzk5MzMnLFxuXHQnI0NDQ0MwMCcsXG5cdCcjQ0NDQzMzJyxcblx0JyNGRjAwMDAnLFxuXHQnI0ZGMDAzMycsXG5cdCcjRkYwMDY2Jyxcblx0JyNGRjAwOTknLFxuXHQnI0ZGMDBDQycsXG5cdCcjRkYwMEZGJyxcblx0JyNGRjMzMDAnLFxuXHQnI0ZGMzMzMycsXG5cdCcjRkYzMzY2Jyxcblx0JyNGRjMzOTknLFxuXHQnI0ZGMzNDQycsXG5cdCcjRkYzM0ZGJyxcblx0JyNGRjY2MDAnLFxuXHQnI0ZGNjYzMycsXG5cdCcjRkY5OTAwJyxcblx0JyNGRjk5MzMnLFxuXHQnI0ZGQ0MwMCcsXG5cdCcjRkZDQzMzJ1xuXTtcblxuLyoqXG4gKiBDdXJyZW50bHkgb25seSBXZWJLaXQtYmFzZWQgV2ViIEluc3BlY3RvcnMsIEZpcmVmb3ggPj0gdjMxLFxuICogYW5kIHRoZSBGaXJlYnVnIGV4dGVuc2lvbiAoYW55IEZpcmVmb3ggdmVyc2lvbikgYXJlIGtub3duXG4gKiB0byBzdXBwb3J0IFwiJWNcIiBDU1MgY3VzdG9taXphdGlvbnMuXG4gKlxuICogVE9ETzogYWRkIGEgYGxvY2FsU3RvcmFnZWAgdmFyaWFibGUgdG8gZXhwbGljaXRseSBlbmFibGUvZGlzYWJsZSBjb2xvcnNcbiAqL1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29tcGxleGl0eVxuZnVuY3Rpb24gdXNlQ29sb3JzKCkge1xuXHQvLyBOQjogSW4gYW4gRWxlY3Ryb24gcHJlbG9hZCBzY3JpcHQsIGRvY3VtZW50IHdpbGwgYmUgZGVmaW5lZCBidXQgbm90IGZ1bGx5XG5cdC8vIGluaXRpYWxpemVkLiBTaW5jZSB3ZSBrbm93IHdlJ3JlIGluIENocm9tZSwgd2UnbGwganVzdCBkZXRlY3QgdGhpcyBjYXNlXG5cdC8vIGV4cGxpY2l0bHlcblx0aWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5wcm9jZXNzICYmICh3aW5kb3cucHJvY2Vzcy50eXBlID09PSAncmVuZGVyZXInIHx8IHdpbmRvdy5wcm9jZXNzLl9fbndqcykpIHtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXG5cdC8vIEludGVybmV0IEV4cGxvcmVyIGFuZCBFZGdlIGRvIG5vdCBzdXBwb3J0IGNvbG9ycy5cblx0aWYgKHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIG5hdmlnYXRvci51c2VyQWdlbnQgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLm1hdGNoKC8oZWRnZXx0cmlkZW50KVxcLyhcXGQrKS8pKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cblx0bGV0IG07XG5cblx0Ly8gSXMgd2Via2l0PyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8xNjQ1OTYwNi8zNzY3NzNcblx0Ly8gZG9jdW1lbnQgaXMgdW5kZWZpbmVkIGluIHJlYWN0LW5hdGl2ZTogaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0LW5hdGl2ZS9wdWxsLzE2MzJcblx0cmV0dXJuICh0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlLldlYmtpdEFwcGVhcmFuY2UpIHx8XG5cdFx0Ly8gSXMgZmlyZWJ1Zz8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMzk4MTIwLzM3Njc3M1xuXHRcdCh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuY29uc29sZSAmJiAod2luZG93LmNvbnNvbGUuZmlyZWJ1ZyB8fCAod2luZG93LmNvbnNvbGUuZXhjZXB0aW9uICYmIHdpbmRvdy5jb25zb2xlLnRhYmxlKSkpIHx8XG5cdFx0Ly8gSXMgZmlyZWZveCA+PSB2MzE/XG5cdFx0Ly8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9Ub29scy9XZWJfQ29uc29sZSNTdHlsaW5nX21lc3NhZ2VzXG5cdFx0KHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIG5hdmlnYXRvci51c2VyQWdlbnQgJiYgKG0gPSBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkubWF0Y2goL2ZpcmVmb3hcXC8oXFxkKykvKSkgJiYgcGFyc2VJbnQobVsxXSwgMTApID49IDMxKSB8fFxuXHRcdC8vIERvdWJsZSBjaGVjayB3ZWJraXQgaW4gdXNlckFnZW50IGp1c3QgaW4gY2FzZSB3ZSBhcmUgaW4gYSB3b3JrZXJcblx0XHQodHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudCAmJiBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkubWF0Y2goL2FwcGxld2Via2l0XFwvKFxcZCspLykpO1xufVxuXG4vKipcbiAqIENvbG9yaXplIGxvZyBhcmd1bWVudHMgaWYgZW5hYmxlZC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGZvcm1hdEFyZ3MoYXJncykge1xuXHRhcmdzWzBdID0gKHRoaXMudXNlQ29sb3JzID8gJyVjJyA6ICcnKSArXG5cdFx0dGhpcy5uYW1lc3BhY2UgK1xuXHRcdCh0aGlzLnVzZUNvbG9ycyA/ICcgJWMnIDogJyAnKSArXG5cdFx0YXJnc1swXSArXG5cdFx0KHRoaXMudXNlQ29sb3JzID8gJyVjICcgOiAnICcpICtcblx0XHQnKycgKyBtb2R1bGUuZXhwb3J0cy5odW1hbml6ZSh0aGlzLmRpZmYpO1xuXG5cdGlmICghdGhpcy51c2VDb2xvcnMpIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHRjb25zdCBjID0gJ2NvbG9yOiAnICsgdGhpcy5jb2xvcjtcblx0YXJncy5zcGxpY2UoMSwgMCwgYywgJ2NvbG9yOiBpbmhlcml0Jyk7XG5cblx0Ly8gVGhlIGZpbmFsIFwiJWNcIiBpcyBzb21ld2hhdCB0cmlja3ksIGJlY2F1c2UgdGhlcmUgY291bGQgYmUgb3RoZXJcblx0Ly8gYXJndW1lbnRzIHBhc3NlZCBlaXRoZXIgYmVmb3JlIG9yIGFmdGVyIHRoZSAlYywgc28gd2UgbmVlZCB0b1xuXHQvLyBmaWd1cmUgb3V0IHRoZSBjb3JyZWN0IGluZGV4IHRvIGluc2VydCB0aGUgQ1NTIGludG9cblx0bGV0IGluZGV4ID0gMDtcblx0bGV0IGxhc3RDID0gMDtcblx0YXJnc1swXS5yZXBsYWNlKC8lW2EtekEtWiVdL2csIG1hdGNoID0+IHtcblx0XHRpZiAobWF0Y2ggPT09ICclJScpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0aW5kZXgrKztcblx0XHRpZiAobWF0Y2ggPT09ICclYycpIHtcblx0XHRcdC8vIFdlIG9ubHkgYXJlIGludGVyZXN0ZWQgaW4gdGhlICpsYXN0KiAlY1xuXHRcdFx0Ly8gKHRoZSB1c2VyIG1heSBoYXZlIHByb3ZpZGVkIHRoZWlyIG93bilcblx0XHRcdGxhc3RDID0gaW5kZXg7XG5cdFx0fVxuXHR9KTtcblxuXHRhcmdzLnNwbGljZShsYXN0QywgMCwgYyk7XG59XG5cbi8qKlxuICogSW52b2tlcyBgY29uc29sZS5kZWJ1ZygpYCB3aGVuIGF2YWlsYWJsZS5cbiAqIE5vLW9wIHdoZW4gYGNvbnNvbGUuZGVidWdgIGlzIG5vdCBhIFwiZnVuY3Rpb25cIi5cbiAqIElmIGBjb25zb2xlLmRlYnVnYCBpcyBub3QgYXZhaWxhYmxlLCBmYWxscyBiYWNrXG4gKiB0byBgY29uc29sZS5sb2dgLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cbmV4cG9ydHMubG9nID0gY29uc29sZS5kZWJ1ZyB8fCBjb25zb2xlLmxvZyB8fCAoKCkgPT4ge30pO1xuXG4vKipcbiAqIFNhdmUgYG5hbWVzcGFjZXNgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gc2F2ZShuYW1lc3BhY2VzKSB7XG5cdHRyeSB7XG5cdFx0aWYgKG5hbWVzcGFjZXMpIHtcblx0XHRcdGV4cG9ydHMuc3RvcmFnZS5zZXRJdGVtKCdkZWJ1ZycsIG5hbWVzcGFjZXMpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRleHBvcnRzLnN0b3JhZ2UucmVtb3ZlSXRlbSgnZGVidWcnKTtcblx0XHR9XG5cdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0Ly8gU3dhbGxvd1xuXHRcdC8vIFhYWCAoQFFpeC0pIHNob3VsZCB3ZSBiZSBsb2dnaW5nIHRoZXNlP1xuXHR9XG59XG5cbi8qKlxuICogTG9hZCBgbmFtZXNwYWNlc2AuXG4gKlxuICogQHJldHVybiB7U3RyaW5nfSByZXR1cm5zIHRoZSBwcmV2aW91c2x5IHBlcnNpc3RlZCBkZWJ1ZyBtb2Rlc1xuICogQGFwaSBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGxvYWQoKSB7XG5cdGxldCByO1xuXHR0cnkge1xuXHRcdHIgPSBleHBvcnRzLnN0b3JhZ2UuZ2V0SXRlbSgnZGVidWcnKTtcblx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHQvLyBTd2FsbG93XG5cdFx0Ly8gWFhYIChAUWl4LSkgc2hvdWxkIHdlIGJlIGxvZ2dpbmcgdGhlc2U/XG5cdH1cblxuXHQvLyBJZiBkZWJ1ZyBpc24ndCBzZXQgaW4gTFMsIGFuZCB3ZSdyZSBpbiBFbGVjdHJvbiwgdHJ5IHRvIGxvYWQgJERFQlVHXG5cdGlmICghciAmJiB0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiYgJ2VudicgaW4gcHJvY2Vzcykge1xuXHRcdHIgPSBwcm9jZXNzLmVudi5ERUJVRztcblx0fVxuXG5cdHJldHVybiByO1xufVxuXG4vKipcbiAqIExvY2Fsc3RvcmFnZSBhdHRlbXB0cyB0byByZXR1cm4gdGhlIGxvY2Fsc3RvcmFnZS5cbiAqXG4gKiBUaGlzIGlzIG5lY2Vzc2FyeSBiZWNhdXNlIHNhZmFyaSB0aHJvd3NcbiAqIHdoZW4gYSB1c2VyIGRpc2FibGVzIGNvb2tpZXMvbG9jYWxzdG9yYWdlXG4gKiBhbmQgeW91IGF0dGVtcHQgdG8gYWNjZXNzIGl0LlxuICpcbiAqIEByZXR1cm4ge0xvY2FsU3RvcmFnZX1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGxvY2Fsc3RvcmFnZSgpIHtcblx0dHJ5IHtcblx0XHQvLyBUVk1MS2l0IChBcHBsZSBUViBKUyBSdW50aW1lKSBkb2VzIG5vdCBoYXZlIGEgd2luZG93IG9iamVjdCwganVzdCBsb2NhbFN0b3JhZ2UgaW4gdGhlIGdsb2JhbCBjb250ZXh0XG5cdFx0Ly8gVGhlIEJyb3dzZXIgYWxzbyBoYXMgbG9jYWxTdG9yYWdlIGluIHRoZSBnbG9iYWwgY29udGV4dC5cblx0XHRyZXR1cm4gbG9jYWxTdG9yYWdlO1xuXHR9IGNhdGNoIChlcnJvcikge1xuXHRcdC8vIFN3YWxsb3dcblx0XHQvLyBYWFggKEBRaXgtKSBzaG91bGQgd2UgYmUgbG9nZ2luZyB0aGVzZT9cblx0fVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY29tbW9uJykoZXhwb3J0cyk7XG5cbmNvbnN0IHtmb3JtYXR0ZXJzfSA9IG1vZHVsZS5leHBvcnRzO1xuXG4vKipcbiAqIE1hcCAlaiB0byBgSlNPTi5zdHJpbmdpZnkoKWAsIHNpbmNlIG5vIFdlYiBJbnNwZWN0b3JzIGRvIHRoYXQgYnkgZGVmYXVsdC5cbiAqL1xuXG5mb3JtYXR0ZXJzLmogPSBmdW5jdGlvbiAodikge1xuXHR0cnkge1xuXHRcdHJldHVybiBKU09OLnN0cmluZ2lmeSh2KTtcblx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRyZXR1cm4gJ1tVbmV4cGVjdGVkSlNPTlBhcnNlRXJyb3JdOiAnICsgZXJyb3IubWVzc2FnZTtcblx0fVxufTtcbiJdLCJuYW1lcyI6WyJleHBvcnRzIiwiZm9ybWF0QXJncyIsInNhdmUiLCJsb2FkIiwidXNlQ29sb3JzIiwic3RvcmFnZSIsImxvY2Fsc3RvcmFnZSIsImRlc3Ryb3kiLCJ3YXJuZWQiLCJjb25zb2xlIiwid2FybiIsImNvbG9ycyIsIndpbmRvdyIsInByb2Nlc3MiLCJ0eXBlIiwiX19ud2pzIiwibmF2aWdhdG9yIiwidXNlckFnZW50IiwidG9Mb3dlckNhc2UiLCJtYXRjaCIsIm0iLCJkb2N1bWVudCIsImRvY3VtZW50RWxlbWVudCIsInN0eWxlIiwiV2Via2l0QXBwZWFyYW5jZSIsImZpcmVidWciLCJleGNlcHRpb24iLCJ0YWJsZSIsInBhcnNlSW50IiwiYXJncyIsIm5hbWVzcGFjZSIsIm1vZHVsZSIsImh1bWFuaXplIiwiZGlmZiIsImMiLCJjb2xvciIsInNwbGljZSIsImluZGV4IiwibGFzdEMiLCJyZXBsYWNlIiwibG9nIiwiZGVidWciLCJuYW1lc3BhY2VzIiwic2V0SXRlbSIsInJlbW92ZUl0ZW0iLCJlcnJvciIsInIiLCJnZXRJdGVtIiwiZW52IiwiREVCVUciLCJsb2NhbFN0b3JhZ2UiLCJyZXF1aXJlIiwiZm9ybWF0dGVycyIsImoiLCJ2IiwiSlNPTiIsInN0cmluZ2lmeSIsIm1lc3NhZ2UiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/socket.io/node_modules/debug/src/browser.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/socket.io/node_modules/debug/src/common.js":
/*!*****************************************************************!*\
  !*** ./node_modules/socket.io/node_modules/debug/src/common.js ***!
  \*****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * This is the common logic for both the Node.js and web browser\n * implementations of `debug()`.\n */ \nfunction setup(env) {\n    createDebug.debug = createDebug;\n    createDebug.default = createDebug;\n    createDebug.coerce = coerce;\n    createDebug.disable = disable;\n    createDebug.enable = enable;\n    createDebug.enabled = enabled;\n    createDebug.humanize = __webpack_require__(/*! ms */ \"(rsc)/./node_modules/ms/index.js\");\n    createDebug.destroy = destroy;\n    Object.keys(env).forEach((key)=>{\n        createDebug[key] = env[key];\n    });\n    /**\n\t* The currently active debug mode names, and names to skip.\n\t*/ createDebug.names = [];\n    createDebug.skips = [];\n    /**\n\t* Map of special \"%n\" handling functions, for the debug \"format\" argument.\n\t*\n\t* Valid key names are a single, lower or upper-case letter, i.e. \"n\" and \"N\".\n\t*/ createDebug.formatters = {};\n    /**\n\t* Selects a color for a debug namespace\n\t* @param {String} namespace The namespace string for the debug instance to be colored\n\t* @return {Number|String} An ANSI color code for the given namespace\n\t* @api private\n\t*/ function selectColor(namespace) {\n        let hash = 0;\n        for(let i = 0; i < namespace.length; i++){\n            hash = (hash << 5) - hash + namespace.charCodeAt(i);\n            hash |= 0; // Convert to 32bit integer\n        }\n        return createDebug.colors[Math.abs(hash) % createDebug.colors.length];\n    }\n    createDebug.selectColor = selectColor;\n    /**\n\t* Create a debugger with the given `namespace`.\n\t*\n\t* @param {String} namespace\n\t* @return {Function}\n\t* @api public\n\t*/ function createDebug(namespace) {\n        let prevTime;\n        let enableOverride = null;\n        let namespacesCache;\n        let enabledCache;\n        function debug(...args) {\n            // Disabled?\n            if (!debug.enabled) {\n                return;\n            }\n            const self = debug;\n            // Set `diff` timestamp\n            const curr = Number(new Date());\n            const ms = curr - (prevTime || curr);\n            self.diff = ms;\n            self.prev = prevTime;\n            self.curr = curr;\n            prevTime = curr;\n            args[0] = createDebug.coerce(args[0]);\n            if (typeof args[0] !== \"string\") {\n                // Anything else let's inspect with %O\n                args.unshift(\"%O\");\n            }\n            // Apply any `formatters` transformations\n            let index = 0;\n            args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format)=>{\n                // If we encounter an escaped % then don't increase the array index\n                if (match === \"%%\") {\n                    return \"%\";\n                }\n                index++;\n                const formatter = createDebug.formatters[format];\n                if (typeof formatter === \"function\") {\n                    const val = args[index];\n                    match = formatter.call(self, val);\n                    // Now we need to remove `args[index]` since it's inlined in the `format`\n                    args.splice(index, 1);\n                    index--;\n                }\n                return match;\n            });\n            // Apply env-specific formatting (colors, etc.)\n            createDebug.formatArgs.call(self, args);\n            const logFn = self.log || createDebug.log;\n            logFn.apply(self, args);\n        }\n        debug.namespace = namespace;\n        debug.useColors = createDebug.useColors();\n        debug.color = createDebug.selectColor(namespace);\n        debug.extend = extend;\n        debug.destroy = createDebug.destroy; // XXX Temporary. Will be removed in the next major release.\n        Object.defineProperty(debug, \"enabled\", {\n            enumerable: true,\n            configurable: false,\n            get: ()=>{\n                if (enableOverride !== null) {\n                    return enableOverride;\n                }\n                if (namespacesCache !== createDebug.namespaces) {\n                    namespacesCache = createDebug.namespaces;\n                    enabledCache = createDebug.enabled(namespace);\n                }\n                return enabledCache;\n            },\n            set: (v)=>{\n                enableOverride = v;\n            }\n        });\n        // Env-specific initialization logic for debug instances\n        if (typeof createDebug.init === \"function\") {\n            createDebug.init(debug);\n        }\n        return debug;\n    }\n    function extend(namespace, delimiter) {\n        const newDebug = createDebug(this.namespace + (typeof delimiter === \"undefined\" ? \":\" : delimiter) + namespace);\n        newDebug.log = this.log;\n        return newDebug;\n    }\n    /**\n\t* Enables a debug mode by namespaces. This can include modes\n\t* separated by a colon and wildcards.\n\t*\n\t* @param {String} namespaces\n\t* @api public\n\t*/ function enable(namespaces) {\n        createDebug.save(namespaces);\n        createDebug.namespaces = namespaces;\n        createDebug.names = [];\n        createDebug.skips = [];\n        let i;\n        const split = (typeof namespaces === \"string\" ? namespaces : \"\").split(/[\\s,]+/);\n        const len = split.length;\n        for(i = 0; i < len; i++){\n            if (!split[i]) {\n                continue;\n            }\n            namespaces = split[i].replace(/\\*/g, \".*?\");\n            if (namespaces[0] === \"-\") {\n                createDebug.skips.push(new RegExp(\"^\" + namespaces.slice(1) + \"$\"));\n            } else {\n                createDebug.names.push(new RegExp(\"^\" + namespaces + \"$\"));\n            }\n        }\n    }\n    /**\n\t* Disable debug output.\n\t*\n\t* @return {String} namespaces\n\t* @api public\n\t*/ function disable() {\n        const namespaces = [\n            ...createDebug.names.map(toNamespace),\n            ...createDebug.skips.map(toNamespace).map((namespace)=>\"-\" + namespace)\n        ].join(\",\");\n        createDebug.enable(\"\");\n        return namespaces;\n    }\n    /**\n\t* Returns true if the given mode name is enabled, false otherwise.\n\t*\n\t* @param {String} name\n\t* @return {Boolean}\n\t* @api public\n\t*/ function enabled(name) {\n        if (name[name.length - 1] === \"*\") {\n            return true;\n        }\n        let i;\n        let len;\n        for(i = 0, len = createDebug.skips.length; i < len; i++){\n            if (createDebug.skips[i].test(name)) {\n                return false;\n            }\n        }\n        for(i = 0, len = createDebug.names.length; i < len; i++){\n            if (createDebug.names[i].test(name)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    /**\n\t* Convert regexp to namespace\n\t*\n\t* @param {RegExp} regxep\n\t* @return {String} namespace\n\t* @api private\n\t*/ function toNamespace(regexp) {\n        return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\\.\\*\\?$/, \"*\");\n    }\n    /**\n\t* Coerce `val`.\n\t*\n\t* @param {Mixed} val\n\t* @return {Mixed}\n\t* @api private\n\t*/ function coerce(val) {\n        if (val instanceof Error) {\n            return val.stack || val.message;\n        }\n        return val;\n    }\n    /**\n\t* XXX DO NOT USE. This is a temporary stub function.\n\t* XXX It WILL be removed in the next major release.\n\t*/ function destroy() {\n        console.warn(\"Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.\");\n    }\n    createDebug.enable(createDebug.load());\n    return createDebug;\n}\nmodule.exports = setup;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc29ja2V0LmlvL25vZGVfbW9kdWxlcy9kZWJ1Zy9zcmMvY29tbW9uLmpzIiwibWFwcGluZ3MiOiJBQUNBOzs7Q0FHQztBQUVELFNBQVNBLE1BQU1DLEdBQUc7SUFDakJDLFlBQVlDLEtBQUssR0FBR0Q7SUFDcEJBLFlBQVlFLE9BQU8sR0FBR0Y7SUFDdEJBLFlBQVlHLE1BQU0sR0FBR0E7SUFDckJILFlBQVlJLE9BQU8sR0FBR0E7SUFDdEJKLFlBQVlLLE1BQU0sR0FBR0E7SUFDckJMLFlBQVlNLE9BQU8sR0FBR0E7SUFDdEJOLFlBQVlPLFFBQVEsR0FBR0MsbUJBQU9BLENBQUM7SUFDL0JSLFlBQVlTLE9BQU8sR0FBR0E7SUFFdEJDLE9BQU9DLElBQUksQ0FBQ1osS0FBS2EsT0FBTyxDQUFDQyxDQUFBQTtRQUN4QmIsV0FBVyxDQUFDYSxJQUFJLEdBQUdkLEdBQUcsQ0FBQ2MsSUFBSTtJQUM1QjtJQUVBOztDQUVBLEdBRUFiLFlBQVljLEtBQUssR0FBRyxFQUFFO0lBQ3RCZCxZQUFZZSxLQUFLLEdBQUcsRUFBRTtJQUV0Qjs7OztDQUlBLEdBQ0FmLFlBQVlnQixVQUFVLEdBQUcsQ0FBQztJQUUxQjs7Ozs7Q0FLQSxHQUNBLFNBQVNDLFlBQVlDLFNBQVM7UUFDN0IsSUFBSUMsT0FBTztRQUVYLElBQUssSUFBSUMsSUFBSSxHQUFHQSxJQUFJRixVQUFVRyxNQUFNLEVBQUVELElBQUs7WUFDMUNELE9BQU8sQ0FBRUEsUUFBUSxLQUFLQSxPQUFRRCxVQUFVSSxVQUFVLENBQUNGO1lBQ25ERCxRQUFRLEdBQUcsMkJBQTJCO1FBQ3ZDO1FBRUEsT0FBT25CLFlBQVl1QixNQUFNLENBQUNDLEtBQUtDLEdBQUcsQ0FBQ04sUUFBUW5CLFlBQVl1QixNQUFNLENBQUNGLE1BQU0sQ0FBQztJQUN0RTtJQUNBckIsWUFBWWlCLFdBQVcsR0FBR0E7SUFFMUI7Ozs7OztDQU1BLEdBQ0EsU0FBU2pCLFlBQVlrQixTQUFTO1FBQzdCLElBQUlRO1FB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QU1sRSxZQUFZZSxLQUFLLENBQUNNLE1BQU0sRUFBRUQsSUFBSThDLEtBQUs5QyxJQUFLO1lBQ3pELElBQUlwQixZQUFZZSxLQUFLLENBQUNLLEVBQUUsQ0FBQ3NELElBQUksQ0FBQ0QsT0FBTztnQkFDcEMsT0FBTztZQUNSO1FBQ0Q7UUFFQSxJQUFLckQsSUFBSSxHQUFHOEMsTUFBTWxFLFlBQVljLEtBQUssQ0FBQ08sTUFBTSxFQUFFRCxJQUFJOEMsS0FBSzlDLElBQUs7WUFDekQsSUFBSXBCLFlBQVljLEtBQUssQ0FBQ00sRUFBRSxDQUFDc0QsSUFBSSxDQUFDRCxPQUFPO2dCQUNwQyxPQUFPO1lBQ1I7UUFDRDtRQUVBLE9BQU87SUFDUjtJQUVBOzs7Ozs7Q0FNQSxHQUNBLFNBQVNGLFlBQVlJLE1BQU07UUFDMUIsT0FBT0EsT0FBT0MsUUFBUSxHQUNwQkMsU0FBUyxDQUFDLEdBQUdGLE9BQU9DLFFBQVEsR0FBR3ZELE1BQU0sR0FBRyxHQUN4Q21CLE9BQU8sQ0FBQyxXQUFXO0lBQ3RCO0lBRUE7Ozs7OztDQU1BLEdBQ0EsU0FBU3JDLE9BQU95QyxHQUFHO1FBQ2xCLElBQUlBLGVBQWVrQyxPQUFPO1lBQ3pCLE9BQU9sQyxJQUFJbUMsS0FBSyxJQUFJbkMsSUFBSW9DLE9BQU87UUFDaEM7UUFDQSxPQUFPcEM7SUFDUjtJQUVBOzs7Q0FHQSxHQUNBLFNBQVNuQztRQUNSd0UsUUFBUUMsSUFBSSxDQUFDO0lBQ2Q7SUFFQWxGLFlBQVlLLE1BQU0sQ0FBQ0wsWUFBWW1GLElBQUk7SUFFbkMsT0FBT25GO0FBQ1I7QUFFQW9GLE9BQU9DLE9BQU8sR0FBR3ZGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZXhhbXJvc2gvLi9ub2RlX21vZHVsZXMvc29ja2V0LmlvL25vZGVfbW9kdWxlcy9kZWJ1Zy9zcmMvY29tbW9uLmpzPzZjZjIiXSwic291cmNlc0NvbnRlbnQiOlsiXG4vKipcbiAqIFRoaXMgaXMgdGhlIGNvbW1vbiBsb2dpYyBmb3IgYm90aCB0aGUgTm9kZS5qcyBhbmQgd2ViIGJyb3dzZXJcbiAqIGltcGxlbWVudGF0aW9ucyBvZiBgZGVidWcoKWAuXG4gKi9cblxuZnVuY3Rpb24gc2V0dXAoZW52KSB7XG5cdGNyZWF0ZURlYnVnLmRlYnVnID0gY3JlYXRlRGVidWc7XG5cdGNyZWF0ZURlYnVnLmRlZmF1bHQgPSBjcmVhdGVEZWJ1Zztcblx0Y3JlYXRlRGVidWcuY29lcmNlID0gY29lcmNlO1xuXHRjcmVhdGVEZWJ1Zy5kaXNhYmxlID0gZGlzYWJsZTtcblx0Y3JlYXRlRGVidWcuZW5hYmxlID0gZW5hYmxlO1xuXHRjcmVhdGVEZWJ1Zy5lbmFibGVkID0gZW5hYmxlZDtcblx0Y3JlYXRlRGVidWcuaHVtYW5pemUgPSByZXF1aXJlKCdtcycpO1xuXHRjcmVhdGVEZWJ1Zy5kZXN0cm95ID0gZGVzdHJveTtcblxuXHRPYmplY3Qua2V5cyhlbnYpLmZvckVhY2goa2V5ID0+IHtcblx0XHRjcmVhdGVEZWJ1Z1trZXldID0gZW52W2tleV07XG5cdH0pO1xuXG5cdC8qKlxuXHQqIFRoZSBjdXJyZW50bHkgYWN0aXZlIGRlYnVnIG1vZGUgbmFtZXMsIGFuZCBuYW1lcyB0byBza2lwLlxuXHQqL1xuXG5cdGNyZWF0ZURlYnVnLm5hbWVzID0gW107XG5cdGNyZWF0ZURlYnVnLnNraXBzID0gW107XG5cblx0LyoqXG5cdCogTWFwIG9mIHNwZWNpYWwgXCIlblwiIGhhbmRsaW5nIGZ1bmN0aW9ucywgZm9yIHRoZSBkZWJ1ZyBcImZvcm1hdFwiIGFyZ3VtZW50LlxuXHQqXG5cdCogVmFsaWQga2V5IG5hbWVzIGFyZSBhIHNpbmdsZSwgbG93ZXIgb3IgdXBwZXItY2FzZSBsZXR0ZXIsIGkuZS4gXCJuXCIgYW5kIFwiTlwiLlxuXHQqL1xuXHRjcmVhdGVEZWJ1Zy5mb3JtYXR0ZXJzID0ge307XG5cblx0LyoqXG5cdCogU2VsZWN0cyBhIGNvbG9yIGZvciBhIGRlYnVnIG5hbWVzcGFjZVxuXHQqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2UgVGhlIG5hbWVzcGFjZSBzdHJpbmcgZm9yIHRoZSBkZWJ1ZyBpbnN0YW5jZSB0byBiZSBjb2xvcmVkXG5cdCogQHJldHVybiB7TnVtYmVyfFN0cmluZ30gQW4gQU5TSSBjb2xvciBjb2RlIGZvciB0aGUgZ2l2ZW4gbmFtZXNwYWNlXG5cdCogQGFwaSBwcml2YXRlXG5cdCovXG5cdGZ1bmN0aW9uIHNlbGVjdENvbG9yKG5hbWVzcGFjZSkge1xuXHRcdGxldCBoYXNoID0gMDtcblxuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgbmFtZXNwYWNlLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRoYXNoID0gKChoYXNoIDw8IDUpIC0gaGFzaCkgKyBuYW1lc3BhY2UuY2hhckNvZGVBdChpKTtcblx0XHRcdGhhc2ggfD0gMDsgLy8gQ29udmVydCB0byAzMmJpdCBpbnRlZ2VyXG5cdFx0fVxuXG5cdFx0cmV0dXJuIGNyZWF0ZURlYnVnLmNvbG9yc1tNYXRoLmFicyhoYXNoKSAlIGNyZWF0ZURlYnVnLmNvbG9ycy5sZW5ndGhdO1xuXHR9XG5cdGNyZWF0ZURlYnVnLnNlbGVjdENvbG9yID0gc2VsZWN0Q29sb3I7XG5cblx0LyoqXG5cdCogQ3JlYXRlIGEgZGVidWdnZXIgd2l0aCB0aGUgZ2l2ZW4gYG5hbWVzcGFjZWAuXG5cdCpcblx0KiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlXG5cdCogQHJldHVybiB7RnVuY3Rpb259XG5cdCogQGFwaSBwdWJsaWNcblx0Ki9cblx0ZnVuY3Rpb24gY3JlYXRlRGVidWcobmFtZXNwYWNlKSB7XG5cdFx0bGV0IHByZXZUaW1lO1xuXHRcdGxldCBlbmFibGVPdmVycmlkZSA9IG51bGw7XG5cdFx0bGV0IG5hbWVzcGFjZXNDYWNoZTtcblx0XHRsZXQgZW5hYmxlZENhY2hlO1xuXG5cdFx0ZnVuY3Rpb24gZGVidWcoLi4uYXJncykge1xuXHRcdFx0Ly8gRGlzYWJsZWQ/XG5cdFx0XHRpZiAoIWRlYnVnLmVuYWJsZWQpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCBzZWxmID0gZGVidWc7XG5cblx0XHRcdC8vIFNldCBgZGlmZmAgdGltZXN0YW1wXG5cdFx0XHRjb25zdCBjdXJyID0gTnVtYmVyKG5ldyBEYXRlKCkpO1xuXHRcdFx0Y29uc3QgbXMgPSBjdXJyIC0gKHByZXZUaW1lIHx8IGN1cnIpO1xuXHRcdFx0c2VsZi5kaWZmID0gbXM7XG5cdFx0XHRzZWxmLnByZXYgPSBwcmV2VGltZTtcblx0XHRcdHNlbGYuY3VyciA9IGN1cnI7XG5cdFx0XHRwcmV2VGltZSA9IGN1cnI7XG5cblx0XHRcdGFyZ3NbMF0gPSBjcmVhdGVEZWJ1Zy5jb2VyY2UoYXJnc1swXSk7XG5cblx0XHRcdGlmICh0eXBlb2YgYXJnc1swXSAhPT0gJ3N0cmluZycpIHtcblx0XHRcdFx0Ly8gQW55dGhpbmcgZWxzZSBsZXQncyBpbnNwZWN0IHdpdGggJU9cblx0XHRcdFx0YXJncy51bnNoaWZ0KCclTycpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBBcHBseSBhbnkgYGZvcm1hdHRlcnNgIHRyYW5zZm9ybWF0aW9uc1xuXHRcdFx0bGV0IGluZGV4ID0gMDtcblx0XHRcdGFyZ3NbMF0gPSBhcmdzWzBdLnJlcGxhY2UoLyUoW2EtekEtWiVdKS9nLCAobWF0Y2gsIGZvcm1hdCkgPT4ge1xuXHRcdFx0XHQvLyBJZiB3ZSBlbmNvdW50ZXIgYW4gZXNjYXBlZCAlIHRoZW4gZG9uJ3QgaW5jcmVhc2UgdGhlIGFycmF5IGluZGV4XG5cdFx0XHRcdGlmIChtYXRjaCA9PT0gJyUlJykge1xuXHRcdFx0XHRcdHJldHVybiAnJSc7XG5cdFx0XHRcdH1cblx0XHRcdFx0aW5kZXgrKztcblx0XHRcdFx0Y29uc3QgZm9ybWF0dGVyID0gY3JlYXRlRGVidWcuZm9ybWF0dGVyc1tmb3JtYXRdO1xuXHRcdFx0XHRpZiAodHlwZW9mIGZvcm1hdHRlciA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0XHRcdGNvbnN0IHZhbCA9IGFyZ3NbaW5kZXhdO1xuXHRcdFx0XHRcdG1hdGNoID0gZm9ybWF0dGVyLmNhbGwoc2VsZiwgdmFsKTtcblxuXHRcdFx0XHRcdC8vIE5vdyB3ZSBuZWVkIHRvIHJlbW92ZSBgYXJnc1tpbmRleF1gIHNpbmNlIGl0J3MgaW5saW5lZCBpbiB0aGUgYGZvcm1hdGBcblx0XHRcdFx0XHRhcmdzLnNwbGljZShpbmRleCwgMSk7XG5cdFx0XHRcdFx0aW5kZXgtLTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gbWF0Y2g7XG5cdFx0XHR9KTtcblxuXHRcdFx0Ly8gQXBwbHkgZW52LXNwZWNpZmljIGZvcm1hdHRpbmcgKGNvbG9ycywgZXRjLilcblx0XHRcdGNyZWF0ZURlYnVnLmZvcm1hdEFyZ3MuY2FsbChzZWxmLCBhcmdzKTtcblxuXHRcdFx0Y29uc3QgbG9nRm4gPSBzZWxmLmxvZyB8fCBjcmVhdGVEZWJ1Zy5sb2c7XG5cdFx0XHRsb2dGbi5hcHBseShzZWxmLCBhcmdzKTtcblx0XHR9XG5cblx0XHRkZWJ1Zy5uYW1lc3BhY2UgPSBuYW1lc3BhY2U7XG5cdFx0ZGVidWcudXNlQ29sb3JzID0gY3JlYXRlRGVidWcudXNlQ29sb3JzKCk7XG5cdFx0ZGVidWcuY29sb3IgPSBjcmVhdGVEZWJ1Zy5zZWxlY3RDb2xvcihuYW1lc3BhY2UpO1xuXHRcdGRlYnVnLmV4dGVuZCA9IGV4dGVuZDtcblx0XHRkZWJ1Zy5kZXN0cm95ID0gY3JlYXRlRGVidWcuZGVzdHJveTsgLy8gWFhYIFRlbXBvcmFyeS4gV2lsbCBiZSByZW1vdmVkIGluIHRoZSBuZXh0IG1ham9yIHJlbGVhc2UuXG5cblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZGVidWcsICdlbmFibGVkJywge1xuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRcdGNvbmZpZ3VyYWJsZTogZmFsc2UsXG5cdFx0XHRnZXQ6ICgpID0+IHtcblx0XHRcdFx0aWYgKGVuYWJsZU92ZXJyaWRlICE9PSBudWxsKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGVuYWJsZU92ZXJyaWRlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChuYW1lc3BhY2VzQ2FjaGUgIT09IGNyZWF0ZURlYnVnLm5hbWVzcGFjZXMpIHtcblx0XHRcdFx0XHRuYW1lc3BhY2VzQ2FjaGUgPSBjcmVhdGVEZWJ1Zy5uYW1lc3BhY2VzO1xuXHRcdFx0XHRcdGVuYWJsZWRDYWNoZSA9IGNyZWF0ZURlYnVnLmVuYWJsZWQobmFtZXNwYWNlKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBlbmFibGVkQ2FjaGU7XG5cdFx0XHR9LFxuXHRcdFx0c2V0OiB2ID0+IHtcblx0XHRcdFx0ZW5hYmxlT3ZlcnJpZGUgPSB2O1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0Ly8gRW52LXNwZWNpZmljIGluaXRpYWxpemF0aW9uIGxvZ2ljIGZvciBkZWJ1ZyBpbnN0YW5jZXNcblx0XHRpZiAodHlwZW9mIGNyZWF0ZURlYnVnLmluaXQgPT09ICdmdW5jdGlvbicpIHtcblx0XHRcdGNyZWF0ZURlYnVnLmluaXQoZGVidWcpO1xuXHRcdH1cblxuXHRcdHJldHVybiBkZWJ1Zztcblx0fVxuXG5cdGZ1bmN0aW9uIGV4dGVuZChuYW1lc3BhY2UsIGRlbGltaXRlcikge1xuXHRcdGNvbnN0IG5ld0RlYnVnID0gY3JlYXRlRGVidWcodGhpcy5uYW1lc3BhY2UgKyAodHlwZW9mIGRlbGltaXRlciA9PT0gJ3VuZGVmaW5lZCcgPyAnOicgOiBkZWxpbWl0ZXIpICsgbmFtZXNwYWNlKTtcblx0XHRuZXdEZWJ1Zy5sb2cgPSB0aGlzLmxvZztcblx0XHRyZXR1cm4gbmV3RGVidWc7XG5cdH1cblxuXHQvKipcblx0KiBFbmFibGVzIGEgZGVidWcgbW9kZSBieSBuYW1lc3BhY2VzLiBUaGlzIGNhbiBpbmNsdWRlIG1vZGVzXG5cdCogc2VwYXJhdGVkIGJ5IGEgY29sb24gYW5kIHdpbGRjYXJkcy5cblx0KlxuXHQqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VzXG5cdCogQGFwaSBwdWJsaWNcblx0Ki9cblx0ZnVuY3Rpb24gZW5hYmxlKG5hbWVzcGFjZXMpIHtcblx0XHRjcmVhdGVEZWJ1Zy5zYXZlKG5hbWVzcGFjZXMpO1xuXHRcdGNyZWF0ZURlYnVnLm5hbWVzcGFjZXMgPSBuYW1lc3BhY2VzO1xuXG5cdFx0Y3JlYXRlRGVidWcubmFtZXMgPSBbXTtcblx0XHRjcmVhdGVEZWJ1Zy5za2lwcyA9IFtdO1xuXG5cdFx0bGV0IGk7XG5cdFx0Y29uc3Qgc3BsaXQgPSAodHlwZW9mIG5hbWVzcGFjZXMgPT09ICdzdHJpbmcnID8gbmFtZXNwYWNlcyA6ICcnKS5zcGxpdCgvW1xccyxdKy8pO1xuXHRcdGNvbnN0IGxlbiA9IHNwbGl0Lmxlbmd0aDtcblxuXHRcdGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0aWYgKCFzcGxpdFtpXSkge1xuXHRcdFx0XHQvLyBpZ25vcmUgZW1wdHkgc3RyaW5nc1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblxuXHRcdFx0bmFtZXNwYWNlcyA9IHNwbGl0W2ldLnJlcGxhY2UoL1xcKi9nLCAnLio/Jyk7XG5cblx0XHRcdGlmIChuYW1lc3BhY2VzWzBdID09PSAnLScpIHtcblx0XHRcdFx0Y3JlYXRlRGVidWcuc2tpcHMucHVzaChuZXcgUmVnRXhwKCdeJyArIG5hbWVzcGFjZXMuc2xpY2UoMSkgKyAnJCcpKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGNyZWF0ZURlYnVnLm5hbWVzLnB1c2gobmV3IFJlZ0V4cCgnXicgKyBuYW1lc3BhY2VzICsgJyQnKSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCogRGlzYWJsZSBkZWJ1ZyBvdXRwdXQuXG5cdCpcblx0KiBAcmV0dXJuIHtTdHJpbmd9IG5hbWVzcGFjZXNcblx0KiBAYXBpIHB1YmxpY1xuXHQqL1xuXHRmdW5jdGlvbiBkaXNhYmxlKCkge1xuXHRcdGNvbnN0IG5hbWVzcGFjZXMgPSBbXG5cdFx0XHQuLi5jcmVhdGVEZWJ1Zy5uYW1lcy5tYXAodG9OYW1lc3BhY2UpLFxuXHRcdFx0Li4uY3JlYXRlRGVidWcuc2tpcHMubWFwKHRvTmFtZXNwYWNlKS5tYXAobmFtZXNwYWNlID0+ICctJyArIG5hbWVzcGFjZSlcblx0XHRdLmpvaW4oJywnKTtcblx0XHRjcmVhdGVEZWJ1Zy5lbmFibGUoJycpO1xuXHRcdHJldHVybiBuYW1lc3BhY2VzO1xuXHR9XG5cblx0LyoqXG5cdCogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBtb2RlIG5hbWUgaXMgZW5hYmxlZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuXHQqXG5cdCogQHBhcmFtIHtTdHJpbmd9IG5hbWVcblx0KiBAcmV0dXJuIHtCb29sZWFufVxuXHQqIEBhcGkgcHVibGljXG5cdCovXG5cdGZ1bmN0aW9uIGVuYWJsZWQobmFtZSkge1xuXHRcdGlmIChuYW1lW25hbWUubGVuZ3RoIC0gMV0gPT09ICcqJykge1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXG5cdFx0bGV0IGk7XG5cdFx0bGV0IGxlbjtcblxuXHRcdGZvciAoaSA9IDAsIGxlbiA9IGNyZWF0ZURlYnVnLnNraXBzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRpZiAoY3JlYXRlRGVidWcuc2tpcHNbaV0udGVzdChuYW1lKSkge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Zm9yIChpID0gMCwgbGVuID0gY3JlYXRlRGVidWcubmFtZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdGlmIChjcmVhdGVEZWJ1Zy5uYW1lc1tpXS50ZXN0KG5hbWUpKSB7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdC8qKlxuXHQqIENvbnZlcnQgcmVnZXhwIHRvIG5hbWVzcGFjZVxuXHQqXG5cdCogQHBhcmFtIHtSZWdFeHB9IHJlZ3hlcFxuXHQqIEByZXR1cm4ge1N0cmluZ30gbmFtZXNwYWNlXG5cdCogQGFwaSBwcml2YXRlXG5cdCovXG5cdGZ1bmN0aW9uIHRvTmFtZXNwYWNlKHJlZ2V4cCkge1xuXHRcdHJldHVybiByZWdleHAudG9TdHJpbmcoKVxuXHRcdFx0LnN1YnN0cmluZygyLCByZWdleHAudG9TdHJpbmcoKS5sZW5ndGggLSAyKVxuXHRcdFx0LnJlcGxhY2UoL1xcLlxcKlxcPyQvLCAnKicpO1xuXHR9XG5cblx0LyoqXG5cdCogQ29lcmNlIGB2YWxgLlxuXHQqXG5cdCogQHBhcmFtIHtNaXhlZH0gdmFsXG5cdCogQHJldHVybiB7TWl4ZWR9XG5cdCogQGFwaSBwcml2YXRlXG5cdCovXG5cdGZ1bmN0aW9uIGNvZXJjZSh2YWwpIHtcblx0XHRpZiAodmFsIGluc3RhbmNlb2YgRXJyb3IpIHtcblx0XHRcdHJldHVybiB2YWwuc3RhY2sgfHwgdmFsLm1lc3NhZ2U7XG5cdFx0fVxuXHRcdHJldHVybiB2YWw7XG5cdH1cblxuXHQvKipcblx0KiBYWFggRE8gTk9UIFVTRS4gVGhpcyBpcyBhIHRlbXBvcmFyeSBzdHViIGZ1bmN0aW9uLlxuXHQqIFhYWCBJdCBXSUxMIGJlIHJlbW92ZWQgaW4gdGhlIG5leHQgbWFqb3IgcmVsZWFzZS5cblx0Ki9cblx0ZnVuY3Rpb24gZGVzdHJveSgpIHtcblx0XHRjb25zb2xlLndhcm4oJ0luc3RhbmNlIG1ldGhvZCBgZGVidWcuZGVzdHJveSgpYCBpcyBkZXByZWNhdGVkIGFuZCBubyBsb25nZXIgZG9lcyBhbnl0aGluZy4gSXQgd2lsbCBiZSByZW1vdmVkIGluIHRoZSBuZXh0IG1ham9yIHZlcnNpb24gb2YgYGRlYnVnYC4nKTtcblx0fVxuXG5cdGNyZWF0ZURlYnVnLmVuYWJsZShjcmVhdGVEZWJ1Zy5sb2FkKCkpO1xuXG5cdHJldHVybiBjcmVhdGVEZWJ1Zztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzZXR1cDtcbiJdLCJuYW1lcyI6WyJzZXR1cCIsImVudiIsImNyZWF0ZURlYnVnIiwiZGVidWciLCJkZWZhdWx0IiwiY29lcmNlIiwiZGlzYWJsZSIsImVuYWJsZSIsImVuYWJsZWQiLCJodW1hbml6ZSIsInJlcXVpcmUiLCJkZXN0cm95IiwiT2JqZWN0Iiwia2V5cyIsImZvckVhY2giLCJrZXkiLCJuYW1lcyIsInNraXBzIiwiZm9ybWF0dGVycyIsInNlbGVjdENvbG9yIiwibmFtZXNwYWNlIiwiaGFzaCIsImkiLCJsZW5ndGgiLCJjaGFyQ29kZUF0IiwiY29sb3JzIiwiTWF0aCIsImFicyIsInByZXZUaW1lIiwiZW5hYmxlT3ZlcnJpZGUiLCJuYW1lc3BhY2VzQ2FjaGUiLCJlbmFibGVkQ2FjaGUiLCJhcmdzIiwic2VsZiIsImN1cnIiLCJOdW1iZXIiLCJEYXRlIiwibXMiLCJkaWZmIiwicHJldiIsInVuc2hpZnQiLCJpbmRleCIsInJlcGxhY2UiLCJtYXRjaCIsImZvcm1hdCIsImZvcm1hdHRlciIsInZhbCIsImNhbGwiLCJzcGxpY2UiLCJmb3JtYXRBcmdzIiwibG9nRm4iLCJsb2ciLCJhcHBseSIsInVzZUNvbG9ycyIsImNvbG9yIiwiZXh0ZW5kIiwiZGVmaW5lUHJvcGVydHkiLCJlbnVtZXJhYmxlIiwiY29uZmlndXJhYmxlIiwiZ2V0IiwibmFtZXNwYWNlcyIsInNldCIsInYiLCJpbml0IiwiZGVsaW1pdGVyIiwibmV3RGVidWciLCJzYXZlIiwic3BsaXQiLCJsZW4iLCJwdXNoIiwiUmVnRXhwIiwic2xpY2UiLCJtYXAiLCJ0b05hbWVzcGFjZSIsImpvaW4iLCJuYW1lIiwidGVzdCIsInJlZ2V4cCIsInRvU3RyaW5nIiwic3Vic3RyaW5nIiwiRXJyb3IiLCJzdGFjayIsIm1lc3NhZ2UiLCJjb25zb2xlIiwid2FybiIsImxvYWQiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/socket.io/node_modules/debug/src/common.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/socket.io/node_modules/debug/src/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/socket.io/node_modules/debug/src/index.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * Detect Electron renderer / nwjs process, which is node, but we should\n * treat as a browser.\n */ \nif (typeof process === \"undefined\" || process.type === \"renderer\" || false === true || process.__nwjs) {\n    module.exports = __webpack_require__(/*! ./browser.js */ \"(rsc)/./node_modules/socket.io/node_modules/debug/src/browser.js\");\n} else {\n    module.exports = __webpack_require__(/*! ./node.js */ \"(rsc)/./node_modules/socket.io/node_modules/debug/src/node.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc29ja2V0LmlvL25vZGVfbW9kdWxlcy9kZWJ1Zy9zcmMvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQUE7OztDQUdDO0FBRUQsSUFBSSxPQUFPQSxZQUFZLGVBQWVBLFFBQVFDLElBQUksS0FBSyxjQUFjRCxLQUFlLEtBQUssUUFBUUEsUUFBUUcsTUFBTSxFQUFFO0lBQ2hIQyw0SEFBeUI7QUFDMUIsT0FBTztJQUNOQSxzSEFBeUI7QUFDMUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9leGFtcm9zaC8uL25vZGVfbW9kdWxlcy9zb2NrZXQuaW8vbm9kZV9tb2R1bGVzL2RlYnVnL3NyYy9pbmRleC5qcz9iMDAxIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogRGV0ZWN0IEVsZWN0cm9uIHJlbmRlcmVyIC8gbndqcyBwcm9jZXNzLCB3aGljaCBpcyBub2RlLCBidXQgd2Ugc2hvdWxkXG4gKiB0cmVhdCBhcyBhIGJyb3dzZXIuXG4gKi9cblxuaWYgKHR5cGVvZiBwcm9jZXNzID09PSAndW5kZWZpbmVkJyB8fCBwcm9jZXNzLnR5cGUgPT09ICdyZW5kZXJlcicgfHwgcHJvY2Vzcy5icm93c2VyID09PSB0cnVlIHx8IHByb2Nlc3MuX19ud2pzKSB7XG5cdG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9icm93c2VyLmpzJyk7XG59IGVsc2Uge1xuXHRtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbm9kZS5qcycpO1xufVxuIl0sIm5hbWVzIjpbInByb2Nlc3MiLCJ0eXBlIiwiYnJvd3NlciIsIl9fbndqcyIsIm1vZHVsZSIsImV4cG9ydHMiLCJyZXF1aXJlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/socket.io/node_modules/debug/src/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/socket.io/node_modules/debug/src/node.js":
/*!***************************************************************!*\
  !*** ./node_modules/socket.io/node_modules/debug/src/node.js ***!
  \***************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("/**\n * Module dependencies.\n */ \nconst tty = __webpack_require__(/*! tty */ \"tty\");\nconst util = __webpack_require__(/*! util */ \"util\");\n/**\n * This is the Node.js implementation of `debug()`.\n */ exports.init = init;\nexports.log = log;\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\nexports.destroy = util.deprecate(()=>{}, \"Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.\");\n/**\n * Colors.\n */ exports.colors = [\n    6,\n    2,\n    3,\n    4,\n    5,\n    1\n];\ntry {\n    // Optional dependency (as in, doesn't need to be installed, NOT like optionalDependencies in package.json)\n    // eslint-disable-next-line import/no-extraneous-dependencies\n    const supportsColor = __webpack_require__(/*! supports-color */ \"(rsc)/./node_modules/supports-color/index.js\");\n    if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {\n        exports.colors = [\n            20,\n            21,\n            26,\n            27,\n            32,\n            33,\n            38,\n            39,\n            40,\n            41,\n            42,\n            43,\n            44,\n            45,\n            56,\n            57,\n            62,\n            63,\n            68,\n            69,\n            74,\n            75,\n            76,\n            77,\n            78,\n            79,\n            80,\n            81,\n            92,\n            93,\n            98,\n            99,\n            112,\n            113,\n            128,\n            129,\n            134,\n            135,\n            148,\n            149,\n            160,\n            161,\n            162,\n            163,\n            164,\n            165,\n            166,\n            167,\n            168,\n            169,\n            170,\n            171,\n            172,\n            173,\n            178,\n            179,\n            184,\n            185,\n            196,\n            197,\n            198,\n            199,\n            200,\n            201,\n            202,\n            203,\n            204,\n            205,\n            206,\n            207,\n            208,\n            209,\n            214,\n            215,\n            220,\n            221\n        ];\n    }\n} catch (error) {\n// Swallow - we only care if `supports-color` is available; it doesn't have to be.\n}\n/**\n * Build up the default `inspectOpts` object from the environment variables.\n *\n *   $ DEBUG_COLORS=no DEBUG_DEPTH=10 DEBUG_SHOW_HIDDEN=enabled node script.js\n */ exports.inspectOpts = Object.keys(process.env).filter((key)=>{\n    return /^debug_/i.test(key);\n}).reduce((obj, key)=>{\n    // Camel-case\n    const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_, k)=>{\n        return k.toUpperCase();\n    });\n    // Coerce string value into JS value\n    let val = process.env[key];\n    if (/^(yes|on|true|enabled)$/i.test(val)) {\n        val = true;\n    } else if (/^(no|off|false|disabled)$/i.test(val)) {\n        val = false;\n    } else if (val === \"null\") {\n        val = null;\n    } else {\n        val = Number(val);\n    }\n    obj[prop] = val;\n    return obj;\n}, {});\n/**\n * Is stdout a TTY? Colored output is enabled when `true`.\n */ function useColors() {\n    return \"colors\" in exports.inspectOpts ? Boolean(exports.inspectOpts.colors) : tty.isatty(process.stderr.fd);\n}\n/**\n * Adds ANSI color escape codes if enabled.\n *\n * @api public\n */ function formatArgs(args) {\n    const { namespace: name, useColors } = this;\n    if (useColors) {\n        const c = this.color;\n        const colorCode = \"\\x1b[3\" + (c < 8 ? c : \"8;5;\" + c);\n        const prefix = `  ${colorCode};1m${name} \\u001B[0m`;\n        args[0] = prefix + args[0].split(\"\\n\").join(\"\\n\" + prefix);\n        args.push(colorCode + \"m+\" + module.exports.humanize(this.diff) + \"\\x1b[0m\");\n    } else {\n        args[0] = getDate() + name + \" \" + args[0];\n    }\n}\nfunction getDate() {\n    if (exports.inspectOpts.hideDate) {\n        return \"\";\n    }\n    return new Date().toISOString() + \" \";\n}\n/**\n * Invokes `util.formatWithOptions()` with the specified arguments and writes to stderr.\n */ function log(...args) {\n    return process.stderr.write(util.formatWithOptions(exports.inspectOpts, ...args) + \"\\n\");\n}\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */ function save(namespaces) {\n    if (namespaces) {\n        process.env.DEBUG = namespaces;\n    } else {\n        // If you set a process.env field to null or undefined, it gets cast to the\n        // string 'null' or 'undefined'. Just delete instead.\n        delete process.env.DEBUG;\n    }\n}\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */ function load() {\n    return process.env.DEBUG;\n}\n/**\n * Init logic for `debug` instances.\n *\n * Create a new `inspectOpts` object in case `useColors` is set\n * differently for a particular `debug` instance.\n */ function init(debug) {\n    debug.inspectOpts = {};\n    const keys = Object.keys(exports.inspectOpts);\n    for(let i = 0; i < keys.length; i++){\n        debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];\n    }\n}\nmodule.exports = __webpack_require__(/*! ./common */ \"(rsc)/./node_modules/socket.io/node_modules/debug/src/common.js\")(exports);\nconst { formatters } = module.exports;\n/**\n * Map %o to `util.inspect()`, all on a single line.\n */ formatters.o = function(v) {\n    this.inspectOpts.colors = this.useColors;\n    return util.inspect(v, this.inspectOpts).split(\"\\n\").map((str)=>str.trim()).join(\" \");\n};\n/**\n * Map %O to `util.inspect()`, allowing multiple lines if needed.\n */ formatters.O = function(v) {\n    this.inspectOpts.colors = this.useColors;\n    return util.inspect(v, this.inspectOpts);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc29ja2V0LmlvL25vZGVfbW9kdWxlcy9kZWJ1Zy9zcmMvbm9kZS5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7Q0FFQztBQUVELE1BQU1BLE1BQU1DLG1CQUFPQSxDQUFDO0FBQ3BCLE1BQU1DLE9BQU9ELG1CQUFPQSxDQUFDO0FBRXJCOztDQUVDLEdBRURFLFlBQVksR0FBR0M7QUFDZkQsV0FBVyxHQUFHRTtBQUNkRixrQkFBa0IsR0FBR0c7QUFDckJILFlBQVksR0FBR0k7QUFDZkosWUFBWSxHQUFHSztBQUNmTCxpQkFBaUIsR0FBR007QUFDcEJOLGVBQWUsR0FBR0QsS0FBS1MsU0FBUyxDQUMvQixLQUFPLEdBQ1A7QUFHRDs7Q0FFQyxHQUVEUixjQUFjLEdBQUc7SUFBQztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7Q0FBRTtBQUVuQyxJQUFJO0lBQ0gsMkdBQTJHO0lBQzNHLDZEQUE2RDtJQUM3RCxNQUFNVSxnQkFBZ0JaLG1CQUFPQSxDQUFDO0lBRTlCLElBQUlZLGlCQUFpQixDQUFDQSxjQUFjQyxNQUFNLElBQUlELGFBQVksRUFBR0UsS0FBSyxJQUFJLEdBQUc7UUFDeEVaLGNBQWMsR0FBRztZQUNoQjtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZQUNB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QUFXLEdBQUcsQ0FBQztJQUVyQixNQUFNRSxPQUFPRCxPQUFPQyxJQUFJLENBQUNoQixRQUFRYyxXQUFXO0lBQzVDLElBQUssSUFBSTRDLElBQUksR0FBR0EsSUFBSTFDLEtBQUsyQyxNQUFNLEVBQUVELElBQUs7UUFDckNELE1BQU0zQyxXQUFXLENBQUNFLElBQUksQ0FBQzBDLEVBQUUsQ0FBQyxHQUFHMUQsUUFBUWMsV0FBVyxDQUFDRSxJQUFJLENBQUMwQyxFQUFFLENBQUM7SUFDMUQ7QUFDRDtBQUVBWixPQUFPOUMsT0FBTyxHQUFHRixtQkFBT0EsQ0FBQyxtRkFBWUU7QUFFckMsTUFBTSxFQUFDNEQsVUFBVSxFQUFDLEdBQUdkLE9BQU85QyxPQUFPO0FBRW5DOztDQUVDLEdBRUQ0RCxXQUFXQyxDQUFDLEdBQUcsU0FBVUMsQ0FBQztJQUN6QixJQUFJLENBQUNoRCxXQUFXLENBQUNMLE1BQU0sR0FBRyxJQUFJLENBQUNILFNBQVM7SUFDeEMsT0FBT1AsS0FBS2dFLE9BQU8sQ0FBQ0QsR0FBRyxJQUFJLENBQUNoRCxXQUFXLEVBQ3JDNkIsS0FBSyxDQUFDLE1BQ05xQixHQUFHLENBQUNDLENBQUFBLE1BQU9BLElBQUlDLElBQUksSUFDbkJ0QixJQUFJLENBQUM7QUFDUjtBQUVBOztDQUVDLEdBRURnQixXQUFXTyxDQUFDLEdBQUcsU0FBVUwsQ0FBQztJQUN6QixJQUFJLENBQUNoRCxXQUFXLENBQUNMLE1BQU0sR0FBRyxJQUFJLENBQUNILFNBQVM7SUFDeEMsT0FBT1AsS0FBS2dFLE9BQU8sQ0FBQ0QsR0FBRyxJQUFJLENBQUNoRCxXQUFXO0FBQ3hDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZXhhbXJvc2gvLi9ub2RlX21vZHVsZXMvc29ja2V0LmlvL25vZGVfbW9kdWxlcy9kZWJ1Zy9zcmMvbm9kZS5qcz8xNTI3Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG5jb25zdCB0dHkgPSByZXF1aXJlKCd0dHknKTtcbmNvbnN0IHV0aWwgPSByZXF1aXJlKCd1dGlsJyk7XG5cbi8qKlxuICogVGhpcyBpcyB0aGUgTm9kZS5qcyBpbXBsZW1lbnRhdGlvbiBvZiBgZGVidWcoKWAuXG4gKi9cblxuZXhwb3J0cy5pbml0ID0gaW5pdDtcbmV4cG9ydHMubG9nID0gbG9nO1xuZXhwb3J0cy5mb3JtYXRBcmdzID0gZm9ybWF0QXJncztcbmV4cG9ydHMuc2F2ZSA9IHNhdmU7XG5leHBvcnRzLmxvYWQgPSBsb2FkO1xuZXhwb3J0cy51c2VDb2xvcnMgPSB1c2VDb2xvcnM7XG5leHBvcnRzLmRlc3Ryb3kgPSB1dGlsLmRlcHJlY2F0ZShcblx0KCkgPT4ge30sXG5cdCdJbnN0YW5jZSBtZXRob2QgYGRlYnVnLmRlc3Ryb3koKWAgaXMgZGVwcmVjYXRlZCBhbmQgbm8gbG9uZ2VyIGRvZXMgYW55dGhpbmcuIEl0IHdpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgbmV4dCBtYWpvciB2ZXJzaW9uIG9mIGBkZWJ1Z2AuJ1xuKTtcblxuLyoqXG4gKiBDb2xvcnMuXG4gKi9cblxuZXhwb3J0cy5jb2xvcnMgPSBbNiwgMiwgMywgNCwgNSwgMV07XG5cbnRyeSB7XG5cdC8vIE9wdGlvbmFsIGRlcGVuZGVuY3kgKGFzIGluLCBkb2Vzbid0IG5lZWQgdG8gYmUgaW5zdGFsbGVkLCBOT1QgbGlrZSBvcHRpb25hbERlcGVuZGVuY2llcyBpbiBwYWNrYWdlLmpzb24pXG5cdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tZXh0cmFuZW91cy1kZXBlbmRlbmNpZXNcblx0Y29uc3Qgc3VwcG9ydHNDb2xvciA9IHJlcXVpcmUoJ3N1cHBvcnRzLWNvbG9yJyk7XG5cblx0aWYgKHN1cHBvcnRzQ29sb3IgJiYgKHN1cHBvcnRzQ29sb3Iuc3RkZXJyIHx8IHN1cHBvcnRzQ29sb3IpLmxldmVsID49IDIpIHtcblx0XHRleHBvcnRzLmNvbG9ycyA9IFtcblx0XHRcdDIwLFxuXHRcdFx0MjEsXG5cdFx0XHQyNixcblx0XHRcdDI3LFxuXHRcdFx0MzIsXG5cdFx0XHQzMyxcblx0XHRcdDM4LFxuXHRcdFx0MzksXG5cdFx0XHQ0MCxcblx0XHRcdDQxLFxuXHRcdFx0NDIsXG5cdFx0XHQ0Myxcblx0XHRcdDQ0LFxuXHRcdFx0NDUsXG5cdFx0XHQ1Nixcblx0XHRcdDU3LFxuXHRcdFx0NjIsXG5cdFx0XHQ2Myxcblx0XHRcdDY4LFxuXHRcdFx0NjksXG5cdFx0XHQ3NCxcblx0XHRcdDc1LFxuXHRcdFx0NzYsXG5cdFx0XHQ3Nyxcblx0XHRcdDc4LFxuXHRcdFx0NzksXG5cdFx0XHQ4MCxcblx0XHRcdDgxLFxuXHRcdFx0OTIsXG5cdFx0XHQ5Myxcblx0XHRcdDk4LFxuXHRcdFx0OTksXG5cdFx0XHQxMTIsXG5cdFx0XHQxMTMsXG5cdFx0XHQxMjgsXG5cdFx0XHQxMjksXG5cdFx0XHQxMzQsXG5cdFx0XHQxMzUsXG5cdFx0XHQxNDgsXG5cdFx0XHQxNDksXG5cdFx0XHQxNjAsXG5cdFx0XHQxNjEsXG5cdFx0XHQxNjIsXG5cdFx0XHQxNjMsXG5cdFx0XHQxNjQsXG5cdFx0XHQxNjUsXG5cdFx0XHQxNjYsXG5cdFx0XHQxNjcsXG5cdFx0XHQxNjgsXG5cdFx0XHQxNjksXG5cdFx0XHQxNzAsXG5cdFx0XHQxNzEsXG5cdFx0XHQxNzIsXG5cdFx0XHQxNzMsXG5cdFx0XHQxNzgsXG5cdFx0XHQxNzksXG5cdFx0XHQxODQsXG5cdFx0XHQxODUsXG5cdFx0XHQxOTYsXG5cdFx0XHQxOTcsXG5cdFx0XHQxOTgsXG5cdFx0XHQxOTksXG5cdFx0XHQyMDAsXG5cdFx0XHQyMDEsXG5cdFx0XHQyMDIsXG5cdFx0XHQyMDMsXG5cdFx0XHQyMDQsXG5cdFx0XHQyMDUsXG5cdFx0XHQyMDYsXG5cdFx0XHQyMDcsXG5cdFx0XHQyMDgsXG5cdFx0XHQyMDksXG5cdFx0XHQyMTQsXG5cdFx0XHQyMTUsXG5cdFx0XHQyMjAsXG5cdFx0XHQyMjFcblx0XHRdO1xuXHR9XG59IGNhdGNoIChlcnJvcikge1xuXHQvLyBTd2FsbG93IC0gd2Ugb25seSBjYXJlIGlmIGBzdXBwb3J0cy1jb2xvcmAgaXMgYXZhaWxhYmxlOyBpdCBkb2Vzbid0IGhhdmUgdG8gYmUuXG59XG5cbi8qKlxuICogQnVpbGQgdXAgdGhlIGRlZmF1bHQgYGluc3BlY3RPcHRzYCBvYmplY3QgZnJvbSB0aGUgZW52aXJvbm1lbnQgdmFyaWFibGVzLlxuICpcbiAqICAgJCBERUJVR19DT0xPUlM9bm8gREVCVUdfREVQVEg9MTAgREVCVUdfU0hPV19ISURERU49ZW5hYmxlZCBub2RlIHNjcmlwdC5qc1xuICovXG5cbmV4cG9ydHMuaW5zcGVjdE9wdHMgPSBPYmplY3Qua2V5cyhwcm9jZXNzLmVudikuZmlsdGVyKGtleSA9PiB7XG5cdHJldHVybiAvXmRlYnVnXy9pLnRlc3Qoa2V5KTtcbn0pLnJlZHVjZSgob2JqLCBrZXkpID0+IHtcblx0Ly8gQ2FtZWwtY2FzZVxuXHRjb25zdCBwcm9wID0ga2V5XG5cdFx0LnN1YnN0cmluZyg2KVxuXHRcdC50b0xvd2VyQ2FzZSgpXG5cdFx0LnJlcGxhY2UoL18oW2Etel0pL2csIChfLCBrKSA9PiB7XG5cdFx0XHRyZXR1cm4gay50b1VwcGVyQ2FzZSgpO1xuXHRcdH0pO1xuXG5cdC8vIENvZXJjZSBzdHJpbmcgdmFsdWUgaW50byBKUyB2YWx1ZVxuXHRsZXQgdmFsID0gcHJvY2Vzcy5lbnZba2V5XTtcblx0aWYgKC9eKHllc3xvbnx0cnVlfGVuYWJsZWQpJC9pLnRlc3QodmFsKSkge1xuXHRcdHZhbCA9IHRydWU7XG5cdH0gZWxzZSBpZiAoL14obm98b2ZmfGZhbHNlfGRpc2FibGVkKSQvaS50ZXN0KHZhbCkpIHtcblx0XHR2YWwgPSBmYWxzZTtcblx0fSBlbHNlIGlmICh2YWwgPT09ICdudWxsJykge1xuXHRcdHZhbCA9IG51bGw7XG5cdH0gZWxzZSB7XG5cdFx0dmFsID0gTnVtYmVyKHZhbCk7XG5cdH1cblxuXHRvYmpbcHJvcF0gPSB2YWw7XG5cdHJldHVybiBvYmo7XG59LCB7fSk7XG5cbi8qKlxuICogSXMgc3Rkb3V0IGEgVFRZPyBDb2xvcmVkIG91dHB1dCBpcyBlbmFibGVkIHdoZW4gYHRydWVgLlxuICovXG5cbmZ1bmN0aW9uIHVzZUNvbG9ycygpIHtcblx0cmV0dXJuICdjb2xvcnMnIGluIGV4cG9ydHMuaW5zcGVjdE9wdHMgP1xuXHRcdEJvb2xlYW4oZXhwb3J0cy5pbnNwZWN0T3B0cy5jb2xvcnMpIDpcblx0XHR0dHkuaXNhdHR5KHByb2Nlc3Muc3RkZXJyLmZkKTtcbn1cblxuLyoqXG4gKiBBZGRzIEFOU0kgY29sb3IgZXNjYXBlIGNvZGVzIGlmIGVuYWJsZWQuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBmb3JtYXRBcmdzKGFyZ3MpIHtcblx0Y29uc3Qge25hbWVzcGFjZTogbmFtZSwgdXNlQ29sb3JzfSA9IHRoaXM7XG5cblx0aWYgKHVzZUNvbG9ycykge1xuXHRcdGNvbnN0IGMgPSB0aGlzLmNvbG9yO1xuXHRcdGNvbnN0IGNvbG9yQ29kZSA9ICdcXHUwMDFCWzMnICsgKGMgPCA4ID8gYyA6ICc4OzU7JyArIGMpO1xuXHRcdGNvbnN0IHByZWZpeCA9IGAgICR7Y29sb3JDb2RlfTsxbSR7bmFtZX0gXFx1MDAxQlswbWA7XG5cblx0XHRhcmdzWzBdID0gcHJlZml4ICsgYXJnc1swXS5zcGxpdCgnXFxuJykuam9pbignXFxuJyArIHByZWZpeCk7XG5cdFx0YXJncy5wdXNoKGNvbG9yQ29kZSArICdtKycgKyBtb2R1bGUuZXhwb3J0cy5odW1hbml6ZSh0aGlzLmRpZmYpICsgJ1xcdTAwMUJbMG0nKTtcblx0fSBlbHNlIHtcblx0XHRhcmdzWzBdID0gZ2V0RGF0ZSgpICsgbmFtZSArICcgJyArIGFyZ3NbMF07XG5cdH1cbn1cblxuZnVuY3Rpb24gZ2V0RGF0ZSgpIHtcblx0aWYgKGV4cG9ydHMuaW5zcGVjdE9wdHMuaGlkZURhdGUpIHtcblx0XHRyZXR1cm4gJyc7XG5cdH1cblx0cmV0dXJuIG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSArICcgJztcbn1cblxuLyoqXG4gKiBJbnZva2VzIGB1dGlsLmZvcm1hdFdpdGhPcHRpb25zKClgIHdpdGggdGhlIHNwZWNpZmllZCBhcmd1bWVudHMgYW5kIHdyaXRlcyB0byBzdGRlcnIuXG4gKi9cblxuZnVuY3Rpb24gbG9nKC4uLmFyZ3MpIHtcblx0cmV0dXJuIHByb2Nlc3Muc3RkZXJyLndyaXRlKHV0aWwuZm9ybWF0V2l0aE9wdGlvbnMoZXhwb3J0cy5pbnNwZWN0T3B0cywgLi4uYXJncykgKyAnXFxuJyk7XG59XG5cbi8qKlxuICogU2F2ZSBgbmFtZXNwYWNlc2AuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZXNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBzYXZlKG5hbWVzcGFjZXMpIHtcblx0aWYgKG5hbWVzcGFjZXMpIHtcblx0XHRwcm9jZXNzLmVudi5ERUJVRyA9IG5hbWVzcGFjZXM7XG5cdH0gZWxzZSB7XG5cdFx0Ly8gSWYgeW91IHNldCBhIHByb2Nlc3MuZW52IGZpZWxkIHRvIG51bGwgb3IgdW5kZWZpbmVkLCBpdCBnZXRzIGNhc3QgdG8gdGhlXG5cdFx0Ly8gc3RyaW5nICdudWxsJyBvciAndW5kZWZpbmVkJy4gSnVzdCBkZWxldGUgaW5zdGVhZC5cblx0XHRkZWxldGUgcHJvY2Vzcy5lbnYuREVCVUc7XG5cdH1cbn1cblxuLyoqXG4gKiBMb2FkIGBuYW1lc3BhY2VzYC5cbiAqXG4gKiBAcmV0dXJuIHtTdHJpbmd9IHJldHVybnMgdGhlIHByZXZpb3VzbHkgcGVyc2lzdGVkIGRlYnVnIG1vZGVzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBsb2FkKCkge1xuXHRyZXR1cm4gcHJvY2Vzcy5lbnYuREVCVUc7XG59XG5cbi8qKlxuICogSW5pdCBsb2dpYyBmb3IgYGRlYnVnYCBpbnN0YW5jZXMuXG4gKlxuICogQ3JlYXRlIGEgbmV3IGBpbnNwZWN0T3B0c2Agb2JqZWN0IGluIGNhc2UgYHVzZUNvbG9yc2AgaXMgc2V0XG4gKiBkaWZmZXJlbnRseSBmb3IgYSBwYXJ0aWN1bGFyIGBkZWJ1Z2AgaW5zdGFuY2UuXG4gKi9cblxuZnVuY3Rpb24gaW5pdChkZWJ1Zykge1xuXHRkZWJ1Zy5pbnNwZWN0T3B0cyA9IHt9O1xuXG5cdGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhleHBvcnRzLmluc3BlY3RPcHRzKTtcblx0Zm9yIChsZXQgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG5cdFx0ZGVidWcuaW5zcGVjdE9wdHNba2V5c1tpXV0gPSBleHBvcnRzLmluc3BlY3RPcHRzW2tleXNbaV1dO1xuXHR9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9jb21tb24nKShleHBvcnRzKTtcblxuY29uc3Qge2Zvcm1hdHRlcnN9ID0gbW9kdWxlLmV4cG9ydHM7XG5cbi8qKlxuICogTWFwICVvIHRvIGB1dGlsLmluc3BlY3QoKWAsIGFsbCBvbiBhIHNpbmdsZSBsaW5lLlxuICovXG5cbmZvcm1hdHRlcnMubyA9IGZ1bmN0aW9uICh2KSB7XG5cdHRoaXMuaW5zcGVjdE9wdHMuY29sb3JzID0gdGhpcy51c2VDb2xvcnM7XG5cdHJldHVybiB1dGlsLmluc3BlY3QodiwgdGhpcy5pbnNwZWN0T3B0cylcblx0XHQuc3BsaXQoJ1xcbicpXG5cdFx0Lm1hcChzdHIgPT4gc3RyLnRyaW0oKSlcblx0XHQuam9pbignICcpO1xufTtcblxuLyoqXG4gKiBNYXAgJU8gdG8gYHV0aWwuaW5zcGVjdCgpYCwgYWxsb3dpbmcgbXVsdGlwbGUgbGluZXMgaWYgbmVlZGVkLlxuICovXG5cbmZvcm1hdHRlcnMuTyA9IGZ1bmN0aW9uICh2KSB7XG5cdHRoaXMuaW5zcGVjdE9wdHMuY29sb3JzID0gdGhpcy51c2VDb2xvcnM7XG5cdHJldHVybiB1dGlsLmluc3BlY3QodiwgdGhpcy5pbnNwZWN0T3B0cyk7XG59O1xuIl0sIm5hbWVzIjpbInR0eSIsInJlcXVpcmUiLCJ1dGlsIiwiZXhwb3J0cyIsImluaXQiLCJsb2ciLCJmb3JtYXRBcmdzIiwic2F2ZSIsImxvYWQiLCJ1c2VDb2xvcnMiLCJkZXN0cm95IiwiZGVwcmVjYXRlIiwiY29sb3JzIiwic3VwcG9ydHNDb2xvciIsInN0ZGVyciIsImxldmVsIiwiZXJyb3IiLCJpbnNwZWN0T3B0cyIsIk9iamVjdCIsImtleXMiLCJwcm9jZXNzIiwiZW52IiwiZmlsdGVyIiwia2V5IiwidGVzdCIsInJlZHVjZSIsIm9iaiIsInByb3AiLCJzdWJzdHJpbmciLCJ0b0xvd2VyQ2FzZSIsInJlcGxhY2UiLCJfIiwiayIsInRvVXBwZXJDYXNlIiwidmFsIiwiTnVtYmVyIiwiQm9vbGVhbiIsImlzYXR0eSIsImZkIiwiYXJncyIsIm5hbWVzcGFjZSIsIm5hbWUiLCJjIiwiY29sb3IiLCJjb2xvckNvZGUiLCJwcmVmaXgiLCJzcGxpdCIsImpvaW4iLCJwdXNoIiwibW9kdWxlIiwiaHVtYW5pemUiLCJkaWZmIiwiZ2V0RGF0ZSIsImhpZGVEYXRlIiwiRGF0ZSIsInRvSVNPU3RyaW5nIiwid3JpdGUiLCJmb3JtYXRXaXRoT3B0aW9ucyIsIm5hbWVzcGFjZXMiLCJERUJVRyIsImRlYnVnIiwiaSIsImxlbmd0aCIsImZvcm1hdHRlcnMiLCJvIiwidiIsImluc3BlY3QiLCJtYXAiLCJzdHIiLCJ0cmltIiwiTyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/socket.io/node_modules/debug/src/node.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/socket.io/dist/broadcast-operator.js":
/*!***********************************************************!*\
  !*** ./node_modules/socket.io/dist/broadcast-operator.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.RemoteSocket = exports.BroadcastOperator = void 0;\nconst socket_types_1 = __webpack_require__(/*! ./socket-types */ \"(rsc)/./node_modules/socket.io/dist/socket-types.js\");\nconst socket_io_parser_1 = __webpack_require__(/*! socket.io-parser */ \"(rsc)/./node_modules/socket.io-parser/build/cjs/index.js\");\nclass BroadcastOperator {\n    constructor(adapter, rooms = new Set(), exceptRooms = new Set(), flags = {}){\n        this.adapter = adapter;\n        this.rooms = rooms;\n        this.exceptRooms = exceptRooms;\n        this.flags = flags;\n    }\n    /**\n     * Targets a room when emitting.\n     *\n     * @example\n     * // the foo event will be broadcast to all connected clients in the room-101 room\n     * io.to(\"room-101\").emit(\"foo\", \"bar\");\n     *\n     * // with an array of rooms (a client will be notified at most once)\n     * io.to([\"room-101\", \"room-102\"]).emit(\"foo\", \"bar\");\n     *\n     * // with multiple chained calls\n     * io.to(\"room-101\").to(\"room-102\").emit(\"foo\", \"bar\");\n     *\n     * @param room - a room, or an array of rooms\n     * @return a new {@link BroadcastOperator} instance for chaining\n     */ to(room) {\n        const rooms = new Set(this.rooms);\n        if (Array.isArray(room)) {\n            room.forEach((r)=>rooms.add(r));\n        } else {\n            rooms.add(room);\n        }\n        return new BroadcastOperator(this.adapter, rooms, this.exceptRooms, this.flags);\n    }\n    /**\n     * Targets a room when emitting. Similar to `to()`, but might feel clearer in some cases:\n     *\n     * @example\n     * // disconnect all clients in the \"room-101\" room\n     * io.in(\"room-101\").disconnectSockets();\n     *\n     * @param room - a room, or an array of rooms\n     * @return a new {@link BroadcastOperator} instance for chaining\n     */ in(room) {\n        return this.to(room);\n    }\n    /**\n     * Excludes a room when emitting.\n     *\n     * @example\n     * // the \"foo\" event will be broadcast to all connected clients, except the ones that are in the \"room-101\" room\n     * io.except(\"room-101\").emit(\"foo\", \"bar\");\n     *\n     * // with an array of rooms\n     * io.except([\"room-101\", \"room-102\"]).emit(\"foo\", \"bar\");\n     *\n     * // with multiple chained calls\n     * io.except(\"room-101\").except(\"room-102\").emit(\"foo\", \"bar\");\n     *\n     * @param room - a room, or an array of rooms\n     * @return a new {@link BroadcastOperator} instance for chaining\n     */ except(room) {\n        const exceptRooms = new Set(this.exceptRooms);\n        if (Array.isArray(room)) {\n            room.forEach((r)=>exceptRooms.add(r));\n        } else {\n            exceptRooms.add(room);\n        }\n        return new BroadcastOperator(this.adapter, this.rooms, exceptRooms, this.flags);\n    }\n    /**\n     * Sets the compress flag.\n     *\n     * @example\n     * io.compress(false).emit(\"hello\");\n     *\n     * @param compress - if `true`, compresses the sending data\n     * @return a new BroadcastOperator instance\n     */ compress(compress) {\n        const flags = Object.assign({}, this.flags, {\n            compress\n        });\n        return new BroadcastOperator(this.adapter, this.rooms, this.exceptRooms, flags);\n    }\n    /**\n     * Sets a modifier for a subsequent event emission that the event data may be lost if the client is not ready to\n     * receive messages (because of network slowness or other issues, or because theyre connected through long polling\n     * and is in the middle of a request-response cycle).\n     *\n     * @example\n     * io.volatile.emit(\"hello\"); // the clients may or may not receive it\n     *\n     * @return a new BroadcastOperator instance\n     */ get volatile() {\n        const flags = Object.assign({}, this.flags, {\n            volatile: true\n        });\n        return new BroadcastOperator(this.adapter, this.rooms, this.exceptRooms, flags);\n    }\n    /**\n     * Sets a modifier for a subsequent event emission that the event data will only be broadcast to the current node.\n     *\n     * @example\n     * // the foo event will be broadcast to all connected clients on this node\n     * io.local.emit(\"foo\", \"bar\");\n     *\n     * @return a new {@link BroadcastOperator} instance for chaining\n     */ get local() {\n        const flags = Object.assign({}, this.flags, {\n            local: true\n        });\n        return new BroadcastOperator(this.adapter, this.rooms, this.exceptRooms, flags);\n    }\n    /**\n     * Adds a timeout in milliseconds for the next operation\n     *\n     * @example\n     * io.timeout(1000).emit(\"some-event\", (err, responses) => {\n     *   if (err) {\n     *     // some clients did not acknowledge the event in the given delay\n     *   } else {\n     *     console.log(responses); // one response per client\n     *   }\n     * });\n     *\n     * @param timeout\n     */ timeout(timeout) {\n        const flags = Object.assign({}, this.flags, {\n            timeout\n        });\n        return new BroadcastOperator(this.adapter, this.rooms, this.exceptRooms, flags);\n    }\n    /**\n     * Emits to all clients.\n     *\n     * @example\n     * // the foo event will be broadcast to all connected clients\n     * io.emit(\"foo\", \"bar\");\n     *\n     * // the foo event will be broadcast to all connected clients in the room-101 room\n     * io.to(\"room-101\").emit(\"foo\", \"bar\");\n     *\n     * // with an acknowledgement expected from all connected clients\n     * io.timeout(1000).emit(\"some-event\", (err, responses) => {\n     *   if (err) {\n     *     // some clients did not acknowledge the event in the given delay\n     *   } else {\n     *     console.log(responses); // one response per client\n     *   }\n     * });\n     *\n     * @return Always true\n     */ emit(ev, ...args) {\n        if (socket_types_1.RESERVED_EVENTS.has(ev)) {\n            throw new Error(`\"${String(ev)}\" is a reserved event name`);\n        }\n        // set up packet object\n        const data = [\n            ev,\n            ...args\n        ];\n        const packet = {\n            type: socket_io_parser_1.PacketType.EVENT,\n            data: data\n        };\n        const withAck = typeof data[data.length - 1] === \"function\";\n        if (!withAck) {\n            this.adapter.broadcast(packet, {\n                rooms: this.rooms,\n                except: this.exceptRooms,\n                flags: this.flags\n            });\n            return true;\n        }\n        const ack = data.pop();\n        let timedOut = false;\n        let responses = [];\n        const timer = setTimeout(()=>{\n            timedOut = true;\n            ack.apply(this, [\n                new Error(\"operation has timed out\"),\n                this.flags.expectSingleResponse ? null : responses\n            ]);\n        }, this.flags.timeout);\n        let expectedServerCount = -1;\n        let actualServerCount = 0;\n        let expectedClientCount = 0;\n        const checkCompleteness = ()=>{\n            if (!timedOut && expectedServerCount === actualServerCount && responses.length === expectedClientCount) {\n                clearTimeout(timer);\n                ack.apply(this, [\n                    null,\n                    this.flags.expectSingleResponse ? responses[0] : responses\n                ]);\n            }\n        };\n        this.adapter.broadcastWithAck(packet, {\n            rooms: this.rooms,\n            except: this.exceptRooms,\n            flags: this.flags\n        }, (clientCount)=>{\n            // each Socket.IO server in the cluster sends the number of clients that were notified\n            expectedClientCount += clientCount;\n            actualServerCount++;\n            checkCompleteness();\n        }, (clientResponse)=>{\n            // each client sends an acknowledgement\n            responses.push(clientResponse);\n            checkCompleteness();\n        });\n        this.adapter.serverCount().then((serverCount)=>{\n            expectedServerCount = serverCount;\n            checkCompleteness();\n        });\n        return true;\n    }\n    /**\n     * Emits an event and waits for an acknowledgement from all clients.\n     *\n     * @example\n     * try {\n     *   const responses = await io.timeout(1000).emitWithAck(\"some-event\");\n     *   console.log(responses); // one response per client\n     * } catch (e) {\n     *   // some clients did not acknowledge the event in the given delay\n     * }\n     *\n     * @return a Promise that will be fulfilled when all clients have acknowledged the event\n     */ emitWithAck(ev, ...args) {\n        return new Promise((resolve, reject)=>{\n            args.push((err, responses)=>{\n                if (err) {\n                    err.responses = responses;\n                    return reject(err);\n                } else {\n                    return resolve(responses);\n                }\n            });\n            this.emit(ev, ...args);\n        });\n    }\n    /**\n     * Gets a list of clients.\n     *\n     * @deprecated this method will be removed in the next major release, please use {@link Server#serverSideEmit} or\n     * {@link fetchSockets} instead.\n     */ allSockets() {\n        if (!this.adapter) {\n            throw new Error(\"No adapter for this namespace, are you trying to get the list of clients of a dynamic namespace?\");\n        }\n        return this.adapter.sockets(this.rooms);\n    }\n    /**\n     * Returns the matching socket instances. This method works across a cluster of several Socket.IO servers.\n     *\n     * Note: this method also works within a cluster of multiple Socket.IO servers, with a compatible {@link Adapter}.\n     *\n     * @example\n     * // return all Socket instances\n     * const sockets = await io.fetchSockets();\n     *\n     * // return all Socket instances in the \"room1\" room\n     * const sockets = await io.in(\"room1\").fetchSockets();\n     *\n     * for (const socket of sockets) {\n     *   console.log(socket.id);\n     *   console.log(socket.handshake);\n     *   console.log(socket.rooms);\n     *   console.log(socket.data);\n     *\n     *   socket.emit(\"hello\");\n     *   socket.join(\"room1\");\n     *   socket.leave(\"room2\");\n     *   socket.disconnect();\n     * }\n     */ fetchSockets() {\n        return this.adapter.fetchSockets({\n            rooms: this.rooms,\n            except: this.exceptRooms,\n            flags: this.flags\n        }).then((sockets)=>{\n            return sockets.map((socket)=>{\n                if (socket.server) {\n                    return socket; // local instance\n                } else {\n                    return new RemoteSocket(this.adapter, socket);\n                }\n            });\n        });\n    }\n    /**\n     * Makes the matching socket instances join the specified rooms.\n     *\n     * Note: this method also works within a cluster of multiple Socket.IO servers, with a compatible {@link Adapter}.\n     *\n     * @example\n     *\n     * // make all socket instances join the \"room1\" room\n     * io.socketsJoin(\"room1\");\n     *\n     * // make all socket instances in the \"room1\" room join the \"room2\" and \"room3\" rooms\n     * io.in(\"room1\").socketsJoin([\"room2\", \"room3\"]);\n     *\n     * @param room - a room, or an array of rooms\n     */ socketsJoin(room) {\n        this.adapter.addSockets({\n            rooms: this.rooms,\n            except: this.exceptRooms,\n            flags: this.flags\n        }, Array.isArray(room) ? room : [\n            room\n        ]);\n    }\n    /**\n     * Makes the matching socket instances leave the specified rooms.\n     *\n     * Note: this method also works within a cluster of multiple Socket.IO servers, with a compatible {@link Adapter}.\n     *\n     * @example\n     * // make all socket instances leave the \"room1\" room\n     * io.socketsLeave(\"room1\");\n     *\n     * // make all socket instances in the \"room1\" room leave the \"room2\" and \"room3\" rooms\n     * io.in(\"room1\").socketsLeave([\"room2\", \"room3\"]);\n     *\n     * @param room - a room, or an array of rooms\n     */ socketsLeave(room) {\n        this.adapter.delSockets({\n            rooms: this.rooms,\n            except: this.exceptRooms,\n            flags: this.flags\n        }, Array.isArray(room) ? room : [\n            room\n        ]);\n    }\n    /**\n     * Makes the matching socket instances disconnect.\n     *\n     * Note: this method also works within a cluster of multiple Socket.IO servers, with a compatible {@link Adapter}.\n     *\n     * @example\n     * // make all socket instances disconnect (the connections might be kept alive for other namespaces)\n     * io.disconnectSockets();\n     *\n     * // make all socket instances in the \"room1\" room disconnect and close the underlying connections\n     * io.in(\"room1\").disconnectSockets(true);\n     *\n     * @param close - whether to close the underlying connection\n     */ disconnectSockets(close = false) {\n        this.adapter.disconnectSockets({\n            rooms: this.rooms,\n            except: this.exceptRooms,\n            flags: this.flags\n        }, close);\n    }\n}\nexports.BroadcastOperator = BroadcastOperator;\n/**\n * Expose of subset of the attributes and methods of the Socket class\n */ class RemoteSocket {\n    constructor(adapter, details){\n        this.id = details.id;\n        this.handshake = details.handshake;\n        this.rooms = new Set(details.rooms);\n        this.data = details.data;\n        this.operator = new BroadcastOperator(adapter, new Set([\n            this.id\n        ]), new Set(), {\n            expectSingleResponse: true\n        });\n    }\n    /**\n     * Adds a timeout in milliseconds for the next operation.\n     *\n     * @example\n     * const sockets = await io.fetchSockets();\n     *\n     * for (const socket of sockets) {\n     *   if (someCondition) {\n     *     socket.timeout(1000).emit(\"some-event\", (err) => {\n     *       if (err) {\n     *         // the client did not acknowledge the event in the given delay\n     *       }\n     *     });\n     *   }\n     * }\n     *\n     * // note: if possible, using a room instead of looping over all sockets is preferable\n     * io.timeout(1000).to(someConditionRoom).emit(\"some-event\", (err, responses) => {\n     *   // ...\n     * });\n     *\n     * @param timeout\n     */ timeout(timeout) {\n        return this.operator.timeout(timeout);\n    }\n    emit(ev, ...args) {\n        return this.operator.emit(ev, ...args);\n    }\n    /**\n     * Joins a room.\n     *\n     * @param {String|Array} room - room or array of rooms\n     */ join(room) {\n        return this.operator.socketsJoin(room);\n    }\n    /**\n     * Leaves a room.\n     *\n     * @param {String} room\n     */ leave(room) {\n        return this.operator.socketsLeave(room);\n    }\n    /**\n     * Disconnects this client.\n     *\n     * @param {Boolean} close - if `true`, closes the underlying connection\n     * @return {Socket} self\n     */ disconnect(close = false) {\n        this.operator.disconnectSockets(close);\n        return this;\n    }\n}\nexports.RemoteSocket = RemoteSocket;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc29ja2V0LmlvL2Rpc3QvYnJvYWRjYXN0LW9wZXJhdG9yLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxvQkFBb0IsR0FBR0EseUJBQXlCLEdBQUcsS0FBSztBQUN4RCxNQUFNSSxpQkFBaUJDLG1CQUFPQSxDQUFDLDJFQUFnQjtBQUMvQyxNQUFNQyxxQkFBcUJELG1CQUFPQSxDQUFDLGtGQUFrQjtBQUNyRCxNQUFNRjtJQUNGSSxZQUFZQyxPQUFPLEVBQUVDLFFBQVEsSUFBSUMsS0FBSyxFQUFFQyxjQUFjLElBQUlELEtBQUssRUFBRUUsUUFBUSxDQUFDLENBQUMsQ0FBRTtRQUN6RSxJQUFJLENBQUNKLE9BQU8sR0FBR0E7UUFDZixJQUFJLENBQUNDLEtBQUssR0FBR0E7UUFDYixJQUFJLENBQUNFLFdBQVcsR0FBR0E7UUFDbkIsSUFBSSxDQUFDQyxLQUFLLEdBQUdBO0lBQ2pCO0lBQ0E7Ozs7Ozs7Ozs7Ozs7OztLQWVDLEdBQ0RDLEdBQUdDLElBQUksRUFBRTtRQUNMLE1BQU1MLFFBQVEsSUFBSUMsSUFBSSxJQUFJLENBQUNELEtBQUs7UUFDaEMsSUFBSU0sTUFBTUMsT0FBTyxDQUFDRixPQUFPO1lBQ3JCQSxLQUFLRyxPQUFPLENBQUMsQ0FBQ0MsSUFBTVQsTUFBTVUsR0FBRyxDQUFDRDtRQUNsQyxPQUNLO1lBQ0RULE1BQU1VLEdBQUcsQ0FBQ0w7UUFDZDtRQUNBLE9BQU8sSUFBSVgsa0JBQWtCLElBQUksQ0FBQ0ssT0FBTyxFQUFFQyxPQUFPLElBQUksQ0FBQ0UsV0FBVyxFQUFFLElBQUksQ0FBQ0MsS0FBSztJQUNsRjtJQUNBOzs7Ozs7Ozs7S0FTQyxHQUNEUSxHQUFHTixJQUFJLEVBQUU7UUFDTCxPQUFPLElBQUksQ0FBQ0QsRUFBRSxDQUFDQztJQUNuQjtJQUNBOzs7Ozs7Ozs7Ozs7Ozs7S0FlQyxHQUNETyxPQUFPUCxJQUFJLEVBQUU7UUFD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UUFDZCxPQUFPLElBQUksQ0FBQ29ELFFBQVEsQ0FBQ3RELElBQUksQ0FBQ0MsT0FBT0M7SUFDckM7SUFDQTs7OztLQUlDLEdBQ0RxRCxLQUFLcEUsSUFBSSxFQUFFO1FBQ1AsT0FBTyxJQUFJLENBQUNtRSxRQUFRLENBQUNULFdBQVcsQ0FBQzFEO0lBQ3JDO0lBQ0E7Ozs7S0FJQyxHQUNEcUUsTUFBTXJFLElBQUksRUFBRTtRQUNSLE9BQU8sSUFBSSxDQUFDbUUsUUFBUSxDQUFDUCxZQUFZLENBQUM1RDtJQUN0QztJQUNBOzs7OztLQUtDLEdBQ0RzRSxXQUFXUCxRQUFRLEtBQUssRUFBRTtRQUN0QixJQUFJLENBQUNJLFFBQVEsQ0FBQ0wsaUJBQWlCLENBQUNDO1FBQ2hDLE9BQU8sSUFBSTtJQUNmO0FBQ0o7QUFDQTdFLG9CQUFvQixHQUFHRSIsInNvdXJjZXMiOlsid2VicGFjazovL2V4YW1yb3NoLy4vbm9kZV9tb2R1bGVzL3NvY2tldC5pby9kaXN0L2Jyb2FkY2FzdC1vcGVyYXRvci5qcz9iYTk3Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5SZW1vdGVTb2NrZXQgPSBleHBvcnRzLkJyb2FkY2FzdE9wZXJhdG9yID0gdm9pZCAwO1xuY29uc3Qgc29ja2V0X3R5cGVzXzEgPSByZXF1aXJlKFwiLi9zb2NrZXQtdHlwZXNcIik7XG5jb25zdCBzb2NrZXRfaW9fcGFyc2VyXzEgPSByZXF1aXJlKFwic29ja2V0LmlvLXBhcnNlclwiKTtcbmNsYXNzIEJyb2FkY2FzdE9wZXJhdG9yIHtcbiAgICBjb25zdHJ1Y3RvcihhZGFwdGVyLCByb29tcyA9IG5ldyBTZXQoKSwgZXhjZXB0Um9vbXMgPSBuZXcgU2V0KCksIGZsYWdzID0ge30pIHtcbiAgICAgICAgdGhpcy5hZGFwdGVyID0gYWRhcHRlcjtcbiAgICAgICAgdGhpcy5yb29tcyA9IHJvb21zO1xuICAgICAgICB0aGlzLmV4Y2VwdFJvb21zID0gZXhjZXB0Um9vbXM7XG4gICAgICAgIHRoaXMuZmxhZ3MgPSBmbGFncztcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGFyZ2V0cyBhIHJvb20gd2hlbiBlbWl0dGluZy5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gdGhlIOKAnGZvb+KAnSBldmVudCB3aWxsIGJlIGJyb2FkY2FzdCB0byBhbGwgY29ubmVjdGVkIGNsaWVudHMgaW4gdGhlIOKAnHJvb20tMTAx4oCdIHJvb21cbiAgICAgKiBpby50byhcInJvb20tMTAxXCIpLmVtaXQoXCJmb29cIiwgXCJiYXJcIik7XG4gICAgICpcbiAgICAgKiAvLyB3aXRoIGFuIGFycmF5IG9mIHJvb21zIChhIGNsaWVudCB3aWxsIGJlIG5vdGlmaWVkIGF0IG1vc3Qgb25jZSlcbiAgICAgKiBpby50byhbXCJyb29tLTEwMVwiLCBcInJvb20tMTAyXCJdKS5lbWl0KFwiZm9vXCIsIFwiYmFyXCIpO1xuICAgICAqXG4gICAgICogLy8gd2l0aCBtdWx0aXBsZSBjaGFpbmVkIGNhbGxzXG4gICAgICogaW8udG8oXCJyb29tLTEwMVwiKS50byhcInJvb20tMTAyXCIpLmVtaXQoXCJmb29cIiwgXCJiYXJcIik7XG4gICAgICpcbiAgICAgKiBAcGFyYW0gcm9vbSAtIGEgcm9vbSwgb3IgYW4gYXJyYXkgb2Ygcm9vbXNcbiAgICAgKiBAcmV0dXJuIGEgbmV3IHtAbGluayBCcm9hZGNhc3RPcGVyYXRvcn0gaW5zdGFuY2UgZm9yIGNoYWluaW5nXG4gICAgICovXG4gICAgdG8ocm9vbSkge1xuICAgICAgICBjb25zdCByb29tcyA9IG5ldyBTZXQodGhpcy5yb29tcyk7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHJvb20pKSB7XG4gICAgICAgICAgICByb29tLmZvckVhY2goKHIpID0+IHJvb21zLmFkZChyKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByb29tcy5hZGQocm9vbSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBCcm9hZGNhc3RPcGVyYXRvcih0aGlzLmFkYXB0ZXIsIHJvb21zLCB0aGlzLmV4Y2VwdFJvb21zLCB0aGlzLmZsYWdzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGFyZ2V0cyBhIHJvb20gd2hlbiBlbWl0dGluZy4gU2ltaWxhciB0byBgdG8oKWAsIGJ1dCBtaWdodCBmZWVsIGNsZWFyZXIgaW4gc29tZSBjYXNlczpcbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gZGlzY29ubmVjdCBhbGwgY2xpZW50cyBpbiB0aGUgXCJyb29tLTEwMVwiIHJvb21cbiAgICAgKiBpby5pbihcInJvb20tMTAxXCIpLmRpc2Nvbm5lY3RTb2NrZXRzKCk7XG4gICAgICpcbiAgICAgKiBAcGFyYW0gcm9vbSAtIGEgcm9vbSwgb3IgYW4gYXJyYXkgb2Ygcm9vbXNcbiAgICAgKiBAcmV0dXJuIGEgbmV3IHtAbGluayBCcm9hZGNhc3RPcGVyYXRvcn0gaW5zdGFuY2UgZm9yIGNoYWluaW5nXG4gICAgICovXG4gICAgaW4ocm9vbSkge1xuICAgICAgICByZXR1cm4gdGhpcy50byhyb29tKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRXhjbHVkZXMgYSByb29tIHdoZW4gZW1pdHRpbmcuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIHRoZSBcImZvb1wiIGV2ZW50IHdpbGwgYmUgYnJvYWRjYXN0IHRvIGFsbCBjb25uZWN0ZWQgY2xpZW50cywgZXhjZXB0IHRoZSBvbmVzIHRoYXQgYXJlIGluIHRoZSBcInJvb20tMTAxXCIgcm9vbVxuICAgICAqIGlvLmV4Y2VwdChcInJvb20tMTAxXCIpLmVtaXQoXCJmb29cIiwgXCJiYXJcIik7XG4gICAgICpcbiAgICAgKiAvLyB3aXRoIGFuIGFycmF5IG9mIHJvb21zXG4gICAgICogaW8uZXhjZXB0KFtcInJvb20tMTAxXCIsIFwicm9vbS0xMDJcIl0pLmVtaXQoXCJmb29cIiwgXCJiYXJcIik7XG4gICAgICpcbiAgICAgKiAvLyB3aXRoIG11bHRpcGxlIGNoYWluZWQgY2FsbHNcbiAgICAgKiBpby5leGNlcHQoXCJyb29tLTEwMVwiKS5leGNlcHQoXCJyb29tLTEwMlwiKS5lbWl0KFwiZm9vXCIsIFwiYmFyXCIpO1xuICAgICAqXG4gICAgICogQHBhcmFtIHJvb20gLSBhIHJvb20sIG9yIGFuIGFycmF5IG9mIHJvb21zXG4gICAgICogQHJldHVybiBhIG5ldyB7QGxpbmsgQnJvYWRjYXN0T3BlcmF0b3J9IGluc3RhbmNlIGZvciBjaGFpbmluZ1xuICAgICAqL1xuICAgIGV4Y2VwdChyb29tKSB7XG4gICAgICAgIGNvbnN0IGV4Y2VwdFJvb21zID0gbmV3IFNldCh0aGlzLmV4Y2VwdFJvb21zKTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocm9vbSkpIHtcbiAgICAgICAgICAgIHJvb20uZm9yRWFjaCgocikgPT4gZXhjZXB0Um9vbXMuYWRkKHIpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGV4Y2VwdFJvb21zLmFkZChyb29tKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IEJyb2FkY2FzdE9wZXJhdG9yKHRoaXMuYWRhcHRlciwgdGhpcy5yb29tcywgZXhjZXB0Um9vbXMsIHRoaXMuZmxhZ3MpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBjb21wcmVzcyBmbGFnLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBpby5jb21wcmVzcyhmYWxzZSkuZW1pdChcImhlbGxvXCIpO1xuICAgICAqXG4gICAgICogQHBhcmFtIGNvbXByZXNzIC0gaWYgYHRydWVgLCBjb21wcmVzc2VzIHRoZSBzZW5kaW5nIGRhdGFcbiAgICAgKiBAcmV0dXJuIGEgbmV3IEJyb2FkY2FzdE9wZXJhdG9yIGluc3RhbmNlXG4gICAgICovXG4gICAgY29tcHJlc3MoY29tcHJlc3MpIHtcbiAgICAgICAgY29uc3QgZmxhZ3MgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLmZsYWdzLCB7IGNvbXByZXNzIH0pO1xuICAgICAgICByZXR1cm4gbmV3IEJyb2FkY2FzdE9wZXJhdG9yKHRoaXMuYWRhcHRlciwgdGhpcy5yb29tcywgdGhpcy5leGNlcHRSb29tcywgZmxhZ3MpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIGEgbW9kaWZpZXIgZm9yIGEgc3Vic2VxdWVudCBldmVudCBlbWlzc2lvbiB0aGF0IHRoZSBldmVudCBkYXRhIG1heSBiZSBsb3N0IGlmIHRoZSBjbGllbnQgaXMgbm90IHJlYWR5IHRvXG4gICAgICogcmVjZWl2ZSBtZXNzYWdlcyAoYmVjYXVzZSBvZiBuZXR3b3JrIHNsb3duZXNzIG9yIG90aGVyIGlzc3Vlcywgb3IgYmVjYXVzZSB0aGV54oCZcmUgY29ubmVjdGVkIHRocm91Z2ggbG9uZyBwb2xsaW5nXG4gICAgICogYW5kIGlzIGluIHRoZSBtaWRkbGUgb2YgYSByZXF1ZXN0LXJlc3BvbnNlIGN5Y2xlKS5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogaW8udm9sYXRpbGUuZW1pdChcImhlbGxvXCIpOyAvLyB0aGUgY2xpZW50cyBtYXkgb3IgbWF5IG5vdCByZWNlaXZlIGl0XG4gICAgICpcbiAgICAgKiBAcmV0dXJuIGEgbmV3IEJyb2FkY2FzdE9wZXJhdG9yIGluc3RhbmNlXG4gICAgICovXG4gICAgZ2V0IHZvbGF0aWxlKCkge1xuICAgICAgICBjb25zdCBmbGFncyA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMuZmxhZ3MsIHsgdm9sYXRpbGU6IHRydWUgfSk7XG4gICAgICAgIHJldHVybiBuZXcgQnJvYWRjYXN0T3BlcmF0b3IodGhpcy5hZGFwdGVyLCB0aGlzLnJvb21zLCB0aGlzLmV4Y2VwdFJvb21zLCBmbGFncyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgYSBtb2RpZmllciBmb3IgYSBzdWJzZXF1ZW50IGV2ZW50IGVtaXNzaW9uIHRoYXQgdGhlIGV2ZW50IGRhdGEgd2lsbCBvbmx5IGJlIGJyb2FkY2FzdCB0byB0aGUgY3VycmVudCBub2RlLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyB0aGUg4oCcZm9v4oCdIGV2ZW50IHdpbGwgYmUgYnJvYWRjYXN0IHRvIGFsbCBjb25uZWN0ZWQgY2xpZW50cyBvbiB0aGlzIG5vZGVcbiAgICAgKiBpby5sb2NhbC5lbWl0KFwiZm9vXCIsIFwiYmFyXCIpO1xuICAgICAqXG4gICAgICogQHJldHVybiBhIG5ldyB7QGxpbmsgQnJvYWRjYXN0T3BlcmF0b3J9IGluc3RhbmNlIGZvciBjaGFpbmluZ1xuICAgICAqL1xuICAgIGdldCBsb2NhbCgpIHtcbiAgICAgICAgY29uc3QgZmxhZ3MgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLmZsYWdzLCB7IGxvY2FsOiB0cnVlIH0pO1xuICAgICAgICByZXR1cm4gbmV3IEJyb2FkY2FzdE9wZXJhdG9yKHRoaXMuYWRhcHRlciwgdGhpcy5yb29tcywgdGhpcy5leGNlcHRSb29tcywgZmxhZ3MpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRzIGEgdGltZW91dCBpbiBtaWxsaXNlY29uZHMgZm9yIHRoZSBuZXh0IG9wZXJhdGlvblxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBpby50aW1lb3V0KDEwMDApLmVtaXQoXCJzb21lLWV2ZW50XCIsIChlcnIsIHJlc3BvbnNlcykgPT4ge1xuICAgICAqICAgaWYgKGVycikge1xuICAgICAqICAgICAvLyBzb21lIGNsaWVudHMgZGlkIG5vdCBhY2tub3dsZWRnZSB0aGUgZXZlbnQgaW4gdGhlIGdpdmVuIGRlbGF5XG4gICAgICogICB9IGVsc2Uge1xuICAgICAqICAgICBjb25zb2xlLmxvZyhyZXNwb25zZXMpOyAvLyBvbmUgcmVzcG9uc2UgcGVyIGNsaWVudFxuICAgICAqICAgfVxuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogQHBhcmFtIHRpbWVvdXRcbiAgICAgKi9cbiAgICB0aW1lb3V0KHRpbWVvdXQpIHtcbiAgICAgICAgY29uc3QgZmxhZ3MgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLmZsYWdzLCB7IHRpbWVvdXQgfSk7XG4gICAgICAgIHJldHVybiBuZXcgQnJvYWRjYXN0T3BlcmF0b3IodGhpcy5hZGFwdGVyLCB0aGlzLnJvb21zLCB0aGlzLmV4Y2VwdFJvb21zLCBmbGFncyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVtaXRzIHRvIGFsbCBjbGllbnRzLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyB0aGUg4oCcZm9v4oCdIGV2ZW50IHdpbGwgYmUgYnJvYWRjYXN0IHRvIGFsbCBjb25uZWN0ZWQgY2xpZW50c1xuICAgICAqIGlvLmVtaXQoXCJmb29cIiwgXCJiYXJcIik7XG4gICAgICpcbiAgICAgKiAvLyB0aGUg4oCcZm9v4oCdIGV2ZW50IHdpbGwgYmUgYnJvYWRjYXN0IHRvIGFsbCBjb25uZWN0ZWQgY2xpZW50cyBpbiB0aGUg4oCccm9vbS0xMDHigJ0gcm9vbVxuICAgICAqIGlvLnRvKFwicm9vbS0xMDFcIikuZW1pdChcImZvb1wiLCBcImJhclwiKTtcbiAgICAgKlxuICAgICAqIC8vIHdpdGggYW4gYWNrbm93bGVkZ2VtZW50IGV4cGVjdGVkIGZyb20gYWxsIGNvbm5lY3RlZCBjbGllbnRzXG4gICAgICogaW8udGltZW91dCgxMDAwKS5lbWl0KFwic29tZS1ldmVudFwiLCAoZXJyLCByZXNwb25zZXMpID0+IHtcbiAgICAgKiAgIGlmIChlcnIpIHtcbiAgICAgKiAgICAgLy8gc29tZSBjbGllbnRzIGRpZCBub3QgYWNrbm93bGVkZ2UgdGhlIGV2ZW50IGluIHRoZSBnaXZlbiBkZWxheVxuICAgICAqICAgfSBlbHNlIHtcbiAgICAgKiAgICAgY29uc29sZS5sb2cocmVzcG9uc2VzKTsgLy8gb25lIHJlc3BvbnNlIHBlciBjbGllbnRcbiAgICAgKiAgIH1cbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIEByZXR1cm4gQWx3YXlzIHRydWVcbiAgICAgKi9cbiAgICBlbWl0KGV2LCAuLi5hcmdzKSB7XG4gICAgICAgIGlmIChzb2NrZXRfdHlwZXNfMS5SRVNFUlZFRF9FVkVOVFMuaGFzKGV2KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBcIiR7U3RyaW5nKGV2KX1cIiBpcyBhIHJlc2VydmVkIGV2ZW50IG5hbWVgKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBzZXQgdXAgcGFja2V0IG9iamVjdFxuICAgICAgICBjb25zdCBkYXRhID0gW2V2LCAuLi5hcmdzXTtcbiAgICAgICAgY29uc3QgcGFja2V0ID0ge1xuICAgICAgICAgICAgdHlwZTogc29ja2V0X2lvX3BhcnNlcl8xLlBhY2tldFR5cGUuRVZFTlQsXG4gICAgICAgICAgICBkYXRhOiBkYXRhLFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCB3aXRoQWNrID0gdHlwZW9mIGRhdGFbZGF0YS5sZW5ndGggLSAxXSA9PT0gXCJmdW5jdGlvblwiO1xuICAgICAgICBpZiAoIXdpdGhBY2spIHtcbiAgICAgICAgICAgIHRoaXMuYWRhcHRlci5icm9hZGNhc3QocGFja2V0LCB7XG4gICAgICAgICAgICAgICAgcm9vbXM6IHRoaXMucm9vbXMsXG4gICAgICAgICAgICAgICAgZXhjZXB0OiB0aGlzLmV4Y2VwdFJvb21zLFxuICAgICAgICAgICAgICAgIGZsYWdzOiB0aGlzLmZsYWdzLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhY2sgPSBkYXRhLnBvcCgpO1xuICAgICAgICBsZXQgdGltZWRPdXQgPSBmYWxzZTtcbiAgICAgICAgbGV0IHJlc3BvbnNlcyA9IFtdO1xuICAgICAgICBjb25zdCB0aW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgdGltZWRPdXQgPSB0cnVlO1xuICAgICAgICAgICAgYWNrLmFwcGx5KHRoaXMsIFtcbiAgICAgICAgICAgICAgICBuZXcgRXJyb3IoXCJvcGVyYXRpb24gaGFzIHRpbWVkIG91dFwiKSxcbiAgICAgICAgICAgICAgICB0aGlzLmZsYWdzLmV4cGVjdFNpbmdsZVJlc3BvbnNlID8gbnVsbCA6IHJlc3BvbnNlcyxcbiAgICAgICAgICAgIF0pO1xuICAgICAgICB9LCB0aGlzLmZsYWdzLnRpbWVvdXQpO1xuICAgICAgICBsZXQgZXhwZWN0ZWRTZXJ2ZXJDb3VudCA9IC0xO1xuICAgICAgICBsZXQgYWN0dWFsU2VydmVyQ291bnQgPSAwO1xuICAgICAgICBsZXQgZXhwZWN0ZWRDbGllbnRDb3VudCA9IDA7XG4gICAgICAgIGNvbnN0IGNoZWNrQ29tcGxldGVuZXNzID0gKCkgPT4ge1xuICAgICAgICAgICAgaWYgKCF0aW1lZE91dCAmJlxuICAgICAgICAgICAgICAgIGV4cGVjdGVkU2VydmVyQ291bnQgPT09IGFjdHVhbFNlcnZlckNvdW50ICYmXG4gICAgICAgICAgICAgICAgcmVzcG9uc2VzLmxlbmd0aCA9PT0gZXhwZWN0ZWRDbGllbnRDb3VudCkge1xuICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lcik7XG4gICAgICAgICAgICAgICAgYWNrLmFwcGx5KHRoaXMsIFtcbiAgICAgICAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5mbGFncy5leHBlY3RTaW5nbGVSZXNwb25zZSA/IHJlc3BvbnNlc1swXSA6IHJlc3BvbnNlcyxcbiAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5hZGFwdGVyLmJyb2FkY2FzdFdpdGhBY2socGFja2V0LCB7XG4gICAgICAgICAgICByb29tczogdGhpcy5yb29tcyxcbiAgICAgICAgICAgIGV4Y2VwdDogdGhpcy5leGNlcHRSb29tcyxcbiAgICAgICAgICAgIGZsYWdzOiB0aGlzLmZsYWdzLFxuICAgICAgICB9LCAoY2xpZW50Q291bnQpID0+IHtcbiAgICAgICAgICAgIC8vIGVhY2ggU29ja2V0LklPIHNlcnZlciBpbiB0aGUgY2x1c3RlciBzZW5kcyB0aGUgbnVtYmVyIG9mIGNsaWVudHMgdGhhdCB3ZXJlIG5vdGlmaWVkXG4gICAgICAgICAgICBleHBlY3RlZENsaWVudENvdW50ICs9IGNsaWVudENvdW50O1xuICAgICAgICAgICAgYWN0dWFsU2VydmVyQ291bnQrKztcbiAgICAgICAgICAgIGNoZWNrQ29tcGxldGVuZXNzKCk7XG4gICAgICAgIH0sIChjbGllbnRSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgLy8gZWFjaCBjbGllbnQgc2VuZHMgYW4gYWNrbm93bGVkZ2VtZW50XG4gICAgICAgICAgICByZXNwb25zZXMucHVzaChjbGllbnRSZXNwb25zZSk7XG4gICAgICAgICAgICBjaGVja0NvbXBsZXRlbmVzcygpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5hZGFwdGVyLnNlcnZlckNvdW50KCkudGhlbigoc2VydmVyQ291bnQpID0+IHtcbiAgICAgICAgICAgIGV4cGVjdGVkU2VydmVyQ291bnQgPSBzZXJ2ZXJDb3VudDtcbiAgICAgICAgICAgIGNoZWNrQ29tcGxldGVuZXNzKCk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRW1pdHMgYW4gZXZlbnQgYW5kIHdhaXRzIGZvciBhbiBhY2tub3dsZWRnZW1lbnQgZnJvbSBhbGwgY2xpZW50cy5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogdHJ5IHtcbiAgICAgKiAgIGNvbnN0IHJlc3BvbnNlcyA9IGF3YWl0IGlvLnRpbWVvdXQoMTAwMCkuZW1pdFdpdGhBY2soXCJzb21lLWV2ZW50XCIpO1xuICAgICAqICAgY29uc29sZS5sb2cocmVzcG9uc2VzKTsgLy8gb25lIHJlc3BvbnNlIHBlciBjbGllbnRcbiAgICAgKiB9IGNhdGNoIChlKSB7XG4gICAgICogICAvLyBzb21lIGNsaWVudHMgZGlkIG5vdCBhY2tub3dsZWRnZSB0aGUgZXZlbnQgaW4gdGhlIGdpdmVuIGRlbGF5XG4gICAgICogfVxuICAgICAqXG4gICAgICogQHJldHVybiBhIFByb21pc2UgdGhhdCB3aWxsIGJlIGZ1bGZpbGxlZCB3aGVuIGFsbCBjbGllbnRzIGhhdmUgYWNrbm93bGVkZ2VkIHRoZSBldmVudFxuICAgICAqL1xuICAgIGVtaXRXaXRoQWNrKGV2LCAuLi5hcmdzKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBhcmdzLnB1c2goKGVyciwgcmVzcG9uc2VzKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICBlcnIucmVzcG9uc2VzID0gcmVzcG9uc2VzO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0KGVycik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZShyZXNwb25zZXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5lbWl0KGV2LCAuLi5hcmdzKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgYSBsaXN0IG9mIGNsaWVudHMuXG4gICAgICpcbiAgICAgKiBAZGVwcmVjYXRlZCB0aGlzIG1ldGhvZCB3aWxsIGJlIHJlbW92ZWQgaW4gdGhlIG5leHQgbWFqb3IgcmVsZWFzZSwgcGxlYXNlIHVzZSB7QGxpbmsgU2VydmVyI3NlcnZlclNpZGVFbWl0fSBvclxuICAgICAqIHtAbGluayBmZXRjaFNvY2tldHN9IGluc3RlYWQuXG4gICAgICovXG4gICAgYWxsU29ja2V0cygpIHtcbiAgICAgICAgaWYgKCF0aGlzLmFkYXB0ZXIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIGFkYXB0ZXIgZm9yIHRoaXMgbmFtZXNwYWNlLCBhcmUgeW91IHRyeWluZyB0byBnZXQgdGhlIGxpc3Qgb2YgY2xpZW50cyBvZiBhIGR5bmFtaWMgbmFtZXNwYWNlP1wiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5hZGFwdGVyLnNvY2tldHModGhpcy5yb29tcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIG1hdGNoaW5nIHNvY2tldCBpbnN0YW5jZXMuIFRoaXMgbWV0aG9kIHdvcmtzIGFjcm9zcyBhIGNsdXN0ZXIgb2Ygc2V2ZXJhbCBTb2NrZXQuSU8gc2VydmVycy5cbiAgICAgKlxuICAgICAqIE5vdGU6IHRoaXMgbWV0aG9kIGFsc28gd29ya3Mgd2l0aGluIGEgY2x1c3RlciBvZiBtdWx0aXBsZSBTb2NrZXQuSU8gc2VydmVycywgd2l0aCBhIGNvbXBhdGlibGUge0BsaW5rIEFkYXB0ZXJ9LlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyByZXR1cm4gYWxsIFNvY2tldCBpbnN0YW5jZXNcbiAgICAgKiBjb25zdCBzb2NrZXRzID0gYXdhaXQgaW8uZmV0Y2hTb2NrZXRzKCk7XG4gICAgICpcbiAgICAgKiAvLyByZXR1cm4gYWxsIFNvY2tldCBpbnN0YW5jZXMgaW4gdGhlIFwicm9vbTFcIiByb29tXG4gICAgICogY29uc3Qgc29ja2V0cyA9IGF3YWl0IGlvLmluKFwicm9vbTFcIikuZmV0Y2hTb2NrZXRzKCk7XG4gICAgICpcbiAgICAgKiBmb3IgKGNvbnN0IHNvY2tldCBvZiBzb2NrZXRzKSB7XG4gICAgICogICBjb25zb2xlLmxvZyhzb2NrZXQuaWQpO1xuICAgICAqICAgY29uc29sZS5sb2coc29ja2V0LmhhbmRzaGFrZSk7XG4gICAgICogICBjb25zb2xlLmxvZyhzb2NrZXQucm9vbXMpO1xuICAgICAqICAgY29uc29sZS5sb2coc29ja2V0LmRhdGEpO1xuICAgICAqXG4gICAgICogICBzb2NrZXQuZW1pdChcImhlbGxvXCIpO1xuICAgICAqICAgc29ja2V0LmpvaW4oXCJyb29tMVwiKTtcbiAgICAgKiAgIHNvY2tldC5sZWF2ZShcInJvb20yXCIpO1xuICAgICAqICAgc29ja2V0LmRpc2Nvbm5lY3QoKTtcbiAgICAgKiB9XG4gICAgICovXG4gICAgZmV0Y2hTb2NrZXRzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hZGFwdGVyXG4gICAgICAgICAgICAuZmV0Y2hTb2NrZXRzKHtcbiAgICAgICAgICAgIHJvb21zOiB0aGlzLnJvb21zLFxuICAgICAgICAgICAgZXhjZXB0OiB0aGlzLmV4Y2VwdFJvb21zLFxuICAgICAgICAgICAgZmxhZ3M6IHRoaXMuZmxhZ3MsXG4gICAgICAgIH0pXG4gICAgICAgICAgICAudGhlbigoc29ja2V0cykgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHNvY2tldHMubWFwKChzb2NrZXQpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoc29ja2V0LnNlcnZlcikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc29ja2V0OyAvLyBsb2NhbCBpbnN0YW5jZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBSZW1vdGVTb2NrZXQodGhpcy5hZGFwdGVyLCBzb2NrZXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWFrZXMgdGhlIG1hdGNoaW5nIHNvY2tldCBpbnN0YW5jZXMgam9pbiB0aGUgc3BlY2lmaWVkIHJvb21zLlxuICAgICAqXG4gICAgICogTm90ZTogdGhpcyBtZXRob2QgYWxzbyB3b3JrcyB3aXRoaW4gYSBjbHVzdGVyIG9mIG11bHRpcGxlIFNvY2tldC5JTyBzZXJ2ZXJzLCB3aXRoIGEgY29tcGF0aWJsZSB7QGxpbmsgQWRhcHRlcn0uXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogLy8gbWFrZSBhbGwgc29ja2V0IGluc3RhbmNlcyBqb2luIHRoZSBcInJvb20xXCIgcm9vbVxuICAgICAqIGlvLnNvY2tldHNKb2luKFwicm9vbTFcIik7XG4gICAgICpcbiAgICAgKiAvLyBtYWtlIGFsbCBzb2NrZXQgaW5zdGFuY2VzIGluIHRoZSBcInJvb20xXCIgcm9vbSBqb2luIHRoZSBcInJvb20yXCIgYW5kIFwicm9vbTNcIiByb29tc1xuICAgICAqIGlvLmluKFwicm9vbTFcIikuc29ja2V0c0pvaW4oW1wicm9vbTJcIiwgXCJyb29tM1wiXSk7XG4gICAgICpcbiAgICAgKiBAcGFyYW0gcm9vbSAtIGEgcm9vbSwgb3IgYW4gYXJyYXkgb2Ygcm9vbXNcbiAgICAgKi9cbiAgICBzb2NrZXRzSm9pbihyb29tKSB7XG4gICAgICAgIHRoaXMuYWRhcHRlci5hZGRTb2NrZXRzKHtcbiAgICAgICAgICAgIHJvb21zOiB0aGlzLnJvb21zLFxuICAgICAgICAgICAgZXhjZXB0OiB0aGlzLmV4Y2VwdFJvb21zLFxuICAgICAgICAgICAgZmxhZ3M6IHRoaXMuZmxhZ3MsXG4gICAgICAgIH0sIEFycmF5LmlzQXJyYXkocm9vbSkgPyByb29tIDogW3Jvb21dKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWFrZXMgdGhlIG1hdGNoaW5nIHNvY2tldCBpbnN0YW5jZXMgbGVhdmUgdGhlIHNwZWNpZmllZCByb29tcy5cbiAgICAgKlxuICAgICAqIE5vdGU6IHRoaXMgbWV0aG9kIGFsc28gd29ya3Mgd2l0aGluIGEgY2x1c3RlciBvZiBtdWx0aXBsZSBTb2NrZXQuSU8gc2VydmVycywgd2l0aCBhIGNvbXBhdGlibGUge0BsaW5rIEFkYXB0ZXJ9LlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBtYWtlIGFsbCBzb2NrZXQgaW5zdGFuY2VzIGxlYXZlIHRoZSBcInJvb20xXCIgcm9vbVxuICAgICAqIGlvLnNvY2tldHNMZWF2ZShcInJvb20xXCIpO1xuICAgICAqXG4gICAgICogLy8gbWFrZSBhbGwgc29ja2V0IGluc3RhbmNlcyBpbiB0aGUgXCJyb29tMVwiIHJvb20gbGVhdmUgdGhlIFwicm9vbTJcIiBhbmQgXCJyb29tM1wiIHJvb21zXG4gICAgICogaW8uaW4oXCJyb29tMVwiKS5zb2NrZXRzTGVhdmUoW1wicm9vbTJcIiwgXCJyb29tM1wiXSk7XG4gICAgICpcbiAgICAgKiBAcGFyYW0gcm9vbSAtIGEgcm9vbSwgb3IgYW4gYXJyYXkgb2Ygcm9vbXNcbiAgICAgKi9cbiAgICBzb2NrZXRzTGVhdmUocm9vbSkge1xuICAgICAgICB0aGlzLmFkYXB0ZXIuZGVsU29ja2V0cyh7XG4gICAgICAgICAgICByb29tczogdGhpcy5yb29tcyxcbiAgICAgICAgICAgIGV4Y2VwdDogdGhpcy5leGNlcHRSb29tcyxcbiAgICAgICAgICAgIGZsYWdzOiB0aGlzLmZsYWdzLFxuICAgICAgICB9LCBBcnJheS5pc0FycmF5KHJvb20pID8gcm9vbSA6IFtyb29tXSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1ha2VzIHRoZSBtYXRjaGluZyBzb2NrZXQgaW5zdGFuY2VzIGRpc2Nvbm5lY3QuXG4gICAgICpcbiAgICAgKiBOb3RlOiB0aGlzIG1ldGhvZCBhbHNvIHdvcmtzIHdpdGhpbiBhIGNsdXN0ZXIgb2YgbXVsdGlwbGUgU29ja2V0LklPIHNlcnZlcnMsIHdpdGggYSBjb21wYXRpYmxlIHtAbGluayBBZGFwdGVyfS5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gbWFrZSBhbGwgc29ja2V0IGluc3RhbmNlcyBkaXNjb25uZWN0ICh0aGUgY29ubmVjdGlvbnMgbWlnaHQgYmUga2VwdCBhbGl2ZSBmb3Igb3RoZXIgbmFtZXNwYWNlcylcbiAgICAgKiBpby5kaXNjb25uZWN0U29ja2V0cygpO1xuICAgICAqXG4gICAgICogLy8gbWFrZSBhbGwgc29ja2V0IGluc3RhbmNlcyBpbiB0aGUgXCJyb29tMVwiIHJvb20gZGlzY29ubmVjdCBhbmQgY2xvc2UgdGhlIHVuZGVybHlpbmcgY29ubmVjdGlvbnNcbiAgICAgKiBpby5pbihcInJvb20xXCIpLmRpc2Nvbm5lY3RTb2NrZXRzKHRydWUpO1xuICAgICAqXG4gICAgICogQHBhcmFtIGNsb3NlIC0gd2hldGhlciB0byBjbG9zZSB0aGUgdW5kZXJseWluZyBjb25uZWN0aW9uXG4gICAgICovXG4gICAgZGlzY29ubmVjdFNvY2tldHMoY2xvc2UgPSBmYWxzZSkge1xuICAgICAgICB0aGlzLmFkYXB0ZXIuZGlzY29ubmVjdFNvY2tldHMoe1xuICAgICAgICAgICAgcm9vbXM6IHRoaXMucm9vbXMsXG4gICAgICAgICAgICBleGNlcHQ6IHRoaXMuZXhjZXB0Um9vbXMsXG4gICAgICAgICAgICBmbGFnczogdGhpcy5mbGFncyxcbiAgICAgICAgfSwgY2xvc2UpO1xuICAgIH1cbn1cbmV4cG9ydHMuQnJvYWRjYXN0T3BlcmF0b3IgPSBCcm9hZGNhc3RPcGVyYXRvcjtcbi8qKlxuICogRXhwb3NlIG9mIHN1YnNldCBvZiB0aGUgYXR0cmlidXRlcyBhbmQgbWV0aG9kcyBvZiB0aGUgU29ja2V0IGNsYXNzXG4gKi9cbmNsYXNzIFJlbW90ZVNvY2tldCB7XG4gICAgY29uc3RydWN0b3IoYWRhcHRlciwgZGV0YWlscykge1xuICAgICAgICB0aGlzLmlkID0gZGV0YWlscy5pZDtcbiAgICAgICAgdGhpcy5oYW5kc2hha2UgPSBkZXRhaWxzLmhhbmRzaGFrZTtcbiAgICAgICAgdGhpcy5yb29tcyA9IG5ldyBTZXQoZGV0YWlscy5yb29tcyk7XG4gICAgICAgIHRoaXMuZGF0YSA9IGRldGFpbHMuZGF0YTtcbiAgICAgICAgdGhpcy5vcGVyYXRvciA9IG5ldyBCcm9hZGNhc3RPcGVyYXRvcihhZGFwdGVyLCBuZXcgU2V0KFt0aGlzLmlkXSksIG5ldyBTZXQoKSwge1xuICAgICAgICAgICAgZXhwZWN0U2luZ2xlUmVzcG9uc2U6IHRydWUsIC8vIHNvIHRoYXQgcmVtb3RlU29ja2V0LmVtaXQoKSB3aXRoIGFja25vd2xlZGdlbWVudCBiZWhhdmVzIGxpa2Ugc29ja2V0LmVtaXQoKVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkcyBhIHRpbWVvdXQgaW4gbWlsbGlzZWNvbmRzIGZvciB0aGUgbmV4dCBvcGVyYXRpb24uXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGNvbnN0IHNvY2tldHMgPSBhd2FpdCBpby5mZXRjaFNvY2tldHMoKTtcbiAgICAgKlxuICAgICAqIGZvciAoY29uc3Qgc29ja2V0IG9mIHNvY2tldHMpIHtcbiAgICAgKiAgIGlmIChzb21lQ29uZGl0aW9uKSB7XG4gICAgICogICAgIHNvY2tldC50aW1lb3V0KDEwMDApLmVtaXQoXCJzb21lLWV2ZW50XCIsIChlcnIpID0+IHtcbiAgICAgKiAgICAgICBpZiAoZXJyKSB7XG4gICAgICogICAgICAgICAvLyB0aGUgY2xpZW50IGRpZCBub3QgYWNrbm93bGVkZ2UgdGhlIGV2ZW50IGluIHRoZSBnaXZlbiBkZWxheVxuICAgICAqICAgICAgIH1cbiAgICAgKiAgICAgfSk7XG4gICAgICogICB9XG4gICAgICogfVxuICAgICAqXG4gICAgICogLy8gbm90ZTogaWYgcG9zc2libGUsIHVzaW5nIGEgcm9vbSBpbnN0ZWFkIG9mIGxvb3Bpbmcgb3ZlciBhbGwgc29ja2V0cyBpcyBwcmVmZXJhYmxlXG4gICAgICogaW8udGltZW91dCgxMDAwKS50byhzb21lQ29uZGl0aW9uUm9vbSkuZW1pdChcInNvbWUtZXZlbnRcIiwgKGVyciwgcmVzcG9uc2VzKSA9PiB7XG4gICAgICogICAvLyAuLi5cbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIEBwYXJhbSB0aW1lb3V0XG4gICAgICovXG4gICAgdGltZW91dCh0aW1lb3V0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wZXJhdG9yLnRpbWVvdXQodGltZW91dCk7XG4gICAgfVxuICAgIGVtaXQoZXYsIC4uLmFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3BlcmF0b3IuZW1pdChldiwgLi4uYXJncyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEpvaW5zIGEgcm9vbS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfEFycmF5fSByb29tIC0gcm9vbSBvciBhcnJheSBvZiByb29tc1xuICAgICAqL1xuICAgIGpvaW4ocm9vbSkge1xuICAgICAgICByZXR1cm4gdGhpcy5vcGVyYXRvci5zb2NrZXRzSm9pbihyb29tKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTGVhdmVzIGEgcm9vbS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSByb29tXG4gICAgICovXG4gICAgbGVhdmUocm9vbSkge1xuICAgICAgICByZXR1cm4gdGhpcy5vcGVyYXRvci5zb2NrZXRzTGVhdmUocm9vbSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERpc2Nvbm5lY3RzIHRoaXMgY2xpZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBjbG9zZSAtIGlmIGB0cnVlYCwgY2xvc2VzIHRoZSB1bmRlcmx5aW5nIGNvbm5lY3Rpb25cbiAgICAgKiBAcmV0dXJuIHtTb2NrZXR9IHNlbGZcbiAgICAgKi9cbiAgICBkaXNjb25uZWN0KGNsb3NlID0gZmFsc2UpIHtcbiAgICAgICAgdGhpcy5vcGVyYXRvci5kaXNjb25uZWN0U29ja2V0cyhjbG9zZSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbn1cbmV4cG9ydHMuUmVtb3RlU29ja2V0ID0gUmVtb3RlU29ja2V0O1xuIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiUmVtb3RlU29ja2V0IiwiQnJvYWRjYXN0T3BlcmF0b3IiLCJzb2NrZXRfdHlwZXNfMSIsInJlcXVpcmUiLCJzb2NrZXRfaW9fcGFyc2VyXzEiLCJjb25zdHJ1Y3RvciIsImFkYXB0ZXIiLCJyb29tcyIsIlNldCIsImV4Y2VwdFJvb21zIiwiZmxhZ3MiLCJ0byIsInJvb20iLCJBcnJheSIsImlzQXJyYXkiLCJmb3JFYWNoIiwiciIsImFkZCIsImluIiwiZXhjZXB0IiwiY29tcHJlc3MiLCJhc3NpZ24iLCJ2b2xhdGlsZSIsImxvY2FsIiwidGltZW91dCIsImVtaXQiLCJldiIsImFyZ3MiLCJSRVNFUlZFRF9FVkVOVFMiLCJoYXMiLCJFcnJvciIsIlN0cmluZyIsImRhdGEiLCJwYWNrZXQiLCJ0eXBlIiwiUGFja2V0VHlwZSIsIkVWRU5UIiwid2l0aEFjayIsImxlbmd0aCIsImJyb2FkY2FzdCIsImFjayIsInBvcCIsInRpbWVkT3V0IiwicmVzcG9uc2VzIiwidGltZXIiLCJzZXRUaW1lb3V0IiwiYXBwbHkiLCJleHBlY3RTaW5nbGVSZXNwb25zZSIsImV4cGVjdGVkU2VydmVyQ291bnQiLCJhY3R1YWxTZXJ2ZXJDb3VudCIsImV4cGVjdGVkQ2xpZW50Q291bnQiLCJjaGVja0NvbXBsZXRlbmVzcyIsImNsZWFyVGltZW91dCIsImJyb2FkY2FzdFdpdGhBY2siLCJjbGllbnRDb3VudCIsImNsaWVudFJlc3BvbnNlIiwicHVzaCIsInNlcnZlckNvdW50IiwidGhlbiIsImVtaXRXaXRoQWNrIiwiUHJvbWlzZSIsInJlc29sdmUiLCJyZWplY3QiLCJlcnIiLCJhbGxTb2NrZXRzIiwic29ja2V0cyIsImZldGNoU29ja2V0cyIsIm1hcCIsInNvY2tldCIsInNlcnZlciIsInNvY2tldHNKb2luIiwiYWRkU29ja2V0cyIsInNvY2tldHNMZWF2ZSIsImRlbFNvY2tldHMiLCJkaXNjb25uZWN0U29ja2V0cyIsImNsb3NlIiwiZGV0YWlscyIsImlkIiwiaGFuZHNoYWtlIiwib3BlcmF0b3IiLCJqb2luIiwibGVhdmUiLCJkaXNjb25uZWN0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/socket.io/dist/broadcast-operator.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/socket.io/dist/client.js":
/*!***********************************************!*\
  !*** ./node_modules/socket.io/dist/client.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.Client = void 0;\nconst socket_io_parser_1 = __webpack_require__(/*! socket.io-parser */ \"(rsc)/./node_modules/socket.io-parser/build/cjs/index.js\");\nconst debugModule = __webpack_require__(/*! debug */ \"(rsc)/./node_modules/socket.io/node_modules/debug/src/index.js\");\nconst url = __webpack_require__(/*! url */ \"url\");\nconst debug = debugModule(\"socket.io:client\");\nclass Client {\n    /**\n     * Client constructor.\n     *\n     * @param server instance\n     * @param conn\n     * @package\n     */ constructor(server, conn){\n        this.sockets = new Map();\n        this.nsps = new Map();\n        this.server = server;\n        this.conn = conn;\n        this.encoder = server.encoder;\n        this.decoder = new server._parser.Decoder();\n        this.id = conn.id;\n        this.setup();\n    }\n    /**\n     * @return the reference to the request that originated the Engine.IO connection\n     *\n     * @public\n     */ get request() {\n        return this.conn.request;\n    }\n    /**\n     * Sets up event listeners.\n     *\n     * @private\n     */ setup() {\n        this.onclose = this.onclose.bind(this);\n        this.ondata = this.ondata.bind(this);\n        this.onerror = this.onerror.bind(this);\n        this.ondecoded = this.ondecoded.bind(this);\n        // @ts-ignore\n        this.decoder.on(\"decoded\", this.ondecoded);\n        this.conn.on(\"data\", this.ondata);\n        this.conn.on(\"error\", this.onerror);\n        this.conn.on(\"close\", this.onclose);\n        this.connectTimeout = setTimeout(()=>{\n            if (this.nsps.size === 0) {\n                debug(\"no namespace joined yet, close the client\");\n                this.close();\n            } else {\n                debug(\"the client has already joined a namespace, nothing to do\");\n            }\n        }, this.server._connectTimeout);\n    }\n    /**\n     * Connects a client to a namespace.\n     *\n     * @param {String} name - the namespace\n     * @param {Object} auth - the auth parameters\n     * @private\n     */ connect(name, auth = {}) {\n        if (this.server._nsps.has(name)) {\n            debug(\"connecting to namespace %s\", name);\n            return this.doConnect(name, auth);\n        }\n        this.server._checkNamespace(name, auth, (dynamicNspName)=>{\n            if (dynamicNspName) {\n                this.doConnect(name, auth);\n            } else {\n                debug(\"creation of namespace %s was denied\", name);\n                this._packet({\n                    type: socket_io_parser_1.PacketType.CONNECT_ERROR,\n                    nsp: name,\n                    data: {\n                        message: \"Invalid namespace\"\n                    }\n                });\n            }\n        });\n    }\n    /**\n     * Connects a client to a namespace.\n     *\n     * @param name - the namespace\n     * @param {Object} auth - the auth parameters\n     *\n     * @private\n     */ doConnect(name, auth) {\n        const nsp = this.server.of(name);\n        nsp._add(this, auth, (socket)=>{\n            this.sockets.set(socket.id, socket);\n            this.nsps.set(nsp.name, socket);\n            if (this.connectTimeout) {\n                clearTimeout(this.connectTimeout);\n                this.connectTimeout = undefined;\n            }\n        });\n    }\n    /**\n     * Disconnects from all namespaces and closes transport.\n     *\n     * @private\n     */ _disconnect() {\n        for (const socket of this.sockets.values()){\n            socket.disconnect();\n        }\n        this.sockets.clear();\n        this.close();\n    }\n    /**\n     * Removes a socket. Called by each `Socket`.\n     *\n     * @private\n     */ _remove(socket) {\n        if (this.sockets.has(socket.id)) {\n            const nsp = this.sockets.get(socket.id).nsp.name;\n            this.sockets.delete(socket.id);\n            this.nsps.delete(nsp);\n        } else {\n            debug(\"ignoring remove for %s\", socket.id);\n        }\n    }\n    /**\n     * Closes the underlying connection.\n     *\n     * @private\n     */ close() {\n        if (\"open\" === this.conn.readyState) {\n            debug(\"forcing transport close\");\n            this.conn.close();\n            this.onclose(\"forced server close\");\n        }\n    }\n    /**\n     * Writes a packet to the transport.\n     *\n     * @param {Object} packet object\n     * @param {Object} opts\n     * @private\n     */ _packet(packet, opts = {}) {\n        if (this.conn.readyState !== \"open\") {\n            debug(\"ignoring packet write %j\", packet);\n            return;\n        }\n        const encodedPackets = opts.preEncoded ? packet // previous versions of the adapter incorrectly used socket.packet() instead of writeToEngine()\n         : this.encoder.encode(packet);\n        this.writeToEngine(encodedPackets, opts);\n    }\n    writeToEngine(encodedPackets, opts) {\n        if (opts.volatile && !this.conn.transport.writable) {\n            debug(\"volatile packet is discarded since the transport is not currently writable\");\n            return;\n        }\n        const packets = Array.isArray(encodedPackets) ? encodedPackets : [\n            encodedPackets\n        ];\n        for (const encodedPacket of packets){\n            this.conn.write(encodedPacket, opts);\n        }\n    }\n    /**\n     * Called with incoming transport data.\n     *\n     * @private\n     */ ondata(data) {\n        // try/catch is needed for protocol violations (GH-1880)\n        try {\n            this.decoder.add(data);\n        } catch (e) {\n            debug(\"invalid packet format\");\n            this.onerror(e);\n        }\n    }\n    /**\n     * Called when parser fully decodes a packet.\n     *\n     * @private\n     */ ondecoded(packet) {\n        let namespace;\n        let authPayload;\n        if (this.conn.protocol === 3) {\n            const parsed = url.parse(packet.nsp, true);\n            namespace = parsed.pathname;\n            authPayload = parsed.query;\n        } else {\n            namespace = packet.nsp;\n            authPayload = packet.data;\n        }\n        const socket = this.nsps.get(namespace);\n        if (!socket && packet.type === socket_io_parser_1.PacketType.CONNECT) {\n            this.connect(namespace, authPayload);\n        } else if (socket && packet.type !== socket_io_parser_1.PacketType.CONNECT && packet.type !== socket_io_parser_1.PacketType.CONNECT_ERROR) {\n            process.nextTick(function() {\n                socket._onpacket(packet);\n            });\n        } else {\n            debug(\"invalid state (packet type: %s)\", packet.type);\n            this.close();\n        }\n    }\n    /**\n     * Handles an error.\n     *\n     * @param {Object} err object\n     * @private\n     */ onerror(err) {\n        for (const socket of this.sockets.values()){\n            socket._onerror(err);\n        }\n        this.conn.close();\n    }\n    /**\n     * Called upon transport close.\n     *\n     * @param reason\n     * @param description\n     * @private\n     */ onclose(reason, description) {\n        debug(\"client close with reason %s\", reason);\n        // ignore a potential subsequent `close` event\n        this.destroy();\n        // `nsps` and `sockets` are cleaned up seamlessly\n        for (const socket of this.sockets.values()){\n            socket._onclose(reason, description);\n        }\n        this.sockets.clear();\n        this.decoder.destroy(); // clean up decoder\n    }\n    /**\n     * Cleans up event listeners.\n     * @private\n     */ destroy() {\n        this.conn.removeListener(\"data\", this.ondata);\n        this.conn.removeListener(\"error\", this.onerror);\n        this.conn.removeListener(\"close\", this.onclose);\n        // @ts-ignore\n        this.decoder.removeListener(\"decoded\", this.ondecoded);\n        if (this.connectTimeout) {\n            clearTimeout(this.connectTimeout);\n            this.connectTimeout = undefined;\n        }\n    }\n}\nexports.Client = Client;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc29ja2V0LmlvL2Rpc3QvY2xpZW50LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxjQUFjLEdBQUcsS0FBSztBQUN0QixNQUFNRyxxQkFBcUJDLG1CQUFPQSxDQUFDLGtGQUFrQjtBQUNyRCxNQUFNQyxjQUFjRCxtQkFBT0EsQ0FBQyw2RUFBTztBQUNuQyxNQUFNRSxNQUFNRixtQkFBT0EsQ0FBQyxnQkFBSztBQUN6QixNQUFNRyxRQUFRRixZQUFZO0FBQzFCLE1BQU1IO0lBQ0Y7Ozs7OztLQU1DLEdBQ0RNLFlBQVlDLE1BQU0sRUFBRUMsSUFBSSxDQUFFO1FBQ3RCLElBQUksQ0FBQ0MsT0FBTyxHQUFHLElBQUlDO1FBQ25CLElBQUksQ0FBQ0MsSUFBSSxHQUFHLElBQUlEO1FBQ2hCLElBQUksQ0FBQ0gsTUFBTSxHQUFHQTtRQUNkLElBQUksQ0FBQ0MsSUFBSSxHQUFHQTtRQUNaLElBQUksQ0FBQ0ksT0FBTyxHQUFHTCxPQUFPSyxPQUFPO1FBQzdCLElBQUksQ0FBQ0MsT0FBTyxHQUFHLElBQUlOLE9BQU9PLE9BQU8sQ0FBQ0MsT0FBTztRQUN6QyxJQUFJLENBQUNDLEVBQUUsR0FBR1IsS0FBS1EsRUFBRTtRQUNqQixJQUFJLENBQUNDLEtBQUs7SUFDZDtJQUNBOzs7O0tBSUMsR0FDRCxJQUFJQyxVQUFVO1FBQ1YsT0FBTyxJQUFJLENBQUNWLElBQUksQ0FBQ1UsT0FBTztJQUM1QjtJQUNBOzs7O0tBSUMsR0FDREQsUUFBUTtRQUNKLElBQUksQ0FBQ0UsT0FBTyxHQUFHLElBQUksQ0FBQ0EsT0FBTyxDQUFDQyxJQUFJLENBQUMsSUFBSTtRQUNyQyxJQUFJLENBQUNDLE1BQU0sR0FBRyxJQUFJLENBQUNBLE1BQU0sQ0FBQ0QsSUFBSSxDQUFDLElBQUk7UUFDbkMsSUFBSSxDQUFDRSxPQUFPLEdBQUcsSUFBSSxDQUFDQSxPQUFPLENBQUNGLElBQUksQ0FB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bkI7SUFDQTs7Ozs7O0tBTUMsR0FDRFQsUUFBUXFFLE1BQU0sRUFBRUMsV0FBVyxFQUFFO1FBQ3pCcEYsTUFBTSwrQkFBK0JtRjtRQUNyQyw4Q0FBOEM7UUFDOUMsSUFBSSxDQUFDRSxPQUFPO1FBQ1osaURBQWlEO1FBQ2pELEtBQUssTUFBTTNDLFVBQVUsSUFBSSxDQUFDdEMsT0FBTyxDQUFDMkMsTUFBTSxHQUFJO1lBQ3hDTCxPQUFPNEMsUUFBUSxDQUFDSCxRQUFRQztRQUM1QjtRQUNBLElBQUksQ0FBQ2hGLE9BQU8sQ0FBQzZDLEtBQUs7UUFDbEIsSUFBSSxDQUFDekMsT0FBTyxDQUFDNkUsT0FBTyxJQUFJLG1CQUFtQjtJQUMvQztJQUNBOzs7S0FHQyxHQUNEQSxVQUFVO1FBQ04sSUFBSSxDQUFDbEYsSUFBSSxDQUFDb0YsY0FBYyxDQUFDLFFBQVEsSUFBSSxDQUFDdkUsTUFBTTtRQUM1QyxJQUFJLENBQUNiLElBQUksQ0FBQ29GLGNBQWMsQ0FBQyxTQUFTLElBQUksQ0FBQ3RFLE9BQU87UUFDOUMsSUFBSSxDQUFDZCxJQUFJLENBQUNvRixjQUFjLENBQUMsU0FBUyxJQUFJLENBQUN6RSxPQUFPO1FBQzlDLGFBQWE7UUFDYixJQUFJLENBQUNOLE9BQU8sQ0FBQytFLGNBQWMsQ0FBQyxXQUFXLElBQUksQ0FBQ3JFLFNBQVM7UUFDckQsSUFBSSxJQUFJLENBQUNFLGNBQWMsRUFBRTtZQUNyQndCLGFBQWEsSUFBSSxDQUFDeEIsY0FBYztZQUNoQyxJQUFJLENBQUNBLGNBQWMsR0FBR3lCO1FBQzFCO0lBQ0o7QUFDSjtBQUNBcEQsY0FBYyxHQUFHRSIsInNvdXJjZXMiOlsid2VicGFjazovL2V4YW1yb3NoLy4vbm9kZV9tb2R1bGVzL3NvY2tldC5pby9kaXN0L2NsaWVudC5qcz82MTc3Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5DbGllbnQgPSB2b2lkIDA7XG5jb25zdCBzb2NrZXRfaW9fcGFyc2VyXzEgPSByZXF1aXJlKFwic29ja2V0LmlvLXBhcnNlclwiKTtcbmNvbnN0IGRlYnVnTW9kdWxlID0gcmVxdWlyZShcImRlYnVnXCIpO1xuY29uc3QgdXJsID0gcmVxdWlyZShcInVybFwiKTtcbmNvbnN0IGRlYnVnID0gZGVidWdNb2R1bGUoXCJzb2NrZXQuaW86Y2xpZW50XCIpO1xuY2xhc3MgQ2xpZW50IHtcbiAgICAvKipcbiAgICAgKiBDbGllbnQgY29uc3RydWN0b3IuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gc2VydmVyIGluc3RhbmNlXG4gICAgICogQHBhcmFtIGNvbm5cbiAgICAgKiBAcGFja2FnZVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHNlcnZlciwgY29ubikge1xuICAgICAgICB0aGlzLnNvY2tldHMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMubnNwcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5zZXJ2ZXIgPSBzZXJ2ZXI7XG4gICAgICAgIHRoaXMuY29ubiA9IGNvbm47XG4gICAgICAgIHRoaXMuZW5jb2RlciA9IHNlcnZlci5lbmNvZGVyO1xuICAgICAgICB0aGlzLmRlY29kZXIgPSBuZXcgc2VydmVyLl9wYXJzZXIuRGVjb2RlcigpO1xuICAgICAgICB0aGlzLmlkID0gY29ubi5pZDtcbiAgICAgICAgdGhpcy5zZXR1cCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHRoZSByZWZlcmVuY2UgdG8gdGhlIHJlcXVlc3QgdGhhdCBvcmlnaW5hdGVkIHRoZSBFbmdpbmUuSU8gY29ubmVjdGlvblxuICAgICAqXG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIGdldCByZXF1ZXN0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb25uLnJlcXVlc3Q7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdXAgZXZlbnQgbGlzdGVuZXJzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBzZXR1cCgpIHtcbiAgICAgICAgdGhpcy5vbmNsb3NlID0gdGhpcy5vbmNsb3NlLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMub25kYXRhID0gdGhpcy5vbmRhdGEuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5vbmVycm9yID0gdGhpcy5vbmVycm9yLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMub25kZWNvZGVkID0gdGhpcy5vbmRlY29kZWQuYmluZCh0aGlzKTtcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICB0aGlzLmRlY29kZXIub24oXCJkZWNvZGVkXCIsIHRoaXMub25kZWNvZGVkKTtcbiAgICAgICAgdGhpcy5jb25uLm9uKFwiZGF0YVwiLCB0aGlzLm9uZGF0YSk7XG4gICAgICAgIHRoaXMuY29ubi5vbihcImVycm9yXCIsIHRoaXMub25lcnJvcik7XG4gICAgICAgIHRoaXMuY29ubi5vbihcImNsb3NlXCIsIHRoaXMub25jbG9zZSk7XG4gICAgICAgIHRoaXMuY29ubmVjdFRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLm5zcHMuc2l6ZSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGRlYnVnKFwibm8gbmFtZXNwYWNlIGpvaW5lZCB5ZXQsIGNsb3NlIHRoZSBjbGllbnRcIik7XG4gICAgICAgICAgICAgICAgdGhpcy5jbG9zZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZGVidWcoXCJ0aGUgY2xpZW50IGhhcyBhbHJlYWR5IGpvaW5lZCBhIG5hbWVzcGFjZSwgbm90aGluZyB0byBkb1wiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgdGhpcy5zZXJ2ZXIuX2Nvbm5lY3RUaW1lb3V0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29ubmVjdHMgYSBjbGllbnQgdG8gYSBuYW1lc3BhY2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSAtIHRoZSBuYW1lc3BhY2VcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gYXV0aCAtIHRoZSBhdXRoIHBhcmFtZXRlcnNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGNvbm5lY3QobmFtZSwgYXV0aCA9IHt9KSB7XG4gICAgICAgIGlmICh0aGlzLnNlcnZlci5fbnNwcy5oYXMobmFtZSkpIHtcbiAgICAgICAgICAgIGRlYnVnKFwiY29ubmVjdGluZyB0byBuYW1lc3BhY2UgJXNcIiwgbmFtZSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kb0Nvbm5lY3QobmFtZSwgYXV0aCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZXJ2ZXIuX2NoZWNrTmFtZXNwYWNlKG5hbWUsIGF1dGgsIChkeW5hbWljTnNwTmFtZSkgPT4ge1xuICAgICAgICAgICAgaWYgKGR5bmFtaWNOc3BOYW1lKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kb0Nvbm5lY3QobmFtZSwgYXV0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBkZWJ1ZyhcImNyZWF0aW9uIG9mIG5hbWVzcGFjZSAlcyB3YXMgZGVuaWVkXCIsIG5hbWUpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3BhY2tldCh7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IHNvY2tldF9pb19wYXJzZXJfMS5QYWNrZXRUeXBlLkNPTk5FQ1RfRVJST1IsXG4gICAgICAgICAgICAgICAgICAgIG5zcDogbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogXCJJbnZhbGlkIG5hbWVzcGFjZVwiLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29ubmVjdHMgYSBjbGllbnQgdG8gYSBuYW1lc3BhY2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbmFtZSAtIHRoZSBuYW1lc3BhY2VcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gYXV0aCAtIHRoZSBhdXRoIHBhcmFtZXRlcnNcbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgZG9Db25uZWN0KG5hbWUsIGF1dGgpIHtcbiAgICAgICAgY29uc3QgbnNwID0gdGhpcy5zZXJ2ZXIub2YobmFtZSk7XG4gICAgICAgIG5zcC5fYWRkKHRoaXMsIGF1dGgsIChzb2NrZXQpID0+IHtcbiAgICAgICAgICAgIHRoaXMuc29ja2V0cy5zZXQoc29ja2V0LmlkLCBzb2NrZXQpO1xuICAgICAgICAgICAgdGhpcy5uc3BzLnNldChuc3AubmFtZSwgc29ja2V0KTtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbm5lY3RUaW1lb3V0KSB7XG4gICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuY29ubmVjdFRpbWVvdXQpO1xuICAgICAgICAgICAgICAgIHRoaXMuY29ubmVjdFRpbWVvdXQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEaXNjb25uZWN0cyBmcm9tIGFsbCBuYW1lc3BhY2VzIGFuZCBjbG9zZXMgdHJhbnNwb3J0LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZGlzY29ubmVjdCgpIHtcbiAgICAgICAgZm9yIChjb25zdCBzb2NrZXQgb2YgdGhpcy5zb2NrZXRzLnZhbHVlcygpKSB7XG4gICAgICAgICAgICBzb2NrZXQuZGlzY29ubmVjdCgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc29ja2V0cy5jbGVhcigpO1xuICAgICAgICB0aGlzLmNsb3NlKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYSBzb2NrZXQuIENhbGxlZCBieSBlYWNoIGBTb2NrZXRgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfcmVtb3ZlKHNvY2tldCkge1xuICAgICAgICBpZiAodGhpcy5zb2NrZXRzLmhhcyhzb2NrZXQuaWQpKSB7XG4gICAgICAgICAgICBjb25zdCBuc3AgPSB0aGlzLnNvY2tldHMuZ2V0KHNvY2tldC5pZCkubnNwLm5hbWU7XG4gICAgICAgICAgICB0aGlzLnNvY2tldHMuZGVsZXRlKHNvY2tldC5pZCk7XG4gICAgICAgICAgICB0aGlzLm5zcHMuZGVsZXRlKG5zcCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkZWJ1ZyhcImlnbm9yaW5nIHJlbW92ZSBmb3IgJXNcIiwgc29ja2V0LmlkKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDbG9zZXMgdGhlIHVuZGVybHlpbmcgY29ubmVjdGlvbi5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgY2xvc2UoKSB7XG4gICAgICAgIGlmIChcIm9wZW5cIiA9PT0gdGhpcy5jb25uLnJlYWR5U3RhdGUpIHtcbiAgICAgICAgICAgIGRlYnVnKFwiZm9yY2luZyB0cmFuc3BvcnQgY2xvc2VcIik7XG4gICAgICAgICAgICB0aGlzLmNvbm4uY2xvc2UoKTtcbiAgICAgICAgICAgIHRoaXMub25jbG9zZShcImZvcmNlZCBzZXJ2ZXIgY2xvc2VcIik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogV3JpdGVzIGEgcGFja2V0IHRvIHRoZSB0cmFuc3BvcnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcGFja2V0IG9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfcGFja2V0KHBhY2tldCwgb3B0cyA9IHt9KSB7XG4gICAgICAgIGlmICh0aGlzLmNvbm4ucmVhZHlTdGF0ZSAhPT0gXCJvcGVuXCIpIHtcbiAgICAgICAgICAgIGRlYnVnKFwiaWdub3JpbmcgcGFja2V0IHdyaXRlICVqXCIsIHBhY2tldCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZW5jb2RlZFBhY2tldHMgPSBvcHRzLnByZUVuY29kZWRcbiAgICAgICAgICAgID8gcGFja2V0IC8vIHByZXZpb3VzIHZlcnNpb25zIG9mIHRoZSBhZGFwdGVyIGluY29ycmVjdGx5IHVzZWQgc29ja2V0LnBhY2tldCgpIGluc3RlYWQgb2Ygd3JpdGVUb0VuZ2luZSgpXG4gICAgICAgICAgICA6IHRoaXMuZW5jb2Rlci5lbmNvZGUocGFja2V0KTtcbiAgICAgICAgdGhpcy53cml0ZVRvRW5naW5lKGVuY29kZWRQYWNrZXRzLCBvcHRzKTtcbiAgICB9XG4gICAgd3JpdGVUb0VuZ2luZShlbmNvZGVkUGFja2V0cywgb3B0cykge1xuICAgICAgICBpZiAob3B0cy52b2xhdGlsZSAmJiAhdGhpcy5jb25uLnRyYW5zcG9ydC53cml0YWJsZSkge1xuICAgICAgICAgICAgZGVidWcoXCJ2b2xhdGlsZSBwYWNrZXQgaXMgZGlzY2FyZGVkIHNpbmNlIHRoZSB0cmFuc3BvcnQgaXMgbm90IGN1cnJlbnRseSB3cml0YWJsZVwiKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwYWNrZXRzID0gQXJyYXkuaXNBcnJheShlbmNvZGVkUGFja2V0cylcbiAgICAgICAgICAgID8gZW5jb2RlZFBhY2tldHNcbiAgICAgICAgICAgIDogW2VuY29kZWRQYWNrZXRzXTtcbiAgICAgICAgZm9yIChjb25zdCBlbmNvZGVkUGFja2V0IG9mIHBhY2tldHMpIHtcbiAgICAgICAgICAgIHRoaXMuY29ubi53cml0ZShlbmNvZGVkUGFja2V0LCBvcHRzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgd2l0aCBpbmNvbWluZyB0cmFuc3BvcnQgZGF0YS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgb25kYXRhKGRhdGEpIHtcbiAgICAgICAgLy8gdHJ5L2NhdGNoIGlzIG5lZWRlZCBmb3IgcHJvdG9jb2wgdmlvbGF0aW9ucyAoR0gtMTg4MClcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMuZGVjb2Rlci5hZGQoZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGRlYnVnKFwiaW52YWxpZCBwYWNrZXQgZm9ybWF0XCIpO1xuICAgICAgICAgICAgdGhpcy5vbmVycm9yKGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGxlZCB3aGVuIHBhcnNlciBmdWxseSBkZWNvZGVzIGEgcGFja2V0LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBvbmRlY29kZWQocGFja2V0KSB7XG4gICAgICAgIGxldCBuYW1lc3BhY2U7XG4gICAgICAgIGxldCBhdXRoUGF5bG9hZDtcbiAgICAgICAgaWYgKHRoaXMuY29ubi5wcm90b2NvbCA9PT0gMykge1xuICAgICAgICAgICAgY29uc3QgcGFyc2VkID0gdXJsLnBhcnNlKHBhY2tldC5uc3AsIHRydWUpO1xuICAgICAgICAgICAgbmFtZXNwYWNlID0gcGFyc2VkLnBhdGhuYW1lO1xuICAgICAgICAgICAgYXV0aFBheWxvYWQgPSBwYXJzZWQucXVlcnk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBuYW1lc3BhY2UgPSBwYWNrZXQubnNwO1xuICAgICAgICAgICAgYXV0aFBheWxvYWQgPSBwYWNrZXQuZGF0YTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzb2NrZXQgPSB0aGlzLm5zcHMuZ2V0KG5hbWVzcGFjZSk7XG4gICAgICAgIGlmICghc29ja2V0ICYmIHBhY2tldC50eXBlID09PSBzb2NrZXRfaW9fcGFyc2VyXzEuUGFja2V0VHlwZS5DT05ORUNUKSB7XG4gICAgICAgICAgICB0aGlzLmNvbm5lY3QobmFtZXNwYWNlLCBhdXRoUGF5bG9hZCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc29ja2V0ICYmXG4gICAgICAgICAgICBwYWNrZXQudHlwZSAhPT0gc29ja2V0X2lvX3BhcnNlcl8xLlBhY2tldFR5cGUuQ09OTkVDVCAmJlxuICAgICAgICAgICAgcGFja2V0LnR5cGUgIT09IHNvY2tldF9pb19wYXJzZXJfMS5QYWNrZXRUeXBlLkNPTk5FQ1RfRVJST1IpIHtcbiAgICAgICAgICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHNvY2tldC5fb25wYWNrZXQocGFja2V0KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZGVidWcoXCJpbnZhbGlkIHN0YXRlIChwYWNrZXQgdHlwZTogJXMpXCIsIHBhY2tldC50eXBlKTtcbiAgICAgICAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBIYW5kbGVzIGFuIGVycm9yLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGVyciBvYmplY3RcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIG9uZXJyb3IoZXJyKSB7XG4gICAgICAgIGZvciAoY29uc3Qgc29ja2V0IG9mIHRoaXMuc29ja2V0cy52YWx1ZXMoKSkge1xuICAgICAgICAgICAgc29ja2V0Ll9vbmVycm9yKGVycik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jb25uLmNsb3NlKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGxlZCB1cG9uIHRyYW5zcG9ydCBjbG9zZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSByZWFzb25cbiAgICAgKiBAcGFyYW0gZGVzY3JpcHRpb25cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIG9uY2xvc2UocmVhc29uLCBkZXNjcmlwdGlvbikge1xuICAgICAgICBkZWJ1ZyhcImNsaWVudCBjbG9zZSB3aXRoIHJlYXNvbiAlc1wiLCByZWFzb24pO1xuICAgICAgICAvLyBpZ25vcmUgYSBwb3RlbnRpYWwgc3Vic2VxdWVudCBgY2xvc2VgIGV2ZW50XG4gICAgICAgIHRoaXMuZGVzdHJveSgpO1xuICAgICAgICAvLyBgbnNwc2AgYW5kIGBzb2NrZXRzYCBhcmUgY2xlYW5lZCB1cCBzZWFtbGVzc2x5XG4gICAgICAgIGZvciAoY29uc3Qgc29ja2V0IG9mIHRoaXMuc29ja2V0cy52YWx1ZXMoKSkge1xuICAgICAgICAgICAgc29ja2V0Ll9vbmNsb3NlKHJlYXNvbiwgZGVzY3JpcHRpb24pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc29ja2V0cy5jbGVhcigpO1xuICAgICAgICB0aGlzLmRlY29kZXIuZGVzdHJveSgpOyAvLyBjbGVhbiB1cCBkZWNvZGVyXG4gICAgfVxuICAgIC8qKlxuICAgICAqIENsZWFucyB1cCBldmVudCBsaXN0ZW5lcnMuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLmNvbm4ucmVtb3ZlTGlzdGVuZXIoXCJkYXRhXCIsIHRoaXMub25kYXRhKTtcbiAgICAgICAgdGhpcy5jb25uLnJlbW92ZUxpc3RlbmVyKFwiZXJyb3JcIiwgdGhpcy5vbmVycm9yKTtcbiAgICAgICAgdGhpcy5jb25uLnJlbW92ZUxpc3RlbmVyKFwiY2xvc2VcIiwgdGhpcy5vbmNsb3NlKTtcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICB0aGlzLmRlY29kZXIucmVtb3ZlTGlzdGVuZXIoXCJkZWNvZGVkXCIsIHRoaXMub25kZWNvZGVkKTtcbiAgICAgICAgaWYgKHRoaXMuY29ubmVjdFRpbWVvdXQpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLmNvbm5lY3RUaW1lb3V0KTtcbiAgICAgICAgICAgIHRoaXMuY29ubmVjdFRpbWVvdXQgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLkNsaWVudCA9IENsaWVudDtcbiJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIkNsaWVudCIsInNvY2tldF9pb19wYXJzZXJfMSIsInJlcXVpcmUiLCJkZWJ1Z01vZHVsZSIsInVybCIsImRlYnVnIiwiY29uc3RydWN0b3IiLCJzZXJ2ZXIiLCJjb25uIiwic29ja2V0cyIsIk1hcCIsIm5zcHMiLCJlbmNvZGVyIiwiZGVjb2RlciIsIl9wYXJzZXIiLCJEZWNvZGVyIiwiaWQiLCJzZXR1cCIsInJlcXVlc3QiLCJvbmNsb3NlIiwiYmluZCIsIm9uZGF0YSIsIm9uZXJyb3IiLCJvbmRlY29kZWQiLCJvbiIsImNvbm5lY3RUaW1lb3V0Iiwic2V0VGltZW91dCIsInNpemUiLCJjbG9zZSIsIl9jb25uZWN0VGltZW91dCIsImNvbm5lY3QiLCJuYW1lIiwiYXV0aCIsIl9uc3BzIiwiaGFzIiwiZG9Db25uZWN0IiwiX2NoZWNrTmFtZXNwYWNlIiwiZHluYW1pY05zcE5hbWUiLCJfcGFja2V0IiwidHlwZSIsIlBhY2tldFR5cGUiLCJDT05ORUNUX0VSUk9SIiwibnNwIiwiZGF0YSIsIm1lc3NhZ2UiLCJvZiIsIl9hZGQiLCJzb2NrZXQiLCJzZXQiLCJjbGVhclRpbWVvdXQiLCJ1bmRlZmluZWQiLCJfZGlzY29ubmVjdCIsInZhbHVlcyIsImRpc2Nvbm5lY3QiLCJjbGVhciIsIl9yZW1vdmUiLCJnZXQiLCJkZWxldGUiLCJyZWFkeVN0YXRlIiwicGFja2V0Iiwib3B0cyIsImVuY29kZWRQYWNrZXRzIiwicHJlRW5jb2RlZCIsImVuY29kZSIsIndyaXRlVG9FbmdpbmUiLCJ2b2xhdGlsZSIsInRyYW5zcG9ydCIsIndyaXRhYmxlIiwicGFja2V0cyIsIkFycmF5IiwiaXNBcnJheSIsImVuY29kZWRQYWNrZXQiLCJ3cml0ZSIsImFkZCIsImUiLCJuYW1lc3BhY2UiLCJhdXRoUGF5bG9hZCIsInByb3RvY29sIiwicGFyc2VkIiwicGFyc2UiLCJwYXRobmFtZSIsInF1ZXJ5IiwiQ09OTkVDVCIsInByb2Nlc3MiLCJuZXh0VGljayIsIl9vbnBhY2tldCIsImVyciIsIl9vbmVycm9yIiwicmVhc29uIiwiZGVzY3JpcHRpb24iLCJkZXN0cm95IiwiX29uY2xvc2UiLCJyZW1vdmVMaXN0ZW5lciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/socket.io/dist/client.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/socket.io/dist/index.js":
/*!**********************************************!*\
  !*** ./node_modules/socket.io/dist/index.js ***!
  \**********************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("\nvar __createBinding = (void 0) && (void 0).__createBinding || (Object.create ? function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n        desc = {\n            enumerable: true,\n            get: function() {\n                return m[k];\n            }\n        };\n    }\n    Object.defineProperty(o, k2, desc);\n} : function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n});\nvar __setModuleDefault = (void 0) && (void 0).__setModuleDefault || (Object.create ? function(o, v) {\n    Object.defineProperty(o, \"default\", {\n        enumerable: true,\n        value: v\n    });\n} : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (void 0) && (void 0).__importStar || function(mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) {\n        for(var k in mod)if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    }\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (void 0) && (void 0).__importDefault || function(mod) {\n    return mod && mod.__esModule ? mod : {\n        \"default\": mod\n    };\n};\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.Namespace = exports.Socket = exports.Server = void 0;\nconst http = __webpack_require__(/*! http */ \"http\");\nconst fs_1 = __webpack_require__(/*! fs */ \"fs\");\nconst zlib_1 = __webpack_require__(/*! zlib */ \"zlib\");\nconst accepts = __webpack_require__(/*! accepts */ \"(rsc)/./node_modules/accepts/index.js\");\nconst stream_1 = __webpack_require__(/*! stream */ \"stream\");\nconst path = __webpack_require__(/*! path */ \"path\");\nconst engine_io_1 = __webpack_require__(/*! engine.io */ \"(rsc)/./node_modules/engine.io/build/engine.io.js\");\nconst client_1 = __webpack_require__(/*! ./client */ \"(rsc)/./node_modules/socket.io/dist/client.js\");\nconst events_1 = __webpack_require__(/*! events */ \"events\");\nconst namespace_1 = __webpack_require__(/*! ./namespace */ \"(rsc)/./node_modules/socket.io/dist/namespace.js\");\nObject.defineProperty(exports, \"Namespace\", ({\n    enumerable: true,\n    get: function() {\n        return namespace_1.Namespace;\n    }\n}));\nconst parent_namespace_1 = __webpack_require__(/*! ./parent-namespace */ \"(rsc)/./node_modules/socket.io/dist/parent-namespace.js\");\nconst socket_io_adapter_1 = __webpack_require__(/*! socket.io-adapter */ \"(rsc)/./node_modules/socket.io-adapter/dist/index.js\");\nconst parser = __importStar(__webpack_require__(/*! socket.io-parser */ \"(rsc)/./node_modules/socket.io-parser/build/cjs/index.js\"));\nconst debug_1 = __importDefault(__webpack_require__(/*! debug */ \"(rsc)/./node_modules/socket.io/node_modules/debug/src/index.js\"));\nconst socket_1 = __webpack_require__(/*! ./socket */ \"(rsc)/./node_modules/socket.io/dist/socket.js\");\nObject.defineProperty(exports, \"Socket\", ({\n    enumerable: true,\n    get: function() {\n        return socket_1.Socket;\n    }\n}));\nconst typed_events_1 = __webpack_require__(/*! ./typed-events */ \"(rsc)/./node_modules/socket.io/dist/typed-events.js\");\nconst uws_1 = __webpack_require__(/*! ./uws */ \"(rsc)/./node_modules/socket.io/dist/uws.js\");\nconst cors_1 = __importDefault(__webpack_require__(/*! cors */ \"(rsc)/./node_modules/cors/lib/index.js\"));\nconst debug = (0, debug_1.default)(\"socket.io:server\");\nconst clientVersion = (__webpack_require__(/*! ../package.json */ \"(rsc)/./node_modules/socket.io/package.json\").version);\nconst dotMapRegex = /\\.map/;\n/**\n * Represents a Socket.IO server.\n *\n * @example\n * import { Server } from \"socket.io\";\n *\n * const io = new Server();\n *\n * io.on(\"connection\", (socket) => {\n *   console.log(`socket ${socket.id} connected`);\n *\n *   // send an event to the client\n *   socket.emit(\"foo\", \"bar\");\n *\n *   socket.on(\"foobar\", () => {\n *     // an event was received from the client\n *   });\n *\n *   // upon disconnection\n *   socket.on(\"disconnect\", (reason) => {\n *     console.log(`socket ${socket.id} disconnected due to ${reason}`);\n *   });\n * });\n *\n * io.listen(3000);\n */ class Server extends typed_events_1.StrictEventEmitter {\n    constructor(srv, opts = {}){\n        super();\n        /**\n         * @private\n         */ this._nsps = new Map();\n        this.parentNsps = new Map();\n        /**\n         * A subset of the {@link parentNsps} map, only containing {@link ParentNamespace} which are based on a regular\n         * expression.\n         *\n         * @private\n         */ this.parentNamespacesFromRegExp = new Map();\n        if (\"object\" === typeof srv && srv instanceof Object && !srv.listen) {\n            opts = srv;\n            srv = undefined;\n        }\n        this.path(opts.path || \"/socket.io\");\n        this.connectTimeout(opts.connectTimeout || 45000);\n        this.serveClient(false !== opts.serveClient);\n        this._parser = opts.parser || parser;\n        this.encoder = new this._parser.Encoder();\n        this.opts = opts;\n        if (opts.connectionStateRecovery) {\n            opts.connectionStateRecovery = Object.assign({\n                maxDisconnectionDuration: 2 * 60 * 1000,\n                skipMiddlewares: true\n            }, opts.connectionStateRecovery);\n            this.adapter(opts.adapter || socket_io_adapter_1.SessionAwareAdapter);\n        } else {\n            this.adapter(opts.adapter || socket_io_adapter_1.Adapter);\n        }\n        opts.cleanupEmptyChildNamespaces = !!opts.cleanupEmptyChildNamespaces;\n        this.sockets = this.of(\"/\");\n        if (srv || typeof srv == \"number\") this.attach(srv);\n        if (this.opts.cors) {\n            this._corsMiddleware = (0, cors_1.default)(this.opts.cors);\n        }\n    }\n    get _opts() {\n        return this.opts;\n    }\n    serveClient(v) {\n        if (!arguments.length) return this._serveClient;\n        this._serveClient = v;\n        return this;\n    }\n    /**\n     * Executes the middleware for an incoming namespace not already created on the server.\n     *\n     * @param name - name of incoming namespace\n     * @param auth - the auth parameters\n     * @param fn - callback\n     *\n     * @private\n     */ _checkNamespace(name, auth, fn) {\n        if (this.parentNsps.size === 0) return fn(false);\n        const keysIterator = this.parentNsps.keys();\n        const run = ()=>{\n            const nextFn = keysIterator.next();\n            if (nextFn.done) {\n                return fn(false);\n            }\n            nextFn.value(name, auth, (err, allow)=>{\n                if (err || !allow) {\n                    return run();\n                }\n                if (this._nsps.has(name)) {\n                    // the namespace was created in the meantime\n                    debug(\"dynamic namespace %s already exists\", name);\n                    return fn(this._nsps.get(name));\n                }\n                const namespace = this.parentNsps.get(nextFn.value).createChild(name);\n                debug(\"dynamic namespace %s was created\", name);\n                fn(namespace);\n            });\n        };\n        run();\n    }\n    path(v) {\n        if (!arguments.length) return this._path;\n        this._path = v.replace(/\\/$/, \"\");\n        const escapedPath = this._path.replace(/[-\\/\\\\^$*+?.()|[\\]{}]/g, \"\\\\$&\");\n        this.clientPathRegex = new RegExp(\"^\" + escapedPath + \"/socket\\\\.io(\\\\.msgpack|\\\\.esm)?(\\\\.min)?\\\\.js(\\\\.map)?(?:\\\\?|$)\");\n        return this;\n    }\n    connectTimeout(v) {\n        if (v === undefined) return this._connectTimeout;\n        this._connectTimeout = v;\n        return this;\n    }\n    adapter(v) {\n        if (!arguments.length) return this._adapter;\n        this._adapter = v;\n        for (const nsp of this._nsps.values()){\n            nsp._initAdapter();\n        }\n        return this;\n    }\n    /**\n     * Attaches socket.io to a server or port.\n     *\n     * @param srv - server or port\n     * @param opts - options passed to engine.io\n     * @return self\n     */ listen(srv, opts = {}) {\n        return this.attach(srv, opts);\n    }\n    /**\n     * Attaches socket.io to a server or port.\n     *\n     * @param srv - server or port\n     * @param opts - options passed to engine.io\n     * @return self\n     */ attach(srv, opts = {}) {\n        if (\"function\" == typeof srv) {\n            const msg = \"You are trying to attach socket.io to an express \" + \"request handler function. Please pass a http.Server instance.\";\n            throw new Error(msg);\n        }\n        // handle a port as a string\n        if (Number(srv) == srv) {\n            srv = Number(srv);\n        }\n        if (\"number\" == typeof srv) {\n            debug(\"creating http server and binding to %d\", srv);\n            const port = srv;\n            srv = http.createServer((req, res)=>{\n                res.writeHead(404);\n                res.end();\n            });\n            srv.listen(port);\n        }\n        // merge the options passed to the Socket.IO server\n        Object.assign(opts, this.opts);\n        // set engine.io path to `/socket.io`\n        opts.path = opts.path || this._path;\n        this.initEngine(srv, opts);\n        return this;\n    }\n    attachApp(app /*: TemplatedApp */ , opts = {}) {\n        // merge the options passed to the Socket.IO server\n        Object.assign(opts, this.opts);\n        // set engine.io path to `/socket.io`\n        opts.path = opts.path || this._path;\n        // initialize engine\n        debug(\"creating uWebSockets.js-based engine with opts %j\", opts);\n        const engine = new engine_io_1.uServer(opts);\n        engine.attach(app, opts);\n        // bind to engine events\n        this.bind(engine);\n        if (this._serveClient) {\n            // attach static file serving\n            app.get(`${this._path}/*`, (res, req)=>{\n                if (!this.clientPathRegex.test(req.getUrl())) {\n                    req.setYield(true);\n                    return;\n                }\n                const filename = req.getUrl().replace(this._path, \"\").replace(/\\?.*$/, \"\").replace(/^\\//, \"\");\n                const isMap = dotMapRegex.test(filename);\n                const type = isMap ? \"map\" : \"source\";\n                // Per the standard, ETags must be quoted:\n                // https://tools.ietf.org/html/rfc7232#section-2.3\n                const expectedEtag = '\"' + clientVersion + '\"';\n                const weakEtag = \"W/\" + expectedEtag;\n                const etag = req.getHeader(\"if-none-match\");\n                if (etag) {\n                    if (expectedEtag === etag || weakEtag === etag) {\n                        debug(\"serve client %s 304\", type);\n                        res.writeStatus(\"304 Not Modified\");\n                        res.end();\n                        return;\n                    }\n                }\n                debug(\"serve client %s\", type);\n                res.writeHeader(\"cache-control\", \"public, max-age=0\");\n                res.writeHeader(\"content-type\", \"application/\" + (isMap ? \"json\" : \"javascript\") + \"; charset=utf-8\");\n                res.writeHeader(\"etag\", expectedEtag);\n                const filepath = path.join(__dirname, \"../client-dist/\", filename);\n                (0, uws_1.serveFile)(res, filepath);\n            });\n        }\n        (0, uws_1.patchAdapter)(app);\n    }\n    /**\n     * Initialize engine\n     *\n     * @param srv - the server to attach to\n     * @param opts - options passed to engine.io\n     * @private\n     */ initEngine(srv, opts) {\n        // initialize engine\n        debug(\"creating engine.io instance with opts %j\", opts);\n        this.eio = (0, engine_io_1.attach)(srv, opts);\n        // attach static file serving\n        if (this._serveClient) this.attachServe(srv);\n        // Export http server\n        this.httpServer = srv;\n        // bind to engine events\n        this.bind(this.eio);\n    }\n    /**\n     * Attaches the static file serving.\n     *\n     * @param srv http server\n     * @private\n     */ attachServe(srv) {\n        debug(\"attaching client serving req handler\");\n        const evs = srv.listeners(\"request\").slice(0);\n        srv.removeAllListeners(\"request\");\n        srv.on(\"request\", (req, res)=>{\n            if (this.clientPathRegex.test(req.url)) {\n                if (this._corsMiddleware) {\n                    this._corsMiddleware(req, res, ()=>{\n                        this.serve(req, res);\n                    });\n                } else {\n                    this.serve(req, res);\n                }\n            } else {\n                for(let i = 0; i < evs.length; i++){\n                    evs[i].call(srv, req, res);\n                }\n            }\n        });\n    }\n    /**\n     * Handles a request serving of client source and map\n     *\n     * @param req\n     * @param res\n     * @private\n     */ serve(req, res) {\n        const filename = req.url.replace(this._path, \"\").replace(/\\?.*$/, \"\");\n        const isMap = dotMapRegex.test(filename);\n        const type = isMap ? \"map\" : \"source\";\n        // Per the standard, ETags must be quoted:\n        // https://tools.ietf.org/html/rfc7232#section-2.3\n        const expectedEtag = '\"' + clientVersion + '\"';\n        const weakEtag = \"W/\" + expectedEtag;\n        const etag = req.headers[\"if-none-match\"];\n        if (etag) {\n            if (expectedEtag === etag || weakEtag === etag) {\n                debug(\"serve client %s 304\", type);\n                res.writeHead(304);\n                res.end();\n                return;\n            }\n        }\n        debug(\"serve client %s\", type);\n        res.setHeader(\"Cache-Control\", \"public, max-age=0\");\n        res.setHeader(\"Content-Type\", \"application/\" + (isMap ? \"json\" : \"javascript\") + \"; charset=utf-8\");\n        res.setHeader(\"ETag\", expectedEtag);\n        Server.sendFile(filename, req, res);\n    }\n    /**\n     * @param filename\n     * @param req\n     * @param res\n     * @private\n     */ static sendFile(filename, req, res) {\n        const readStream = (0, fs_1.createReadStream)(path.join(__dirname, \"../client-dist/\", filename));\n        const encoding = accepts(req).encodings([\n            \"br\",\n            \"gzip\",\n            \"deflate\"\n        ]);\n        const onError = (err)=>{\n            if (err) {\n                res.end();\n            }\n        };\n        switch(encoding){\n            case \"br\":\n                res.writeHead(200, {\n                    \"content-encoding\": \"br\"\n                });\n                (0, stream_1.pipeline)(readStream, (0, zlib_1.createBrotliCompress)(), res, onError);\n                break;\n            case \"gzip\":\n                res.writeHead(200, {\n                    \"content-encoding\": \"gzip\"\n                });\n                (0, stream_1.pipeline)(readStream, (0, zlib_1.createGzip)(), res, onError);\n                break;\n            case \"deflate\":\n                res.writeHead(200, {\n                    \"content-encoding\": \"deflate\"\n                });\n                (0, stream_1.pipeline)(readStream, (0, zlib_1.createDeflate)(), res, onError);\n                break;\n            default:\n                res.writeHead(200);\n                (0, stream_1.pipeline)(readStream, res, onError);\n        }\n    }\n    /**\n     * Binds socket.io to an engine.io instance.\n     *\n     * @param engine engine.io (or compatible) server\n     * @return self\n     */ bind(engine) {\n        // TODO apply strict types to the engine: \"connection\" event, `close()` and a method to serve static content\n        //  this would allow to provide any custom engine, like one based on Deno or Bun built-in HTTP server\n        this.engine = engine;\n        this.engine.on(\"connection\", this.onconnection.bind(this));\n        return this;\n    }\n    /**\n     * Called with each incoming transport connection.\n     *\n     * @param {engine.Socket} conn\n     * @return self\n     * @private\n     */ onconnection(conn) {\n        debug(\"incoming connection with id %s\", conn.id);\n        const client = new client_1.Client(this, conn);\n        if (conn.protocol === 3) {\n            // @ts-ignore\n            client.connect(\"/\");\n        }\n        return this;\n    }\n    /**\n     * Looks up a namespace.\n     *\n     * @example\n     * // with a simple string\n     * const myNamespace = io.of(\"/my-namespace\");\n     *\n     * // with a regex\n     * const dynamicNsp = io.of(/^\\/dynamic-\\d+$/).on(\"connection\", (socket) => {\n     *   const namespace = socket.nsp; // newNamespace.name === \"/dynamic-101\"\n     *\n     *   // broadcast to all clients in the given sub-namespace\n     *   namespace.emit(\"hello\");\n     * });\n     *\n     * @param name - nsp name\n     * @param fn optional, nsp `connection` ev handler\n     */ of(name, fn) {\n        if (typeof name === \"function\" || name instanceof RegExp) {\n            const parentNsp = new parent_namespace_1.ParentNamespace(this);\n            debug(\"initializing parent namespace %s\", parentNsp.name);\n            if (typeof name === \"function\") {\n                this.parentNsps.set(name, parentNsp);\n            } else {\n                this.parentNsps.set((nsp, conn, next)=>next(null, name.test(nsp)), parentNsp);\n                this.parentNamespacesFromRegExp.set(name, parentNsp);\n            }\n            if (fn) {\n                // @ts-ignore\n                parentNsp.on(\"connect\", fn);\n            }\n            return parentNsp;\n        }\n        if (String(name)[0] !== \"/\") name = \"/\" + name;\n        let nsp = this._nsps.get(name);\n        if (!nsp) {\n            for (const [regex, parentNamespace] of this.parentNamespacesFromRegExp){\n                if (regex.test(name)) {\n                    debug(\"attaching namespace %s to parent namespace %s\", name, regex);\n                    return parentNamespace.createChild(name);\n                }\n            }\n            debug(\"initializing namespace %s\", name);\n            nsp = new namespace_1.Namespace(this, name);\n            this._nsps.set(name, nsp);\n            if (name !== \"/\") {\n                // @ts-ignore\n                this.sockets.emitReserved(\"new_namespace\", nsp);\n            }\n        }\n        if (fn) nsp.on(\"connect\", fn);\n        return nsp;\n    }\n    /**\n     * Closes server connection\n     *\n     * @param [fn] optional, called as `fn([err])` on error OR all conns closed\n     */ async close(fn) {\n        await Promise.allSettled([\n            ...this._nsps.values()\n        ].map(async (nsp)=>{\n            nsp.sockets.forEach((socket)=>{\n                socket._onclose(\"server shutting down\");\n            });\n            await nsp.adapter.close();\n        }));\n        this.engine.close();\n        // restore the Adapter prototype, when the Socket.IO server was attached to a uWebSockets.js server\n        (0, uws_1.restoreAdapter)();\n        if (this.httpServer) {\n            this.httpServer.close(fn);\n        } else {\n            fn && fn();\n        }\n    }\n    /**\n     * Registers a middleware, which is a function that gets executed for every incoming {@link Socket}.\n     *\n     * @example\n     * io.use((socket, next) => {\n     *   // ...\n     *   next();\n     * });\n     *\n     * @param fn - the middleware function\n     */ use(fn) {\n        this.sockets.use(fn);\n        return this;\n    }\n    /**\n     * Targets a room when emitting.\n     *\n     * @example\n     * // the foo event will be broadcast to all connected clients in the room-101 room\n     * io.to(\"room-101\").emit(\"foo\", \"bar\");\n     *\n     * // with an array of rooms (a client will be notified at most once)\n     * io.to([\"room-101\", \"room-102\"]).emit(\"foo\", \"bar\");\n     *\n     * // with multiple chained calls\n     * io.to(\"room-101\").to(\"room-102\").emit(\"foo\", \"bar\");\n     *\n     * @param room - a room, or an array of rooms\n     * @return a new {@link BroadcastOperator} instance for chaining\n     */ to(room) {\n        return this.sockets.to(room);\n    }\n    /**\n     * Targets a room when emitting. Similar to `to()`, but might feel clearer in some cases:\n     *\n     * @example\n     * // disconnect all clients in the \"room-101\" room\n     * io.in(\"room-101\").disconnectSockets();\n     *\n     * @param room - a room, or an array of rooms\n     * @return a new {@link BroadcastOperator} instance for chaining\n     */ in(room) {\n        return this.sockets.in(room);\n    }\n    /**\n     * Excludes a room when emitting.\n     *\n     * @example\n     * // the \"foo\" event will be broadcast to all connected clients, except the ones that are in the \"room-101\" room\n     * io.except(\"room-101\").emit(\"foo\", \"bar\");\n     *\n     * // with an array of rooms\n     * io.except([\"room-101\", \"room-102\"]).emit(\"foo\", \"bar\");\n     *\n     * // with multiple chained calls\n     * io.except(\"room-101\").except(\"room-102\").emit(\"foo\", \"bar\");\n     *\n     * @param room - a room, or an array of rooms\n     * @return a new {@link BroadcastOperator} instance for chaining\n     */ except(room) {\n        return this.sockets.except(room);\n    }\n    /**\n     * Sends a `message` event to all clients.\n     *\n     * This method mimics the WebSocket.send() method.\n     *\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/send\n     *\n     * @example\n     * io.send(\"hello\");\n     *\n     * // this is equivalent to\n     * io.emit(\"message\", \"hello\");\n     *\n     * @return self\n     */ send(...args) {\n        // This type-cast is needed because EmitEvents likely doesn't have `message` as a key.\n        // if you specify the EmitEvents, the type of args will be never.\n        this.sockets.emit(\"message\", ...args);\n        return this;\n    }\n    /**\n     * Sends a `message` event to all clients. Alias of {@link send}.\n     *\n     * @return self\n     */ write(...args) {\n        // This type-cast is needed because EmitEvents likely doesn't have `message` as a key.\n        // if you specify the EmitEvents, the type of args will be never.\n        this.sockets.emit(\"message\", ...args);\n        return this;\n    }\n    /**\n     * Sends a message to the other Socket.IO servers of the cluster.\n     *\n     * @example\n     * io.serverSideEmit(\"hello\", \"world\");\n     *\n     * io.on(\"hello\", (arg1) => {\n     *   console.log(arg1); // prints \"world\"\n     * });\n     *\n     * // acknowledgements (without binary content) are supported too:\n     * io.serverSideEmit(\"ping\", (err, responses) => {\n     *  if (err) {\n     *     // some servers did not acknowledge the event in the given delay\n     *   } else {\n     *     console.log(responses); // one response per server (except the current one)\n     *   }\n     * });\n     *\n     * io.on(\"ping\", (cb) => {\n     *   cb(\"pong\");\n     * });\n     *\n     * @param ev - the event name\n     * @param args - an array of arguments, which may include an acknowledgement callback at the end\n     */ serverSideEmit(ev, ...args) {\n        return this.sockets.serverSideEmit(ev, ...args);\n    }\n    /**\n     * Sends a message and expect an acknowledgement from the other Socket.IO servers of the cluster.\n     *\n     * @example\n     * try {\n     *   const responses = await io.serverSideEmitWithAck(\"ping\");\n     *   console.log(responses); // one response per server (except the current one)\n     * } catch (e) {\n     *   // some servers did not acknowledge the event in the given delay\n     * }\n     *\n     * @param ev - the event name\n     * @param args - an array of arguments\n     *\n     * @return a Promise that will be fulfilled when all servers have acknowledged the event\n     */ serverSideEmitWithAck(ev, ...args) {\n        return this.sockets.serverSideEmitWithAck(ev, ...args);\n    }\n    /**\n     * Gets a list of socket ids.\n     *\n     * @deprecated this method will be removed in the next major release, please use {@link Server#serverSideEmit} or\n     * {@link Server#fetchSockets} instead.\n     */ allSockets() {\n        return this.sockets.allSockets();\n    }\n    /**\n     * Sets the compress flag.\n     *\n     * @example\n     * io.compress(false).emit(\"hello\");\n     *\n     * @param compress - if `true`, compresses the sending data\n     * @return a new {@link BroadcastOperator} instance for chaining\n     */ compress(compress) {\n        return this.sockets.compress(compress);\n    }\n    /**\n     * Sets a modifier for a subsequent event emission that the event data may be lost if the client is not ready to\n     * receive messages (because of network slowness or other issues, or because theyre connected through long polling\n     * and is in the middle of a request-response cycle).\n     *\n     * @example\n     * io.volatile.emit(\"hello\"); // the clients may or may not receive it\n     *\n     * @return a new {@link BroadcastOperator} instance for chaining\n     */ get volatile() {\n        return this.sockets.volatile;\n    }\n    /**\n     * Sets a modifier for a subsequent event emission that the event data will only be broadcast to the current node.\n     *\n     * @example\n     * // the foo event will be broadcast to all connected clients on this node\n     * io.local.emit(\"foo\", \"bar\");\n     *\n     * @return a new {@link BroadcastOperator} instance for chaining\n     */ get local() {\n        return this.sockets.local;\n    }\n    /**\n     * Adds a timeout in milliseconds for the next operation.\n     *\n     * @example\n     * io.timeout(1000).emit(\"some-event\", (err, responses) => {\n     *   if (err) {\n     *     // some clients did not acknowledge the event in the given delay\n     *   } else {\n     *     console.log(responses); // one response per client\n     *   }\n     * });\n     *\n     * @param timeout\n     */ timeout(timeout) {\n        return this.sockets.timeout(timeout);\n    }\n    /**\n     * Returns the matching socket instances.\n     *\n     * Note: this method also works within a cluster of multiple Socket.IO servers, with a compatible {@link Adapter}.\n     *\n     * @example\n     * // return all Socket instances\n     * const sockets = await io.fetchSockets();\n     *\n     * // return all Socket instances in the \"room1\" room\n     * const sockets = await io.in(\"room1\").fetchSockets();\n     *\n     * for (const socket of sockets) {\n     *   console.log(socket.id);\n     *   console.log(socket.handshake);\n     *   console.log(socket.rooms);\n     *   console.log(socket.data);\n     *\n     *   socket.emit(\"hello\");\n     *   socket.join(\"room1\");\n     *   socket.leave(\"room2\");\n     *   socket.disconnect();\n     * }\n     */ fetchSockets() {\n        return this.sockets.fetchSockets();\n    }\n    /**\n     * Makes the matching socket instances join the specified rooms.\n     *\n     * Note: this method also works within a cluster of multiple Socket.IO servers, with a compatible {@link Adapter}.\n     *\n     * @example\n     *\n     * // make all socket instances join the \"room1\" room\n     * io.socketsJoin(\"room1\");\n     *\n     * // make all socket instances in the \"room1\" room join the \"room2\" and \"room3\" rooms\n     * io.in(\"room1\").socketsJoin([\"room2\", \"room3\"]);\n     *\n     * @param room - a room, or an array of rooms\n     */ socketsJoin(room) {\n        return this.sockets.socketsJoin(room);\n    }\n    /**\n     * Makes the matching socket instances leave the specified rooms.\n     *\n     * Note: this method also works within a cluster of multiple Socket.IO servers, with a compatible {@link Adapter}.\n     *\n     * @example\n     * // make all socket instances leave the \"room1\" room\n     * io.socketsLeave(\"room1\");\n     *\n     * // make all socket instances in the \"room1\" room leave the \"room2\" and \"room3\" rooms\n     * io.in(\"room1\").socketsLeave([\"room2\", \"room3\"]);\n     *\n     * @param room - a room, or an array of rooms\n     */ socketsLeave(room) {\n        return this.sockets.socketsLeave(room);\n    }\n    /**\n     * Makes the matching socket instances disconnect.\n     *\n     * Note: this method also works within a cluster of multiple Socket.IO servers, with a compatible {@link Adapter}.\n     *\n     * @example\n     * // make all socket instances disconnect (the connections might be kept alive for other namespaces)\n     * io.disconnectSockets();\n     *\n     * // make all socket instances in the \"room1\" room disconnect and close the underlying connections\n     * io.in(\"room1\").disconnectSockets(true);\n     *\n     * @param close - whether to close the underlying connection\n     */ disconnectSockets(close = false) {\n        return this.sockets.disconnectSockets(close);\n    }\n}\nexports.Server = Server;\n/**\n * Expose main namespace (/).\n */ const emitterMethods = Object.keys(events_1.EventEmitter.prototype).filter(function(key) {\n    return typeof events_1.EventEmitter.prototype[key] === \"function\";\n});\nemitterMethods.forEach(function(fn) {\n    Server.prototype[fn] = function() {\n        return this.sockets[fn].apply(this.sockets, arguments);\n    };\n});\nmodule.exports = (srv, opts)=>new Server(srv, opts);\nmodule.exports.Server = Server;\nmodule.exports.Namespace = namespace_1.Namespace;\nmodule.exports.Socket = socket_1.Socket;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc29ja2V0LmlvL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYixJQUFJQSxrQkFBa0IsQ0FBQyxNQUFHLEtBQUssT0FBRyxFQUFFQSxlQUFlLElBQU1DLENBQUFBLE9BQU9DLE1BQU0sR0FBSSxTQUFTQyxDQUFDLEVBQUVDLENBQUMsRUFBRUMsQ0FBQyxFQUFFQyxFQUFFO0lBQzFGLElBQUlBLE9BQU9DLFdBQVdELEtBQUtEO0lBQzNCLElBQUlHLE9BQU9QLE9BQU9RLHdCQUF3QixDQUFDTCxHQUFHQztJQUM5QyxJQUFJLENBQUNHLFFBQVMsVUFBU0EsT0FBTyxDQUFDSixFQUFFTSxVQUFVLEdBQUdGLEtBQUtHLFFBQVEsSUFBSUgsS0FBS0ksWUFBWSxHQUFHO1FBQ2pGSixPQUFPO1lBQUVLLFlBQVk7WUFBTUMsS0FBSztnQkFBYSxPQUFPVixDQUFDLENBQUNDLEVBQUU7WUFBRTtRQUFFO0lBQzlEO0lBQ0FKLE9BQU9jLGNBQWMsQ0FBQ1osR0FBR0csSUFBSUU7QUFDakMsSUFBTSxTQUFTTCxDQUFDLEVBQUVDLENBQUMsRUFBRUMsQ0FBQyxFQUFFQyxFQUFFO0lBQ3RCLElBQUlBLE9BQU9DLFdBQVdELEtBQUtEO0lBQzNCRixDQUFDLENBQUNHLEdBQUcsR0FBR0YsQ0FBQyxDQUFDQyxFQUFFO0FBQ2hCLENBQUM7QUFDRCxJQUFJVyxxQkFBcUIsQ0FBQyxNQUFHLEtBQUssT0FBRyxFQUFFQSxrQkFBa0IsSUFBTWYsQ0FBQUEsT0FBT0MsTUFBTSxHQUFJLFNBQVNDLENBQUMsRUFBRWMsQ0FBQztJQUN6RmhCLE9BQU9jLGNBQWMsQ0FBQ1osR0FBRyxXQUFXO1FBQUVVLFlBQVk7UUFBTUssT0FBT0Q7SUFBRTtBQUNyRSxJQUFLLFNBQVNkLENBQUMsRUFBRWMsQ0FBQztJQUNkZCxDQUFDLENBQUMsVUFBVSxHQUFHYztBQUNuQjtBQUNBLElBQUlFLGVBQWUsQ0FBQyxNQUFHLEtBQUssT0FBRyxFQUFFQSxZQUFZLElB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Ozs7Ozs7Ozs7S0FjQyxHQUNEQyxZQUFZaEIsSUFBSSxFQUFFO1FBQ2QsT0FBTyxJQUFJLENBQUNsSCxPQUFPLENBQUNrSSxXQUFXLENBQUNoQjtJQUNwQztJQUNBOzs7Ozs7Ozs7Ozs7O0tBYUMsR0FDRGlCLGFBQWFqQixJQUFJLEVBQUU7UUFDZixPQUFPLElBQUksQ0FBQ2xILE9BQU8sQ0FBQ21JLFlBQVksQ0FBQ2pCO0lBQ3JDO0lBQ0E7Ozs7Ozs7Ozs7Ozs7S0FhQyxHQUNEa0Isa0JBQWtCNUIsUUFBUSxLQUFLLEVBQUU7UUFDN0IsT0FBTyxJQUFJLENBQUN4RyxPQUFPLENBQUNvSSxpQkFBaUIsQ0FBQzVCO0lBQzFDO0FBQ0o7QUFDQTFKLGNBQWMsR0FBR0c7QUFDakI7O0NBRUMsR0FDRCxNQUFNb0wsaUJBQWlCaE4sT0FBTzBGLElBQUksQ0FBQ3BELFNBQVMySyxZQUFZLENBQUM1TCxTQUFTLEVBQUU2TCxNQUFNLENBQUMsU0FBVUMsR0FBRztJQUNwRixPQUFPLE9BQU83SyxTQUFTMkssWUFBWSxDQUFDNUwsU0FBUyxDQUFDOEwsSUFBSSxLQUFLO0FBQzNEO0FBQ0FILGVBQWV6QixPQUFPLENBQUMsU0FBVWhHLEVBQUU7SUFDL0IzRCxPQUFPUCxTQUFTLENBQUNrRSxHQUFHLEdBQUc7UUFDbkIsT0FBTyxJQUFJLENBQUNaLE9BQU8sQ0FBQ1ksR0FBRyxDQUFDNkgsS0FBSyxDQUFDLElBQUksQ0FBQ3pJLE9BQU8sRUFBRU07SUFDaEQ7QUFDSjtBQUNBb0ksT0FBTzVMLE9BQU8sR0FBRyxDQUFDOEIsS0FBS0MsT0FBUyxJQUFJNUIsT0FBTzJCLEtBQUtDO0FBQ2hENkoscUJBQXFCLEdBQUd6TDtBQUN4QnlMLHdCQUF3QixHQUFHOUssWUFBWWIsU0FBUztBQUNoRDJMLHFCQUFxQixHQUFHekssU0FBU2pCLE1BQU0iLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9leGFtcm9zaC8uL25vZGVfbW9kdWxlcy9zb2NrZXQuaW8vZGlzdC9pbmRleC5qcz8zNWFjIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX3NldE1vZHVsZURlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdCkgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgdikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcbn0pIDogZnVuY3Rpb24obywgdikge1xuICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcbn0pO1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xuICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLk5hbWVzcGFjZSA9IGV4cG9ydHMuU29ja2V0ID0gZXhwb3J0cy5TZXJ2ZXIgPSB2b2lkIDA7XG5jb25zdCBodHRwID0gcmVxdWlyZShcImh0dHBcIik7XG5jb25zdCBmc18xID0gcmVxdWlyZShcImZzXCIpO1xuY29uc3QgemxpYl8xID0gcmVxdWlyZShcInpsaWJcIik7XG5jb25zdCBhY2NlcHRzID0gcmVxdWlyZShcImFjY2VwdHNcIik7XG5jb25zdCBzdHJlYW1fMSA9IHJlcXVpcmUoXCJzdHJlYW1cIik7XG5jb25zdCBwYXRoID0gcmVxdWlyZShcInBhdGhcIik7XG5jb25zdCBlbmdpbmVfaW9fMSA9IHJlcXVpcmUoXCJlbmdpbmUuaW9cIik7XG5jb25zdCBjbGllbnRfMSA9IHJlcXVpcmUoXCIuL2NsaWVudFwiKTtcbmNvbnN0IGV2ZW50c18xID0gcmVxdWlyZShcImV2ZW50c1wiKTtcbmNvbnN0IG5hbWVzcGFjZV8xID0gcmVxdWlyZShcIi4vbmFtZXNwYWNlXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTmFtZXNwYWNlXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBuYW1lc3BhY2VfMS5OYW1lc3BhY2U7IH0gfSk7XG5jb25zdCBwYXJlbnRfbmFtZXNwYWNlXzEgPSByZXF1aXJlKFwiLi9wYXJlbnQtbmFtZXNwYWNlXCIpO1xuY29uc3Qgc29ja2V0X2lvX2FkYXB0ZXJfMSA9IHJlcXVpcmUoXCJzb2NrZXQuaW8tYWRhcHRlclwiKTtcbmNvbnN0IHBhcnNlciA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwic29ja2V0LmlvLXBhcnNlclwiKSk7XG5jb25zdCBkZWJ1Z18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJkZWJ1Z1wiKSk7XG5jb25zdCBzb2NrZXRfMSA9IHJlcXVpcmUoXCIuL3NvY2tldFwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlNvY2tldFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gc29ja2V0XzEuU29ja2V0OyB9IH0pO1xuY29uc3QgdHlwZWRfZXZlbnRzXzEgPSByZXF1aXJlKFwiLi90eXBlZC1ldmVudHNcIik7XG5jb25zdCB1d3NfMSA9IHJlcXVpcmUoXCIuL3V3c1wiKTtcbmNvbnN0IGNvcnNfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiY29yc1wiKSk7XG5jb25zdCBkZWJ1ZyA9ICgwLCBkZWJ1Z18xLmRlZmF1bHQpKFwic29ja2V0LmlvOnNlcnZlclwiKTtcbmNvbnN0IGNsaWVudFZlcnNpb24gPSByZXF1aXJlKFwiLi4vcGFja2FnZS5qc29uXCIpLnZlcnNpb247XG5jb25zdCBkb3RNYXBSZWdleCA9IC9cXC5tYXAvO1xuLyoqXG4gKiBSZXByZXNlbnRzIGEgU29ja2V0LklPIHNlcnZlci5cbiAqXG4gKiBAZXhhbXBsZVxuICogaW1wb3J0IHsgU2VydmVyIH0gZnJvbSBcInNvY2tldC5pb1wiO1xuICpcbiAqIGNvbnN0IGlvID0gbmV3IFNlcnZlcigpO1xuICpcbiAqIGlvLm9uKFwiY29ubmVjdGlvblwiLCAoc29ja2V0KSA9PiB7XG4gKiAgIGNvbnNvbGUubG9nKGBzb2NrZXQgJHtzb2NrZXQuaWR9IGNvbm5lY3RlZGApO1xuICpcbiAqICAgLy8gc2VuZCBhbiBldmVudCB0byB0aGUgY2xpZW50XG4gKiAgIHNvY2tldC5lbWl0KFwiZm9vXCIsIFwiYmFyXCIpO1xuICpcbiAqICAgc29ja2V0Lm9uKFwiZm9vYmFyXCIsICgpID0+IHtcbiAqICAgICAvLyBhbiBldmVudCB3YXMgcmVjZWl2ZWQgZnJvbSB0aGUgY2xpZW50XG4gKiAgIH0pO1xuICpcbiAqICAgLy8gdXBvbiBkaXNjb25uZWN0aW9uXG4gKiAgIHNvY2tldC5vbihcImRpc2Nvbm5lY3RcIiwgKHJlYXNvbikgPT4ge1xuICogICAgIGNvbnNvbGUubG9nKGBzb2NrZXQgJHtzb2NrZXQuaWR9IGRpc2Nvbm5lY3RlZCBkdWUgdG8gJHtyZWFzb259YCk7XG4gKiAgIH0pO1xuICogfSk7XG4gKlxuICogaW8ubGlzdGVuKDMwMDApO1xuICovXG5jbGFzcyBTZXJ2ZXIgZXh0ZW5kcyB0eXBlZF9ldmVudHNfMS5TdHJpY3RFdmVudEVtaXR0ZXIge1xuICAgIGNvbnN0cnVjdG9yKHNydiwgb3B0cyA9IHt9KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fbnNwcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5wYXJlbnROc3BzID0gbmV3IE1hcCgpO1xuICAgICAgICAvKipcbiAgICAgICAgICogQSBzdWJzZXQgb2YgdGhlIHtAbGluayBwYXJlbnROc3BzfSBtYXAsIG9ubHkgY29udGFpbmluZyB7QGxpbmsgUGFyZW50TmFtZXNwYWNlfSB3aGljaCBhcmUgYmFzZWQgb24gYSByZWd1bGFyXG4gICAgICAgICAqIGV4cHJlc3Npb24uXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnBhcmVudE5hbWVzcGFjZXNGcm9tUmVnRXhwID0gbmV3IE1hcCgpO1xuICAgICAgICBpZiAoXCJvYmplY3RcIiA9PT0gdHlwZW9mIHNydiAmJlxuICAgICAgICAgICAgc3J2IGluc3RhbmNlb2YgT2JqZWN0ICYmXG4gICAgICAgICAgICAhc3J2Lmxpc3Rlbikge1xuICAgICAgICAgICAgb3B0cyA9IHNydjtcbiAgICAgICAgICAgIHNydiA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnBhdGgob3B0cy5wYXRoIHx8IFwiL3NvY2tldC5pb1wiKTtcbiAgICAgICAgdGhpcy5jb25uZWN0VGltZW91dChvcHRzLmNvbm5lY3RUaW1lb3V0IHx8IDQ1MDAwKTtcbiAgICAgICAgdGhpcy5zZXJ2ZUNsaWVudChmYWxzZSAhPT0gb3B0cy5zZXJ2ZUNsaWVudCk7XG4gICAgICAgIHRoaXMuX3BhcnNlciA9IG9wdHMucGFyc2VyIHx8IHBhcnNlcjtcbiAgICAgICAgdGhpcy5lbmNvZGVyID0gbmV3IHRoaXMuX3BhcnNlci5FbmNvZGVyKCk7XG4gICAgICAgIHRoaXMub3B0cyA9IG9wdHM7XG4gICAgICAgIGlmIChvcHRzLmNvbm5lY3Rpb25TdGF0ZVJlY292ZXJ5KSB7XG4gICAgICAgICAgICBvcHRzLmNvbm5lY3Rpb25TdGF0ZVJlY292ZXJ5ID0gT2JqZWN0LmFzc2lnbih7XG4gICAgICAgICAgICAgICAgbWF4RGlzY29ubmVjdGlvbkR1cmF0aW9uOiAyICogNjAgKiAxMDAwLFxuICAgICAgICAgICAgICAgIHNraXBNaWRkbGV3YXJlczogdHJ1ZSxcbiAgICAgICAgICAgIH0sIG9wdHMuY29ubmVjdGlvblN0YXRlUmVjb3ZlcnkpO1xuICAgICAgICAgICAgdGhpcy5hZGFwdGVyKG9wdHMuYWRhcHRlciB8fCBzb2NrZXRfaW9fYWRhcHRlcl8xLlNlc3Npb25Bd2FyZUFkYXB0ZXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5hZGFwdGVyKG9wdHMuYWRhcHRlciB8fCBzb2NrZXRfaW9fYWRhcHRlcl8xLkFkYXB0ZXIpO1xuICAgICAgICB9XG4gICAgICAgIG9wdHMuY2xlYW51cEVtcHR5Q2hpbGROYW1lc3BhY2VzID0gISFvcHRzLmNsZWFudXBFbXB0eUNoaWxkTmFtZXNwYWNlcztcbiAgICAgICAgdGhpcy5zb2NrZXRzID0gdGhpcy5vZihcIi9cIik7XG4gICAgICAgIGlmIChzcnYgfHwgdHlwZW9mIHNydiA9PSBcIm51bWJlclwiKVxuICAgICAgICAgICAgdGhpcy5hdHRhY2goc3J2KTtcbiAgICAgICAgaWYgKHRoaXMub3B0cy5jb3JzKSB7XG4gICAgICAgICAgICB0aGlzLl9jb3JzTWlkZGxld2FyZSA9ICgwLCBjb3JzXzEuZGVmYXVsdCkodGhpcy5vcHRzLmNvcnMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBfb3B0cygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3B0cztcbiAgICB9XG4gICAgc2VydmVDbGllbnQodikge1xuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc2VydmVDbGllbnQ7XG4gICAgICAgIHRoaXMuX3NlcnZlQ2xpZW50ID0gdjtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEV4ZWN1dGVzIHRoZSBtaWRkbGV3YXJlIGZvciBhbiBpbmNvbWluZyBuYW1lc3BhY2Ugbm90IGFscmVhZHkgY3JlYXRlZCBvbiB0aGUgc2VydmVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIG5hbWUgLSBuYW1lIG9mIGluY29taW5nIG5hbWVzcGFjZVxuICAgICAqIEBwYXJhbSBhdXRoIC0gdGhlIGF1dGggcGFyYW1ldGVyc1xuICAgICAqIEBwYXJhbSBmbiAtIGNhbGxiYWNrXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9jaGVja05hbWVzcGFjZShuYW1lLCBhdXRoLCBmbikge1xuICAgICAgICBpZiAodGhpcy5wYXJlbnROc3BzLnNpemUgPT09IDApXG4gICAgICAgICAgICByZXR1cm4gZm4oZmFsc2UpO1xuICAgICAgICBjb25zdCBrZXlzSXRlcmF0b3IgPSB0aGlzLnBhcmVudE5zcHMua2V5cygpO1xuICAgICAgICBjb25zdCBydW4gPSAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBuZXh0Rm4gPSBrZXlzSXRlcmF0b3IubmV4dCgpO1xuICAgICAgICAgICAgaWYgKG5leHRGbi5kb25lKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZuKGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5leHRGbi52YWx1ZShuYW1lLCBhdXRoLCAoZXJyLCBhbGxvdykgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChlcnIgfHwgIWFsbG93KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBydW4oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX25zcHMuaGFzKG5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHRoZSBuYW1lc3BhY2Ugd2FzIGNyZWF0ZWQgaW4gdGhlIG1lYW50aW1lXG4gICAgICAgICAgICAgICAgICAgIGRlYnVnKFwiZHluYW1pYyBuYW1lc3BhY2UgJXMgYWxyZWFkeSBleGlzdHNcIiwgbmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmbih0aGlzLl9uc3BzLmdldChuYW1lKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IG5hbWVzcGFjZSA9IHRoaXMucGFyZW50TnNwcy5nZXQobmV4dEZuLnZhbHVlKS5jcmVhdGVDaGlsZChuYW1lKTtcbiAgICAgICAgICAgICAgICBkZWJ1ZyhcImR5bmFtaWMgbmFtZXNwYWNlICVzIHdhcyBjcmVhdGVkXCIsIG5hbWUpO1xuICAgICAgICAgICAgICAgIGZuKG5hbWVzcGFjZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgcnVuKCk7XG4gICAgfVxuICAgIHBhdGgodikge1xuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcGF0aDtcbiAgICAgICAgdGhpcy5fcGF0aCA9IHYucmVwbGFjZSgvXFwvJC8sIFwiXCIpO1xuICAgICAgICBjb25zdCBlc2NhcGVkUGF0aCA9IHRoaXMuX3BhdGgucmVwbGFjZSgvWy1cXC9cXFxcXiQqKz8uKCl8W1xcXXt9XS9nLCBcIlxcXFwkJlwiKTtcbiAgICAgICAgdGhpcy5jbGllbnRQYXRoUmVnZXggPSBuZXcgUmVnRXhwKFwiXlwiICtcbiAgICAgICAgICAgIGVzY2FwZWRQYXRoICtcbiAgICAgICAgICAgIFwiL3NvY2tldFxcXFwuaW8oXFxcXC5tc2dwYWNrfFxcXFwuZXNtKT8oXFxcXC5taW4pP1xcXFwuanMoXFxcXC5tYXApPyg/OlxcXFw/fCQpXCIpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgY29ubmVjdFRpbWVvdXQodikge1xuICAgICAgICBpZiAodiA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2Nvbm5lY3RUaW1lb3V0O1xuICAgICAgICB0aGlzLl9jb25uZWN0VGltZW91dCA9IHY7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBhZGFwdGVyKHYpIHtcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2FkYXB0ZXI7XG4gICAgICAgIHRoaXMuX2FkYXB0ZXIgPSB2O1xuICAgICAgICBmb3IgKGNvbnN0IG5zcCBvZiB0aGlzLl9uc3BzLnZhbHVlcygpKSB7XG4gICAgICAgICAgICBuc3AuX2luaXRBZGFwdGVyKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEF0dGFjaGVzIHNvY2tldC5pbyB0byBhIHNlcnZlciBvciBwb3J0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHNydiAtIHNlcnZlciBvciBwb3J0XG4gICAgICogQHBhcmFtIG9wdHMgLSBvcHRpb25zIHBhc3NlZCB0byBlbmdpbmUuaW9cbiAgICAgKiBAcmV0dXJuIHNlbGZcbiAgICAgKi9cbiAgICBsaXN0ZW4oc3J2LCBvcHRzID0ge30pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXR0YWNoKHNydiwgb3B0cyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEF0dGFjaGVzIHNvY2tldC5pbyB0byBhIHNlcnZlciBvciBwb3J0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHNydiAtIHNlcnZlciBvciBwb3J0XG4gICAgICogQHBhcmFtIG9wdHMgLSBvcHRpb25zIHBhc3NlZCB0byBlbmdpbmUuaW9cbiAgICAgKiBAcmV0dXJuIHNlbGZcbiAgICAgKi9cbiAgICBhdHRhY2goc3J2LCBvcHRzID0ge30pIHtcbiAgICAgICAgaWYgKFwiZnVuY3Rpb25cIiA9PSB0eXBlb2Ygc3J2KSB7XG4gICAgICAgICAgICBjb25zdCBtc2cgPSBcIllvdSBhcmUgdHJ5aW5nIHRvIGF0dGFjaCBzb2NrZXQuaW8gdG8gYW4gZXhwcmVzcyBcIiArXG4gICAgICAgICAgICAgICAgXCJyZXF1ZXN0IGhhbmRsZXIgZnVuY3Rpb24uIFBsZWFzZSBwYXNzIGEgaHR0cC5TZXJ2ZXIgaW5zdGFuY2UuXCI7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBoYW5kbGUgYSBwb3J0IGFzIGEgc3RyaW5nXG4gICAgICAgIGlmIChOdW1iZXIoc3J2KSA9PSBzcnYpIHtcbiAgICAgICAgICAgIHNydiA9IE51bWJlcihzcnYpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChcIm51bWJlclwiID09IHR5cGVvZiBzcnYpIHtcbiAgICAgICAgICAgIGRlYnVnKFwiY3JlYXRpbmcgaHR0cCBzZXJ2ZXIgYW5kIGJpbmRpbmcgdG8gJWRcIiwgc3J2KTtcbiAgICAgICAgICAgIGNvbnN0IHBvcnQgPSBzcnY7XG4gICAgICAgICAgICBzcnYgPSBodHRwLmNyZWF0ZVNlcnZlcigocmVxLCByZXMpID0+IHtcbiAgICAgICAgICAgICAgICByZXMud3JpdGVIZWFkKDQwNCk7XG4gICAgICAgICAgICAgICAgcmVzLmVuZCgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzcnYubGlzdGVuKHBvcnQpO1xuICAgICAgICB9XG4gICAgICAgIC8vIG1lcmdlIHRoZSBvcHRpb25zIHBhc3NlZCB0byB0aGUgU29ja2V0LklPIHNlcnZlclxuICAgICAgICBPYmplY3QuYXNzaWduKG9wdHMsIHRoaXMub3B0cyk7XG4gICAgICAgIC8vIHNldCBlbmdpbmUuaW8gcGF0aCB0byBgL3NvY2tldC5pb2BcbiAgICAgICAgb3B0cy5wYXRoID0gb3B0cy5wYXRoIHx8IHRoaXMuX3BhdGg7XG4gICAgICAgIHRoaXMuaW5pdEVuZ2luZShzcnYsIG9wdHMpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgYXR0YWNoQXBwKGFwcCAvKjogVGVtcGxhdGVkQXBwICovLCBvcHRzID0ge30pIHtcbiAgICAgICAgLy8gbWVyZ2UgdGhlIG9wdGlvbnMgcGFzc2VkIHRvIHRoZSBTb2NrZXQuSU8gc2VydmVyXG4gICAgICAgIE9iamVjdC5hc3NpZ24ob3B0cywgdGhpcy5vcHRzKTtcbiAgICAgICAgLy8gc2V0IGVuZ2luZS5pbyBwYXRoIHRvIGAvc29ja2V0LmlvYFxuICAgICAgICBvcHRzLnBhdGggPSBvcHRzLnBhdGggfHwgdGhpcy5fcGF0aDtcbiAgICAgICAgLy8gaW5pdGlhbGl6ZSBlbmdpbmVcbiAgICAgICAgZGVidWcoXCJjcmVhdGluZyB1V2ViU29ja2V0cy5qcy1iYXNlZCBlbmdpbmUgd2l0aCBvcHRzICVqXCIsIG9wdHMpO1xuICAgICAgICBjb25zdCBlbmdpbmUgPSBuZXcgZW5naW5lX2lvXzEudVNlcnZlcihvcHRzKTtcbiAgICAgICAgZW5naW5lLmF0dGFjaChhcHAsIG9wdHMpO1xuICAgICAgICAvLyBiaW5kIHRvIGVuZ2luZSBldmVudHNcbiAgICAgICAgdGhpcy5iaW5kKGVuZ2luZSk7XG4gICAgICAgIGlmICh0aGlzLl9zZXJ2ZUNsaWVudCkge1xuICAgICAgICAgICAgLy8gYXR0YWNoIHN0YXRpYyBmaWxlIHNlcnZpbmdcbiAgICAgICAgICAgIGFwcC5nZXQoYCR7dGhpcy5fcGF0aH0vKmAsIChyZXMsIHJlcSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5jbGllbnRQYXRoUmVnZXgudGVzdChyZXEuZ2V0VXJsKCkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlcS5zZXRZaWVsZCh0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBmaWxlbmFtZSA9IHJlcVxuICAgICAgICAgICAgICAgICAgICAuZ2V0VXJsKClcbiAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UodGhpcy5fcGF0aCwgXCJcIilcbiAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcPy4qJC8sIFwiXCIpXG4gICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9eXFwvLywgXCJcIik7XG4gICAgICAgICAgICAgICAgY29uc3QgaXNNYXAgPSBkb3RNYXBSZWdleC50ZXN0KGZpbGVuYW1lKTtcbiAgICAgICAgICAgICAgICBjb25zdCB0eXBlID0gaXNNYXAgPyBcIm1hcFwiIDogXCJzb3VyY2VcIjtcbiAgICAgICAgICAgICAgICAvLyBQZXIgdGhlIHN0YW5kYXJkLCBFVGFncyBtdXN0IGJlIHF1b3RlZDpcbiAgICAgICAgICAgICAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNzIzMiNzZWN0aW9uLTIuM1xuICAgICAgICAgICAgICAgIGNvbnN0IGV4cGVjdGVkRXRhZyA9ICdcIicgKyBjbGllbnRWZXJzaW9uICsgJ1wiJztcbiAgICAgICAgICAgICAgICBjb25zdCB3ZWFrRXRhZyA9IFwiVy9cIiArIGV4cGVjdGVkRXRhZztcbiAgICAgICAgICAgICAgICBjb25zdCBldGFnID0gcmVxLmdldEhlYWRlcihcImlmLW5vbmUtbWF0Y2hcIik7XG4gICAgICAgICAgICAgICAgaWYgKGV0YWcpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGV4cGVjdGVkRXRhZyA9PT0gZXRhZyB8fCB3ZWFrRXRhZyA9PT0gZXRhZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVidWcoXCJzZXJ2ZSBjbGllbnQgJXMgMzA0XCIsIHR5cGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzLndyaXRlU3RhdHVzKFwiMzA0IE5vdCBNb2RpZmllZFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcy5lbmQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkZWJ1ZyhcInNlcnZlIGNsaWVudCAlc1wiLCB0eXBlKTtcbiAgICAgICAgICAgICAgICByZXMud3JpdGVIZWFkZXIoXCJjYWNoZS1jb250cm9sXCIsIFwicHVibGljLCBtYXgtYWdlPTBcIik7XG4gICAgICAgICAgICAgICAgcmVzLndyaXRlSGVhZGVyKFwiY29udGVudC10eXBlXCIsIFwiYXBwbGljYXRpb24vXCIgKyAoaXNNYXAgPyBcImpzb25cIiA6IFwiamF2YXNjcmlwdFwiKSArIFwiOyBjaGFyc2V0PXV0Zi04XCIpO1xuICAgICAgICAgICAgICAgIHJlcy53cml0ZUhlYWRlcihcImV0YWdcIiwgZXhwZWN0ZWRFdGFnKTtcbiAgICAgICAgICAgICAgICBjb25zdCBmaWxlcGF0aCA9IHBhdGguam9pbihfX2Rpcm5hbWUsIFwiLi4vY2xpZW50LWRpc3QvXCIsIGZpbGVuYW1lKTtcbiAgICAgICAgICAgICAgICAoMCwgdXdzXzEuc2VydmVGaWxlKShyZXMsIGZpbGVwYXRoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgICgwLCB1d3NfMS5wYXRjaEFkYXB0ZXIpKGFwcCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemUgZW5naW5lXG4gICAgICpcbiAgICAgKiBAcGFyYW0gc3J2IC0gdGhlIHNlcnZlciB0byBhdHRhY2ggdG9cbiAgICAgKiBAcGFyYW0gb3B0cyAtIG9wdGlvbnMgcGFzc2VkIHRvIGVuZ2luZS5pb1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgaW5pdEVuZ2luZShzcnYsIG9wdHMpIHtcbiAgICAgICAgLy8gaW5pdGlhbGl6ZSBlbmdpbmVcbiAgICAgICAgZGVidWcoXCJjcmVhdGluZyBlbmdpbmUuaW8gaW5zdGFuY2Ugd2l0aCBvcHRzICVqXCIsIG9wdHMpO1xuICAgICAgICB0aGlzLmVpbyA9ICgwLCBlbmdpbmVfaW9fMS5hdHRhY2gpKHNydiwgb3B0cyk7XG4gICAgICAgIC8vIGF0dGFjaCBzdGF0aWMgZmlsZSBzZXJ2aW5nXG4gICAgICAgIGlmICh0aGlzLl9zZXJ2ZUNsaWVudClcbiAgICAgICAgICAgIHRoaXMuYXR0YWNoU2VydmUoc3J2KTtcbiAgICAgICAgLy8gRXhwb3J0IGh0dHAgc2VydmVyXG4gICAgICAgIHRoaXMuaHR0cFNlcnZlciA9IHNydjtcbiAgICAgICAgLy8gYmluZCB0byBlbmdpbmUgZXZlbnRzXG4gICAgICAgIHRoaXMuYmluZCh0aGlzLmVpbyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEF0dGFjaGVzIHRoZSBzdGF0aWMgZmlsZSBzZXJ2aW5nLlxuICAgICAqXG4gICAgICogQHBhcmFtIHNydiBodHRwIHNlcnZlclxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgYXR0YWNoU2VydmUoc3J2KSB7XG4gICAgICAgIGRlYnVnKFwiYXR0YWNoaW5nIGNsaWVudCBzZXJ2aW5nIHJlcSBoYW5kbGVyXCIpO1xuICAgICAgICBjb25zdCBldnMgPSBzcnYubGlzdGVuZXJzKFwicmVxdWVzdFwiKS5zbGljZSgwKTtcbiAgICAgICAgc3J2LnJlbW92ZUFsbExpc3RlbmVycyhcInJlcXVlc3RcIik7XG4gICAgICAgIHNydi5vbihcInJlcXVlc3RcIiwgKHJlcSwgcmVzKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5jbGllbnRQYXRoUmVnZXgudGVzdChyZXEudXJsKSkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9jb3JzTWlkZGxld2FyZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jb3JzTWlkZGxld2FyZShyZXEsIHJlcywgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXJ2ZShyZXEsIHJlcyk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXJ2ZShyZXEsIHJlcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBldnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgZXZzW2ldLmNhbGwoc3J2LCByZXEsIHJlcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSGFuZGxlcyBhIHJlcXVlc3Qgc2VydmluZyBvZiBjbGllbnQgc291cmNlIGFuZCBtYXBcbiAgICAgKlxuICAgICAqIEBwYXJhbSByZXFcbiAgICAgKiBAcGFyYW0gcmVzXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBzZXJ2ZShyZXEsIHJlcykge1xuICAgICAgICBjb25zdCBmaWxlbmFtZSA9IHJlcS51cmwucmVwbGFjZSh0aGlzLl9wYXRoLCBcIlwiKS5yZXBsYWNlKC9cXD8uKiQvLCBcIlwiKTtcbiAgICAgICAgY29uc3QgaXNNYXAgPSBkb3RNYXBSZWdleC50ZXN0KGZpbGVuYW1lKTtcbiAgICAgICAgY29uc3QgdHlwZSA9IGlzTWFwID8gXCJtYXBcIiA6IFwic291cmNlXCI7XG4gICAgICAgIC8vIFBlciB0aGUgc3RhbmRhcmQsIEVUYWdzIG11c3QgYmUgcXVvdGVkOlxuICAgICAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNzIzMiNzZWN0aW9uLTIuM1xuICAgICAgICBjb25zdCBleHBlY3RlZEV0YWcgPSAnXCInICsgY2xpZW50VmVyc2lvbiArICdcIic7XG4gICAgICAgIGNvbnN0IHdlYWtFdGFnID0gXCJXL1wiICsgZXhwZWN0ZWRFdGFnO1xuICAgICAgICBjb25zdCBldGFnID0gcmVxLmhlYWRlcnNbXCJpZi1ub25lLW1hdGNoXCJdO1xuICAgICAgICBpZiAoZXRhZykge1xuICAgICAgICAgICAgaWYgKGV4cGVjdGVkRXRhZyA9PT0gZXRhZyB8fCB3ZWFrRXRhZyA9PT0gZXRhZykge1xuICAgICAgICAgICAgICAgIGRlYnVnKFwic2VydmUgY2xpZW50ICVzIDMwNFwiLCB0eXBlKTtcbiAgICAgICAgICAgICAgICByZXMud3JpdGVIZWFkKDMwNCk7XG4gICAgICAgICAgICAgICAgcmVzLmVuZCgpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBkZWJ1ZyhcInNlcnZlIGNsaWVudCAlc1wiLCB0eXBlKTtcbiAgICAgICAgcmVzLnNldEhlYWRlcihcIkNhY2hlLUNvbnRyb2xcIiwgXCJwdWJsaWMsIG1heC1hZ2U9MFwiKTtcbiAgICAgICAgcmVzLnNldEhlYWRlcihcIkNvbnRlbnQtVHlwZVwiLCBcImFwcGxpY2F0aW9uL1wiICsgKGlzTWFwID8gXCJqc29uXCIgOiBcImphdmFzY3JpcHRcIikgKyBcIjsgY2hhcnNldD11dGYtOFwiKTtcbiAgICAgICAgcmVzLnNldEhlYWRlcihcIkVUYWdcIiwgZXhwZWN0ZWRFdGFnKTtcbiAgICAgICAgU2VydmVyLnNlbmRGaWxlKGZpbGVuYW1lLCByZXEsIHJlcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmaWxlbmFtZVxuICAgICAqIEBwYXJhbSByZXFcbiAgICAgKiBAcGFyYW0gcmVzXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBzdGF0aWMgc2VuZEZpbGUoZmlsZW5hbWUsIHJlcSwgcmVzKSB7XG4gICAgICAgIGNvbnN0IHJlYWRTdHJlYW0gPSAoMCwgZnNfMS5jcmVhdGVSZWFkU3RyZWFtKShwYXRoLmpvaW4oX19kaXJuYW1lLCBcIi4uL2NsaWVudC1kaXN0L1wiLCBmaWxlbmFtZSkpO1xuICAgICAgICBjb25zdCBlbmNvZGluZyA9IGFjY2VwdHMocmVxKS5lbmNvZGluZ3MoW1wiYnJcIiwgXCJnemlwXCIsIFwiZGVmbGF0ZVwiXSk7XG4gICAgICAgIGNvbnN0IG9uRXJyb3IgPSAoZXJyKSA9PiB7XG4gICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgcmVzLmVuZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICAgICAgICBjYXNlIFwiYnJcIjpcbiAgICAgICAgICAgICAgICByZXMud3JpdGVIZWFkKDIwMCwgeyBcImNvbnRlbnQtZW5jb2RpbmdcIjogXCJiclwiIH0pO1xuICAgICAgICAgICAgICAgICgwLCBzdHJlYW1fMS5waXBlbGluZSkocmVhZFN0cmVhbSwgKDAsIHpsaWJfMS5jcmVhdGVCcm90bGlDb21wcmVzcykoKSwgcmVzLCBvbkVycm9yKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJnemlwXCI6XG4gICAgICAgICAgICAgICAgcmVzLndyaXRlSGVhZCgyMDAsIHsgXCJjb250ZW50LWVuY29kaW5nXCI6IFwiZ3ppcFwiIH0pO1xuICAgICAgICAgICAgICAgICgwLCBzdHJlYW1fMS5waXBlbGluZSkocmVhZFN0cmVhbSwgKDAsIHpsaWJfMS5jcmVhdGVHemlwKSgpLCByZXMsIG9uRXJyb3IpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcImRlZmxhdGVcIjpcbiAgICAgICAgICAgICAgICByZXMud3JpdGVIZWFkKDIwMCwgeyBcImNvbnRlbnQtZW5jb2RpbmdcIjogXCJkZWZsYXRlXCIgfSk7XG4gICAgICAgICAgICAgICAgKDAsIHN0cmVhbV8xLnBpcGVsaW5lKShyZWFkU3RyZWFtLCAoMCwgemxpYl8xLmNyZWF0ZURlZmxhdGUpKCksIHJlcywgb25FcnJvcik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJlcy53cml0ZUhlYWQoMjAwKTtcbiAgICAgICAgICAgICAgICAoMCwgc3RyZWFtXzEucGlwZWxpbmUpKHJlYWRTdHJlYW0sIHJlcywgb25FcnJvcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQmluZHMgc29ja2V0LmlvIHRvIGFuIGVuZ2luZS5pbyBpbnN0YW5jZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBlbmdpbmUgZW5naW5lLmlvIChvciBjb21wYXRpYmxlKSBzZXJ2ZXJcbiAgICAgKiBAcmV0dXJuIHNlbGZcbiAgICAgKi9cbiAgICBiaW5kKGVuZ2luZSkge1xuICAgICAgICAvLyBUT0RPIGFwcGx5IHN0cmljdCB0eXBlcyB0byB0aGUgZW5naW5lOiBcImNvbm5lY3Rpb25cIiBldmVudCwgYGNsb3NlKClgIGFuZCBhIG1ldGhvZCB0byBzZXJ2ZSBzdGF0aWMgY29udGVudFxuICAgICAgICAvLyAgdGhpcyB3b3VsZCBhbGxvdyB0byBwcm92aWRlIGFueSBjdXN0b20gZW5naW5lLCBsaWtlIG9uZSBiYXNlZCBvbiBEZW5vIG9yIEJ1biBidWlsdC1pbiBIVFRQIHNlcnZlclxuICAgICAgICB0aGlzLmVuZ2luZSA9IGVuZ2luZTtcbiAgICAgICAgdGhpcy5lbmdpbmUub24oXCJjb25uZWN0aW9uXCIsIHRoaXMub25jb25uZWN0aW9uLmJpbmQodGhpcykpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHdpdGggZWFjaCBpbmNvbWluZyB0cmFuc3BvcnQgY29ubmVjdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7ZW5naW5lLlNvY2tldH0gY29ublxuICAgICAqIEByZXR1cm4gc2VsZlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgb25jb25uZWN0aW9uKGNvbm4pIHtcbiAgICAgICAgZGVidWcoXCJpbmNvbWluZyBjb25uZWN0aW9uIHdpdGggaWQgJXNcIiwgY29ubi5pZCk7XG4gICAgICAgIGNvbnN0IGNsaWVudCA9IG5ldyBjbGllbnRfMS5DbGllbnQodGhpcywgY29ubik7XG4gICAgICAgIGlmIChjb25uLnByb3RvY29sID09PSAzKSB7XG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICBjbGllbnQuY29ubmVjdChcIi9cIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExvb2tzIHVwIGEgbmFtZXNwYWNlLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyB3aXRoIGEgc2ltcGxlIHN0cmluZ1xuICAgICAqIGNvbnN0IG15TmFtZXNwYWNlID0gaW8ub2YoXCIvbXktbmFtZXNwYWNlXCIpO1xuICAgICAqXG4gICAgICogLy8gd2l0aCBhIHJlZ2V4XG4gICAgICogY29uc3QgZHluYW1pY05zcCA9IGlvLm9mKC9eXFwvZHluYW1pYy1cXGQrJC8pLm9uKFwiY29ubmVjdGlvblwiLCAoc29ja2V0KSA9PiB7XG4gICAgICogICBjb25zdCBuYW1lc3BhY2UgPSBzb2NrZXQubnNwOyAvLyBuZXdOYW1lc3BhY2UubmFtZSA9PT0gXCIvZHluYW1pYy0xMDFcIlxuICAgICAqXG4gICAgICogICAvLyBicm9hZGNhc3QgdG8gYWxsIGNsaWVudHMgaW4gdGhlIGdpdmVuIHN1Yi1uYW1lc3BhY2VcbiAgICAgKiAgIG5hbWVzcGFjZS5lbWl0KFwiaGVsbG9cIik7XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBAcGFyYW0gbmFtZSAtIG5zcCBuYW1lXG4gICAgICogQHBhcmFtIGZuIG9wdGlvbmFsLCBuc3AgYGNvbm5lY3Rpb25gIGV2IGhhbmRsZXJcbiAgICAgKi9cbiAgICBvZihuYW1lLCBmbikge1xuICAgICAgICBpZiAodHlwZW9mIG5hbWUgPT09IFwiZnVuY3Rpb25cIiB8fCBuYW1lIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgICAgICAgICBjb25zdCBwYXJlbnROc3AgPSBuZXcgcGFyZW50X25hbWVzcGFjZV8xLlBhcmVudE5hbWVzcGFjZSh0aGlzKTtcbiAgICAgICAgICAgIGRlYnVnKFwiaW5pdGlhbGl6aW5nIHBhcmVudCBuYW1lc3BhY2UgJXNcIiwgcGFyZW50TnNwLm5hbWUpO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBuYW1lID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBhcmVudE5zcHMuc2V0KG5hbWUsIHBhcmVudE5zcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBhcmVudE5zcHMuc2V0KChuc3AsIGNvbm4sIG5leHQpID0+IG5leHQobnVsbCwgbmFtZS50ZXN0KG5zcCkpLCBwYXJlbnROc3ApO1xuICAgICAgICAgICAgICAgIHRoaXMucGFyZW50TmFtZXNwYWNlc0Zyb21SZWdFeHAuc2V0KG5hbWUsIHBhcmVudE5zcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZm4pIHtcbiAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICAgICAgcGFyZW50TnNwLm9uKFwiY29ubmVjdFwiLCBmbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcGFyZW50TnNwO1xuICAgICAgICB9XG4gICAgICAgIGlmIChTdHJpbmcobmFtZSlbMF0gIT09IFwiL1wiKVxuICAgICAgICAgICAgbmFtZSA9IFwiL1wiICsgbmFtZTtcbiAgICAgICAgbGV0IG5zcCA9IHRoaXMuX25zcHMuZ2V0KG5hbWUpO1xuICAgICAgICBpZiAoIW5zcCkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBbcmVnZXgsIHBhcmVudE5hbWVzcGFjZV0gb2YgdGhpcy5wYXJlbnROYW1lc3BhY2VzRnJvbVJlZ0V4cCkge1xuICAgICAgICAgICAgICAgIGlmIChyZWdleC50ZXN0KG5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlYnVnKFwiYXR0YWNoaW5nIG5hbWVzcGFjZSAlcyB0byBwYXJlbnQgbmFtZXNwYWNlICVzXCIsIG5hbWUsIHJlZ2V4KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhcmVudE5hbWVzcGFjZS5jcmVhdGVDaGlsZChuYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWJ1ZyhcImluaXRpYWxpemluZyBuYW1lc3BhY2UgJXNcIiwgbmFtZSk7XG4gICAgICAgICAgICBuc3AgPSBuZXcgbmFtZXNwYWNlXzEuTmFtZXNwYWNlKHRoaXMsIG5hbWUpO1xuICAgICAgICAgICAgdGhpcy5fbnNwcy5zZXQobmFtZSwgbnNwKTtcbiAgICAgICAgICAgIGlmIChuYW1lICE9PSBcIi9cIikge1xuICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgICAgICB0aGlzLnNvY2tldHMuZW1pdFJlc2VydmVkKFwibmV3X25hbWVzcGFjZVwiLCBuc3ApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChmbilcbiAgICAgICAgICAgIG5zcC5vbihcImNvbm5lY3RcIiwgZm4pO1xuICAgICAgICByZXR1cm4gbnNwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDbG9zZXMgc2VydmVyIGNvbm5lY3Rpb25cbiAgICAgKlxuICAgICAqIEBwYXJhbSBbZm5dIG9wdGlvbmFsLCBjYWxsZWQgYXMgYGZuKFtlcnJdKWAgb24gZXJyb3IgT1IgYWxsIGNvbm5zIGNsb3NlZFxuICAgICAqL1xuICAgIGFzeW5jIGNsb3NlKGZuKSB7XG4gICAgICAgIGF3YWl0IFByb21pc2UuYWxsU2V0dGxlZChbLi4udGhpcy5fbnNwcy52YWx1ZXMoKV0ubWFwKGFzeW5jIChuc3ApID0+IHtcbiAgICAgICAgICAgIG5zcC5zb2NrZXRzLmZvckVhY2goKHNvY2tldCkgPT4ge1xuICAgICAgICAgICAgICAgIHNvY2tldC5fb25jbG9zZShcInNlcnZlciBzaHV0dGluZyBkb3duXCIpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBhd2FpdCBuc3AuYWRhcHRlci5jbG9zZSgpO1xuICAgICAgICB9KSk7XG4gICAgICAgIHRoaXMuZW5naW5lLmNsb3NlKCk7XG4gICAgICAgIC8vIHJlc3RvcmUgdGhlIEFkYXB0ZXIgcHJvdG90eXBlLCB3aGVuIHRoZSBTb2NrZXQuSU8gc2VydmVyIHdhcyBhdHRhY2hlZCB0byBhIHVXZWJTb2NrZXRzLmpzIHNlcnZlclxuICAgICAgICAoMCwgdXdzXzEucmVzdG9yZUFkYXB0ZXIpKCk7XG4gICAgICAgIGlmICh0aGlzLmh0dHBTZXJ2ZXIpIHtcbiAgICAgICAgICAgIHRoaXMuaHR0cFNlcnZlci5jbG9zZShmbik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmbiAmJiBmbigpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVycyBhIG1pZGRsZXdhcmUsIHdoaWNoIGlzIGEgZnVuY3Rpb24gdGhhdCBnZXRzIGV4ZWN1dGVkIGZvciBldmVyeSBpbmNvbWluZyB7QGxpbmsgU29ja2V0fS5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogaW8udXNlKChzb2NrZXQsIG5leHQpID0+IHtcbiAgICAgKiAgIC8vIC4uLlxuICAgICAqICAgbmV4dCgpO1xuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogQHBhcmFtIGZuIC0gdGhlIG1pZGRsZXdhcmUgZnVuY3Rpb25cbiAgICAgKi9cbiAgICB1c2UoZm4pIHtcbiAgICAgICAgdGhpcy5zb2NrZXRzLnVzZShmbik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUYXJnZXRzIGEgcm9vbSB3aGVuIGVtaXR0aW5nLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyB0aGUg4oCcZm9v4oCdIGV2ZW50IHdpbGwgYmUgYnJvYWRjYXN0IHRvIGFsbCBjb25uZWN0ZWQgY2xpZW50cyBpbiB0aGUg4oCccm9vbS0xMDHigJ0gcm9vbVxuICAgICAqIGlvLnRvKFwicm9vbS0xMDFcIikuZW1pdChcImZvb1wiLCBcImJhclwiKTtcbiAgICAgKlxuICAgICAqIC8vIHdpdGggYW4gYXJyYXkgb2Ygcm9vbXMgKGEgY2xpZW50IHdpbGwgYmUgbm90aWZpZWQgYXQgbW9zdCBvbmNlKVxuICAgICAqIGlvLnRvKFtcInJvb20tMTAxXCIsIFwicm9vbS0xMDJcIl0pLmVtaXQoXCJmb29cIiwgXCJiYXJcIik7XG4gICAgICpcbiAgICAgKiAvLyB3aXRoIG11bHRpcGxlIGNoYWluZWQgY2FsbHNcbiAgICAgKiBpby50byhcInJvb20tMTAxXCIpLnRvKFwicm9vbS0xMDJcIikuZW1pdChcImZvb1wiLCBcImJhclwiKTtcbiAgICAgKlxuICAgICAqIEBwYXJhbSByb29tIC0gYSByb29tLCBvciBhbiBhcnJheSBvZiByb29tc1xuICAgICAqIEByZXR1cm4gYSBuZXcge0BsaW5rIEJyb2FkY2FzdE9wZXJhdG9yfSBpbnN0YW5jZSBmb3IgY2hhaW5pbmdcbiAgICAgKi9cbiAgICB0byhyb29tKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNvY2tldHMudG8ocm9vbSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRhcmdldHMgYSByb29tIHdoZW4gZW1pdHRpbmcuIFNpbWlsYXIgdG8gYHRvKClgLCBidXQgbWlnaHQgZmVlbCBjbGVhcmVyIGluIHNvbWUgY2FzZXM6XG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIGRpc2Nvbm5lY3QgYWxsIGNsaWVudHMgaW4gdGhlIFwicm9vbS0xMDFcIiByb29tXG4gICAgICogaW8uaW4oXCJyb29tLTEwMVwiKS5kaXNjb25uZWN0U29ja2V0cygpO1xuICAgICAqXG4gICAgICogQHBhcmFtIHJvb20gLSBhIHJvb20sIG9yIGFuIGFycmF5IG9mIHJvb21zXG4gICAgICogQHJldHVybiBhIG5ldyB7QGxpbmsgQnJvYWRjYXN0T3BlcmF0b3J9IGluc3RhbmNlIGZvciBjaGFpbmluZ1xuICAgICAqL1xuICAgIGluKHJvb20pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc29ja2V0cy5pbihyb29tKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRXhjbHVkZXMgYSByb29tIHdoZW4gZW1pdHRpbmcuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIHRoZSBcImZvb1wiIGV2ZW50IHdpbGwgYmUgYnJvYWRjYXN0IHRvIGFsbCBjb25uZWN0ZWQgY2xpZW50cywgZXhjZXB0IHRoZSBvbmVzIHRoYXQgYXJlIGluIHRoZSBcInJvb20tMTAxXCIgcm9vbVxuICAgICAqIGlvLmV4Y2VwdChcInJvb20tMTAxXCIpLmVtaXQoXCJmb29cIiwgXCJiYXJcIik7XG4gICAgICpcbiAgICAgKiAvLyB3aXRoIGFuIGFycmF5IG9mIHJvb21zXG4gICAgICogaW8uZXhjZXB0KFtcInJvb20tMTAxXCIsIFwicm9vbS0xMDJcIl0pLmVtaXQoXCJmb29cIiwgXCJiYXJcIik7XG4gICAgICpcbiAgICAgKiAvLyB3aXRoIG11bHRpcGxlIGNoYWluZWQgY2FsbHNcbiAgICAgKiBpby5leGNlcHQoXCJyb29tLTEwMVwiKS5leGNlcHQoXCJyb29tLTEwMlwiKS5lbWl0KFwiZm9vXCIsIFwiYmFyXCIpO1xuICAgICAqXG4gICAgICogQHBhcmFtIHJvb20gLSBhIHJvb20sIG9yIGFuIGFycmF5IG9mIHJvb21zXG4gICAgICogQHJldHVybiBhIG5ldyB7QGxpbmsgQnJvYWRjYXN0T3BlcmF0b3J9IGluc3RhbmNlIGZvciBjaGFpbmluZ1xuICAgICAqL1xuICAgIGV4Y2VwdChyb29tKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNvY2tldHMuZXhjZXB0KHJvb20pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZW5kcyBhIGBtZXNzYWdlYCBldmVudCB0byBhbGwgY2xpZW50cy5cbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIG1pbWljcyB0aGUgV2ViU29ja2V0LnNlbmQoKSBtZXRob2QuXG4gICAgICpcbiAgICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9XZWJTb2NrZXQvc2VuZFxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBpby5zZW5kKFwiaGVsbG9cIik7XG4gICAgICpcbiAgICAgKiAvLyB0aGlzIGlzIGVxdWl2YWxlbnQgdG9cbiAgICAgKiBpby5lbWl0KFwibWVzc2FnZVwiLCBcImhlbGxvXCIpO1xuICAgICAqXG4gICAgICogQHJldHVybiBzZWxmXG4gICAgICovXG4gICAgc2VuZCguLi5hcmdzKSB7XG4gICAgICAgIC8vIFRoaXMgdHlwZS1jYXN0IGlzIG5lZWRlZCBiZWNhdXNlIEVtaXRFdmVudHMgbGlrZWx5IGRvZXNuJ3QgaGF2ZSBgbWVzc2FnZWAgYXMgYSBrZXkuXG4gICAgICAgIC8vIGlmIHlvdSBzcGVjaWZ5IHRoZSBFbWl0RXZlbnRzLCB0aGUgdHlwZSBvZiBhcmdzIHdpbGwgYmUgbmV2ZXIuXG4gICAgICAgIHRoaXMuc29ja2V0cy5lbWl0KFwibWVzc2FnZVwiLCAuLi5hcmdzKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlbmRzIGEgYG1lc3NhZ2VgIGV2ZW50IHRvIGFsbCBjbGllbnRzLiBBbGlhcyBvZiB7QGxpbmsgc2VuZH0uXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHNlbGZcbiAgICAgKi9cbiAgICB3cml0ZSguLi5hcmdzKSB7XG4gICAgICAgIC8vIFRoaXMgdHlwZS1jYXN0IGlzIG5lZWRlZCBiZWNhdXNlIEVtaXRFdmVudHMgbGlrZWx5IGRvZXNuJ3QgaGF2ZSBgbWVzc2FnZWAgYXMgYSBrZXkuXG4gICAgICAgIC8vIGlmIHlvdSBzcGVjaWZ5IHRoZSBFbWl0RXZlbnRzLCB0aGUgdHlwZSBvZiBhcmdzIHdpbGwgYmUgbmV2ZXIuXG4gICAgICAgIHRoaXMuc29ja2V0cy5lbWl0KFwibWVzc2FnZVwiLCAuLi5hcmdzKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlbmRzIGEgbWVzc2FnZSB0byB0aGUgb3RoZXIgU29ja2V0LklPIHNlcnZlcnMgb2YgdGhlIGNsdXN0ZXIuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGlvLnNlcnZlclNpZGVFbWl0KFwiaGVsbG9cIiwgXCJ3b3JsZFwiKTtcbiAgICAgKlxuICAgICAqIGlvLm9uKFwiaGVsbG9cIiwgKGFyZzEpID0+IHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKGFyZzEpOyAvLyBwcmludHMgXCJ3b3JsZFwiXG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiAvLyBhY2tub3dsZWRnZW1lbnRzICh3aXRob3V0IGJpbmFyeSBjb250ZW50KSBhcmUgc3VwcG9ydGVkIHRvbzpcbiAgICAgKiBpby5zZXJ2ZXJTaWRlRW1pdChcInBpbmdcIiwgKGVyciwgcmVzcG9uc2VzKSA9PiB7XG4gICAgICogIGlmIChlcnIpIHtcbiAgICAgKiAgICAgLy8gc29tZSBzZXJ2ZXJzIGRpZCBub3QgYWNrbm93bGVkZ2UgdGhlIGV2ZW50IGluIHRoZSBnaXZlbiBkZWxheVxuICAgICAqICAgfSBlbHNlIHtcbiAgICAgKiAgICAgY29uc29sZS5sb2cocmVzcG9uc2VzKTsgLy8gb25lIHJlc3BvbnNlIHBlciBzZXJ2ZXIgKGV4Y2VwdCB0aGUgY3VycmVudCBvbmUpXG4gICAgICogICB9XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBpby5vbihcInBpbmdcIiwgKGNiKSA9PiB7XG4gICAgICogICBjYihcInBvbmdcIik7XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBAcGFyYW0gZXYgLSB0aGUgZXZlbnQgbmFtZVxuICAgICAqIEBwYXJhbSBhcmdzIC0gYW4gYXJyYXkgb2YgYXJndW1lbnRzLCB3aGljaCBtYXkgaW5jbHVkZSBhbiBhY2tub3dsZWRnZW1lbnQgY2FsbGJhY2sgYXQgdGhlIGVuZFxuICAgICAqL1xuICAgIHNlcnZlclNpZGVFbWl0KGV2LCAuLi5hcmdzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNvY2tldHMuc2VydmVyU2lkZUVtaXQoZXYsIC4uLmFyZ3MpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZW5kcyBhIG1lc3NhZ2UgYW5kIGV4cGVjdCBhbiBhY2tub3dsZWRnZW1lbnQgZnJvbSB0aGUgb3RoZXIgU29ja2V0LklPIHNlcnZlcnMgb2YgdGhlIGNsdXN0ZXIuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIHRyeSB7XG4gICAgICogICBjb25zdCByZXNwb25zZXMgPSBhd2FpdCBpby5zZXJ2ZXJTaWRlRW1pdFdpdGhBY2soXCJwaW5nXCIpO1xuICAgICAqICAgY29uc29sZS5sb2cocmVzcG9uc2VzKTsgLy8gb25lIHJlc3BvbnNlIHBlciBzZXJ2ZXIgKGV4Y2VwdCB0aGUgY3VycmVudCBvbmUpXG4gICAgICogfSBjYXRjaCAoZSkge1xuICAgICAqICAgLy8gc29tZSBzZXJ2ZXJzIGRpZCBub3QgYWNrbm93bGVkZ2UgdGhlIGV2ZW50IGluIHRoZSBnaXZlbiBkZWxheVxuICAgICAqIH1cbiAgICAgKlxuICAgICAqIEBwYXJhbSBldiAtIHRoZSBldmVudCBuYW1lXG4gICAgICogQHBhcmFtIGFyZ3MgLSBhbiBhcnJheSBvZiBhcmd1bWVudHNcbiAgICAgKlxuICAgICAqIEByZXR1cm4gYSBQcm9taXNlIHRoYXQgd2lsbCBiZSBmdWxmaWxsZWQgd2hlbiBhbGwgc2VydmVycyBoYXZlIGFja25vd2xlZGdlZCB0aGUgZXZlbnRcbiAgICAgKi9cbiAgICBzZXJ2ZXJTaWRlRW1pdFdpdGhBY2soZXYsIC4uLmFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc29ja2V0cy5zZXJ2ZXJTaWRlRW1pdFdpdGhBY2soZXYsIC4uLmFyZ3MpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIGEgbGlzdCBvZiBzb2NrZXQgaWRzLlxuICAgICAqXG4gICAgICogQGRlcHJlY2F0ZWQgdGhpcyBtZXRob2Qgd2lsbCBiZSByZW1vdmVkIGluIHRoZSBuZXh0IG1ham9yIHJlbGVhc2UsIHBsZWFzZSB1c2Uge0BsaW5rIFNlcnZlciNzZXJ2ZXJTaWRlRW1pdH0gb3JcbiAgICAgKiB7QGxpbmsgU2VydmVyI2ZldGNoU29ja2V0c30gaW5zdGVhZC5cbiAgICAgKi9cbiAgICBhbGxTb2NrZXRzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zb2NrZXRzLmFsbFNvY2tldHMoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgY29tcHJlc3MgZmxhZy5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogaW8uY29tcHJlc3MoZmFsc2UpLmVtaXQoXCJoZWxsb1wiKTtcbiAgICAgKlxuICAgICAqIEBwYXJhbSBjb21wcmVzcyAtIGlmIGB0cnVlYCwgY29tcHJlc3NlcyB0aGUgc2VuZGluZyBkYXRhXG4gICAgICogQHJldHVybiBhIG5ldyB7QGxpbmsgQnJvYWRjYXN0T3BlcmF0b3J9IGluc3RhbmNlIGZvciBjaGFpbmluZ1xuICAgICAqL1xuICAgIGNvbXByZXNzKGNvbXByZXNzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNvY2tldHMuY29tcHJlc3MoY29tcHJlc3MpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIGEgbW9kaWZpZXIgZm9yIGEgc3Vic2VxdWVudCBldmVudCBlbWlzc2lvbiB0aGF0IHRoZSBldmVudCBkYXRhIG1heSBiZSBsb3N0IGlmIHRoZSBjbGllbnQgaXMgbm90IHJlYWR5IHRvXG4gICAgICogcmVjZWl2ZSBtZXNzYWdlcyAoYmVjYXVzZSBvZiBuZXR3b3JrIHNsb3duZXNzIG9yIG90aGVyIGlzc3Vlcywgb3IgYmVjYXVzZSB0aGV54oCZcmUgY29ubmVjdGVkIHRocm91Z2ggbG9uZyBwb2xsaW5nXG4gICAgICogYW5kIGlzIGluIHRoZSBtaWRkbGUgb2YgYSByZXF1ZXN0LXJlc3BvbnNlIGN5Y2xlKS5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogaW8udm9sYXRpbGUuZW1pdChcImhlbGxvXCIpOyAvLyB0aGUgY2xpZW50cyBtYXkgb3IgbWF5IG5vdCByZWNlaXZlIGl0XG4gICAgICpcbiAgICAgKiBAcmV0dXJuIGEgbmV3IHtAbGluayBCcm9hZGNhc3RPcGVyYXRvcn0gaW5zdGFuY2UgZm9yIGNoYWluaW5nXG4gICAgICovXG4gICAgZ2V0IHZvbGF0aWxlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zb2NrZXRzLnZvbGF0aWxlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIGEgbW9kaWZpZXIgZm9yIGEgc3Vic2VxdWVudCBldmVudCBlbWlzc2lvbiB0aGF0IHRoZSBldmVudCBkYXRhIHdpbGwgb25seSBiZSBicm9hZGNhc3QgdG8gdGhlIGN1cnJlbnQgbm9kZS5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gdGhlIOKAnGZvb+KAnSBldmVudCB3aWxsIGJlIGJyb2FkY2FzdCB0byBhbGwgY29ubmVjdGVkIGNsaWVudHMgb24gdGhpcyBub2RlXG4gICAgICogaW8ubG9jYWwuZW1pdChcImZvb1wiLCBcImJhclwiKTtcbiAgICAgKlxuICAgICAqIEByZXR1cm4gYSBuZXcge0BsaW5rIEJyb2FkY2FzdE9wZXJhdG9yfSBpbnN0YW5jZSBmb3IgY2hhaW5pbmdcbiAgICAgKi9cbiAgICBnZXQgbG9jYWwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNvY2tldHMubG9jYWw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZHMgYSB0aW1lb3V0IGluIG1pbGxpc2Vjb25kcyBmb3IgdGhlIG5leHQgb3BlcmF0aW9uLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBpby50aW1lb3V0KDEwMDApLmVtaXQoXCJzb21lLWV2ZW50XCIsIChlcnIsIHJlc3BvbnNlcykgPT4ge1xuICAgICAqICAgaWYgKGVycikge1xuICAgICAqICAgICAvLyBzb21lIGNsaWVudHMgZGlkIG5vdCBhY2tub3dsZWRnZSB0aGUgZXZlbnQgaW4gdGhlIGdpdmVuIGRlbGF5XG4gICAgICogICB9IGVsc2Uge1xuICAgICAqICAgICBjb25zb2xlLmxvZyhyZXNwb25zZXMpOyAvLyBvbmUgcmVzcG9uc2UgcGVyIGNsaWVudFxuICAgICAqICAgfVxuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogQHBhcmFtIHRpbWVvdXRcbiAgICAgKi9cbiAgICB0aW1lb3V0KHRpbWVvdXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc29ja2V0cy50aW1lb3V0KHRpbWVvdXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBtYXRjaGluZyBzb2NrZXQgaW5zdGFuY2VzLlxuICAgICAqXG4gICAgICogTm90ZTogdGhpcyBtZXRob2QgYWxzbyB3b3JrcyB3aXRoaW4gYSBjbHVzdGVyIG9mIG11bHRpcGxlIFNvY2tldC5JTyBzZXJ2ZXJzLCB3aXRoIGEgY29tcGF0aWJsZSB7QGxpbmsgQWRhcHRlcn0uXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIHJldHVybiBhbGwgU29ja2V0IGluc3RhbmNlc1xuICAgICAqIGNvbnN0IHNvY2tldHMgPSBhd2FpdCBpby5mZXRjaFNvY2tldHMoKTtcbiAgICAgKlxuICAgICAqIC8vIHJldHVybiBhbGwgU29ja2V0IGluc3RhbmNlcyBpbiB0aGUgXCJyb29tMVwiIHJvb21cbiAgICAgKiBjb25zdCBzb2NrZXRzID0gYXdhaXQgaW8uaW4oXCJyb29tMVwiKS5mZXRjaFNvY2tldHMoKTtcbiAgICAgKlxuICAgICAqIGZvciAoY29uc3Qgc29ja2V0IG9mIHNvY2tldHMpIHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKHNvY2tldC5pZCk7XG4gICAgICogICBjb25zb2xlLmxvZyhzb2NrZXQuaGFuZHNoYWtlKTtcbiAgICAgKiAgIGNvbnNvbGUubG9nKHNvY2tldC5yb29tcyk7XG4gICAgICogICBjb25zb2xlLmxvZyhzb2NrZXQuZGF0YSk7XG4gICAgICpcbiAgICAgKiAgIHNvY2tldC5lbWl0KFwiaGVsbG9cIik7XG4gICAgICogICBzb2NrZXQuam9pbihcInJvb20xXCIpO1xuICAgICAqICAgc29ja2V0LmxlYXZlKFwicm9vbTJcIik7XG4gICAgICogICBzb2NrZXQuZGlzY29ubmVjdCgpO1xuICAgICAqIH1cbiAgICAgKi9cbiAgICBmZXRjaFNvY2tldHMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNvY2tldHMuZmV0Y2hTb2NrZXRzKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1ha2VzIHRoZSBtYXRjaGluZyBzb2NrZXQgaW5zdGFuY2VzIGpvaW4gdGhlIHNwZWNpZmllZCByb29tcy5cbiAgICAgKlxuICAgICAqIE5vdGU6IHRoaXMgbWV0aG9kIGFsc28gd29ya3Mgd2l0aGluIGEgY2x1c3RlciBvZiBtdWx0aXBsZSBTb2NrZXQuSU8gc2VydmVycywgd2l0aCBhIGNvbXBhdGlibGUge0BsaW5rIEFkYXB0ZXJ9LlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIC8vIG1ha2UgYWxsIHNvY2tldCBpbnN0YW5jZXMgam9pbiB0aGUgXCJyb29tMVwiIHJvb21cbiAgICAgKiBpby5zb2NrZXRzSm9pbihcInJvb20xXCIpO1xuICAgICAqXG4gICAgICogLy8gbWFrZSBhbGwgc29ja2V0IGluc3RhbmNlcyBpbiB0aGUgXCJyb29tMVwiIHJvb20gam9pbiB0aGUgXCJyb29tMlwiIGFuZCBcInJvb20zXCIgcm9vbXNcbiAgICAgKiBpby5pbihcInJvb20xXCIpLnNvY2tldHNKb2luKFtcInJvb20yXCIsIFwicm9vbTNcIl0pO1xuICAgICAqXG4gICAgICogQHBhcmFtIHJvb20gLSBhIHJvb20sIG9yIGFuIGFycmF5IG9mIHJvb21zXG4gICAgICovXG4gICAgc29ja2V0c0pvaW4ocm9vbSkge1xuICAgICAgICByZXR1cm4gdGhpcy5zb2NrZXRzLnNvY2tldHNKb2luKHJvb20pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNYWtlcyB0aGUgbWF0Y2hpbmcgc29ja2V0IGluc3RhbmNlcyBsZWF2ZSB0aGUgc3BlY2lmaWVkIHJvb21zLlxuICAgICAqXG4gICAgICogTm90ZTogdGhpcyBtZXRob2QgYWxzbyB3b3JrcyB3aXRoaW4gYSBjbHVzdGVyIG9mIG11bHRpcGxlIFNvY2tldC5JTyBzZXJ2ZXJzLCB3aXRoIGEgY29tcGF0aWJsZSB7QGxpbmsgQWRhcHRlcn0uXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIG1ha2UgYWxsIHNvY2tldCBpbnN0YW5jZXMgbGVhdmUgdGhlIFwicm9vbTFcIiByb29tXG4gICAgICogaW8uc29ja2V0c0xlYXZlKFwicm9vbTFcIik7XG4gICAgICpcbiAgICAgKiAvLyBtYWtlIGFsbCBzb2NrZXQgaW5zdGFuY2VzIGluIHRoZSBcInJvb20xXCIgcm9vbSBsZWF2ZSB0aGUgXCJyb29tMlwiIGFuZCBcInJvb20zXCIgcm9vbXNcbiAgICAgKiBpby5pbihcInJvb20xXCIpLnNvY2tldHNMZWF2ZShbXCJyb29tMlwiLCBcInJvb20zXCJdKTtcbiAgICAgKlxuICAgICAqIEBwYXJhbSByb29tIC0gYSByb29tLCBvciBhbiBhcnJheSBvZiByb29tc1xuICAgICAqL1xuICAgIHNvY2tldHNMZWF2ZShyb29tKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNvY2tldHMuc29ja2V0c0xlYXZlKHJvb20pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNYWtlcyB0aGUgbWF0Y2hpbmcgc29ja2V0IGluc3RhbmNlcyBkaXNjb25uZWN0LlxuICAgICAqXG4gICAgICogTm90ZTogdGhpcyBtZXRob2QgYWxzbyB3b3JrcyB3aXRoaW4gYSBjbHVzdGVyIG9mIG11bHRpcGxlIFNvY2tldC5JTyBzZXJ2ZXJzLCB3aXRoIGEgY29tcGF0aWJsZSB7QGxpbmsgQWRhcHRlcn0uXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIG1ha2UgYWxsIHNvY2tldCBpbnN0YW5jZXMgZGlzY29ubmVjdCAodGhlIGNvbm5lY3Rpb25zIG1pZ2h0IGJlIGtlcHQgYWxpdmUgZm9yIG90aGVyIG5hbWVzcGFjZXMpXG4gICAgICogaW8uZGlzY29ubmVjdFNvY2tldHMoKTtcbiAgICAgKlxuICAgICAqIC8vIG1ha2UgYWxsIHNvY2tldCBpbnN0YW5jZXMgaW4gdGhlIFwicm9vbTFcIiByb29tIGRpc2Nvbm5lY3QgYW5kIGNsb3NlIHRoZSB1bmRlcmx5aW5nIGNvbm5lY3Rpb25zXG4gICAgICogaW8uaW4oXCJyb29tMVwiKS5kaXNjb25uZWN0U29ja2V0cyh0cnVlKTtcbiAgICAgKlxuICAgICAqIEBwYXJhbSBjbG9zZSAtIHdoZXRoZXIgdG8gY2xvc2UgdGhlIHVuZGVybHlpbmcgY29ubmVjdGlvblxuICAgICAqL1xuICAgIGRpc2Nvbm5lY3RTb2NrZXRzKGNsb3NlID0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc29ja2V0cy5kaXNjb25uZWN0U29ja2V0cyhjbG9zZSk7XG4gICAgfVxufVxuZXhwb3J0cy5TZXJ2ZXIgPSBTZXJ2ZXI7XG4vKipcbiAqIEV4cG9zZSBtYWluIG5hbWVzcGFjZSAoLykuXG4gKi9cbmNvbnN0IGVtaXR0ZXJNZXRob2RzID0gT2JqZWN0LmtleXMoZXZlbnRzXzEuRXZlbnRFbWl0dGVyLnByb3RvdHlwZSkuZmlsdGVyKGZ1bmN0aW9uIChrZXkpIHtcbiAgICByZXR1cm4gdHlwZW9mIGV2ZW50c18xLkV2ZW50RW1pdHRlci5wcm90b3R5cGVba2V5XSA9PT0gXCJmdW5jdGlvblwiO1xufSk7XG5lbWl0dGVyTWV0aG9kcy5mb3JFYWNoKGZ1bmN0aW9uIChmbikge1xuICAgIFNlcnZlci5wcm90b3R5cGVbZm5dID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zb2NrZXRzW2ZuXS5hcHBseSh0aGlzLnNvY2tldHMsIGFyZ3VtZW50cyk7XG4gICAgfTtcbn0pO1xubW9kdWxlLmV4cG9ydHMgPSAoc3J2LCBvcHRzKSA9PiBuZXcgU2VydmVyKHNydiwgb3B0cyk7XG5tb2R1bGUuZXhwb3J0cy5TZXJ2ZXIgPSBTZXJ2ZXI7XG5tb2R1bGUuZXhwb3J0cy5OYW1lc3BhY2UgPSBuYW1lc3BhY2VfMS5OYW1lc3BhY2U7XG5tb2R1bGUuZXhwb3J0cy5Tb2NrZXQgPSBzb2NrZXRfMS5Tb2NrZXQ7XG4iXSwibmFtZXMiOlsiX19jcmVhdGVCaW5kaW5nIiwiT2JqZWN0IiwiY3JlYXRlIiwibyIsIm0iLCJrIiwiazIiLCJ1bmRlZmluZWQiLCJkZXNjIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiX19lc01vZHVsZSIsIndyaXRhYmxlIiwiY29uZmlndXJhYmxlIiwiZW51bWVyYWJsZSIsImdldCIsImRlZmluZVByb3BlcnR5IiwiX19zZXRNb2R1bGVEZWZhdWx0IiwidiIsInZhbHVlIiwiX19pbXBvcnRTdGFyIiwibW9kIiwicmVzdWx0IiwicHJvdG90eXBlIiwiaGFzT3duUHJvcGVydHkiLCJjYWxsIiwiX19pbXBvcnREZWZhdWx0IiwiZXhwb3J0cyIsIk5hbWVzcGFjZSIsIlNvY2tldCIsIlNlcnZlciIsImh0dHAiLCJyZXF1aXJlIiwiZnNfMSIsInpsaWJfMSIsImFjY2VwdHMiLCJzdHJlYW1fMSIsInBhdGgiLCJlbmdpbmVfaW9fMSIsImNsaWVudF8xIiwiZXZlbnRzXzEiLCJuYW1lc3BhY2VfMSIsInBhcmVudF9uYW1lc3BhY2VfMSIsInNvY2tldF9pb19hZGFwdGVyXzEiLCJwYXJzZXIiLCJkZWJ1Z18xIiwic29ja2V0XzEiLCJ0eXBlZF9ldmVudHNfMSIsInV3c18xIiwiY29yc18xIiwiZGVidWciLCJkZWZhdWx0IiwiY2xpZW50VmVyc2lvbiIsInZlcnNpb24iLCJkb3RNYXBSZWdleCIsIlN0cmljdEV2ZW50RW1pdHRlciIsImNvbnN0cnVjdG9yIiwic3J2Iiwib3B0cyIsIl9uc3BzIiwiTWFwIiwicGFyZW50TnNwcyIsInBhcmVudE5hbWVzcGFjZXNGcm9tUmVnRXhwIiwibGlzdGVuIiwiY29ubmVjdFRpbWVvdXQiLCJzZXJ2ZUNsaWVudCIsIl9wYXJzZXIiLCJlbmNvZGVyIiwiRW5jb2RlciIsImNvbm5lY3Rpb25TdGF0ZVJlY292ZXJ5IiwiYXNzaWduIiwibWF4RGlzY29ubmVjdGlvbkR1cmF0aW9uIiwic2tpcE1pZGRsZXdhcmVzIiwiYWRhcHRlciIsIlNlc3Npb25Bd2FyZUFkYXB0ZXIiLCJBZGFwdGVyIiwiY2xlYW51cEVtcHR5Q2hpbGROYW1lc3BhY2VzIiwic29ja2V0cyIsIm9mIiwiYXR0YWNoIiwiY29ycyIsIl9jb3JzTWlkZGxld2FyZSIsIl9vcHRzIiwiYXJndW1lbnRzIiwibGVuZ3RoIiwiX3NlcnZlQ2xpZW50IiwiX2NoZWNrTmFtZXNwYWNlIiwibmFtZSIsImF1dGgiLCJmbiIsInNpemUiLCJrZXlzSXRlcmF0b3IiLCJrZXlzIiwicnVuIiwibmV4dEZuIiwibmV4dCIsImRvbmUiLCJlcnIiLCJhbGxvdyIsImhhcyIsIm5hbWVzcGFjZSIsImNyZWF0ZUNoaWxkIiwiX3BhdGgiLCJyZXBsYWNlIiwiZXNjYXBlZFBhdGgiLCJjbGllbnRQYXRoUmVnZXgiLCJSZWdFeHAiLCJfY29ubmVjdFRpbWVvdXQiLCJfYWRhcHRlciIsIm5zcCIsInZhbHVlcyIsIl9pbml0QWRhcHRlciIsIm1zZyIsIkVycm9yIiwiTnVtYmVyIiwicG9ydCIsImNyZWF0ZVNlcnZlciIsInJlcSIsInJlcyIsIndyaXRlSGVhZCIsImVuZCIsImluaXRFbmdpbmUiLCJhdHRhY2hBcHAiLCJhcHAiLCJlbmdpbmUiLCJ1U2VydmVyIiwiYmluZCIsInRlc3QiLCJnZXRVcmwiLCJzZXRZaWVsZCIsImZpbGVuYW1lIiwiaXNNYXAiLCJ0eXBlIiwiZXhwZWN0ZWRFdGFnIiwid2Vha0V0YWciLCJldGFnIiwiZ2V0SGVhZGVyIiwid3JpdGVTdGF0dXMiLCJ3cml0ZUhlYWRlciIsImZpbGVwYXRoIiwiam9pbiIsIl9fZGlybmFtZSIsInNlcnZlRmlsZSIsInBhdGNoQWRhcHRlciIsImVpbyIsImF0dGFjaFNlcnZlIiwiaHR0cFNlcnZlciIsImV2cyIsImxpc3RlbmVycyIsInNsaWNlIiwicmVtb3ZlQWxsTGlzdGVuZXJzIiwib24iLCJ1cmwiLCJzZXJ2ZSIsImkiLCJoZWFkZXJzIiwic2V0SGVhZGVyIiwic2VuZEZpbGUiLCJyZWFkU3RyZWFtIiwiY3JlYXRlUmVhZFN0cmVhbSIsImVuY29kaW5nIiwiZW5jb2RpbmdzIiwib25FcnJvciIsInBpcGVsaW5lIiwiY3JlYXRlQnJvdGxpQ29tcHJlc3MiLCJjcmVhdGVHemlwIiwiY3JlYXRlRGVmbGF0ZSIsIm9uY29ubmVjdGlvbiIsImNvbm4iLCJpZCIsImNsaWVudCIsIkNsaWVudCIsInByb3RvY29sIiwiY29ubmVjdCIsInBhcmVudE5zcCIsIlBhcmVudE5hbWVzcGFjZSIsInNldCIsIlN0cmluZyIsInJlZ2V4IiwicGFyZW50TmFtZXNwYWNlIiwiZW1pdFJlc2VydmVkIiwiY2xvc2UiLCJQcm9taXNlIiwiYWxsU2V0dGxlZCIsIm1hcCIsImZvckVhY2giLCJzb2NrZXQiLCJfb25jbG9zZSIsInJlc3RvcmVBZGFwdGVyIiwidXNlIiwidG8iLCJyb29tIiwiaW4iLCJleGNlcHQiLCJzZW5kIiwiYXJncyIsImVtaXQiLCJ3cml0ZSIsInNlcnZlclNpZGVFbWl0IiwiZXYiLCJzZXJ2ZXJTaWRlRW1pdFdpdGhBY2siLCJhbGxTb2NrZXRzIiwiY29tcHJlc3MiLCJ2b2xhdGlsZSIsImxvY2FsIiwidGltZW91dCIsImZldGNoU29ja2V0cyIsInNvY2tldHNKb2luIiwic29ja2V0c0xlYXZlIiwiZGlzY29ubmVjdFNvY2tldHMiLCJlbWl0dGVyTWV0aG9kcyIsIkV2ZW50RW1pdHRlciIsImZpbHRlciIsImtleSIsImFwcGx5IiwibW9kdWxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/socket.io/dist/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/socket.io/dist/namespace.js":
/*!**************************************************!*\
  !*** ./node_modules/socket.io/dist/namespace.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nvar __importDefault = (void 0) && (void 0).__importDefault || function(mod) {\n    return mod && mod.__esModule ? mod : {\n        \"default\": mod\n    };\n};\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.Namespace = exports.RESERVED_EVENTS = void 0;\nconst socket_1 = __webpack_require__(/*! ./socket */ \"(rsc)/./node_modules/socket.io/dist/socket.js\");\nconst typed_events_1 = __webpack_require__(/*! ./typed-events */ \"(rsc)/./node_modules/socket.io/dist/typed-events.js\");\nconst debug_1 = __importDefault(__webpack_require__(/*! debug */ \"(rsc)/./node_modules/socket.io/node_modules/debug/src/index.js\"));\nconst broadcast_operator_1 = __webpack_require__(/*! ./broadcast-operator */ \"(rsc)/./node_modules/socket.io/dist/broadcast-operator.js\");\nconst debug = (0, debug_1.default)(\"socket.io:namespace\");\nexports.RESERVED_EVENTS = new Set([\n    \"connect\",\n    \"connection\",\n    \"new_namespace\"\n]);\n/**\n * A Namespace is a communication channel that allows you to split the logic of your application over a single shared\n * connection.\n *\n * Each namespace has its own:\n *\n * - event handlers\n *\n * ```\n * io.of(\"/orders\").on(\"connection\", (socket) => {\n *   socket.on(\"order:list\", () => {});\n *   socket.on(\"order:create\", () => {});\n * });\n *\n * io.of(\"/users\").on(\"connection\", (socket) => {\n *   socket.on(\"user:list\", () => {});\n * });\n * ```\n *\n * - rooms\n *\n * ```\n * const orderNamespace = io.of(\"/orders\");\n *\n * orderNamespace.on(\"connection\", (socket) => {\n *   socket.join(\"room1\");\n *   orderNamespace.to(\"room1\").emit(\"hello\");\n * });\n *\n * const userNamespace = io.of(\"/users\");\n *\n * userNamespace.on(\"connection\", (socket) => {\n *   socket.join(\"room1\"); // distinct from the room in the \"orders\" namespace\n *   userNamespace.to(\"room1\").emit(\"hol\");\n * });\n * ```\n *\n * - middlewares\n *\n * ```\n * const orderNamespace = io.of(\"/orders\");\n *\n * orderNamespace.use((socket, next) => {\n *   // ensure the socket has access to the \"orders\" namespace\n * });\n *\n * const userNamespace = io.of(\"/users\");\n *\n * userNamespace.use((socket, next) => {\n *   // ensure the socket has access to the \"users\" namespace\n * });\n * ```\n */ class Namespace extends typed_events_1.StrictEventEmitter {\n    /**\n     * Namespace constructor.\n     *\n     * @param server instance\n     * @param name\n     */ constructor(server, name){\n        super();\n        /**\n         * A map of currently connected sockets.\n         */ this.sockets = new Map();\n        /**\n         * A map of currently connecting sockets.\n         */ this._preConnectSockets = new Map();\n        this._fns = [];\n        /** @private */ this._ids = 0;\n        this.server = server;\n        this.name = name;\n        this._initAdapter();\n    }\n    /**\n     * Initializes the `Adapter` for this nsp.\n     * Run upon changing adapter by `Server#adapter`\n     * in addition to the constructor.\n     *\n     * @private\n     */ _initAdapter() {\n        // @ts-ignore\n        this.adapter = new (this.server.adapter())(this);\n    }\n    /**\n     * Registers a middleware, which is a function that gets executed for every incoming {@link Socket}.\n     *\n     * @example\n     * const myNamespace = io.of(\"/my-namespace\");\n     *\n     * myNamespace.use((socket, next) => {\n     *   // ...\n     *   next();\n     * });\n     *\n     * @param fn - the middleware function\n     */ use(fn) {\n        this._fns.push(fn);\n        return this;\n    }\n    /**\n     * Executes the middleware for an incoming client.\n     *\n     * @param socket - the socket that will get added\n     * @param fn - last fn call in the middleware\n     * @private\n     */ run(socket, fn) {\n        if (!this._fns.length) return fn();\n        const fns = this._fns.slice(0);\n        function run(i) {\n            fns[i](socket, (err)=>{\n                // upon error, short-circuit\n                if (err) return fn(err);\n                // if no middleware left, summon callback\n                if (!fns[i + 1]) return fn();\n                // go on to next\n                run(i + 1);\n            });\n        }\n        run(0);\n    }\n    /**\n     * Targets a room when emitting.\n     *\n     * @example\n     * const myNamespace = io.of(\"/my-namespace\");\n     *\n     * // the foo event will be broadcast to all connected clients in the room-101 room\n     * myNamespace.to(\"room-101\").emit(\"foo\", \"bar\");\n     *\n     * // with an array of rooms (a client will be notified at most once)\n     * myNamespace.to([\"room-101\", \"room-102\"]).emit(\"foo\", \"bar\");\n     *\n     * // with multiple chained calls\n     * myNamespace.to(\"room-101\").to(\"room-102\").emit(\"foo\", \"bar\");\n     *\n     * @param room - a room, or an array of rooms\n     * @return a new {@link BroadcastOperator} instance for chaining\n     */ to(room) {\n        return new broadcast_operator_1.BroadcastOperator(this.adapter).to(room);\n    }\n    /**\n     * Targets a room when emitting. Similar to `to()`, but might feel clearer in some cases:\n     *\n     * @example\n     * const myNamespace = io.of(\"/my-namespace\");\n     *\n     * // disconnect all clients in the \"room-101\" room\n     * myNamespace.in(\"room-101\").disconnectSockets();\n     *\n     * @param room - a room, or an array of rooms\n     * @return a new {@link BroadcastOperator} instance for chaining\n     */ in(room) {\n        return new broadcast_operator_1.BroadcastOperator(this.adapter).in(room);\n    }\n    /**\n     * Excludes a room when emitting.\n     *\n     * @example\n     * const myNamespace = io.of(\"/my-namespace\");\n     *\n     * // the \"foo\" event will be broadcast to all connected clients, except the ones that are in the \"room-101\" room\n     * myNamespace.except(\"room-101\").emit(\"foo\", \"bar\");\n     *\n     * // with an array of rooms\n     * myNamespace.except([\"room-101\", \"room-102\"]).emit(\"foo\", \"bar\");\n     *\n     * // with multiple chained calls\n     * myNamespace.except(\"room-101\").except(\"room-102\").emit(\"foo\", \"bar\");\n     *\n     * @param room - a room, or an array of rooms\n     * @return a new {@link BroadcastOperator} instance for chaining\n     */ except(room) {\n        return new broadcast_operator_1.BroadcastOperator(this.adapter).except(room);\n    }\n    /**\n     * Adds a new client.\n     *\n     * @return {Socket}\n     * @private\n     */ async _add(client, auth, fn) {\n        var _a;\n        debug(\"adding socket to nsp %s\", this.name);\n        const socket = await this._createSocket(client, auth);\n        this._preConnectSockets.set(socket.id, socket);\n        if (// @ts-ignore\n        ((_a = this.server.opts.connectionStateRecovery) === null || _a === void 0 ? void 0 : _a.skipMiddlewares) && socket.recovered && client.conn.readyState === \"open\") {\n            return this._doConnect(socket, fn);\n        }\n        this.run(socket, (err)=>{\n            process.nextTick(()=>{\n                if (\"open\" !== client.conn.readyState) {\n                    debug(\"next called after client was closed - ignoring socket\");\n                    socket._cleanup();\n                    return;\n                }\n                if (err) {\n                    debug(\"middleware error, sending CONNECT_ERROR packet to the client\");\n                    socket._cleanup();\n                    if (client.conn.protocol === 3) {\n                        return socket._error(err.data || err.message);\n                    } else {\n                        return socket._error({\n                            message: err.message,\n                            data: err.data\n                        });\n                    }\n                }\n                this._doConnect(socket, fn);\n            });\n        });\n    }\n    async _createSocket(client, auth) {\n        const sessionId = auth.pid;\n        const offset = auth.offset;\n        if (// @ts-ignore\n        this.server.opts.connectionStateRecovery && typeof sessionId === \"string\" && typeof offset === \"string\") {\n            let session;\n            try {\n                session = await this.adapter.restoreSession(sessionId, offset);\n            } catch (e) {\n                debug(\"error while restoring session: %s\", e);\n            }\n            if (session) {\n                debug(\"connection state recovered for sid %s\", session.sid);\n                return new socket_1.Socket(this, client, auth, session);\n            }\n        }\n        return new socket_1.Socket(this, client, auth);\n    }\n    _doConnect(socket, fn) {\n        this._preConnectSockets.delete(socket.id);\n        this.sockets.set(socket.id, socket);\n        // it's paramount that the internal `onconnect` logic\n        // fires before user-set events to prevent state order\n        // violations (such as a disconnection before the connection\n        // logic is complete)\n        socket._onconnect();\n        if (fn) fn(socket);\n        // fire user-set events\n        this.emitReserved(\"connect\", socket);\n        this.emitReserved(\"connection\", socket);\n    }\n    /**\n     * Removes a client. Called by each `Socket`.\n     *\n     * @private\n     */ _remove(socket) {\n        this.sockets.delete(socket.id) || this._preConnectSockets.delete(socket.id);\n    }\n    /**\n     * Emits to all connected clients.\n     *\n     * @example\n     * const myNamespace = io.of(\"/my-namespace\");\n     *\n     * myNamespace.emit(\"hello\", \"world\");\n     *\n     * // all serializable datastructures are supported (no need to call JSON.stringify)\n     * myNamespace.emit(\"hello\", 1, \"2\", { 3: [\"4\"], 5: Uint8Array.from([6]) });\n     *\n     * // with an acknowledgement from the clients\n     * myNamespace.timeout(1000).emit(\"some-event\", (err, responses) => {\n     *   if (err) {\n     *     // some clients did not acknowledge the event in the given delay\n     *   } else {\n     *     console.log(responses); // one response per client\n     *   }\n     * });\n     *\n     * @return Always true\n     */ emit(ev, ...args) {\n        return new broadcast_operator_1.BroadcastOperator(this.adapter).emit(ev, ...args);\n    }\n    /**\n     * Sends a `message` event to all clients.\n     *\n     * This method mimics the WebSocket.send() method.\n     *\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/send\n     *\n     * @example\n     * const myNamespace = io.of(\"/my-namespace\");\n     *\n     * myNamespace.send(\"hello\");\n     *\n     * // this is equivalent to\n     * myNamespace.emit(\"message\", \"hello\");\n     *\n     * @return self\n     */ send(...args) {\n        // This type-cast is needed because EmitEvents likely doesn't have `message` as a key.\n        // if you specify the EmitEvents, the type of args will be never.\n        this.emit(\"message\", ...args);\n        return this;\n    }\n    /**\n     * Sends a `message` event to all clients. Sends a `message` event. Alias of {@link send}.\n     *\n     * @return self\n     */ write(...args) {\n        // This type-cast is needed because EmitEvents likely doesn't have `message` as a key.\n        // if you specify the EmitEvents, the type of args will be never.\n        this.emit(\"message\", ...args);\n        return this;\n    }\n    /**\n     * Sends a message to the other Socket.IO servers of the cluster.\n     *\n     * @example\n     * const myNamespace = io.of(\"/my-namespace\");\n     *\n     * myNamespace.serverSideEmit(\"hello\", \"world\");\n     *\n     * myNamespace.on(\"hello\", (arg1) => {\n     *   console.log(arg1); // prints \"world\"\n     * });\n     *\n     * // acknowledgements (without binary content) are supported too:\n     * myNamespace.serverSideEmit(\"ping\", (err, responses) => {\n     *  if (err) {\n     *     // some servers did not acknowledge the event in the given delay\n     *   } else {\n     *     console.log(responses); // one response per server (except the current one)\n     *   }\n     * });\n     *\n     * myNamespace.on(\"ping\", (cb) => {\n     *   cb(\"pong\");\n     * });\n     *\n     * @param ev - the event name\n     * @param args - an array of arguments, which may include an acknowledgement callback at the end\n     */ serverSideEmit(ev, ...args) {\n        if (exports.RESERVED_EVENTS.has(ev)) {\n            throw new Error(`\"${String(ev)}\" is a reserved event name`);\n        }\n        args.unshift(ev);\n        this.adapter.serverSideEmit(args);\n        return true;\n    }\n    /**\n     * Sends a message and expect an acknowledgement from the other Socket.IO servers of the cluster.\n     *\n     * @example\n     * const myNamespace = io.of(\"/my-namespace\");\n     *\n     * try {\n     *   const responses = await myNamespace.serverSideEmitWithAck(\"ping\");\n     *   console.log(responses); // one response per server (except the current one)\n     * } catch (e) {\n     *   // some servers did not acknowledge the event in the given delay\n     * }\n     *\n     * @param ev - the event name\n     * @param args - an array of arguments\n     *\n     * @return a Promise that will be fulfilled when all servers have acknowledged the event\n     */ serverSideEmitWithAck(ev, ...args) {\n        return new Promise((resolve, reject)=>{\n            args.push((err, responses)=>{\n                if (err) {\n                    err.responses = responses;\n                    return reject(err);\n                } else {\n                    return resolve(responses);\n                }\n            });\n            this.serverSideEmit(ev, ...args);\n        });\n    }\n    /**\n     * Called when a packet is received from another Socket.IO server\n     *\n     * @param args - an array of arguments, which may include an acknowledgement callback at the end\n     *\n     * @private\n     */ _onServerSideEmit(args) {\n        super.emitUntyped.apply(this, args);\n    }\n    /**\n     * Gets a list of clients.\n     *\n     * @deprecated this method will be removed in the next major release, please use {@link Namespace#serverSideEmit} or\n     * {@link Namespace#fetchSockets} instead.\n     */ allSockets() {\n        return new broadcast_operator_1.BroadcastOperator(this.adapter).allSockets();\n    }\n    /**\n     * Sets the compress flag.\n     *\n     * @example\n     * const myNamespace = io.of(\"/my-namespace\");\n     *\n     * myNamespace.compress(false).emit(\"hello\");\n     *\n     * @param compress - if `true`, compresses the sending data\n     * @return self\n     */ compress(compress) {\n        return new broadcast_operator_1.BroadcastOperator(this.adapter).compress(compress);\n    }\n    /**\n     * Sets a modifier for a subsequent event emission that the event data may be lost if the client is not ready to\n     * receive messages (because of network slowness or other issues, or because theyre connected through long polling\n     * and is in the middle of a request-response cycle).\n     *\n     * @example\n     * const myNamespace = io.of(\"/my-namespace\");\n     *\n     * myNamespace.volatile.emit(\"hello\"); // the clients may or may not receive it\n     *\n     * @return self\n     */ get volatile() {\n        return new broadcast_operator_1.BroadcastOperator(this.adapter).volatile;\n    }\n    /**\n     * Sets a modifier for a subsequent event emission that the event data will only be broadcast to the current node.\n     *\n     * @example\n     * const myNamespace = io.of(\"/my-namespace\");\n     *\n     * // the foo event will be broadcast to all connected clients on this node\n     * myNamespace.local.emit(\"foo\", \"bar\");\n     *\n     * @return a new {@link BroadcastOperator} instance for chaining\n     */ get local() {\n        return new broadcast_operator_1.BroadcastOperator(this.adapter).local;\n    }\n    /**\n     * Adds a timeout in milliseconds for the next operation.\n     *\n     * @example\n     * const myNamespace = io.of(\"/my-namespace\");\n     *\n     * myNamespace.timeout(1000).emit(\"some-event\", (err, responses) => {\n     *   if (err) {\n     *     // some clients did not acknowledge the event in the given delay\n     *   } else {\n     *     console.log(responses); // one response per client\n     *   }\n     * });\n     *\n     * @param timeout\n     */ timeout(timeout) {\n        return new broadcast_operator_1.BroadcastOperator(this.adapter).timeout(timeout);\n    }\n    /**\n     * Returns the matching socket instances.\n     *\n     * Note: this method also works within a cluster of multiple Socket.IO servers, with a compatible {@link Adapter}.\n     *\n     * @example\n     * const myNamespace = io.of(\"/my-namespace\");\n     *\n     * // return all Socket instances\n     * const sockets = await myNamespace.fetchSockets();\n     *\n     * // return all Socket instances in the \"room1\" room\n     * const sockets = await myNamespace.in(\"room1\").fetchSockets();\n     *\n     * for (const socket of sockets) {\n     *   console.log(socket.id);\n     *   console.log(socket.handshake);\n     *   console.log(socket.rooms);\n     *   console.log(socket.data);\n     *\n     *   socket.emit(\"hello\");\n     *   socket.join(\"room1\");\n     *   socket.leave(\"room2\");\n     *   socket.disconnect();\n     * }\n     */ fetchSockets() {\n        return new broadcast_operator_1.BroadcastOperator(this.adapter).fetchSockets();\n    }\n    /**\n     * Makes the matching socket instances join the specified rooms.\n     *\n     * Note: this method also works within a cluster of multiple Socket.IO servers, with a compatible {@link Adapter}.\n     *\n     * @example\n     * const myNamespace = io.of(\"/my-namespace\");\n     *\n     * // make all socket instances join the \"room1\" room\n     * myNamespace.socketsJoin(\"room1\");\n     *\n     * // make all socket instances in the \"room1\" room join the \"room2\" and \"room3\" rooms\n     * myNamespace.in(\"room1\").socketsJoin([\"room2\", \"room3\"]);\n     *\n     * @param room - a room, or an array of rooms\n     */ socketsJoin(room) {\n        return new broadcast_operator_1.BroadcastOperator(this.adapter).socketsJoin(room);\n    }\n    /**\n     * Makes the matching socket instances leave the specified rooms.\n     *\n     * Note: this method also works within a cluster of multiple Socket.IO servers, with a compatible {@link Adapter}.\n     *\n     * @example\n     * const myNamespace = io.of(\"/my-namespace\");\n     *\n     * // make all socket instances leave the \"room1\" room\n     * myNamespace.socketsLeave(\"room1\");\n     *\n     * // make all socket instances in the \"room1\" room leave the \"room2\" and \"room3\" rooms\n     * myNamespace.in(\"room1\").socketsLeave([\"room2\", \"room3\"]);\n     *\n     * @param room - a room, or an array of rooms\n     */ socketsLeave(room) {\n        return new broadcast_operator_1.BroadcastOperator(this.adapter).socketsLeave(room);\n    }\n    /**\n     * Makes the matching socket instances disconnect.\n     *\n     * Note: this method also works within a cluster of multiple Socket.IO servers, with a compatible {@link Adapter}.\n     *\n     * @example\n     * const myNamespace = io.of(\"/my-namespace\");\n     *\n     * // make all socket instances disconnect (the connections might be kept alive for other namespaces)\n     * myNamespace.disconnectSockets();\n     *\n     * // make all socket instances in the \"room1\" room disconnect and close the underlying connections\n     * myNamespace.in(\"room1\").disconnectSockets(true);\n     *\n     * @param close - whether to close the underlying connection\n     */ disconnectSockets(close = false) {\n        return new broadcast_operator_1.BroadcastOperator(this.adapter).disconnectSockets(close);\n    }\n}\nexports.Namespace = Namespace;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc29ja2V0LmlvL2Rpc3QvbmFtZXNwYWNlLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsSUFBSUEsa0JBQWtCLENBQUMsTUFBRyxLQUFLLE9BQUcsRUFBRUEsZUFBZSxJQUFLLFNBQVVDLEdBQUc7SUFDakUsT0FBTyxPQUFRQSxJQUFJQyxVQUFVLEdBQUlELE1BQU07UUFBRSxXQUFXQTtJQUFJO0FBQzVEO0FBQ0FFLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxpQkFBaUIsR0FBR0EsdUJBQXVCLEdBQUcsS0FBSztBQUNuRCxNQUFNSSxXQUFXQyxtQkFBT0EsQ0FBQywrREFBVTtBQUNuQyxNQUFNQyxpQkFBaUJELG1CQUFPQSxDQUFDLDJFQUFnQjtBQUMvQyxNQUFNRSxVQUFVWixnQkFBZ0JVLG1CQUFPQSxDQUFDLDZFQUFPO0FBQy9DLE1BQU1HLHVCQUF1QkgsbUJBQU9BLENBQUMsdUZBQXNCO0FBQzNELE1BQU1JLFFBQVEsQ0FBQyxHQUFHRixRQUFRRyxPQUFPLEVBQUU7QUFDbkNWLHVCQUF1QixHQUFHLElBQUlXLElBQUk7SUFBQztJQUFXO0lBQWM7Q0FBZ0I7QUFDNUU7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FvREMsR0FDRCxNQUFNVCxrQkFBa0JJLGVBQWVNLGtCQUFrQjtJQUNyRDs7Ozs7S0FLQyxHQUNEQyxZQUFZQyxNQUFNLEVBQUVDLElBQUksQ0FBRTtRQUN0QixLQUFLO1FBQ0w7O1NBRUMsR0FDRCxJQUFJLENBQUNDLE9BQU8sR0FBRyxJQUFJQztRQUNuQjs7U0FFQyxHQUNELElBQUksQ0FBQ0Msa0JBQWtCLEdBQUcsSUFBSUQ7UUFDOUIsSUFBSSxDQUFDRSxJQUFJLEdBQUcsRUFBRTtRQUNkLGFBQWEsR0FDYixJQUFJLENBQUNDLElBQUksR0FBRztRQUNaLElBQUksQ0FBQ04sTUFBTSxHQUFHQTtRQUNkLElBQUksQ0FBQ0MsSUFBSSxHQUFHQTtRQUNaLElBQUksQ0FBQ00sWUFBWTtJQUNyQjtJQUNBOzs7Ozs7S0FNQyxHQUNEQSxlQUFlO1FBQ1gsYUFBYTtRQUNiLElBQUksQ0FBQ0MsT0FBTyxHQUFHLElBQUssS0FBSSxDQUFDUixNQUFNLENBQUNRLE9BQU8sRUFBQyxFQUFHLElBQUk7SUFDbkQ7SUFDQTs7Ozs7Ozs7Ozs7O0tBWUMsR0FDREMsSUFBSUMsRUFBRSxFQUFFO1FBQ0osSUFBSSxDQUFDTCxJQUFJLENBQUNNLElBQUksQ0FBQ0Q7UUFDZixPQUFPLElBQUk7SUFDZjtJQUNBOzs7Ozs7S0FNQyxHQUNERSxJQUFJQyxNQUFNLEVBQUVILEVBQUUsRUFBRTtRQUNaLElBQUksQ0FBQyxJQUFJLENBQUNMLElBQUksQ0FBQ1MsTUFBTSxFQUNqQixPQUFPSjtRQUNYLE1BQU1LLE1BQU0sSUFBSSxDQUFDVixJQUFJLENBQUNXLEtBQUssQ0FBQztRQUM1QixTQUFTSixJQUFJSyxDQUFDO1lBQ1ZGLEdBQUcsQ0FBQ0UsRUFBRSxDQUFDSixRQUFRLENBQUNLO2dCQUNaLDRCQUE0QjtnQkFDNUIsSUFBSUEsS0FDQSxPQUFPUixHQUFHUTtnQkFDZCx5Q0FBeUM7Z0JBQ3pDLElBQUksQ0FBQ0gsR0FBRyxDQUFDRSxJQUFJLEVBQUUsRUFDWCxPQUFPUDtnQkFDWCxnQkFBZ0I7Z0JBQ2hCRSxJQUFJSyxJQUFJO1lBQ1o7UUFDSjtRQUNBTCxJQUFJO0lBQ1I7SUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7S0FpQkMsR0FDRE8sR0FBR0MsSUFBSSxFQUFFO1FBQ0wsT0FBTyxJQUFJMUIscUJBQXFCMkIsaUJBQWlCLENBQUMsSUFBSSxDQUFDYixPQUFPLEVBQUVXLEVBQUUsQ0FBQ0M7SUFDdkU7SUFDQTs7Ozs7Ozs7Ozs7S0FXQyxHQUNERSxHQUFHRixJQUFJLEVBQUU7UUFDTCxPQUFPLElBQUkxQixxQkFBcUIyQixpQkFBaUIsQ0FBQyxJQUFJLENBQUNiLE9BQU8sRUFBRWMsRUFBRSxDQUFDRjtJQUN2RTtJQUNBOzs7Ozs7Ozs7Ozs7Ozs7OztLQWlCQyxHQUNERyxPQUFPSCxJQUFJLEVBQUU7UUFDVCxPQUFPLElBQUkxQixxQkFBcUIyQixpQkFBaUIsQ0FBQyxJQUFJLENBQUNiLE9BQU8sRUFBRWUsTUFBTSxDQUFDSDtJQUMzRTtJQUNBOzs7OztLQUtDLEdBQ0QsTUFBTUksS0FBS0MsTUFBTSxFQUFFQyxJQUFJLEVBQUVoQixFQUFFLEVBQUU7UUFDekIsSUFBSWlCO1FBQ0poQyxNQUFNLDJCQUEyQixJQUFJLENBQUNNLElBQUk7UUFDMUMsTUFBTVksU0FBUyxNQUFNLElBQUksQ0FBQ2UsYUFBYSxDQUFDSCxRQUFRQztRQUNoRCxJQUFJLENBQUN0QixrQkFBa0IsQ0FBQ3lCLEdBQUcsQ0FBQ2hCLE9BQU9pQixFQUFFLEVBQUVqQjtRQUN2QyxJQUVBLGFBRGE7UUFDWixFQUFDYyxLQUFLLElBQUksQ0FBQzNCLE1BQU0sQ0FBQytCLElBQUksQ0FBQ0MsdUJBQXVCLE1BQU0sUUFBUUwsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHTSxlQUFlLEtBQ3BHcEIsT0FBT3FCLFNBQVMsSUFDaEJULE9BQU9VLElBQUksQ0FBQ0MsVUFBVSxLQUFLLFFBQVE7WUFDbkMsT0FBTyxJQUFJLENBQUNDLFVBQVUsQ0FBQ3hCLFFBQVFIO1FBQ25DO1FBQ0EsSUFBSSxDQUFDRSxHQUFHLENBQUNDLFFBQVEsQ0FBQ0s7WUFDZG9CLFFBQVFDLFFBQVEsQ0FBQztnQkFDYixJQUFJLFdBQVdkLE9BQU9VLElBQUksQ0FBQ0MsVUFBVSxFQUFFO29CQUNuQ3pDLE1BQU07b0JBQ05rQixPQUFPMkIsUUFBUTtvQkFDZjtnQkFDSjtnQkFDQSxJQUFJdEIsS0FBSztvQkFDTHZCLE1BQU07b0JBQ05rQixPQUFPMkIsUUFBUTtvQkFDZixJQUFJZixPQUFPVSxJQUFJLENBQUNNLFFBQVEsS0FBSyxHQUFHO3dCQUM1QixPQUFPNUIsT0FBTzZCLE1BQU0sQ0FBQ3hCLElBQUl5QixJQUFJLElBQUl6QixJQUFJMEIsT0FBTztvQkFDaEQsT0FDSzt3QkFDRCxPQUFPL0IsT0FBTzZCLE1BQU0sQ0FBQzs0QkFDakJFLFNBQVMxQixJQUFJMEIsT0FBTzs0QkFDcEJELE1BQU16QixJQUFJeUIsSUFBSTt3QkFDbEI7b0JBQ0o7Z0JBQ0o7Z0JBQ0EsSUFBSSxDQUFDTixVQUFVLENBQUN4QixRQUFRSDtZQUM1QjtRQUNKO0lBQ0o7SUFDQSxNQUFNa0IsY0FBY0gsTUFBTSxFQUFFQyxJQUFJLEVBQUU7UUFDOUIsTUFBTW1CLFlBQVluQixLQUFLb0IsR0FBRztRQUMxQixNQUFNQyxTQUFTckIsS0FBS3FCLE1BQU07UUFDMUIsSUFDQSxhQUFhO1FBQ2IsSUFBSSxDQUFDL0MsTUFBTSxDQUFDK0IsSUFBSSxDQUFDQyx1QkFBdUIsSUFDcEMsT0FBT2EsY0FBYyxZQUNyQixPQUFPRSxXQUFXLFVBQVU7WUFDNUIsSUFBSUM7WUFDSixJQUFJO2dCQUNBQSxVQUFVLE1BQU0sSUFBSSxDQUFDeEMsT0FBTyxDQUFDeUMsY0FBYyxDQUFDSixXQUFXRTtZQUMzRCxFQUNBLE9BQU9HLEdBQUc7Z0JBQ052RCxNQUFNLHFDQUFxQ3VEO1lBQy9DO1lBQ0EsSUFBSUYsU0FBUztnQkFDVHJELE1BQU0seUNBQXlDcUQsUUFBUUcsR0FBRztnQkFDMUQsT0FBTyxJQUFJN0QsU0FBUzhELE1BQU0sQ0FBQyxJQUFJLEVBQUUzQixRQUFRQyxNQUFNc0I7WUFDbkQ7UUFDSjtRQUNBLE9BQU8sSUFBSTFELFNBQVM4RCxNQUFNLENBQUMsSUFBSSxFQUFFM0IsUUFBUUM7SUFDN0M7SUFDQVcsV0FBV3hCLE1BQU0sRUFBRUgsRUFBRSxFQUFFO1FBQ25CLElBQUksQ0FBQ04sa0JBQWtCLENBQUNpRCxNQUFNLENBQUN4QyxPQUFPaUIsRUFBRTtRQUN4QyxJQUFJLENBQUM1QixPQUFPLENBQUMyQixHQUFHLENBQUNoQixPQUFPaUIsRUFBRSxFQUFFakI7UUFDNUIscURBQXFEO1FBQ3JELHNEQUFzRDtRQUN0RCw0REFBNEQ7UUFDNUQscUJBQXFCO1FBQ3JCQSxPQUFPeUMsVUFBVTtRQUNqQixJQUFJNUMsSUFDQUEsR0FBR0c7UUFDUCx1QkFBdUI7UUFDdkIsSUFBSSxDQUFDMEMsWUFBWSxDQUFDLFdBQVcxQztRQUM3QixJQUFJLENBQUMwQyxZQUFZLENBQUMsY0FBYzFDO0lBQ3BDO0lBQ0E7Ozs7S0FJQyxHQUNEMkMsUUFBUTNDLE1BQU0sRUFBRTtRQUNaLElBQUksQ0FBQ1gsT0FBTyxDQUFDbUQsTUFBTSxDQUFDeEMsT0FBT2lCLEVBQUUsS0FBSyxJQUFJLENBQUMxQixrQkFBa0IsQ0FBQ2lELE1BQU0sQ0FBQ3hDLE9BQU9pQixFQUFFO0lBQzlFO0lBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztLQXFCQyxHQUNEMkIsS0FBS0MsRUFBRSxFQUFFLEdBQUdDLElBQUksRUFBRTtRQUNkLE9BQU8sSUFBSWpFLHFCQUFxQjJCLGlCQUFpQixDQUFDLElBQUksQ0FBQ2IsT0FBTyxFQUFFaUQsSUFBSSxDQUFDQyxPQUFPQztJQUNoRjtJQUNBOzs7Ozs7Ozs7Ozs7Ozs7O0tBZ0JDLEdBQ0RDLEtBQUssR0FBR0QsSUFBSSxFQUFFO1FBQ1Ysc0ZBQXNGO1FBQ3RGLGlFQUFpRTtRQUNqRSxJQUFJLENBQUNGLElBQUksQ0FBQyxjQUFjRTtRQUN4QixPQUFPLElBQUk7SUFDZjtJQUNBOzs7O0tBSUMsR0FDREUsTUFBTSxHQUFHRixJQUFJLEVBQUU7UUFDWCxzRkFBc0Y7UUFDdEYsaUVBQWlFO1FBQ2pFLElBQUksQ0FBQ0YsSUFBSSxDQUFDLGNBQWNFO1FBQ3hCLE9BQU8sSUFBSTtJQUNmO0lBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztLQTJCQyxHQUNERyxlQUFlSixFQUFFLEVBQUUsR0FBR0MsSUFBSSxFQUFFO1FBQ3hCLElBQUl6RSxRQUFRRyxlQUFlLENBQUMwRSxHQUFHLENBQUNMLEtBQUs7WUFDakMsTUFBTSxJQUFJTSxNQUFNLENBQUMsQ0FBQyxFQUFFQyxPQUFPUCxJQUFJLDBCQUEwQixDQUFDO1FBQzlEO1FBQ0FDLEtBQUtPLE9BQU8sQ0FBQ1I7UUFDYixJQUFJLENBQUNsRCxPQUFPLENBQUNzRCxjQUFjLENBQUNIO1FBQzVCLE9BQU87SUFDWDtJQUNBOzs7Ozs7Ozs7Ozs7Ozs7OztLQWlCQyxHQUNEUSxzQkFBc0JULEVBQUUsRUFBRSxHQUFHQyxJQUFJLEVBQUU7UUFDL0IsT0FBTyxJQUFJUyxRQUFRLENBQUNDLFNBQVNDO1lBQ3pCWCxLQUFLaEQsSUFBSSxDQUFDLENBQUNPLEtBQUtxRDtnQkFDWixJQUFJckQsS0FBSztvQkFDTEEsSUFBSXFELFNBQVMsR0FBR0E7b0JBQ2hCLE9BQU9ELE9BQU9wRDtnQkFDbEIsT0FDSztvQkFDRCxPQUFPbUQsUUFBUUU7Z0JBQ25CO1lBQ0o7WUFDQSxJQUFJLENBQUNULGNBQWMsQ0FBQ0osT0FBT0M7UUFDL0I7SUFDSjtJQUNBOzs7Ozs7S0FNQyxHQUNEYSxrQkFBa0JiLElBQUksRUFBRTtRQUNwQixLQUFLLENBQUNjLFlBQVlDLEtBQUssQ0FBQyxJQUFJLEVBQUVmO0lBQ2xDO0lBQ0E7Ozs7O0tBS0MsR0FDRGdCLGFBQWE7UUFDVCxPQUFPLElBQUlqRixxQkFBcUIyQixpQkFBaUIsQ0FBQyxJQUFJLENBQUNiLE9BQU8sRUFBRW1FLFVBQVU7SUFDOUU7SUFDQTs7Ozs7Ozs7OztLQVVDLEdBQ0RDLFNBQVNBLFFBQVEsRUFBRTtRQUNmLE9BQU8sSUFBSWxGLHFCQUFxQjJCLGlCQUFpQixDQUFDLElBQUksQ0FBQ2IsT0FBTyxFQUFFb0UsUUFBUSxDQUFDQTtJQUM3RTtJQUNBOzs7Ozs7Ozs7OztLQVdDLEdBQ0QsSUFBSUMsV0FBVztRQUNYLE9BQU8sSUFBSW5GLHFCQUFxQjJCLGlCQUFpQixDQUFDLElBQUksQ0FBQ2IsT0FBTyxFQUFFcUUsUUFBUTtJQUM1RTtJQUNBOzs7Ozs7Ozs7O0tBVUMsR0FDRCxJQUFJQyxRQUFRO1FBQ1IsT0FBTyxJQUFJcEYscUJBQXFCMkIsaUJBQWlCLENBQUMsSUFBSSxDQUFDYixPQUFPLEVBQUVzRSxLQUFLO0lBQ3pFO0lBQ0E7Ozs7Ozs7Ozs7Ozs7OztLQWVDLEdBQ0RDLFFBQVFBLE9BQU8sRUFBRTtRQUNiLE9BQU8sSUFBSXJGLHFCQUFxQjJCLGlCQUFpQixDQUFDLElBQUksQ0FBQ2IsT0FBTyxFQUFFdUUsT0FBTyxDQUFDQTtJQUM1RTtJQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0tBeUJDLEdBQ0RDLGVBQWU7UUFDWCxPQUFPLElBQUl0RixxQkFBcUIyQixpQkFBaUIsQ0FBQyxJQUFJLENBQUNiLE9BQU8sRUFBRXdFLFlBQVk7SUFDaEY7SUFDQTs7Ozs7Ozs7Ozs7Ozs7O0tBZUMsR0FDREMsWUFBWTdELElBQUksRUFBRTtRQUNkLE9BQU8sSUFBSTFCLHFCQUFxQjJCLGlCQUFpQixDQUFDLElBQUksQ0FBQ2IsT0FBTyxFQUFFeUUsV0FBVyxDQUFDN0Q7SUFDaEY7SUFDQTs7Ozs7Ozs7Ozs7Ozs7O0tBZUMsR0FDRDhELGFBQWE5RCxJQUFJLEVBQUU7UUFDZixPQUFPLElBQUkxQixxQkFBcUIyQixpQkFBaUIsQ0FBQyxJQUFJLENBQUNiLE9BQU8sRUFBRTBFLFlBQVksQ0FBQzlEO0lBQ2pGO0lBQ0E7Ozs7Ozs7Ozs7Ozs7OztLQWVDLEdBQ0QrRCxrQkFBa0JDLFFBQVEsS0FBSyxFQUFFO1FBQzdCLE9BQU8sSUFBSTFGLHFCQUFxQjJCLGlCQUFpQixDQUFDLElBQUksQ0FBQ2IsT0FBTyxFQUFFMkUsaUJBQWlCLENBQUNDO0lBQ3RGO0FBQ0o7QUFDQWxHLGlCQUFpQixHQUFHRSIsInNvdXJjZXMiOlsid2VicGFjazovL2V4YW1yb3NoLy4vbm9kZV9tb2R1bGVzL3NvY2tldC5pby9kaXN0L25hbWVzcGFjZS5qcz9iOTdlIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5OYW1lc3BhY2UgPSBleHBvcnRzLlJFU0VSVkVEX0VWRU5UUyA9IHZvaWQgMDtcbmNvbnN0IHNvY2tldF8xID0gcmVxdWlyZShcIi4vc29ja2V0XCIpO1xuY29uc3QgdHlwZWRfZXZlbnRzXzEgPSByZXF1aXJlKFwiLi90eXBlZC1ldmVudHNcIik7XG5jb25zdCBkZWJ1Z18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJkZWJ1Z1wiKSk7XG5jb25zdCBicm9hZGNhc3Rfb3BlcmF0b3JfMSA9IHJlcXVpcmUoXCIuL2Jyb2FkY2FzdC1vcGVyYXRvclwiKTtcbmNvbnN0IGRlYnVnID0gKDAsIGRlYnVnXzEuZGVmYXVsdCkoXCJzb2NrZXQuaW86bmFtZXNwYWNlXCIpO1xuZXhwb3J0cy5SRVNFUlZFRF9FVkVOVFMgPSBuZXcgU2V0KFtcImNvbm5lY3RcIiwgXCJjb25uZWN0aW9uXCIsIFwibmV3X25hbWVzcGFjZVwiXSk7XG4vKipcbiAqIEEgTmFtZXNwYWNlIGlzIGEgY29tbXVuaWNhdGlvbiBjaGFubmVsIHRoYXQgYWxsb3dzIHlvdSB0byBzcGxpdCB0aGUgbG9naWMgb2YgeW91ciBhcHBsaWNhdGlvbiBvdmVyIGEgc2luZ2xlIHNoYXJlZFxuICogY29ubmVjdGlvbi5cbiAqXG4gKiBFYWNoIG5hbWVzcGFjZSBoYXMgaXRzIG93bjpcbiAqXG4gKiAtIGV2ZW50IGhhbmRsZXJzXG4gKlxuICogYGBgXG4gKiBpby5vZihcIi9vcmRlcnNcIikub24oXCJjb25uZWN0aW9uXCIsIChzb2NrZXQpID0+IHtcbiAqICAgc29ja2V0Lm9uKFwib3JkZXI6bGlzdFwiLCAoKSA9PiB7fSk7XG4gKiAgIHNvY2tldC5vbihcIm9yZGVyOmNyZWF0ZVwiLCAoKSA9PiB7fSk7XG4gKiB9KTtcbiAqXG4gKiBpby5vZihcIi91c2Vyc1wiKS5vbihcImNvbm5lY3Rpb25cIiwgKHNvY2tldCkgPT4ge1xuICogICBzb2NrZXQub24oXCJ1c2VyOmxpc3RcIiwgKCkgPT4ge30pO1xuICogfSk7XG4gKiBgYGBcbiAqXG4gKiAtIHJvb21zXG4gKlxuICogYGBgXG4gKiBjb25zdCBvcmRlck5hbWVzcGFjZSA9IGlvLm9mKFwiL29yZGVyc1wiKTtcbiAqXG4gKiBvcmRlck5hbWVzcGFjZS5vbihcImNvbm5lY3Rpb25cIiwgKHNvY2tldCkgPT4ge1xuICogICBzb2NrZXQuam9pbihcInJvb20xXCIpO1xuICogICBvcmRlck5hbWVzcGFjZS50byhcInJvb20xXCIpLmVtaXQoXCJoZWxsb1wiKTtcbiAqIH0pO1xuICpcbiAqIGNvbnN0IHVzZXJOYW1lc3BhY2UgPSBpby5vZihcIi91c2Vyc1wiKTtcbiAqXG4gKiB1c2VyTmFtZXNwYWNlLm9uKFwiY29ubmVjdGlvblwiLCAoc29ja2V0KSA9PiB7XG4gKiAgIHNvY2tldC5qb2luKFwicm9vbTFcIik7IC8vIGRpc3RpbmN0IGZyb20gdGhlIHJvb20gaW4gdGhlIFwib3JkZXJzXCIgbmFtZXNwYWNlXG4gKiAgIHVzZXJOYW1lc3BhY2UudG8oXCJyb29tMVwiKS5lbWl0KFwiaG9sw6BcIik7XG4gKiB9KTtcbiAqIGBgYFxuICpcbiAqIC0gbWlkZGxld2FyZXNcbiAqXG4gKiBgYGBcbiAqIGNvbnN0IG9yZGVyTmFtZXNwYWNlID0gaW8ub2YoXCIvb3JkZXJzXCIpO1xuICpcbiAqIG9yZGVyTmFtZXNwYWNlLnVzZSgoc29ja2V0LCBuZXh0KSA9PiB7XG4gKiAgIC8vIGVuc3VyZSB0aGUgc29ja2V0IGhhcyBhY2Nlc3MgdG8gdGhlIFwib3JkZXJzXCIgbmFtZXNwYWNlXG4gKiB9KTtcbiAqXG4gKiBjb25zdCB1c2VyTmFtZXNwYWNlID0gaW8ub2YoXCIvdXNlcnNcIik7XG4gKlxuICogdXNlck5hbWVzcGFjZS51c2UoKHNvY2tldCwgbmV4dCkgPT4ge1xuICogICAvLyBlbnN1cmUgdGhlIHNvY2tldCBoYXMgYWNjZXNzIHRvIHRoZSBcInVzZXJzXCIgbmFtZXNwYWNlXG4gKiB9KTtcbiAqIGBgYFxuICovXG5jbGFzcyBOYW1lc3BhY2UgZXh0ZW5kcyB0eXBlZF9ldmVudHNfMS5TdHJpY3RFdmVudEVtaXR0ZXIge1xuICAgIC8qKlxuICAgICAqIE5hbWVzcGFjZSBjb25zdHJ1Y3Rvci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBzZXJ2ZXIgaW5zdGFuY2VcbiAgICAgKiBAcGFyYW0gbmFtZVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHNlcnZlciwgbmFtZSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogQSBtYXAgb2YgY3VycmVudGx5IGNvbm5lY3RlZCBzb2NrZXRzLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zb2NrZXRzID0gbmV3IE1hcCgpO1xuICAgICAgICAvKipcbiAgICAgICAgICogQSBtYXAgb2YgY3VycmVudGx5IGNvbm5lY3Rpbmcgc29ja2V0cy5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX3ByZUNvbm5lY3RTb2NrZXRzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLl9mbnMgPSBbXTtcbiAgICAgICAgLyoqIEBwcml2YXRlICovXG4gICAgICAgIHRoaXMuX2lkcyA9IDA7XG4gICAgICAgIHRoaXMuc2VydmVyID0gc2VydmVyO1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLl9pbml0QWRhcHRlcigpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplcyB0aGUgYEFkYXB0ZXJgIGZvciB0aGlzIG5zcC5cbiAgICAgKiBSdW4gdXBvbiBjaGFuZ2luZyBhZGFwdGVyIGJ5IGBTZXJ2ZXIjYWRhcHRlcmBcbiAgICAgKiBpbiBhZGRpdGlvbiB0byB0aGUgY29uc3RydWN0b3IuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9pbml0QWRhcHRlcigpIHtcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICB0aGlzLmFkYXB0ZXIgPSBuZXcgKHRoaXMuc2VydmVyLmFkYXB0ZXIoKSkodGhpcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVycyBhIG1pZGRsZXdhcmUsIHdoaWNoIGlzIGEgZnVuY3Rpb24gdGhhdCBnZXRzIGV4ZWN1dGVkIGZvciBldmVyeSBpbmNvbWluZyB7QGxpbmsgU29ja2V0fS5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogY29uc3QgbXlOYW1lc3BhY2UgPSBpby5vZihcIi9teS1uYW1lc3BhY2VcIik7XG4gICAgICpcbiAgICAgKiBteU5hbWVzcGFjZS51c2UoKHNvY2tldCwgbmV4dCkgPT4ge1xuICAgICAqICAgLy8gLi4uXG4gICAgICogICBuZXh0KCk7XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBAcGFyYW0gZm4gLSB0aGUgbWlkZGxld2FyZSBmdW5jdGlvblxuICAgICAqL1xuICAgIHVzZShmbikge1xuICAgICAgICB0aGlzLl9mbnMucHVzaChmbik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFeGVjdXRlcyB0aGUgbWlkZGxld2FyZSBmb3IgYW4gaW5jb21pbmcgY2xpZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIHNvY2tldCAtIHRoZSBzb2NrZXQgdGhhdCB3aWxsIGdldCBhZGRlZFxuICAgICAqIEBwYXJhbSBmbiAtIGxhc3QgZm4gY2FsbCBpbiB0aGUgbWlkZGxld2FyZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgcnVuKHNvY2tldCwgZm4pIHtcbiAgICAgICAgaWYgKCF0aGlzLl9mbnMubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIGZuKCk7XG4gICAgICAgIGNvbnN0IGZucyA9IHRoaXMuX2Zucy5zbGljZSgwKTtcbiAgICAgICAgZnVuY3Rpb24gcnVuKGkpIHtcbiAgICAgICAgICAgIGZuc1tpXShzb2NrZXQsIChlcnIpID0+IHtcbiAgICAgICAgICAgICAgICAvLyB1cG9uIGVycm9yLCBzaG9ydC1jaXJjdWl0XG4gICAgICAgICAgICAgICAgaWYgKGVycilcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZuKGVycik7XG4gICAgICAgICAgICAgICAgLy8gaWYgbm8gbWlkZGxld2FyZSBsZWZ0LCBzdW1tb24gY2FsbGJhY2tcbiAgICAgICAgICAgICAgICBpZiAoIWZuc1tpICsgMV0pXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmbigpO1xuICAgICAgICAgICAgICAgIC8vIGdvIG9uIHRvIG5leHRcbiAgICAgICAgICAgICAgICBydW4oaSArIDEpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcnVuKDApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUYXJnZXRzIGEgcm9vbSB3aGVuIGVtaXR0aW5nLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBjb25zdCBteU5hbWVzcGFjZSA9IGlvLm9mKFwiL215LW5hbWVzcGFjZVwiKTtcbiAgICAgKlxuICAgICAqIC8vIHRoZSDigJxmb2/igJ0gZXZlbnQgd2lsbCBiZSBicm9hZGNhc3QgdG8gYWxsIGNvbm5lY3RlZCBjbGllbnRzIGluIHRoZSDigJxyb29tLTEwMeKAnSByb29tXG4gICAgICogbXlOYW1lc3BhY2UudG8oXCJyb29tLTEwMVwiKS5lbWl0KFwiZm9vXCIsIFwiYmFyXCIpO1xuICAgICAqXG4gICAgICogLy8gd2l0aCBhbiBhcnJheSBvZiByb29tcyAoYSBjbGllbnQgd2lsbCBiZSBub3RpZmllZCBhdCBtb3N0IG9uY2UpXG4gICAgICogbXlOYW1lc3BhY2UudG8oW1wicm9vbS0xMDFcIiwgXCJyb29tLTEwMlwiXSkuZW1pdChcImZvb1wiLCBcImJhclwiKTtcbiAgICAgKlxuICAgICAqIC8vIHdpdGggbXVsdGlwbGUgY2hhaW5lZCBjYWxsc1xuICAgICAqIG15TmFtZXNwYWNlLnRvKFwicm9vbS0xMDFcIikudG8oXCJyb29tLTEwMlwiKS5lbWl0KFwiZm9vXCIsIFwiYmFyXCIpO1xuICAgICAqXG4gICAgICogQHBhcmFtIHJvb20gLSBhIHJvb20sIG9yIGFuIGFycmF5IG9mIHJvb21zXG4gICAgICogQHJldHVybiBhIG5ldyB7QGxpbmsgQnJvYWRjYXN0T3BlcmF0b3J9IGluc3RhbmNlIGZvciBjaGFpbmluZ1xuICAgICAqL1xuICAgIHRvKHJvb20pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBicm9hZGNhc3Rfb3BlcmF0b3JfMS5Ccm9hZGNhc3RPcGVyYXRvcih0aGlzLmFkYXB0ZXIpLnRvKHJvb20pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUYXJnZXRzIGEgcm9vbSB3aGVuIGVtaXR0aW5nLiBTaW1pbGFyIHRvIGB0bygpYCwgYnV0IG1pZ2h0IGZlZWwgY2xlYXJlciBpbiBzb21lIGNhc2VzOlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBjb25zdCBteU5hbWVzcGFjZSA9IGlvLm9mKFwiL215LW5hbWVzcGFjZVwiKTtcbiAgICAgKlxuICAgICAqIC8vIGRpc2Nvbm5lY3QgYWxsIGNsaWVudHMgaW4gdGhlIFwicm9vbS0xMDFcIiByb29tXG4gICAgICogbXlOYW1lc3BhY2UuaW4oXCJyb29tLTEwMVwiKS5kaXNjb25uZWN0U29ja2V0cygpO1xuICAgICAqXG4gICAgICogQHBhcmFtIHJvb20gLSBhIHJvb20sIG9yIGFuIGFycmF5IG9mIHJvb21zXG4gICAgICogQHJldHVybiBhIG5ldyB7QGxpbmsgQnJvYWRjYXN0T3BlcmF0b3J9IGluc3RhbmNlIGZvciBjaGFpbmluZ1xuICAgICAqL1xuICAgIGluKHJvb20pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBicm9hZGNhc3Rfb3BlcmF0b3JfMS5Ccm9hZGNhc3RPcGVyYXRvcih0aGlzLmFkYXB0ZXIpLmluKHJvb20pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFeGNsdWRlcyBhIHJvb20gd2hlbiBlbWl0dGluZy5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogY29uc3QgbXlOYW1lc3BhY2UgPSBpby5vZihcIi9teS1uYW1lc3BhY2VcIik7XG4gICAgICpcbiAgICAgKiAvLyB0aGUgXCJmb29cIiBldmVudCB3aWxsIGJlIGJyb2FkY2FzdCB0byBhbGwgY29ubmVjdGVkIGNsaWVudHMsIGV4Y2VwdCB0aGUgb25lcyB0aGF0IGFyZSBpbiB0aGUgXCJyb29tLTEwMVwiIHJvb21cbiAgICAgKiBteU5hbWVzcGFjZS5leGNlcHQoXCJyb29tLTEwMVwiKS5lbWl0KFwiZm9vXCIsIFwiYmFyXCIpO1xuICAgICAqXG4gICAgICogLy8gd2l0aCBhbiBhcnJheSBvZiByb29tc1xuICAgICAqIG15TmFtZXNwYWNlLmV4Y2VwdChbXCJyb29tLTEwMVwiLCBcInJvb20tMTAyXCJdKS5lbWl0KFwiZm9vXCIsIFwiYmFyXCIpO1xuICAgICAqXG4gICAgICogLy8gd2l0aCBtdWx0aXBsZSBjaGFpbmVkIGNhbGxzXG4gICAgICogbXlOYW1lc3BhY2UuZXhjZXB0KFwicm9vbS0xMDFcIikuZXhjZXB0KFwicm9vbS0xMDJcIikuZW1pdChcImZvb1wiLCBcImJhclwiKTtcbiAgICAgKlxuICAgICAqIEBwYXJhbSByb29tIC0gYSByb29tLCBvciBhbiBhcnJheSBvZiByb29tc1xuICAgICAqIEByZXR1cm4gYSBuZXcge0BsaW5rIEJyb2FkY2FzdE9wZXJhdG9yfSBpbnN0YW5jZSBmb3IgY2hhaW5pbmdcbiAgICAgKi9cbiAgICBleGNlcHQocm9vbSkge1xuICAgICAgICByZXR1cm4gbmV3IGJyb2FkY2FzdF9vcGVyYXRvcl8xLkJyb2FkY2FzdE9wZXJhdG9yKHRoaXMuYWRhcHRlcikuZXhjZXB0KHJvb20pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRzIGEgbmV3IGNsaWVudC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge1NvY2tldH1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGFzeW5jIF9hZGQoY2xpZW50LCBhdXRoLCBmbikge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGRlYnVnKFwiYWRkaW5nIHNvY2tldCB0byBuc3AgJXNcIiwgdGhpcy5uYW1lKTtcbiAgICAgICAgY29uc3Qgc29ja2V0ID0gYXdhaXQgdGhpcy5fY3JlYXRlU29ja2V0KGNsaWVudCwgYXV0aCk7XG4gICAgICAgIHRoaXMuX3ByZUNvbm5lY3RTb2NrZXRzLnNldChzb2NrZXQuaWQsIHNvY2tldCk7XG4gICAgICAgIGlmIChcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAoKF9hID0gdGhpcy5zZXJ2ZXIub3B0cy5jb25uZWN0aW9uU3RhdGVSZWNvdmVyeSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnNraXBNaWRkbGV3YXJlcykgJiZcbiAgICAgICAgICAgIHNvY2tldC5yZWNvdmVyZWQgJiZcbiAgICAgICAgICAgIGNsaWVudC5jb25uLnJlYWR5U3RhdGUgPT09IFwib3BlblwiKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZG9Db25uZWN0KHNvY2tldCwgZm4pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucnVuKHNvY2tldCwgKGVycikgPT4ge1xuICAgICAgICAgICAgcHJvY2Vzcy5uZXh0VGljaygoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKFwib3BlblwiICE9PSBjbGllbnQuY29ubi5yZWFkeVN0YXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlYnVnKFwibmV4dCBjYWxsZWQgYWZ0ZXIgY2xpZW50IHdhcyBjbG9zZWQgLSBpZ25vcmluZyBzb2NrZXRcIik7XG4gICAgICAgICAgICAgICAgICAgIHNvY2tldC5fY2xlYW51cCgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVidWcoXCJtaWRkbGV3YXJlIGVycm9yLCBzZW5kaW5nIENPTk5FQ1RfRVJST1IgcGFja2V0IHRvIHRoZSBjbGllbnRcIik7XG4gICAgICAgICAgICAgICAgICAgIHNvY2tldC5fY2xlYW51cCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2xpZW50LmNvbm4ucHJvdG9jb2wgPT09IDMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzb2NrZXQuX2Vycm9yKGVyci5kYXRhIHx8IGVyci5tZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzb2NrZXQuX2Vycm9yKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBlcnIubWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiBlcnIuZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuX2RvQ29ubmVjdChzb2NrZXQsIGZuKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgYXN5bmMgX2NyZWF0ZVNvY2tldChjbGllbnQsIGF1dGgpIHtcbiAgICAgICAgY29uc3Qgc2Vzc2lvbklkID0gYXV0aC5waWQ7XG4gICAgICAgIGNvbnN0IG9mZnNldCA9IGF1dGgub2Zmc2V0O1xuICAgICAgICBpZiAoXG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgdGhpcy5zZXJ2ZXIub3B0cy5jb25uZWN0aW9uU3RhdGVSZWNvdmVyeSAmJlxuICAgICAgICAgICAgdHlwZW9mIHNlc3Npb25JZCA9PT0gXCJzdHJpbmdcIiAmJlxuICAgICAgICAgICAgdHlwZW9mIG9mZnNldCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgbGV0IHNlc3Npb247XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHNlc3Npb24gPSBhd2FpdCB0aGlzLmFkYXB0ZXIucmVzdG9yZVNlc3Npb24oc2Vzc2lvbklkLCBvZmZzZXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBkZWJ1ZyhcImVycm9yIHdoaWxlIHJlc3RvcmluZyBzZXNzaW9uOiAlc1wiLCBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzZXNzaW9uKSB7XG4gICAgICAgICAgICAgICAgZGVidWcoXCJjb25uZWN0aW9uIHN0YXRlIHJlY292ZXJlZCBmb3Igc2lkICVzXCIsIHNlc3Npb24uc2lkKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IHNvY2tldF8xLlNvY2tldCh0aGlzLCBjbGllbnQsIGF1dGgsIHNlc3Npb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgc29ja2V0XzEuU29ja2V0KHRoaXMsIGNsaWVudCwgYXV0aCk7XG4gICAgfVxuICAgIF9kb0Nvbm5lY3Qoc29ja2V0LCBmbikge1xuICAgICAgICB0aGlzLl9wcmVDb25uZWN0U29ja2V0cy5kZWxldGUoc29ja2V0LmlkKTtcbiAgICAgICAgdGhpcy5zb2NrZXRzLnNldChzb2NrZXQuaWQsIHNvY2tldCk7XG4gICAgICAgIC8vIGl0J3MgcGFyYW1vdW50IHRoYXQgdGhlIGludGVybmFsIGBvbmNvbm5lY3RgIGxvZ2ljXG4gICAgICAgIC8vIGZpcmVzIGJlZm9yZSB1c2VyLXNldCBldmVudHMgdG8gcHJldmVudCBzdGF0ZSBvcmRlclxuICAgICAgICAvLyB2aW9sYXRpb25zIChzdWNoIGFzIGEgZGlzY29ubmVjdGlvbiBiZWZvcmUgdGhlIGNvbm5lY3Rpb25cbiAgICAgICAgLy8gbG9naWMgaXMgY29tcGxldGUpXG4gICAgICAgIHNvY2tldC5fb25jb25uZWN0KCk7XG4gICAgICAgIGlmIChmbilcbiAgICAgICAgICAgIGZuKHNvY2tldCk7XG4gICAgICAgIC8vIGZpcmUgdXNlci1zZXQgZXZlbnRzXG4gICAgICAgIHRoaXMuZW1pdFJlc2VydmVkKFwiY29ubmVjdFwiLCBzb2NrZXQpO1xuICAgICAgICB0aGlzLmVtaXRSZXNlcnZlZChcImNvbm5lY3Rpb25cIiwgc29ja2V0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhIGNsaWVudC4gQ2FsbGVkIGJ5IGVhY2ggYFNvY2tldGAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9yZW1vdmUoc29ja2V0KSB7XG4gICAgICAgIHRoaXMuc29ja2V0cy5kZWxldGUoc29ja2V0LmlkKSB8fCB0aGlzLl9wcmVDb25uZWN0U29ja2V0cy5kZWxldGUoc29ja2V0LmlkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRW1pdHMgdG8gYWxsIGNvbm5lY3RlZCBjbGllbnRzLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBjb25zdCBteU5hbWVzcGFjZSA9IGlvLm9mKFwiL215LW5hbWVzcGFjZVwiKTtcbiAgICAgKlxuICAgICAqIG15TmFtZXNwYWNlLmVtaXQoXCJoZWxsb1wiLCBcIndvcmxkXCIpO1xuICAgICAqXG4gICAgICogLy8gYWxsIHNlcmlhbGl6YWJsZSBkYXRhc3RydWN0dXJlcyBhcmUgc3VwcG9ydGVkIChubyBuZWVkIHRvIGNhbGwgSlNPTi5zdHJpbmdpZnkpXG4gICAgICogbXlOYW1lc3BhY2UuZW1pdChcImhlbGxvXCIsIDEsIFwiMlwiLCB7IDM6IFtcIjRcIl0sIDU6IFVpbnQ4QXJyYXkuZnJvbShbNl0pIH0pO1xuICAgICAqXG4gICAgICogLy8gd2l0aCBhbiBhY2tub3dsZWRnZW1lbnQgZnJvbSB0aGUgY2xpZW50c1xuICAgICAqIG15TmFtZXNwYWNlLnRpbWVvdXQoMTAwMCkuZW1pdChcInNvbWUtZXZlbnRcIiwgKGVyciwgcmVzcG9uc2VzKSA9PiB7XG4gICAgICogICBpZiAoZXJyKSB7XG4gICAgICogICAgIC8vIHNvbWUgY2xpZW50cyBkaWQgbm90IGFja25vd2xlZGdlIHRoZSBldmVudCBpbiB0aGUgZ2l2ZW4gZGVsYXlcbiAgICAgKiAgIH0gZWxzZSB7XG4gICAgICogICAgIGNvbnNvbGUubG9nKHJlc3BvbnNlcyk7IC8vIG9uZSByZXNwb25zZSBwZXIgY2xpZW50XG4gICAgICogICB9XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBAcmV0dXJuIEFsd2F5cyB0cnVlXG4gICAgICovXG4gICAgZW1pdChldiwgLi4uYXJncykge1xuICAgICAgICByZXR1cm4gbmV3IGJyb2FkY2FzdF9vcGVyYXRvcl8xLkJyb2FkY2FzdE9wZXJhdG9yKHRoaXMuYWRhcHRlcikuZW1pdChldiwgLi4uYXJncyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlbmRzIGEgYG1lc3NhZ2VgIGV2ZW50IHRvIGFsbCBjbGllbnRzLlxuICAgICAqXG4gICAgICogVGhpcyBtZXRob2QgbWltaWNzIHRoZSBXZWJTb2NrZXQuc2VuZCgpIG1ldGhvZC5cbiAgICAgKlxuICAgICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1dlYlNvY2tldC9zZW5kXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGNvbnN0IG15TmFtZXNwYWNlID0gaW8ub2YoXCIvbXktbmFtZXNwYWNlXCIpO1xuICAgICAqXG4gICAgICogbXlOYW1lc3BhY2Uuc2VuZChcImhlbGxvXCIpO1xuICAgICAqXG4gICAgICogLy8gdGhpcyBpcyBlcXVpdmFsZW50IHRvXG4gICAgICogbXlOYW1lc3BhY2UuZW1pdChcIm1lc3NhZ2VcIiwgXCJoZWxsb1wiKTtcbiAgICAgKlxuICAgICAqIEByZXR1cm4gc2VsZlxuICAgICAqL1xuICAgIHNlbmQoLi4uYXJncykge1xuICAgICAgICAvLyBUaGlzIHR5cGUtY2FzdCBpcyBuZWVkZWQgYmVjYXVzZSBFbWl0RXZlbnRzIGxpa2VseSBkb2Vzbid0IGhhdmUgYG1lc3NhZ2VgIGFzIGEga2V5LlxuICAgICAgICAvLyBpZiB5b3Ugc3BlY2lmeSB0aGUgRW1pdEV2ZW50cywgdGhlIHR5cGUgb2YgYXJncyB3aWxsIGJlIG5ldmVyLlxuICAgICAgICB0aGlzLmVtaXQoXCJtZXNzYWdlXCIsIC4uLmFyZ3MpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VuZHMgYSBgbWVzc2FnZWAgZXZlbnQgdG8gYWxsIGNsaWVudHMuIFNlbmRzIGEgYG1lc3NhZ2VgIGV2ZW50LiBBbGlhcyBvZiB7QGxpbmsgc2VuZH0uXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHNlbGZcbiAgICAgKi9cbiAgICB3cml0ZSguLi5hcmdzKSB7XG4gICAgICAgIC8vIFRoaXMgdHlwZS1jYXN0IGlzIG5lZWRlZCBiZWNhdXNlIEVtaXRFdmVudHMgbGlrZWx5IGRvZXNuJ3QgaGF2ZSBgbWVzc2FnZWAgYXMgYSBrZXkuXG4gICAgICAgIC8vIGlmIHlvdSBzcGVjaWZ5IHRoZSBFbWl0RXZlbnRzLCB0aGUgdHlwZSBvZiBhcmdzIHdpbGwgYmUgbmV2ZXIuXG4gICAgICAgIHRoaXMuZW1pdChcIm1lc3NhZ2VcIiwgLi4uYXJncyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZW5kcyBhIG1lc3NhZ2UgdG8gdGhlIG90aGVyIFNvY2tldC5JTyBzZXJ2ZXJzIG9mIHRoZSBjbHVzdGVyLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBjb25zdCBteU5hbWVzcGFjZSA9IGlvLm9mKFwiL215LW5hbWVzcGFjZVwiKTtcbiAgICAgKlxuICAgICAqIG15TmFtZXNwYWNlLnNlcnZlclNpZGVFbWl0KFwiaGVsbG9cIiwgXCJ3b3JsZFwiKTtcbiAgICAgKlxuICAgICAqIG15TmFtZXNwYWNlLm9uKFwiaGVsbG9cIiwgKGFyZzEpID0+IHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKGFyZzEpOyAvLyBwcmludHMgXCJ3b3JsZFwiXG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiAvLyBhY2tub3dsZWRnZW1lbnRzICh3aXRob3V0IGJpbmFyeSBjb250ZW50KSBhcmUgc3VwcG9ydGVkIHRvbzpcbiAgICAgKiBteU5hbWVzcGFjZS5zZXJ2ZXJTaWRlRW1pdChcInBpbmdcIiwgKGVyciwgcmVzcG9uc2VzKSA9PiB7XG4gICAgICogIGlmIChlcnIpIHtcbiAgICAgKiAgICAgLy8gc29tZSBzZXJ2ZXJzIGRpZCBub3QgYWNrbm93bGVkZ2UgdGhlIGV2ZW50IGluIHRoZSBnaXZlbiBkZWxheVxuICAgICAqICAgfSBlbHNlIHtcbiAgICAgKiAgICAgY29uc29sZS5sb2cocmVzcG9uc2VzKTsgLy8gb25lIHJlc3BvbnNlIHBlciBzZXJ2ZXIgKGV4Y2VwdCB0aGUgY3VycmVudCBvbmUpXG4gICAgICogICB9XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBteU5hbWVzcGFjZS5vbihcInBpbmdcIiwgKGNiKSA9PiB7XG4gICAgICogICBjYihcInBvbmdcIik7XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBAcGFyYW0gZXYgLSB0aGUgZXZlbnQgbmFtZVxuICAgICAqIEBwYXJhbSBhcmdzIC0gYW4gYXJyYXkgb2YgYXJndW1lbnRzLCB3aGljaCBtYXkgaW5jbHVkZSBhbiBhY2tub3dsZWRnZW1lbnQgY2FsbGJhY2sgYXQgdGhlIGVuZFxuICAgICAqL1xuICAgIHNlcnZlclNpZGVFbWl0KGV2LCAuLi5hcmdzKSB7XG4gICAgICAgIGlmIChleHBvcnRzLlJFU0VSVkVEX0VWRU5UUy5oYXMoZXYpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFwiJHtTdHJpbmcoZXYpfVwiIGlzIGEgcmVzZXJ2ZWQgZXZlbnQgbmFtZWApO1xuICAgICAgICB9XG4gICAgICAgIGFyZ3MudW5zaGlmdChldik7XG4gICAgICAgIHRoaXMuYWRhcHRlci5zZXJ2ZXJTaWRlRW1pdChhcmdzKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlbmRzIGEgbWVzc2FnZSBhbmQgZXhwZWN0IGFuIGFja25vd2xlZGdlbWVudCBmcm9tIHRoZSBvdGhlciBTb2NrZXQuSU8gc2VydmVycyBvZiB0aGUgY2x1c3Rlci5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogY29uc3QgbXlOYW1lc3BhY2UgPSBpby5vZihcIi9teS1uYW1lc3BhY2VcIik7XG4gICAgICpcbiAgICAgKiB0cnkge1xuICAgICAqICAgY29uc3QgcmVzcG9uc2VzID0gYXdhaXQgbXlOYW1lc3BhY2Uuc2VydmVyU2lkZUVtaXRXaXRoQWNrKFwicGluZ1wiKTtcbiAgICAgKiAgIGNvbnNvbGUubG9nKHJlc3BvbnNlcyk7IC8vIG9uZSByZXNwb25zZSBwZXIgc2VydmVyIChleGNlcHQgdGhlIGN1cnJlbnQgb25lKVxuICAgICAqIH0gY2F0Y2ggKGUpIHtcbiAgICAgKiAgIC8vIHNvbWUgc2VydmVycyBkaWQgbm90IGFja25vd2xlZGdlIHRoZSBldmVudCBpbiB0aGUgZ2l2ZW4gZGVsYXlcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBAcGFyYW0gZXYgLSB0aGUgZXZlbnQgbmFtZVxuICAgICAqIEBwYXJhbSBhcmdzIC0gYW4gYXJyYXkgb2YgYXJndW1lbnRzXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIGEgUHJvbWlzZSB0aGF0IHdpbGwgYmUgZnVsZmlsbGVkIHdoZW4gYWxsIHNlcnZlcnMgaGF2ZSBhY2tub3dsZWRnZWQgdGhlIGV2ZW50XG4gICAgICovXG4gICAgc2VydmVyU2lkZUVtaXRXaXRoQWNrKGV2LCAuLi5hcmdzKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBhcmdzLnB1c2goKGVyciwgcmVzcG9uc2VzKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICBlcnIucmVzcG9uc2VzID0gcmVzcG9uc2VzO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0KGVycik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZShyZXNwb25zZXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5zZXJ2ZXJTaWRlRW1pdChldiwgLi4uYXJncyk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgd2hlbiBhIHBhY2tldCBpcyByZWNlaXZlZCBmcm9tIGFub3RoZXIgU29ja2V0LklPIHNlcnZlclxuICAgICAqXG4gICAgICogQHBhcmFtIGFyZ3MgLSBhbiBhcnJheSBvZiBhcmd1bWVudHMsIHdoaWNoIG1heSBpbmNsdWRlIGFuIGFja25vd2xlZGdlbWVudCBjYWxsYmFjayBhdCB0aGUgZW5kXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9vblNlcnZlclNpZGVFbWl0KGFyZ3MpIHtcbiAgICAgICAgc3VwZXIuZW1pdFVudHlwZWQuYXBwbHkodGhpcywgYXJncyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgYSBsaXN0IG9mIGNsaWVudHMuXG4gICAgICpcbiAgICAgKiBAZGVwcmVjYXRlZCB0aGlzIG1ldGhvZCB3aWxsIGJlIHJlbW92ZWQgaW4gdGhlIG5leHQgbWFqb3IgcmVsZWFzZSwgcGxlYXNlIHVzZSB7QGxpbmsgTmFtZXNwYWNlI3NlcnZlclNpZGVFbWl0fSBvclxuICAgICAqIHtAbGluayBOYW1lc3BhY2UjZmV0Y2hTb2NrZXRzfSBpbnN0ZWFkLlxuICAgICAqL1xuICAgIGFsbFNvY2tldHMoKSB7XG4gICAgICAgIHJldHVybiBuZXcgYnJvYWRjYXN0X29wZXJhdG9yXzEuQnJvYWRjYXN0T3BlcmF0b3IodGhpcy5hZGFwdGVyKS5hbGxTb2NrZXRzKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGNvbXByZXNzIGZsYWcuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGNvbnN0IG15TmFtZXNwYWNlID0gaW8ub2YoXCIvbXktbmFtZXNwYWNlXCIpO1xuICAgICAqXG4gICAgICogbXlOYW1lc3BhY2UuY29tcHJlc3MoZmFsc2UpLmVtaXQoXCJoZWxsb1wiKTtcbiAgICAgKlxuICAgICAqIEBwYXJhbSBjb21wcmVzcyAtIGlmIGB0cnVlYCwgY29tcHJlc3NlcyB0aGUgc2VuZGluZyBkYXRhXG4gICAgICogQHJldHVybiBzZWxmXG4gICAgICovXG4gICAgY29tcHJlc3MoY29tcHJlc3MpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBicm9hZGNhc3Rfb3BlcmF0b3JfMS5Ccm9hZGNhc3RPcGVyYXRvcih0aGlzLmFkYXB0ZXIpLmNvbXByZXNzKGNvbXByZXNzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyBhIG1vZGlmaWVyIGZvciBhIHN1YnNlcXVlbnQgZXZlbnQgZW1pc3Npb24gdGhhdCB0aGUgZXZlbnQgZGF0YSBtYXkgYmUgbG9zdCBpZiB0aGUgY2xpZW50IGlzIG5vdCByZWFkeSB0b1xuICAgICAqIHJlY2VpdmUgbWVzc2FnZXMgKGJlY2F1c2Ugb2YgbmV0d29yayBzbG93bmVzcyBvciBvdGhlciBpc3N1ZXMsIG9yIGJlY2F1c2UgdGhleeKAmXJlIGNvbm5lY3RlZCB0aHJvdWdoIGxvbmcgcG9sbGluZ1xuICAgICAqIGFuZCBpcyBpbiB0aGUgbWlkZGxlIG9mIGEgcmVxdWVzdC1yZXNwb25zZSBjeWNsZSkuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGNvbnN0IG15TmFtZXNwYWNlID0gaW8ub2YoXCIvbXktbmFtZXNwYWNlXCIpO1xuICAgICAqXG4gICAgICogbXlOYW1lc3BhY2Uudm9sYXRpbGUuZW1pdChcImhlbGxvXCIpOyAvLyB0aGUgY2xpZW50cyBtYXkgb3IgbWF5IG5vdCByZWNlaXZlIGl0XG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHNlbGZcbiAgICAgKi9cbiAgICBnZXQgdm9sYXRpbGUoKSB7XG4gICAgICAgIHJldHVybiBuZXcgYnJvYWRjYXN0X29wZXJhdG9yXzEuQnJvYWRjYXN0T3BlcmF0b3IodGhpcy5hZGFwdGVyKS52b2xhdGlsZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyBhIG1vZGlmaWVyIGZvciBhIHN1YnNlcXVlbnQgZXZlbnQgZW1pc3Npb24gdGhhdCB0aGUgZXZlbnQgZGF0YSB3aWxsIG9ubHkgYmUgYnJvYWRjYXN0IHRvIHRoZSBjdXJyZW50IG5vZGUuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGNvbnN0IG15TmFtZXNwYWNlID0gaW8ub2YoXCIvbXktbmFtZXNwYWNlXCIpO1xuICAgICAqXG4gICAgICogLy8gdGhlIOKAnGZvb+KAnSBldmVudCB3aWxsIGJlIGJyb2FkY2FzdCB0byBhbGwgY29ubmVjdGVkIGNsaWVudHMgb24gdGhpcyBub2RlXG4gICAgICogbXlOYW1lc3BhY2UubG9jYWwuZW1pdChcImZvb1wiLCBcImJhclwiKTtcbiAgICAgKlxuICAgICAqIEByZXR1cm4gYSBuZXcge0BsaW5rIEJyb2FkY2FzdE9wZXJhdG9yfSBpbnN0YW5jZSBmb3IgY2hhaW5pbmdcbiAgICAgKi9cbiAgICBnZXQgbG9jYWwoKSB7XG4gICAgICAgIHJldHVybiBuZXcgYnJvYWRjYXN0X29wZXJhdG9yXzEuQnJvYWRjYXN0T3BlcmF0b3IodGhpcy5hZGFwdGVyKS5sb2NhbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkcyBhIHRpbWVvdXQgaW4gbWlsbGlzZWNvbmRzIGZvciB0aGUgbmV4dCBvcGVyYXRpb24uXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGNvbnN0IG15TmFtZXNwYWNlID0gaW8ub2YoXCIvbXktbmFtZXNwYWNlXCIpO1xuICAgICAqXG4gICAgICogbXlOYW1lc3BhY2UudGltZW91dCgxMDAwKS5lbWl0KFwic29tZS1ldmVudFwiLCAoZXJyLCByZXNwb25zZXMpID0+IHtcbiAgICAgKiAgIGlmIChlcnIpIHtcbiAgICAgKiAgICAgLy8gc29tZSBjbGllbnRzIGRpZCBub3QgYWNrbm93bGVkZ2UgdGhlIGV2ZW50IGluIHRoZSBnaXZlbiBkZWxheVxuICAgICAqICAgfSBlbHNlIHtcbiAgICAgKiAgICAgY29uc29sZS5sb2cocmVzcG9uc2VzKTsgLy8gb25lIHJlc3BvbnNlIHBlciBjbGllbnRcbiAgICAgKiAgIH1cbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIEBwYXJhbSB0aW1lb3V0XG4gICAgICovXG4gICAgdGltZW91dCh0aW1lb3V0KSB7XG4gICAgICAgIHJldHVybiBuZXcgYnJvYWRjYXN0X29wZXJhdG9yXzEuQnJvYWRjYXN0T3BlcmF0b3IodGhpcy5hZGFwdGVyKS50aW1lb3V0KHRpbWVvdXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBtYXRjaGluZyBzb2NrZXQgaW5zdGFuY2VzLlxuICAgICAqXG4gICAgICogTm90ZTogdGhpcyBtZXRob2QgYWxzbyB3b3JrcyB3aXRoaW4gYSBjbHVzdGVyIG9mIG11bHRpcGxlIFNvY2tldC5JTyBzZXJ2ZXJzLCB3aXRoIGEgY29tcGF0aWJsZSB7QGxpbmsgQWRhcHRlcn0uXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGNvbnN0IG15TmFtZXNwYWNlID0gaW8ub2YoXCIvbXktbmFtZXNwYWNlXCIpO1xuICAgICAqXG4gICAgICogLy8gcmV0dXJuIGFsbCBTb2NrZXQgaW5zdGFuY2VzXG4gICAgICogY29uc3Qgc29ja2V0cyA9IGF3YWl0IG15TmFtZXNwYWNlLmZldGNoU29ja2V0cygpO1xuICAgICAqXG4gICAgICogLy8gcmV0dXJuIGFsbCBTb2NrZXQgaW5zdGFuY2VzIGluIHRoZSBcInJvb20xXCIgcm9vbVxuICAgICAqIGNvbnN0IHNvY2tldHMgPSBhd2FpdCBteU5hbWVzcGFjZS5pbihcInJvb20xXCIpLmZldGNoU29ja2V0cygpO1xuICAgICAqXG4gICAgICogZm9yIChjb25zdCBzb2NrZXQgb2Ygc29ja2V0cykge1xuICAgICAqICAgY29uc29sZS5sb2coc29ja2V0LmlkKTtcbiAgICAgKiAgIGNvbnNvbGUubG9nKHNvY2tldC5oYW5kc2hha2UpO1xuICAgICAqICAgY29uc29sZS5sb2coc29ja2V0LnJvb21zKTtcbiAgICAgKiAgIGNvbnNvbGUubG9nKHNvY2tldC5kYXRhKTtcbiAgICAgKlxuICAgICAqICAgc29ja2V0LmVtaXQoXCJoZWxsb1wiKTtcbiAgICAgKiAgIHNvY2tldC5qb2luKFwicm9vbTFcIik7XG4gICAgICogICBzb2NrZXQubGVhdmUoXCJyb29tMlwiKTtcbiAgICAgKiAgIHNvY2tldC5kaXNjb25uZWN0KCk7XG4gICAgICogfVxuICAgICAqL1xuICAgIGZldGNoU29ja2V0cygpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBicm9hZGNhc3Rfb3BlcmF0b3JfMS5Ccm9hZGNhc3RPcGVyYXRvcih0aGlzLmFkYXB0ZXIpLmZldGNoU29ja2V0cygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNYWtlcyB0aGUgbWF0Y2hpbmcgc29ja2V0IGluc3RhbmNlcyBqb2luIHRoZSBzcGVjaWZpZWQgcm9vbXMuXG4gICAgICpcbiAgICAgKiBOb3RlOiB0aGlzIG1ldGhvZCBhbHNvIHdvcmtzIHdpdGhpbiBhIGNsdXN0ZXIgb2YgbXVsdGlwbGUgU29ja2V0LklPIHNlcnZlcnMsIHdpdGggYSBjb21wYXRpYmxlIHtAbGluayBBZGFwdGVyfS5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogY29uc3QgbXlOYW1lc3BhY2UgPSBpby5vZihcIi9teS1uYW1lc3BhY2VcIik7XG4gICAgICpcbiAgICAgKiAvLyBtYWtlIGFsbCBzb2NrZXQgaW5zdGFuY2VzIGpvaW4gdGhlIFwicm9vbTFcIiByb29tXG4gICAgICogbXlOYW1lc3BhY2Uuc29ja2V0c0pvaW4oXCJyb29tMVwiKTtcbiAgICAgKlxuICAgICAqIC8vIG1ha2UgYWxsIHNvY2tldCBpbnN0YW5jZXMgaW4gdGhlIFwicm9vbTFcIiByb29tIGpvaW4gdGhlIFwicm9vbTJcIiBhbmQgXCJyb29tM1wiIHJvb21zXG4gICAgICogbXlOYW1lc3BhY2UuaW4oXCJyb29tMVwiKS5zb2NrZXRzSm9pbihbXCJyb29tMlwiLCBcInJvb20zXCJdKTtcbiAgICAgKlxuICAgICAqIEBwYXJhbSByb29tIC0gYSByb29tLCBvciBhbiBhcnJheSBvZiByb29tc1xuICAgICAqL1xuICAgIHNvY2tldHNKb2luKHJvb20pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBicm9hZGNhc3Rfb3BlcmF0b3JfMS5Ccm9hZGNhc3RPcGVyYXRvcih0aGlzLmFkYXB0ZXIpLnNvY2tldHNKb2luKHJvb20pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNYWtlcyB0aGUgbWF0Y2hpbmcgc29ja2V0IGluc3RhbmNlcyBsZWF2ZSB0aGUgc3BlY2lmaWVkIHJvb21zLlxuICAgICAqXG4gICAgICogTm90ZTogdGhpcyBtZXRob2QgYWxzbyB3b3JrcyB3aXRoaW4gYSBjbHVzdGVyIG9mIG11bHRpcGxlIFNvY2tldC5JTyBzZXJ2ZXJzLCB3aXRoIGEgY29tcGF0aWJsZSB7QGxpbmsgQWRhcHRlcn0uXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGNvbnN0IG15TmFtZXNwYWNlID0gaW8ub2YoXCIvbXktbmFtZXNwYWNlXCIpO1xuICAgICAqXG4gICAgICogLy8gbWFrZSBhbGwgc29ja2V0IGluc3RhbmNlcyBsZWF2ZSB0aGUgXCJyb29tMVwiIHJvb21cbiAgICAgKiBteU5hbWVzcGFjZS5zb2NrZXRzTGVhdmUoXCJyb29tMVwiKTtcbiAgICAgKlxuICAgICAqIC8vIG1ha2UgYWxsIHNvY2tldCBpbnN0YW5jZXMgaW4gdGhlIFwicm9vbTFcIiByb29tIGxlYXZlIHRoZSBcInJvb20yXCIgYW5kIFwicm9vbTNcIiByb29tc1xuICAgICAqIG15TmFtZXNwYWNlLmluKFwicm9vbTFcIikuc29ja2V0c0xlYXZlKFtcInJvb20yXCIsIFwicm9vbTNcIl0pO1xuICAgICAqXG4gICAgICogQHBhcmFtIHJvb20gLSBhIHJvb20sIG9yIGFuIGFycmF5IG9mIHJvb21zXG4gICAgICovXG4gICAgc29ja2V0c0xlYXZlKHJvb20pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBicm9hZGNhc3Rfb3BlcmF0b3JfMS5Ccm9hZGNhc3RPcGVyYXRvcih0aGlzLmFkYXB0ZXIpLnNvY2tldHNMZWF2ZShyb29tKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWFrZXMgdGhlIG1hdGNoaW5nIHNvY2tldCBpbnN0YW5jZXMgZGlzY29ubmVjdC5cbiAgICAgKlxuICAgICAqIE5vdGU6IHRoaXMgbWV0aG9kIGFsc28gd29ya3Mgd2l0aGluIGEgY2x1c3RlciBvZiBtdWx0aXBsZSBTb2NrZXQuSU8gc2VydmVycywgd2l0aCBhIGNvbXBhdGlibGUge0BsaW5rIEFkYXB0ZXJ9LlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBjb25zdCBteU5hbWVzcGFjZSA9IGlvLm9mKFwiL215LW5hbWVzcGFjZVwiKTtcbiAgICAgKlxuICAgICAqIC8vIG1ha2UgYWxsIHNvY2tldCBpbnN0YW5jZXMgZGlzY29ubmVjdCAodGhlIGNvbm5lY3Rpb25zIG1pZ2h0IGJlIGtlcHQgYWxpdmUgZm9yIG90aGVyIG5hbWVzcGFjZXMpXG4gICAgICogbXlOYW1lc3BhY2UuZGlzY29ubmVjdFNvY2tldHMoKTtcbiAgICAgKlxuICAgICAqIC8vIG1ha2UgYWxsIHNvY2tldCBpbnN0YW5jZXMgaW4gdGhlIFwicm9vbTFcIiByb29tIGRpc2Nvbm5lY3QgYW5kIGNsb3NlIHRoZSB1bmRlcmx5aW5nIGNvbm5lY3Rpb25zXG4gICAgICogbXlOYW1lc3BhY2UuaW4oXCJyb29tMVwiKS5kaXNjb25uZWN0U29ja2V0cyh0cnVlKTtcbiAgICAgKlxuICAgICAqIEBwYXJhbSBjbG9zZSAtIHdoZXRoZXIgdG8gY2xvc2UgdGhlIHVuZGVybHlpbmcgY29ubmVjdGlvblxuICAgICAqL1xuICAgIGRpc2Nvbm5lY3RTb2NrZXRzKGNsb3NlID0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBicm9hZGNhc3Rfb3BlcmF0b3JfMS5Ccm9hZGNhc3RPcGVyYXRvcih0aGlzLmFkYXB0ZXIpLmRpc2Nvbm5lY3RTb2NrZXRzKGNsb3NlKTtcbiAgICB9XG59XG5leHBvcnRzLk5hbWVzcGFjZSA9IE5hbWVzcGFjZTtcbiJdLCJuYW1lcyI6WyJfX2ltcG9ydERlZmF1bHQiLCJtb2QiLCJfX2VzTW9kdWxlIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJOYW1lc3BhY2UiLCJSRVNFUlZFRF9FVkVOVFMiLCJzb2NrZXRfMSIsInJlcXVpcmUiLCJ0eXBlZF9ldmVudHNfMSIsImRlYnVnXzEiLCJicm9hZGNhc3Rfb3BlcmF0b3JfMSIsImRlYnVnIiwiZGVmYXVsdCIsIlNldCIsIlN0cmljdEV2ZW50RW1pdHRlciIsImNvbnN0cnVjdG9yIiwic2VydmVyIiwibmFtZSIsInNvY2tldHMiLCJNYXAiLCJfcHJlQ29ubmVjdFNvY2tldHMiLCJfZm5zIiwiX2lkcyIsIl9pbml0QWRhcHRlciIsImFkYXB0ZXIiLCJ1c2UiLCJmbiIsInB1c2giLCJydW4iLCJzb2NrZXQiLCJsZW5ndGgiLCJmbnMiLCJzbGljZSIsImkiLCJlcnIiLCJ0byIsInJvb20iLCJCcm9hZGNhc3RPcGVyYXRvciIsImluIiwiZXhjZXB0IiwiX2FkZCIsImNsaWVudCIsImF1dGgiLCJfYSIsIl9jcmVhdGVTb2NrZXQiLCJzZXQiLCJpZCIsIm9wdHMiLCJjb25uZWN0aW9uU3RhdGVSZWNvdmVyeSIsInNraXBNaWRkbGV3YXJlcyIsInJlY292ZXJlZCIsImNvbm4iLCJyZWFkeVN0YXRlIiwiX2RvQ29ubmVjdCIsInByb2Nlc3MiLCJuZXh0VGljayIsIl9jbGVhbnVwIiwicHJvdG9jb2wiLCJfZXJyb3IiLCJkYXRhIiwibWVzc2FnZSIsInNlc3Npb25JZCIsInBpZCIsIm9mZnNldCIsInNlc3Npb24iLCJyZXN0b3JlU2Vzc2lvbiIsImUiLCJzaWQiLCJTb2NrZXQiLCJkZWxldGUiLCJfb25jb25uZWN0IiwiZW1pdFJlc2VydmVkIiwiX3JlbW92ZSIsImVtaXQiLCJldiIsImFyZ3MiLCJzZW5kIiwid3JpdGUiLCJzZXJ2ZXJTaWRlRW1pdCIsImhhcyIsIkVycm9yIiwiU3RyaW5nIiwidW5zaGlmdCIsInNlcnZlclNpZGVFbWl0V2l0aEFjayIsIlByb21pc2UiLCJyZXNvbHZlIiwicmVqZWN0IiwicmVzcG9uc2VzIiwiX29uU2VydmVyU2lkZUVtaXQiLCJlbWl0VW50eXBlZCIsImFwcGx5IiwiYWxsU29ja2V0cyIsImNvbXByZXNzIiwidm9sYXRpbGUiLCJsb2NhbCIsInRpbWVvdXQiLCJmZXRjaFNvY2tldHMiLCJzb2NrZXRzSm9pbiIsInNvY2tldHNMZWF2ZSIsImRpc2Nvbm5lY3RTb2NrZXRzIiwiY2xvc2UiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/socket.io/dist/namespace.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/socket.io/dist/parent-namespace.js":
/*!*********************************************************!*\
  !*** ./node_modules/socket.io/dist/parent-namespace.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nvar __importDefault = (void 0) && (void 0).__importDefault || function(mod) {\n    return mod && mod.__esModule ? mod : {\n        \"default\": mod\n    };\n};\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.ParentNamespace = void 0;\nconst namespace_1 = __webpack_require__(/*! ./namespace */ \"(rsc)/./node_modules/socket.io/dist/namespace.js\");\nconst socket_io_adapter_1 = __webpack_require__(/*! socket.io-adapter */ \"(rsc)/./node_modules/socket.io-adapter/dist/index.js\");\nconst debug_1 = __importDefault(__webpack_require__(/*! debug */ \"(rsc)/./node_modules/socket.io/node_modules/debug/src/index.js\"));\nconst debug = (0, debug_1.default)(\"socket.io:parent-namespace\");\n/**\n * A parent namespace is a special {@link Namespace} that holds a list of child namespaces which were created either\n * with a regular expression or with a function.\n *\n * @example\n * const parentNamespace = io.of(/\\/dynamic-\\d+/);\n *\n * parentNamespace.on(\"connection\", (socket) => {\n *   const childNamespace = socket.nsp;\n * }\n *\n * // will reach all the clients that are in one of the child namespaces, like \"/dynamic-101\"\n * parentNamespace.emit(\"hello\", \"world\");\n *\n */ class ParentNamespace extends namespace_1.Namespace {\n    constructor(server){\n        super(server, \"/_\" + ParentNamespace.count++);\n        this.children = new Set();\n    }\n    /**\n     * @private\n     */ _initAdapter() {\n        this.adapter = new ParentBroadcastAdapter(this);\n    }\n    emit(ev, ...args) {\n        this.children.forEach((nsp)=>{\n            nsp.emit(ev, ...args);\n        });\n        return true;\n    }\n    createChild(name) {\n        debug(\"creating child namespace %s\", name);\n        const namespace = new namespace_1.Namespace(this.server, name);\n        this[\"_fns\"].forEach((fn)=>namespace.use(fn));\n        this.listeners(\"connect\").forEach((listener)=>namespace.on(\"connect\", listener));\n        this.listeners(\"connection\").forEach((listener)=>namespace.on(\"connection\", listener));\n        this.children.add(namespace);\n        if (this.server._opts.cleanupEmptyChildNamespaces) {\n            const remove = namespace._remove;\n            namespace._remove = (socket)=>{\n                remove.call(namespace, socket);\n                if (namespace.sockets.size === 0) {\n                    debug(\"closing child namespace %s\", name);\n                    namespace.adapter.close();\n                    this.server._nsps.delete(namespace.name);\n                    this.children.delete(namespace);\n                }\n            };\n        }\n        this.server._nsps.set(name, namespace);\n        // @ts-ignore\n        this.server.sockets.emitReserved(\"new_namespace\", namespace);\n        return namespace;\n    }\n    fetchSockets() {\n        // note: we could make the fetchSockets() method work for dynamic namespaces created with a regex (by sending the\n        // regex to the other Socket.IO servers, and returning the sockets of each matching namespace for example), but\n        // the behavior for namespaces created with a function is less clear\n        // note: we cannot loop over each children namespace, because with multiple Socket.IO servers, a given namespace\n        // may exist on one node but not exist on another (since it is created upon client connection)\n        throw new Error(\"fetchSockets() is not supported on parent namespaces\");\n    }\n}\nexports.ParentNamespace = ParentNamespace;\nParentNamespace.count = 0;\n/**\n * A dummy adapter that only supports broadcasting to child (concrete) namespaces.\n * @private file\n */ class ParentBroadcastAdapter extends socket_io_adapter_1.Adapter {\n    broadcast(packet, opts) {\n        this.nsp.children.forEach((nsp)=>{\n            nsp.adapter.broadcast(packet, opts);\n        });\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc29ja2V0LmlvL2Rpc3QvcGFyZW50LW5hbWVzcGFjZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLElBQUlBLGtCQUFrQixDQUFDLE1BQUcsS0FBSyxPQUFHLEVBQUVBLGVBQWUsSUFBSyxTQUFVQyxHQUFHO0lBQ2pFLE9BQU8sT0FBUUEsSUFBSUMsVUFBVSxHQUFJRCxNQUFNO1FBQUUsV0FBV0E7SUFBSTtBQUM1RDtBQUNBRSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsdUJBQXVCLEdBQUcsS0FBSztBQUMvQixNQUFNRyxjQUFjQyxtQkFBT0EsQ0FBQyxxRUFBYTtBQUN6QyxNQUFNQyxzQkFBc0JELG1CQUFPQSxDQUFDLCtFQUFtQjtBQUN2RCxNQUFNRSxVQUFVWCxnQkFBZ0JTLG1CQUFPQSxDQUFDLDZFQUFPO0FBQy9DLE1BQU1HLFFBQVEsQ0FBQyxHQUFHRCxRQUFRRSxPQUFPLEVBQUU7QUFDbkM7Ozs7Ozs7Ozs7Ozs7O0NBY0MsR0FDRCxNQUFNTix3QkFBd0JDLFlBQVlNLFNBQVM7SUFDL0NDLFlBQVlDLE1BQU0sQ0FBRTtRQUNoQixLQUFLLENBQUNBLFFBQVEsT0FBT1QsZ0JBQWdCVSxLQUFLO1FBQzFDLElBQUksQ0FBQ0MsUUFBUSxHQUFHLElBQUlDO0lBQ3hCO0lBQ0E7O0tBRUMsR0FDREMsZUFBZTtRQUNYLElBQUksQ0FBQ0MsT0FBTyxHQUFHLElBQUlDLHVCQUF1QixJQUFJO0lBQ2xEO0lBQ0FDLEtBQUtDLEVBQUUsRUFBRSxHQUFHQyxJQUFJLEVBQUU7UUFDZCxJQUFJLENBQUNQLFFBQVEsQ0FBQ1EsT0FBTyxDQUFDLENBQUNDO1lBQ25CQSxJQUFJSixJQUFJLENBQUNDLE9BQU9DO1FBQ3BCO1FBQ0EsT0FBTztJQUNYO0lBQ0FHLFlBQVlDLElBQUksRUFBRTtRQUNkakIsTUFBTSwrQkFBK0JpQjtRQUNyQyxNQUFNQyxZQUFZLElBQUl0QixZQUFZTSxTQUFTLENBQUMsSUFBSSxDQUFDRSxNQUFNLEVBQUVhO1FBQ3pELElBQUksQ0FBQyxPQUFPLENBQUNILE9BQU8sQ0FBQyxDQUFDSyxLQUFPRCxVQUFVRSxHQUFHLENBQUNEO1FBQzNDLElBQUksQ0FBQ0UsU0FBUyxDQUFDLFdBQVdQLE9BQU8sQ0FBQyxDQUFDUSxXQUFhSixVQUFVSyxFQUFFLENBQUMsV0FBV0Q7UUFDeEUsSUFBSSxDQUFDRCxTQUFTLENBQUMsY0FBY1AsT0FBTyxDQUFDLENBQUNRLFdBQWFKLFVBQVVLLEVBQUUsQ0FBQyxjQUFjRDtRQUM5RSxJQUFJLENBQUNoQixRQUFRLENBQUNrQixHQUFHLENBQUNOO1FBQ2xCLElBQUksSUFBSSxDQUFDZCxNQUFNLENBQUNxQixLQUFLLENBQUNDLDJCQUEyQixFQUFFO1lBQy9DLE1BQU1DLFNBQVNULFVBQVVVLE9BQU87WUFDaENWLFVBQVVVLE9BQU8sR0FBRyxDQUFDQztnQkFDakJGLE9BQU9HLElBQUksQ0FBQ1osV0FBV1c7Z0JBQ3ZCLElBQUlYLFVBQVVhLE9BQU8sQ0FBQ0MsSUFBSSxLQUFLLEdBQUc7b0JBQzlCaEMsTUFBTSw4QkFBOEJpQjtvQkFDcENDLFVBQVVULE9BQU8sQ0FBQ3dCLEtBQUs7b0JBQ3ZCLElBQUksQ0FBQzdCLE1BQU0sQ0FBQzhCLEtBQUssQ0FBQ0MsTUFBTSxDQUFDakIsVUFBVUQsSUFBSTtvQkFDdkMsSUFBSSxDQUFDWCxRQUFRLENBQUM2QixNQUFNLENBQUNqQjtnQkFDekI7WUFDSjtRQUNKO1FBQ0EsSUFBSSxDQUFDZCxNQUFNLENBQUM4QixLQUFLLENBQUNFLEdBQUcsQ0FBQ25CLE1BQU1DO1FBQzVCLGFBQWE7UUFDYixJQUFJLENBQUNkLE1BQU0sQ0FBQzJCLE9BQU8sQ0FBQ00sWUFBWSxDQUFDLGlCQUFpQm5CO1FBQ2xELE9BQU9BO0lBQ1g7SUFDQW9CLGVBQWU7UUFDWCxpSEFBaUg7UUFDakgsK0dBQStHO1FBQy9HLG9FQUFvRTtRQUNwRSxpSEFBaUg7UUFDakgsOEZBQThGO1FBQzlGLE1BQU0sSUFBSUMsTUFBTTtJQUNwQjtBQUNKO0FBQ0E5Qyx1QkFBdUIsR0FBR0U7QUFDMUJBLGdCQUFnQlUsS0FBSyxHQUFHO0FBQ3hCOzs7Q0FHQyxHQUNELE1BQU1LLCtCQUErQlosb0JBQW9CMEMsT0FBTztJQUM1REMsVUFBVUMsTUFBTSxFQUFFQyxJQUFJLEVBQUU7UUFDcEIsSUFBSSxDQUFDNUIsR0FBRyxDQUFDVCxRQUFRLENBQUNRLE9BQU8sQ0FBQyxDQUFDQztZQUN2QkEsSUFBSU4sT0FBTyxDQUFDZ0MsU0FBUyxDQUFDQyxRQUFRQztRQUNsQztJQUNKO0FBQ0oiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9leGFtcm9zaC8uL25vZGVfbW9kdWxlcy9zb2NrZXQuaW8vZGlzdC9wYXJlbnQtbmFtZXNwYWNlLmpzP2VkYWIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlBhcmVudE5hbWVzcGFjZSA9IHZvaWQgMDtcbmNvbnN0IG5hbWVzcGFjZV8xID0gcmVxdWlyZShcIi4vbmFtZXNwYWNlXCIpO1xuY29uc3Qgc29ja2V0X2lvX2FkYXB0ZXJfMSA9IHJlcXVpcmUoXCJzb2NrZXQuaW8tYWRhcHRlclwiKTtcbmNvbnN0IGRlYnVnXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImRlYnVnXCIpKTtcbmNvbnN0IGRlYnVnID0gKDAsIGRlYnVnXzEuZGVmYXVsdCkoXCJzb2NrZXQuaW86cGFyZW50LW5hbWVzcGFjZVwiKTtcbi8qKlxuICogQSBwYXJlbnQgbmFtZXNwYWNlIGlzIGEgc3BlY2lhbCB7QGxpbmsgTmFtZXNwYWNlfSB0aGF0IGhvbGRzIGEgbGlzdCBvZiBjaGlsZCBuYW1lc3BhY2VzIHdoaWNoIHdlcmUgY3JlYXRlZCBlaXRoZXJcbiAqIHdpdGggYSByZWd1bGFyIGV4cHJlc3Npb24gb3Igd2l0aCBhIGZ1bmN0aW9uLlxuICpcbiAqIEBleGFtcGxlXG4gKiBjb25zdCBwYXJlbnROYW1lc3BhY2UgPSBpby5vZigvXFwvZHluYW1pYy1cXGQrLyk7XG4gKlxuICogcGFyZW50TmFtZXNwYWNlLm9uKFwiY29ubmVjdGlvblwiLCAoc29ja2V0KSA9PiB7XG4gKiAgIGNvbnN0IGNoaWxkTmFtZXNwYWNlID0gc29ja2V0Lm5zcDtcbiAqIH1cbiAqXG4gKiAvLyB3aWxsIHJlYWNoIGFsbCB0aGUgY2xpZW50cyB0aGF0IGFyZSBpbiBvbmUgb2YgdGhlIGNoaWxkIG5hbWVzcGFjZXMsIGxpa2UgXCIvZHluYW1pYy0xMDFcIlxuICogcGFyZW50TmFtZXNwYWNlLmVtaXQoXCJoZWxsb1wiLCBcIndvcmxkXCIpO1xuICpcbiAqL1xuY2xhc3MgUGFyZW50TmFtZXNwYWNlIGV4dGVuZHMgbmFtZXNwYWNlXzEuTmFtZXNwYWNlIHtcbiAgICBjb25zdHJ1Y3RvcihzZXJ2ZXIpIHtcbiAgICAgICAgc3VwZXIoc2VydmVyLCBcIi9fXCIgKyBQYXJlbnROYW1lc3BhY2UuY291bnQrKyk7XG4gICAgICAgIHRoaXMuY2hpbGRyZW4gPSBuZXcgU2V0KCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2luaXRBZGFwdGVyKCkge1xuICAgICAgICB0aGlzLmFkYXB0ZXIgPSBuZXcgUGFyZW50QnJvYWRjYXN0QWRhcHRlcih0aGlzKTtcbiAgICB9XG4gICAgZW1pdChldiwgLi4uYXJncykge1xuICAgICAgICB0aGlzLmNoaWxkcmVuLmZvckVhY2goKG5zcCkgPT4ge1xuICAgICAgICAgICAgbnNwLmVtaXQoZXYsIC4uLmFyZ3MpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGNyZWF0ZUNoaWxkKG5hbWUpIHtcbiAgICAgICAgZGVidWcoXCJjcmVhdGluZyBjaGlsZCBuYW1lc3BhY2UgJXNcIiwgbmFtZSk7XG4gICAgICAgIGNvbnN0IG5hbWVzcGFjZSA9IG5ldyBuYW1lc3BhY2VfMS5OYW1lc3BhY2UodGhpcy5zZXJ2ZXIsIG5hbWUpO1xuICAgICAgICB0aGlzW1wiX2Zuc1wiXS5mb3JFYWNoKChmbikgPT4gbmFtZXNwYWNlLnVzZShmbikpO1xuICAgICAgICB0aGlzLmxpc3RlbmVycyhcImNvbm5lY3RcIikuZm9yRWFjaCgobGlzdGVuZXIpID0+IG5hbWVzcGFjZS5vbihcImNvbm5lY3RcIiwgbGlzdGVuZXIpKTtcbiAgICAgICAgdGhpcy5saXN0ZW5lcnMoXCJjb25uZWN0aW9uXCIpLmZvckVhY2goKGxpc3RlbmVyKSA9PiBuYW1lc3BhY2Uub24oXCJjb25uZWN0aW9uXCIsIGxpc3RlbmVyKSk7XG4gICAgICAgIHRoaXMuY2hpbGRyZW4uYWRkKG5hbWVzcGFjZSk7XG4gICAgICAgIGlmICh0aGlzLnNlcnZlci5fb3B0cy5jbGVhbnVwRW1wdHlDaGlsZE5hbWVzcGFjZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlbW92ZSA9IG5hbWVzcGFjZS5fcmVtb3ZlO1xuICAgICAgICAgICAgbmFtZXNwYWNlLl9yZW1vdmUgPSAoc29ja2V0KSA9PiB7XG4gICAgICAgICAgICAgICAgcmVtb3ZlLmNhbGwobmFtZXNwYWNlLCBzb2NrZXQpO1xuICAgICAgICAgICAgICAgIGlmIChuYW1lc3BhY2Uuc29ja2V0cy5zaXplID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlYnVnKFwiY2xvc2luZyBjaGlsZCBuYW1lc3BhY2UgJXNcIiwgbmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIG5hbWVzcGFjZS5hZGFwdGVyLmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2VydmVyLl9uc3BzLmRlbGV0ZShuYW1lc3BhY2UubmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2hpbGRyZW4uZGVsZXRlKG5hbWVzcGFjZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNlcnZlci5fbnNwcy5zZXQobmFtZSwgbmFtZXNwYWNlKTtcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICB0aGlzLnNlcnZlci5zb2NrZXRzLmVtaXRSZXNlcnZlZChcIm5ld19uYW1lc3BhY2VcIiwgbmFtZXNwYWNlKTtcbiAgICAgICAgcmV0dXJuIG5hbWVzcGFjZTtcbiAgICB9XG4gICAgZmV0Y2hTb2NrZXRzKCkge1xuICAgICAgICAvLyBub3RlOiB3ZSBjb3VsZCBtYWtlIHRoZSBmZXRjaFNvY2tldHMoKSBtZXRob2Qgd29yayBmb3IgZHluYW1pYyBuYW1lc3BhY2VzIGNyZWF0ZWQgd2l0aCBhIHJlZ2V4IChieSBzZW5kaW5nIHRoZVxuICAgICAgICAvLyByZWdleCB0byB0aGUgb3RoZXIgU29ja2V0LklPIHNlcnZlcnMsIGFuZCByZXR1cm5pbmcgdGhlIHNvY2tldHMgb2YgZWFjaCBtYXRjaGluZyBuYW1lc3BhY2UgZm9yIGV4YW1wbGUpLCBidXRcbiAgICAgICAgLy8gdGhlIGJlaGF2aW9yIGZvciBuYW1lc3BhY2VzIGNyZWF0ZWQgd2l0aCBhIGZ1bmN0aW9uIGlzIGxlc3MgY2xlYXJcbiAgICAgICAgLy8gbm90ZcKyOiB3ZSBjYW5ub3QgbG9vcCBvdmVyIGVhY2ggY2hpbGRyZW4gbmFtZXNwYWNlLCBiZWNhdXNlIHdpdGggbXVsdGlwbGUgU29ja2V0LklPIHNlcnZlcnMsIGEgZ2l2ZW4gbmFtZXNwYWNlXG4gICAgICAgIC8vIG1heSBleGlzdCBvbiBvbmUgbm9kZSBidXQgbm90IGV4aXN0IG9uIGFub3RoZXIgKHNpbmNlIGl0IGlzIGNyZWF0ZWQgdXBvbiBjbGllbnQgY29ubmVjdGlvbilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZmV0Y2hTb2NrZXRzKCkgaXMgbm90IHN1cHBvcnRlZCBvbiBwYXJlbnQgbmFtZXNwYWNlc1wiKTtcbiAgICB9XG59XG5leHBvcnRzLlBhcmVudE5hbWVzcGFjZSA9IFBhcmVudE5hbWVzcGFjZTtcblBhcmVudE5hbWVzcGFjZS5jb3VudCA9IDA7XG4vKipcbiAqIEEgZHVtbXkgYWRhcHRlciB0aGF0IG9ubHkgc3VwcG9ydHMgYnJvYWRjYXN0aW5nIHRvIGNoaWxkIChjb25jcmV0ZSkgbmFtZXNwYWNlcy5cbiAqIEBwcml2YXRlIGZpbGVcbiAqL1xuY2xhc3MgUGFyZW50QnJvYWRjYXN0QWRhcHRlciBleHRlbmRzIHNvY2tldF9pb19hZGFwdGVyXzEuQWRhcHRlciB7XG4gICAgYnJvYWRjYXN0KHBhY2tldCwgb3B0cykge1xuICAgICAgICB0aGlzLm5zcC5jaGlsZHJlbi5mb3JFYWNoKChuc3ApID0+IHtcbiAgICAgICAgICAgIG5zcC5hZGFwdGVyLmJyb2FkY2FzdChwYWNrZXQsIG9wdHMpO1xuICAgICAgICB9KTtcbiAgICB9XG59XG4iXSwibmFtZXMiOlsiX19pbXBvcnREZWZhdWx0IiwibW9kIiwiX19lc01vZHVsZSIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiUGFyZW50TmFtZXNwYWNlIiwibmFtZXNwYWNlXzEiLCJyZXF1aXJlIiwic29ja2V0X2lvX2FkYXB0ZXJfMSIsImRlYnVnXzEiLCJkZWJ1ZyIsImRlZmF1bHQiLCJOYW1lc3BhY2UiLCJjb25zdHJ1Y3RvciIsInNlcnZlciIsImNvdW50IiwiY2hpbGRyZW4iLCJTZXQiLCJfaW5pdEFkYXB0ZXIiLCJhZGFwdGVyIiwiUGFyZW50QnJvYWRjYXN0QWRhcHRlciIsImVtaXQiLCJldiIsImFyZ3MiLCJmb3JFYWNoIiwibnNwIiwiY3JlYXRlQ2hpbGQiLCJuYW1lIiwibmFtZXNwYWNlIiwiZm4iLCJ1c2UiLCJsaXN0ZW5lcnMiLCJsaXN0ZW5lciIsIm9uIiwiYWRkIiwiX29wdHMiLCJjbGVhbnVwRW1wdHlDaGlsZE5hbWVzcGFjZXMiLCJyZW1vdmUiLCJfcmVtb3ZlIiwic29ja2V0IiwiY2FsbCIsInNvY2tldHMiLCJzaXplIiwiY2xvc2UiLCJfbnNwcyIsImRlbGV0ZSIsInNldCIsImVtaXRSZXNlcnZlZCIsImZldGNoU29ja2V0cyIsIkVycm9yIiwiQWRhcHRlciIsImJyb2FkY2FzdCIsInBhY2tldCIsIm9wdHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/socket.io/dist/parent-namespace.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/socket.io/dist/socket-types.js":
/*!*****************************************************!*\
  !*** ./node_modules/socket.io/dist/socket-types.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.RESERVED_EVENTS = void 0;\nexports.RESERVED_EVENTS = new Set([\n    \"connect\",\n    \"connect_error\",\n    \"disconnect\",\n    \"disconnecting\",\n    \"newListener\",\n    \"removeListener\"\n]);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc29ja2V0LmlvL2Rpc3Qvc29ja2V0LXR5cGVzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCx1QkFBdUIsR0FBRyxLQUFLO0FBQy9CQSx1QkFBdUIsR0FBRyxJQUFJRyxJQUFJO0lBQzlCO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtDQUNIIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZXhhbXJvc2gvLi9ub2RlX21vZHVsZXMvc29ja2V0LmlvL2Rpc3Qvc29ja2V0LXR5cGVzLmpzP2MwZDAiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlJFU0VSVkVEX0VWRU5UUyA9IHZvaWQgMDtcbmV4cG9ydHMuUkVTRVJWRURfRVZFTlRTID0gbmV3IFNldChbXG4gICAgXCJjb25uZWN0XCIsXG4gICAgXCJjb25uZWN0X2Vycm9yXCIsXG4gICAgXCJkaXNjb25uZWN0XCIsXG4gICAgXCJkaXNjb25uZWN0aW5nXCIsXG4gICAgXCJuZXdMaXN0ZW5lclwiLFxuICAgIFwicmVtb3ZlTGlzdGVuZXJcIixcbl0pO1xuIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiUkVTRVJWRURfRVZFTlRTIiwiU2V0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/socket.io/dist/socket-types.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/socket.io/dist/socket.js":
/*!***********************************************!*\
  !*** ./node_modules/socket.io/dist/socket.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nvar __importDefault = (void 0) && (void 0).__importDefault || function(mod) {\n    return mod && mod.__esModule ? mod : {\n        \"default\": mod\n    };\n};\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.Socket = void 0;\nconst socket_io_parser_1 = __webpack_require__(/*! socket.io-parser */ \"(rsc)/./node_modules/socket.io-parser/build/cjs/index.js\");\nconst debug_1 = __importDefault(__webpack_require__(/*! debug */ \"(rsc)/./node_modules/socket.io/node_modules/debug/src/index.js\"));\nconst typed_events_1 = __webpack_require__(/*! ./typed-events */ \"(rsc)/./node_modules/socket.io/dist/typed-events.js\");\nconst base64id_1 = __importDefault(__webpack_require__(/*! base64id */ \"(rsc)/./node_modules/base64id/lib/base64id.js\"));\nconst broadcast_operator_1 = __webpack_require__(/*! ./broadcast-operator */ \"(rsc)/./node_modules/socket.io/dist/broadcast-operator.js\");\nconst socket_types_1 = __webpack_require__(/*! ./socket-types */ \"(rsc)/./node_modules/socket.io/dist/socket-types.js\");\nconst debug = (0, debug_1.default)(\"socket.io:socket\");\nconst RECOVERABLE_DISCONNECT_REASONS = new Set([\n    \"transport error\",\n    \"transport close\",\n    \"forced close\",\n    \"ping timeout\",\n    \"server shutting down\",\n    \"forced server close\"\n]);\nfunction noop() {}\n/**\n * This is the main object for interacting with a client.\n *\n * A Socket belongs to a given {@link Namespace} and uses an underlying {@link Client} to communicate.\n *\n * Within each {@link Namespace}, you can also define arbitrary channels (called \"rooms\") that the {@link Socket} can\n * join and leave. That provides a convenient way to broadcast to a group of socket instances.\n *\n * @example\n * io.on(\"connection\", (socket) => {\n *   console.log(`socket ${socket.id} connected`);\n *\n *   // send an event to the client\n *   socket.emit(\"foo\", \"bar\");\n *\n *   socket.on(\"foobar\", () => {\n *     // an event was received from the client\n *   });\n *\n *   // join the room named \"room1\"\n *   socket.join(\"room1\");\n *\n *   // broadcast to everyone in the room named \"room1\"\n *   io.to(\"room1\").emit(\"hello\");\n *\n *   // upon disconnection\n *   socket.on(\"disconnect\", (reason) => {\n *     console.log(`socket ${socket.id} disconnected due to ${reason}`);\n *   });\n * });\n */ class Socket extends typed_events_1.StrictEventEmitter {\n    /**\n     * Interface to a `Client` for a given `Namespace`.\n     *\n     * @param {Namespace} nsp\n     * @param {Client} client\n     * @param {Object} auth\n     * @package\n     */ constructor(nsp, client, auth, previousSession){\n        super();\n        this.nsp = nsp;\n        this.client = client;\n        /**\n         * Whether the connection state was recovered after a temporary disconnection. In that case, any missed packets will\n         * be transmitted to the client, the data attribute and the rooms will be restored.\n         */ this.recovered = false;\n        /**\n         * Additional information that can be attached to the Socket instance and which will be used in the\n         * {@link Server.fetchSockets()} method.\n         */ this.data = {};\n        /**\n         * Whether the socket is currently connected or not.\n         *\n         * @example\n         * io.use((socket, next) => {\n         *   console.log(socket.connected); // false\n         *   next();\n         * });\n         *\n         * io.on(\"connection\", (socket) => {\n         *   console.log(socket.connected); // true\n         * });\n         */ this.connected = false;\n        this.acks = new Map();\n        this.fns = [];\n        this.flags = {};\n        this.server = nsp.server;\n        this.adapter = this.nsp.adapter;\n        if (previousSession) {\n            this.id = previousSession.sid;\n            this.pid = previousSession.pid;\n            previousSession.rooms.forEach((room)=>this.join(room));\n            this.data = previousSession.data;\n            previousSession.missedPackets.forEach((packet)=>{\n                this.packet({\n                    type: socket_io_parser_1.PacketType.EVENT,\n                    data: packet\n                });\n            });\n            this.recovered = true;\n        } else {\n            if (client.conn.protocol === 3) {\n                // @ts-ignore\n                this.id = nsp.name !== \"/\" ? nsp.name + \"#\" + client.id : client.id;\n            } else {\n                this.id = base64id_1.default.generateId(); // don't reuse the Engine.IO id because it's sensitive information\n            }\n            if (this.server._opts.connectionStateRecovery) {\n                this.pid = base64id_1.default.generateId();\n            }\n        }\n        this.handshake = this.buildHandshake(auth);\n        // prevents crash when the socket receives an \"error\" event without listener\n        this.on(\"error\", noop);\n    }\n    /**\n     * Builds the `handshake` BC object\n     *\n     * @private\n     */ buildHandshake(auth) {\n        var _a, _b, _c, _d;\n        return {\n            headers: ((_a = this.request) === null || _a === void 0 ? void 0 : _a.headers) || {},\n            time: new Date() + \"\",\n            address: this.conn.remoteAddress,\n            xdomain: !!((_b = this.request) === null || _b === void 0 ? void 0 : _b.headers.origin),\n            // @ts-ignore\n            secure: !this.request || !!this.request.connection.encrypted,\n            issued: +new Date(),\n            url: (_c = this.request) === null || _c === void 0 ? void 0 : _c.url,\n            // @ts-ignore\n            query: ((_d = this.request) === null || _d === void 0 ? void 0 : _d._query) || {},\n            auth\n        };\n    }\n    /**\n     * Emits to this client.\n     *\n     * @example\n     * io.on(\"connection\", (socket) => {\n     *   socket.emit(\"hello\", \"world\");\n     *\n     *   // all serializable datastructures are supported (no need to call JSON.stringify)\n     *   socket.emit(\"hello\", 1, \"2\", { 3: [\"4\"], 5: Buffer.from([6]) });\n     *\n     *   // with an acknowledgement from the client\n     *   socket.emit(\"hello\", \"world\", (val) => {\n     *     // ...\n     *   });\n     * });\n     *\n     * @return Always returns `true`.\n     */ emit(ev, ...args) {\n        if (socket_types_1.RESERVED_EVENTS.has(ev)) {\n            throw new Error(`\"${String(ev)}\" is a reserved event name`);\n        }\n        const data = [\n            ev,\n            ...args\n        ];\n        const packet = {\n            type: socket_io_parser_1.PacketType.EVENT,\n            data: data\n        };\n        // access last argument to see if it's an ACK callback\n        if (typeof data[data.length - 1] === \"function\") {\n            const id = this.nsp._ids++;\n            debug(\"emitting packet with ack id %d\", id);\n            this.registerAckCallback(id, data.pop());\n            packet.id = id;\n        }\n        const flags = Object.assign({}, this.flags);\n        this.flags = {};\n        // @ts-ignore\n        if (this.nsp.server.opts.connectionStateRecovery) {\n            // this ensures the packet is stored and can be transmitted upon reconnection\n            this.adapter.broadcast(packet, {\n                rooms: new Set([\n                    this.id\n                ]),\n                except: new Set(),\n                flags\n            });\n        } else {\n            this.notifyOutgoingListeners(packet);\n            this.packet(packet, flags);\n        }\n        return true;\n    }\n    /**\n     * Emits an event and waits for an acknowledgement\n     *\n     * @example\n     * io.on(\"connection\", async (socket) => {\n     *   // without timeout\n     *   const response = await socket.emitWithAck(\"hello\", \"world\");\n     *\n     *   // with a specific timeout\n     *   try {\n     *     const response = await socket.timeout(1000).emitWithAck(\"hello\", \"world\");\n     *   } catch (err) {\n     *     // the client did not acknowledge the event in the given delay\n     *   }\n     * });\n     *\n     * @return a Promise that will be fulfilled when the client acknowledges the event\n     */ emitWithAck(ev, ...args) {\n        // the timeout flag is optional\n        const withErr = this.flags.timeout !== undefined;\n        return new Promise((resolve, reject)=>{\n            args.push((arg1, arg2)=>{\n                if (withErr) {\n                    return arg1 ? reject(arg1) : resolve(arg2);\n                } else {\n                    return resolve(arg1);\n                }\n            });\n            this.emit(ev, ...args);\n        });\n    }\n    /**\n     * @private\n     */ registerAckCallback(id, ack) {\n        const timeout = this.flags.timeout;\n        if (timeout === undefined) {\n            this.acks.set(id, ack);\n            return;\n        }\n        const timer = setTimeout(()=>{\n            debug(\"event with ack id %d has timed out after %d ms\", id, timeout);\n            this.acks.delete(id);\n            ack.call(this, new Error(\"operation has timed out\"));\n        }, timeout);\n        this.acks.set(id, (...args)=>{\n            clearTimeout(timer);\n            ack.apply(this, [\n                null,\n                ...args\n            ]);\n        });\n    }\n    /**\n     * Targets a room when broadcasting.\n     *\n     * @example\n     * io.on(\"connection\", (socket) => {\n     *   // the foo event will be broadcast to all connected clients in the room-101 room, except this socket\n     *   socket.to(\"room-101\").emit(\"foo\", \"bar\");\n     *\n     *   // the code above is equivalent to:\n     *   io.to(\"room-101\").except(socket.id).emit(\"foo\", \"bar\");\n     *\n     *   // with an array of rooms (a client will be notified at most once)\n     *   socket.to([\"room-101\", \"room-102\"]).emit(\"foo\", \"bar\");\n     *\n     *   // with multiple chained calls\n     *   socket.to(\"room-101\").to(\"room-102\").emit(\"foo\", \"bar\");\n     * });\n     *\n     * @param room - a room, or an array of rooms\n     * @return a new {@link BroadcastOperator} instance for chaining\n     */ to(room) {\n        return this.newBroadcastOperator().to(room);\n    }\n    /**\n     * Targets a room when broadcasting. Similar to `to()`, but might feel clearer in some cases:\n     *\n     * @example\n     * io.on(\"connection\", (socket) => {\n     *   // disconnect all clients in the \"room-101\" room, except this socket\n     *   socket.in(\"room-101\").disconnectSockets();\n     * });\n     *\n     * @param room - a room, or an array of rooms\n     * @return a new {@link BroadcastOperator} instance for chaining\n     */ in(room) {\n        return this.newBroadcastOperator().in(room);\n    }\n    /**\n     * Excludes a room when broadcasting.\n     *\n     * @example\n     * io.on(\"connection\", (socket) => {\n     *   // the \"foo\" event will be broadcast to all connected clients, except the ones that are in the \"room-101\" room\n     *   // and this socket\n     *   socket.except(\"room-101\").emit(\"foo\", \"bar\");\n     *\n     *   // with an array of rooms\n     *   socket.except([\"room-101\", \"room-102\"]).emit(\"foo\", \"bar\");\n     *\n     *   // with multiple chained calls\n     *   socket.except(\"room-101\").except(\"room-102\").emit(\"foo\", \"bar\");\n     * });\n     *\n     * @param room - a room, or an array of rooms\n     * @return a new {@link BroadcastOperator} instance for chaining\n     */ except(room) {\n        return this.newBroadcastOperator().except(room);\n    }\n    /**\n     * Sends a `message` event.\n     *\n     * This method mimics the WebSocket.send() method.\n     *\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/send\n     *\n     * @example\n     * io.on(\"connection\", (socket) => {\n     *   socket.send(\"hello\");\n     *\n     *   // this is equivalent to\n     *   socket.emit(\"message\", \"hello\");\n     * });\n     *\n     * @return self\n     */ send(...args) {\n        this.emit(\"message\", ...args);\n        return this;\n    }\n    /**\n     * Sends a `message` event. Alias of {@link send}.\n     *\n     * @return self\n     */ write(...args) {\n        this.emit(\"message\", ...args);\n        return this;\n    }\n    /**\n     * Writes a packet.\n     *\n     * @param {Object} packet - packet object\n     * @param {Object} opts - options\n     * @private\n     */ packet(packet, opts = {}) {\n        packet.nsp = this.nsp.name;\n        opts.compress = false !== opts.compress;\n        this.client._packet(packet, opts);\n    }\n    /**\n     * Joins a room.\n     *\n     * @example\n     * io.on(\"connection\", (socket) => {\n     *   // join a single room\n     *   socket.join(\"room1\");\n     *\n     *   // join multiple rooms\n     *   socket.join([\"room1\", \"room2\"]);\n     * });\n     *\n     * @param {String|Array} rooms - room or array of rooms\n     * @return a Promise or nothing, depending on the adapter\n     */ join(rooms) {\n        debug(\"join room %s\", rooms);\n        return this.adapter.addAll(this.id, new Set(Array.isArray(rooms) ? rooms : [\n            rooms\n        ]));\n    }\n    /**\n     * Leaves a room.\n     *\n     * @example\n     * io.on(\"connection\", (socket) => {\n     *   // leave a single room\n     *   socket.leave(\"room1\");\n     *\n     *   // leave multiple rooms\n     *   socket.leave(\"room1\").leave(\"room2\");\n     * });\n     *\n     * @param {String} room\n     * @return a Promise or nothing, depending on the adapter\n     */ leave(room) {\n        debug(\"leave room %s\", room);\n        return this.adapter.del(this.id, room);\n    }\n    /**\n     * Leave all rooms.\n     *\n     * @private\n     */ leaveAll() {\n        this.adapter.delAll(this.id);\n    }\n    /**\n     * Called by `Namespace` upon successful\n     * middleware execution (ie: authorization).\n     * Socket is added to namespace array before\n     * call to join, so adapters can access it.\n     *\n     * @private\n     */ _onconnect() {\n        debug(\"socket connected - writing packet\");\n        this.connected = true;\n        this.join(this.id);\n        if (this.conn.protocol === 3) {\n            this.packet({\n                type: socket_io_parser_1.PacketType.CONNECT\n            });\n        } else {\n            this.packet({\n                type: socket_io_parser_1.PacketType.CONNECT,\n                data: {\n                    sid: this.id,\n                    pid: this.pid\n                }\n            });\n        }\n    }\n    /**\n     * Called with each packet. Called by `Client`.\n     *\n     * @param {Object} packet\n     * @private\n     */ _onpacket(packet) {\n        debug(\"got packet %j\", packet);\n        switch(packet.type){\n            case socket_io_parser_1.PacketType.EVENT:\n                this.onevent(packet);\n                break;\n            case socket_io_parser_1.PacketType.BINARY_EVENT:\n                this.onevent(packet);\n                break;\n            case socket_io_parser_1.PacketType.ACK:\n                this.onack(packet);\n                break;\n            case socket_io_parser_1.PacketType.BINARY_ACK:\n                this.onack(packet);\n                break;\n            case socket_io_parser_1.PacketType.DISCONNECT:\n                this.ondisconnect();\n                break;\n        }\n    }\n    /**\n     * Called upon event packet.\n     *\n     * @param {Packet} packet - packet object\n     * @private\n     */ onevent(packet) {\n        const args = packet.data || [];\n        debug(\"emitting event %j\", args);\n        if (null != packet.id) {\n            debug(\"attaching ack callback to event\");\n            args.push(this.ack(packet.id));\n        }\n        if (this._anyListeners && this._anyListeners.length) {\n            const listeners = this._anyListeners.slice();\n            for (const listener of listeners){\n                listener.apply(this, args);\n            }\n        }\n        this.dispatch(args);\n    }\n    /**\n     * Produces an ack callback to emit with an event.\n     *\n     * @param {Number} id - packet id\n     * @private\n     */ ack(id) {\n        const self = this;\n        let sent = false;\n        return function() {\n            // prevent double callbacks\n            if (sent) return;\n            const args = Array.prototype.slice.call(arguments);\n            debug(\"sending ack %j\", args);\n            self.packet({\n                id: id,\n                type: socket_io_parser_1.PacketType.ACK,\n                data: args\n            });\n            sent = true;\n        };\n    }\n    /**\n     * Called upon ack packet.\n     *\n     * @private\n     */ onack(packet) {\n        const ack = this.acks.get(packet.id);\n        if (\"function\" == typeof ack) {\n            debug(\"calling ack %s with %j\", packet.id, packet.data);\n            ack.apply(this, packet.data);\n            this.acks.delete(packet.id);\n        } else {\n            debug(\"bad ack %s\", packet.id);\n        }\n    }\n    /**\n     * Called upon client disconnect packet.\n     *\n     * @private\n     */ ondisconnect() {\n        debug(\"got disconnect packet\");\n        this._onclose(\"client namespace disconnect\");\n    }\n    /**\n     * Handles a client error.\n     *\n     * @private\n     */ _onerror(err) {\n        // FIXME the meaning of the \"error\" event is overloaded:\n        //  - it can be sent by the client (`socket.emit(\"error\")`)\n        //  - it can be emitted when the connection encounters an error (an invalid packet for example)\n        //  - it can be emitted when a packet is rejected in a middleware (`socket.use()`)\n        this.emitReserved(\"error\", err);\n    }\n    /**\n     * Called upon closing. Called by `Client`.\n     *\n     * @param {String} reason\n     * @param description\n     * @throw {Error} optional error object\n     *\n     * @private\n     */ _onclose(reason, description) {\n        if (!this.connected) return this;\n        debug(\"closing socket - reason %s\", reason);\n        this.emitReserved(\"disconnecting\", reason, description);\n        if (this.server._opts.connectionStateRecovery && RECOVERABLE_DISCONNECT_REASONS.has(reason)) {\n            debug(\"connection state recovery is enabled for sid %s\", this.id);\n            this.adapter.persistSession({\n                sid: this.id,\n                pid: this.pid,\n                rooms: [\n                    ...this.rooms\n                ],\n                data: this.data\n            });\n        }\n        this._cleanup();\n        this.client._remove(this);\n        this.connected = false;\n        this.emitReserved(\"disconnect\", reason, description);\n        return;\n    }\n    /**\n     * Makes the socket leave all the rooms it was part of and prevents it from joining any other room\n     *\n     * @private\n     */ _cleanup() {\n        this.leaveAll();\n        this.nsp._remove(this);\n        this.join = noop;\n    }\n    /**\n     * Produces an `error` packet.\n     *\n     * @param {Object} err - error object\n     *\n     * @private\n     */ _error(err) {\n        this.packet({\n            type: socket_io_parser_1.PacketType.CONNECT_ERROR,\n            data: err\n        });\n    }\n    /**\n     * Disconnects this client.\n     *\n     * @example\n     * io.on(\"connection\", (socket) => {\n     *   // disconnect this socket (the connection might be kept alive for other namespaces)\n     *   socket.disconnect();\n     *\n     *   // disconnect this socket and close the underlying connection\n     *   socket.disconnect(true);\n     * })\n     *\n     * @param {Boolean} close - if `true`, closes the underlying connection\n     * @return self\n     */ disconnect(close = false) {\n        if (!this.connected) return this;\n        if (close) {\n            this.client._disconnect();\n        } else {\n            this.packet({\n                type: socket_io_parser_1.PacketType.DISCONNECT\n            });\n            this._onclose(\"server namespace disconnect\");\n        }\n        return this;\n    }\n    /**\n     * Sets the compress flag.\n     *\n     * @example\n     * io.on(\"connection\", (socket) => {\n     *   socket.compress(false).emit(\"hello\");\n     * });\n     *\n     * @param {Boolean} compress - if `true`, compresses the sending data\n     * @return {Socket} self\n     */ compress(compress) {\n        this.flags.compress = compress;\n        return this;\n    }\n    /**\n     * Sets a modifier for a subsequent event emission that the event data may be lost if the client is not ready to\n     * receive messages (because of network slowness or other issues, or because theyre connected through long polling\n     * and is in the middle of a request-response cycle).\n     *\n     * @example\n     * io.on(\"connection\", (socket) => {\n     *   socket.volatile.emit(\"hello\"); // the client may or may not receive it\n     * });\n     *\n     * @return {Socket} self\n     */ get volatile() {\n        this.flags.volatile = true;\n        return this;\n    }\n    /**\n     * Sets a modifier for a subsequent event emission that the event data will only be broadcast to every sockets but the\n     * sender.\n     *\n     * @example\n     * io.on(\"connection\", (socket) => {\n     *   // the foo event will be broadcast to all connected clients, except this socket\n     *   socket.broadcast.emit(\"foo\", \"bar\");\n     * });\n     *\n     * @return a new {@link BroadcastOperator} instance for chaining\n     */ get broadcast() {\n        return this.newBroadcastOperator();\n    }\n    /**\n     * Sets a modifier for a subsequent event emission that the event data will only be broadcast to the current node.\n     *\n     * @example\n     * io.on(\"connection\", (socket) => {\n     *   // the foo event will be broadcast to all connected clients on this node, except this socket\n     *   socket.local.emit(\"foo\", \"bar\");\n     * });\n     *\n     * @return a new {@link BroadcastOperator} instance for chaining\n     */ get local() {\n        return this.newBroadcastOperator().local;\n    }\n    /**\n     * Sets a modifier for a subsequent event emission that the callback will be called with an error when the\n     * given number of milliseconds have elapsed without an acknowledgement from the client:\n     *\n     * @example\n     * io.on(\"connection\", (socket) => {\n     *   socket.timeout(5000).emit(\"my-event\", (err) => {\n     *     if (err) {\n     *       // the client did not acknowledge the event in the given delay\n     *     }\n     *   });\n     * });\n     *\n     * @returns self\n     */ timeout(timeout) {\n        this.flags.timeout = timeout;\n        return this;\n    }\n    /**\n     * Dispatch incoming event to socket listeners.\n     *\n     * @param {Array} event - event that will get emitted\n     * @private\n     */ dispatch(event) {\n        debug(\"dispatching an event %j\", event);\n        this.run(event, (err)=>{\n            process.nextTick(()=>{\n                if (err) {\n                    return this._onerror(err);\n                }\n                if (this.connected) {\n                    super.emitUntyped.apply(this, event);\n                } else {\n                    debug(\"ignore packet received after disconnection\");\n                }\n            });\n        });\n    }\n    /**\n     * Sets up socket middleware.\n     *\n     * @example\n     * io.on(\"connection\", (socket) => {\n     *   socket.use(([event, ...args], next) => {\n     *     if (isUnauthorized(event)) {\n     *       return next(new Error(\"unauthorized event\"));\n     *     }\n     *     // do not forget to call next\n     *     next();\n     *   });\n     *\n     *   socket.on(\"error\", (err) => {\n     *     if (err && err.message === \"unauthorized event\") {\n     *       socket.disconnect();\n     *     }\n     *   });\n     * });\n     *\n     * @param {Function} fn - middleware function (event, next)\n     * @return {Socket} self\n     */ use(fn) {\n        this.fns.push(fn);\n        return this;\n    }\n    /**\n     * Executes the middleware for an incoming event.\n     *\n     * @param {Array} event - event that will get emitted\n     * @param {Function} fn - last fn call in the middleware\n     * @private\n     */ run(event, fn) {\n        if (!this.fns.length) return fn();\n        const fns = this.fns.slice(0);\n        function run(i) {\n            fns[i](event, (err)=>{\n                // upon error, short-circuit\n                if (err) return fn(err);\n                // if no middleware left, summon callback\n                if (!fns[i + 1]) return fn();\n                // go on to next\n                run(i + 1);\n            });\n        }\n        run(0);\n    }\n    /**\n     * Whether the socket is currently disconnected\n     */ get disconnected() {\n        return !this.connected;\n    }\n    /**\n     * A reference to the request that originated the underlying Engine.IO Socket.\n     */ get request() {\n        return this.client.request;\n    }\n    /**\n     * A reference to the underlying Client transport connection (Engine.IO Socket object).\n     *\n     * @example\n     * io.on(\"connection\", (socket) => {\n     *   console.log(socket.conn.transport.name); // prints \"polling\" or \"websocket\"\n     *\n     *   socket.conn.once(\"upgrade\", () => {\n     *     console.log(socket.conn.transport.name); // prints \"websocket\"\n     *   });\n     * });\n     */ get conn() {\n        return this.client.conn;\n    }\n    /**\n     * Returns the rooms the socket is currently in.\n     *\n     * @example\n     * io.on(\"connection\", (socket) => {\n     *   console.log(socket.rooms); // Set { <socket.id> }\n     *\n     *   socket.join(\"room1\");\n     *\n     *   console.log(socket.rooms); // Set { <socket.id>, \"room1\" }\n     * });\n     */ get rooms() {\n        return this.adapter.socketRooms(this.id) || new Set();\n    }\n    /**\n     * Adds a listener that will be fired when any event is received. The event name is passed as the first argument to\n     * the callback.\n     *\n     * @example\n     * io.on(\"connection\", (socket) => {\n     *   socket.onAny((event, ...args) => {\n     *     console.log(`got event ${event}`);\n     *   });\n     * });\n     *\n     * @param listener\n     */ onAny(listener) {\n        this._anyListeners = this._anyListeners || [];\n        this._anyListeners.push(listener);\n        return this;\n    }\n    /**\n     * Adds a listener that will be fired when any event is received. The event name is passed as the first argument to\n     * the callback. The listener is added to the beginning of the listeners array.\n     *\n     * @param listener\n     */ prependAny(listener) {\n        this._anyListeners = this._anyListeners || [];\n        this._anyListeners.unshift(listener);\n        return this;\n    }\n    /**\n     * Removes the listener that will be fired when any event is received.\n     *\n     * @example\n     * io.on(\"connection\", (socket) => {\n     *   const catchAllListener = (event, ...args) => {\n     *     console.log(`got event ${event}`);\n     *   }\n     *\n     *   socket.onAny(catchAllListener);\n     *\n     *   // remove a specific listener\n     *   socket.offAny(catchAllListener);\n     *\n     *   // or remove all listeners\n     *   socket.offAny();\n     * });\n     *\n     * @param listener\n     */ offAny(listener) {\n        if (!this._anyListeners) {\n            return this;\n        }\n        if (listener) {\n            const listeners = this._anyListeners;\n            for(let i = 0; i < listeners.length; i++){\n                if (listener === listeners[i]) {\n                    listeners.splice(i, 1);\n                    return this;\n                }\n            }\n        } else {\n            this._anyListeners = [];\n        }\n        return this;\n    }\n    /**\n     * Returns an array of listeners that are listening for any event that is specified. This array can be manipulated,\n     * e.g. to remove listeners.\n     */ listenersAny() {\n        return this._anyListeners || [];\n    }\n    /**\n     * Adds a listener that will be fired when any event is sent. The event name is passed as the first argument to\n     * the callback.\n     *\n     * Note: acknowledgements sent to the client are not included.\n     *\n     * @example\n     * io.on(\"connection\", (socket) => {\n     *   socket.onAnyOutgoing((event, ...args) => {\n     *     console.log(`sent event ${event}`);\n     *   });\n     * });\n     *\n     * @param listener\n     */ onAnyOutgoing(listener) {\n        this._anyOutgoingListeners = this._anyOutgoingListeners || [];\n        this._anyOutgoingListeners.push(listener);\n        return this;\n    }\n    /**\n     * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the\n     * callback. The listener is added to the beginning of the listeners array.\n     *\n     * @example\n     * io.on(\"connection\", (socket) => {\n     *   socket.prependAnyOutgoing((event, ...args) => {\n     *     console.log(`sent event ${event}`);\n     *   });\n     * });\n     *\n     * @param listener\n     */ prependAnyOutgoing(listener) {\n        this._anyOutgoingListeners = this._anyOutgoingListeners || [];\n        this._anyOutgoingListeners.unshift(listener);\n        return this;\n    }\n    /**\n     * Removes the listener that will be fired when any event is sent.\n     *\n     * @example\n     * io.on(\"connection\", (socket) => {\n     *   const catchAllListener = (event, ...args) => {\n     *     console.log(`sent event ${event}`);\n     *   }\n     *\n     *   socket.onAnyOutgoing(catchAllListener);\n     *\n     *   // remove a specific listener\n     *   socket.offAnyOutgoing(catchAllListener);\n     *\n     *   // or remove all listeners\n     *   socket.offAnyOutgoing();\n     * });\n     *\n     * @param listener - the catch-all listener\n     */ offAnyOutgoing(listener) {\n        if (!this._anyOutgoingListeners) {\n            return this;\n        }\n        if (listener) {\n            const listeners = this._anyOutgoingListeners;\n            for(let i = 0; i < listeners.length; i++){\n                if (listener === listeners[i]) {\n                    listeners.splice(i, 1);\n                    return this;\n                }\n            }\n        } else {\n            this._anyOutgoingListeners = [];\n        }\n        return this;\n    }\n    /**\n     * Returns an array of listeners that are listening for any event that is specified. This array can be manipulated,\n     * e.g. to remove listeners.\n     */ listenersAnyOutgoing() {\n        return this._anyOutgoingListeners || [];\n    }\n    /**\n     * Notify the listeners for each packet sent (emit or broadcast)\n     *\n     * @param packet\n     *\n     * @private\n     */ notifyOutgoingListeners(packet) {\n        if (this._anyOutgoingListeners && this._anyOutgoingListeners.length) {\n            const listeners = this._anyOutgoingListeners.slice();\n            for (const listener of listeners){\n                listener.apply(this, packet.data);\n            }\n        }\n    }\n    newBroadcastOperator() {\n        const flags = Object.assign({}, this.flags);\n        this.flags = {};\n        return new broadcast_operator_1.BroadcastOperator(this.adapter, new Set(), new Set([\n            this.id\n        ]), flags);\n    }\n}\nexports.Socket = Socket;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc29ja2V0LmlvL2Rpc3Qvc29ja2V0LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsSUFBSUEsa0JBQWtCLENBQUMsTUFBRyxLQUFLLE9BQUcsRUFBRUEsZUFBZSxJQUFLLFNBQVVDLEdBQUc7SUFDakUsT0FBTyxPQUFRQSxJQUFJQyxVQUFVLEdBQUlELE1BQU07UUFBRSxXQUFXQTtJQUFJO0FBQzVEO0FBQ0FFLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxjQUFjLEdBQUcsS0FBSztBQUN0QixNQUFNRyxxQkFBcUJDLG1CQUFPQSxDQUFDLGtGQUFrQjtBQUNyRCxNQUFNQyxVQUFVVixnQkFBZ0JTLG1CQUFPQSxDQUFDLDZFQUFPO0FBQy9DLE1BQU1FLGlCQUFpQkYsbUJBQU9BLENBQUMsMkVBQWdCO0FBQy9DLE1BQU1HLGFBQWFaLGdCQUFnQlMsbUJBQU9BLENBQUMsK0RBQVU7QUFDckQsTUFBTUksdUJBQXVCSixtQkFBT0EsQ0FBQyx1RkFBc0I7QUFDM0QsTUFBTUssaUJBQWlCTCxtQkFBT0EsQ0FBQywyRUFBZ0I7QUFDL0MsTUFBTU0sUUFBUSxDQUFDLEdBQUdMLFFBQVFNLE9BQU8sRUFBRTtBQUNuQyxNQUFNQyxpQ0FBaUMsSUFBSUMsSUFBSTtJQUMzQztJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7Q0FDSDtBQUNELFNBQVNDLFFBQVM7QUFDbEI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQThCQyxHQUNELE1BQU1aLGVBQWVJLGVBQWVTLGtCQUFrQjtJQUNsRDs7Ozs7OztLQU9DLEdBQ0RDLFlBQVlDLEdBQUcsRUFBRUMsTUFBTSxFQUFFQyxJQUFJLEVBQUVDLGVBQWUsQ0FBRTtRQUM1QyxLQUFLO1FBQ0wsSUFBSSxDQUFDSCxHQUFHLEdBQUdBO1FBQ1gsSUFBSSxDQUFDQyxNQUFNLEdBQUdBO1FBQ2Q7OztTQUdDLEdBQ0QsSUFBSSxDQUFDRyxTQUFTLEdBQUc7UUFDakI7OztTQUdDLEdBQ0QsSUFBSSxDQUFDQyxJQUFJLEdBQUcsQ0FBQztRQUNiOzs7Ozs7Ozs7Ozs7U0FZQyxHQUNELElBQUksQ0FBQ0MsU0FBUyxHQUFHO1FBQ2pCLElBQUksQ0FBQ0MsSUFBSSxHQUFHLElBQUlDO1FBQ2hCLElBQUksQ0FBQ0MsR0FBRyxHQUFHLEVBQUU7UUFDYixJQUFJLENBQUNDLEtBQUssR0FBRyxDQUFDO1FBQ2QsSUFBSSxDQUFDQyxNQUFNLEdBQUdYLElBQUlXLE1BQU07UUFDeEIsSUFBSSxDQUFDQyxPQUFPLEdBQUcsSUFBSSxDQUFDWixHQUFHLENBQUNZLE9BQU87UUFDL0IsSUFBSVQsaUJBQWlCO1lBQ2pCLElBQUksQ0FBQ1UsRUFBRSxHQUFHVixnQkFBZ0JXLEdBQUc7WUFDN0IsSUFBSSxDQUFDQyxHQUFHLEdBQUdaLGdCQUFnQlksR0FBRztZQUM5QlosZ0JBQWdCYSxLQUFLLENBQUNDLE9BQU8sQ0FBQyxDQUFDQyxPQUFTLElBQUksQ0FBQ0MsSUFBSSxDQUFDRDtZQUNsRCxJQUFJLENBQUNiLElBQUksR0FBR0YsZ0JBQWdCRSxJQUFJO1lBQ2hDRixnQkFBZ0JpQixhQUFhLENBQUNILE9BQU8sQ0FBQyxDQUFDSTtnQkFDbkMsSUFBSSxDQUFDQSxNQUFNLENBQUM7b0JBQ1JDLE1BQU1wQyxtQkFBbUJxQyxVQUFVLENBQUNDLEtBQUs7b0JBQ3pDbkIsTUFBTWdCO2dCQUNWO1lBQ0o7WUFDQSxJQUFJLENBQUNqQixTQUFTLEdBQUc7UUFDckIsT0FDSztZQUNELElBQUlILE9BQU93QixJQUFJLENBQUNDLFFBQVEsS0FBSyxHQUFHO2dCQUM1QixhQUFhO2dCQUNiLElBQUksQ0FBQ2IsRUFBRSxHQUFHYixJQUFJMkIsSUFBSSxLQUFLLE1BQU0zQixJQUFJMkIsSUFBSSxHQUFHLE1BQU0xQixPQUFPWSxFQUFFLEdBQUdaLE9BQU9ZLEVBQUU7WUFDdkUsT0FDSztnQkFDRCxJQUFJLENBQUNBLEVBQUUsR0FBR3ZCLFdBQVdJLE9BQU8sQ0FBQ2tDLFVBQVUsSUFBSSxrRUFBa0U7WUFDakg7WUFDQSxJQUFJLElBQUksQ0FBQ2pCLE1BQU0sQ0FBQ2tCLEtBQUssQ0FBQ0MsdUJBQXVCLEVBQUU7Z0JBQzNDLElBQUksQ0FBQ2YsR0FBRyxHQUFHekIsV0FBV0ksT0FBTyxDQUFDa0MsVUFBVTtZQUM1QztRQUNKO1FBQ0EsSUFBSSxDQUFDRyxTQUFTLEdBQUcsSUFBSSxDQUFDQyxjQUFjLENBQUM5QjtRQUNyQyw0RUFBNEU7UUFDNUUsSUFBSSxDQUFDK0IsRUFBRSxDQUFDLFNBQVNwQztJQUNyQjtJQUNBOzs7O0tBSUMsR0FDRG1DLGVBQWU5QixJQUFJLEVBQUU7UUFDakIsSUFBSWdDLElBQUlDLElBQUlDLElBQUlDO1FBQ2hCLE9BQU87WUFDSEMsU0FBUyxDQUFDLENBQUNKLEtBQUssSUFBSSxDQUFDSyxPQUFPLE1BQU0sUUFBUUwsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHSSxPQUFPLEtBQUssQ0FBQztZQUNuRkUsTUFBTSxJQUFJQyxTQUFTO1lBQ25CQyxTQUFTLElBQUksQ0FBQ2pCLElBQUksQ0FBQ2tCLGFBQWE7WUFDaENDLFNBQVMsQ0FBQyxDQUFFLEVBQUNULEtBQUssSUFBSSxDQUFDSSxPQUFPLE1BQU0sUUFBUUosT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHRyxPQUFPLENBQUNPLE1BQU07WUFDdEYsYUFBYTtZQUNiQyxRQUFRLENBQUMsSUFBSSxDQUFDUCxPQUFPLElBQUksQ0FBQyxDQUFDLElBQUksQ0FBQ0EsT0FBTyxDQUFDUSxVQUFVLENBQUNDLFNBQVM7WUFDNURDLFFBQVEsQ0FBQyxJQUFJUjtZQUNiUyxLQUFLLENBQUNkLEtBQUssSUFBSSxDQUFDRyxPQUFPLE1BQU0sUUFBUUgsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHYyxHQUFHO1lBQ3BFLGFBQWE7WUFDYkMsT0FBTyxDQUFDLENBQUNkLEtBQUssSUFBSSxDQUFDRSxPQUFPLE1BQU0sUUFBUUYsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHZSxNQUFNLEtBQUssQ0FBQztZQUNoRmxEO1FBQ0o7SUFDSjtJQUNBOzs7Ozs7Ozs7Ozs7Ozs7OztLQWlCQyxHQUNEbUQsS0FBS0MsRUFBRSxFQUFFLEdBQUdDLElBQUksRUFBRTtRQUNkLElBQUkvRCxlQUFlZ0UsZUFBZSxDQUFDQyxHQUFHLENBQUNILEtBQUs7WUFDeEMsTUFBTSxJQUFJSSxNQUFNLENBQUMsQ0FBQyxFQUFFQyxPQUFPTCxJQUFJLDBCQUEwQixDQUFDO1FBQzlEO1FBQ0EsTUFBTWpELE9BQU87WUFBQ2lEO2VBQU9DO1NBQUs7UUFDMUIsTUFBTWxDLFNBQVM7WUFDWEMsTUFBTXBDLG1CQUFtQnFDLFVBQVUsQ0FBQ0MsS0FBSztZQUN6Q25CLE1BQU1BO1FBQ1Y7UUFDQSxzREFBc0Q7UUFDdEQsSUFBSSxPQUFPQSxJQUFJLENBQUNBLEtBQUt1RCxNQUFNLEdBQUcsRUFBRSxLQUFLLFlBQVk7WUFDN0MsTUFBTS9DLEtBQUssSUFBSSxDQUFDYixHQUFHLENBQUM2RCxJQUFJO1lBQ3hCcEUsTUFBTSxrQ0FBa0NvQjtZQUN4QyxJQUFJLENBQUNpRCxtQkFBbUIsQ0FBQ2pELElBQUlSLEtBQUswRCxHQUFHO1lBQ3JDMUMsT0FBT1IsRUFBRSxHQUFHQTtRQUNoQjtRQUNBLE1BQU1ILFFBQVE3QixPQUFPbUYsTUFBTSxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUN0RCxLQUFLO1FBQzFDLElBQUksQ0FBQ0EsS0FBSyxHQUFHLENBQUM7UUFDZCxhQUFhO1FBQ2IsSUFBSSxJQUFJLENBQUNWLEdBQUcsQ0FBQ1csTUFBTSxDQUFDc0QsSUFBSSxDQUFDbkMsdUJBQXVCLEVBQUU7WUFDOUMsNkVBQTZFO1lBQzdFLElBQUksQ0FBQ2xCLE9BQU8sQ0FBQ3NELFNBQVMsQ0FBQzdDLFFBQVE7Z0JBQzNCTCxPQUFPLElBQUlwQixJQUFJO29CQUFDLElBQUksQ0FBQ2lCLEVBQUU7aUJBQUM7Z0JBQ3hCc0QsUUFBUSxJQUFJdkU7Z0JBQ1pjO1lBQ0o7UUFDSixPQUNLO1lBQ0QsSUFBSSxDQUFDMEQsdUJBQXVCLENBQUMvQztZQUM3QixJQUFJLENBQUNBLE1BQU0sQ0FBQ0EsUUFBUVg7UUFDeEI7UUFDQSxPQUFPO0lBQ1g7SUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7S0FpQkMsR0FDRDJELFlBQVlmLEVBQUUsRUFBRSxHQUFHQyxJQUFJLEVBQUU7UUFDckIsK0JBQStCO1FBQy9CLE1BQU1lLFVBQVUsSUFBSSxDQUFDNUQsS0FBSyxDQUFDNkQsT0FBTyxLQUFLQztRQUN2QyxPQUFPLElBQUlDLFFBQVEsQ0FBQ0MsU0FBU0M7WUFDekJwQixLQUFLcUIsSUFBSSxDQUFDLENBQUNDLE1BQU1DO2dCQUNiLElBQUlSLFNBQVM7b0JBQ1QsT0FBT08sT0FBT0YsT0FBT0UsUUFBUUgsUUFBUUk7Z0JBQ3pDLE9BQ0s7b0JBQ0QsT0FBT0osUUFBUUc7Z0JBQ25CO1lBQ0o7WUFDQSxJQUFJLENBQUN4QixJQUFJLENBQUNDLE9BQU9DO1FBQ3JCO0lBQ0o7SUFDQTs7S0FFQyxHQUNETyxvQkFBb0JqRCxFQUFFLEVBQUVrRSxHQUFHLEVBQUU7UUFDekIsTUFBTVIsVUFBVSxJQUFJLENBQUM3RCxLQUFLLENBQUM2RCxPQUFPO1FBQ2xDLElBQUlBLFlBQVlDLFdBQVc7WUFDdkIsSUFBSSxDQUFDakUsSUFBSSxDQUFDeUUsR0FBRyxDQUFDbkUsSUFBSWtFO1lBQ2xCO1FBQ0o7UUFDQSxNQUFNRSxRQUFRQyxXQUFXO1lBQ3JCekYsTUFBTSxrREFBa0RvQixJQUFJMEQ7WUFDNUQsSUFBSSxDQUFDaEUsSUFBSSxDQUFDNEUsTUFBTSxDQUFDdEU7WUFDakJrRSxJQUFJSyxJQUFJLENBQUMsSUFBSSxFQUFFLElBQUkxQixNQUFNO1FBQzdCLEdBQUdhO1FBQ0gsSUFBSSxDQUFDaEUsSUFBSSxDQUFDeUUsR0FBRyxDQUFDbkUsSUFBSSxDQUFDLEdBQUcwQztZQUNsQjhCLGFBQWFKO1lBQ2JGLElBQUlPLEtBQUssQ0FBQyxJQUFJLEVBQUU7Z0JBQUM7bUJBQVMvQjthQUFLO1FBQ25DO0lBQ0o7SUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7S0FvQkMsR0FDRGdDLEdBQUdyRSxJQUFJLEVBQUU7UUFDTCxPQUFPLElBQUksQ0FBQ3NFLG9CQUFvQixHQUFHRCxFQUFFLENBQUNyRTtJQUMxQztJQUNBOzs7Ozs7Ozs7OztLQVdDLEdBQ0R1RSxHQUFHdkUsSUFBSSxFQUFFO1FBQ0wsT0FBTyxJQUFJLENBQUNzRSxvQkFBb0IsR0FBR0MsRUFBRSxDQUFDdkU7SUFDMUM7SUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7O0tBa0JDLEdBQ0RpRCxPQUFPakQsSUFBSSxFQUFFO1FBQ1QsT0FBTyxJQUFJLENBQUNzRSxvQkFBb0IsR0FBR3JCLE1BQU0sQ0FBQ2pEO0lBQzlDO0lBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7S0FnQkMsR0FDRHdFLEtBQUssR0FBR25DLElBQUksRUFBRTtRQUNWLElBQUksQ0FBQ0YsSUFBSSxDQUFDLGNBQWNFO1FBQ3hCLE9BQU8sSUFBSTtJQUNmO0lBQ0E7Ozs7S0FJQyxHQUNEb0MsTUFBTSxHQUFHcEMsSUFBSSxFQUFFO1FBQ1gsSUFBSSxDQUFDRixJQUFJLENBQUMsY0FBY0U7UUFDeEIsT0FBTyxJQUFJO0lBQ2Y7SUFDQTs7Ozs7O0tBTUMsR0FDRGxDLE9BQU9BLE1BQU0sRUFBRTRDLE9BQU8sQ0FBQyxDQUFDLEVBQUU7UUFDdEI1QyxPQUFPckIsR0FBRyxHQUFHLElBQUksQ0FBQ0EsR0FBRyxDQUFDMkIsSUFBSTtRQUMxQnNDLEtBQUsyQixRQUFRLEdBQUcsVUFBVTNCLEtBQUsyQixRQUFRO1FBQ3ZDLElBQUksQ0FBQzNGLE1BQU0sQ0FBQzRGLE9BQU8sQ0FBQ3hFLFFBQVE0QztJQUNoQztJQUNBOzs7Ozs7Ozs7Ozs7OztLQWNDLEdBQ0Q5QyxLQUFLSCxLQUFLLEVBQUU7UUFDUnZCLE1BQU0sZ0JBQWdCdUI7UUFDdEIsT0FBTyxJQUFJLENBQUNKLE9BQU8sQ0FBQ2tGLE1BQU0sQ0FBQyxJQUFJLENBQUNqRixFQUFFLEVBQUUsSUFBSWpCLElBQUltRyxNQUFNQyxPQUFPLENBQUNoRixTQUFTQSxRQUFRO1lBQUNBO1NBQU07SUFDdEY7SUFDQTs7Ozs7Ozs7Ozs7Ozs7S0FjQyxHQUNEaUYsTUFBTS9FLElBQUksRUFBRTtRQUNSekIsTUFBTSxpQkFBaUJ5QjtRQUN2QixPQUFPLElBQUksQ0FBQ04sT0FBTyxDQUFDc0YsR0FBRyxDQUFDLElBQUksQ0FBQ3JGLEVBQUUsRUFBRUs7SUFDckM7SUFDQTs7OztLQUlDLEdBQ0RpRixXQUFXO1FBQ1AsSUFBSSxDQUFDdkYsT0FBTyxDQUFDd0YsTUFBTSxDQUFDLElBQUksQ0FBQ3ZGLEVBQUU7SUFDL0I7SUFDQTs7Ozs7OztLQU9DLEdBQ0R3RixhQUFhO1FBQ1Q1RyxNQUFNO1FBQ04sSUFBSSxDQUFDYSxTQUFTLEdBQUc7UUFDakIsSUFBSSxDQUFDYSxJQUFJLENBQUMsSUFBSSxDQUFDTixFQUFFO1FBQ2pCLElBQUksSUFBSSxDQUFDWSxJQUFJLENBQUNDLFFBQVEsS0FBSyxHQUFHO1lBQzFCLElBQUksQ0FBQ0wsTUFBTSxDQUFDO2dCQUFFQyxNQUFNcEMsbUJBQW1CcUMsVUFBVSxDQUFDK0UsT0FBTztZQUFDO1FBQzlELE9BQ0s7WUFDRCxJQUFJLENBQUNqRixNQUFNLENBQUM7Z0JBQ1JDLE1BQU1wQyxtQkFBbUJxQyxVQUFVLENBQUMrRSxPQUFPO2dCQUMzQ2pHLE1BQU07b0JBQUVTLEtBQUssSUFBSSxDQUFDRCxFQUFFO29CQUFFRSxLQUFLLElBQUksQ0FBQ0EsR0FBRztnQkFBQztZQUN4QztRQUNKO0lBQ0o7SUFDQTs7Ozs7S0FLQyxHQUNEd0YsVUFBVWxGLE1BQU0sRUFBRTtRQUNkNUIsTUFBTSxpQkFBaUI0QjtRQUN2QixPQUFRQSxPQUFPQyxJQUFJO1lBQ2YsS0FBS3BDLG1CQUFtQnFDLFVBQVUsQ0FBQ0MsS0FBSztnQkFDcEMsSUFBSSxDQUFDZ0YsT0FBTyxDQUFDbkY7Z0JBQ2I7WUFDSixLQUFLbkMsbUJBQW1CcUMsVUFBVSxDQUFDa0YsWUFBWTtnQkFDM0MsSUFBSSxDQUFDRCxPQUFPLENBQUNuRjtnQkFDYjtZQUNKLEtBQUtuQyxtQkFBbUJxQyxVQUFVLENBQUNtRixHQUFHO2dCQUNsQyxJQUFJLENBQUNDLEtBQUssQ0FBQ3RGO2dCQUNYO1lBQ0osS0FBS25DLG1CQUFtQnFDLFVBQVUsQ0FBQ3FGLFVBQVU7Z0JBQ3pDLElBQUksQ0FBQ0QsS0FBSyxDQUFDdEY7Z0JBQ1g7WUFDSixLQUFLbkMsbUJBQW1CcUMsVUFBVSxDQUFDc0YsVUFBVTtnQkFDekMsSUFBSSxDQUFDQyxZQUFZO2dCQUNqQjtRQUNSO0lBQ0o7SUFDQTs7Ozs7S0FLQyxHQUNETixRQUFRbkYsTUFBTSxFQUFFO1FBQ1osTUFBTWtDLE9BQU9sQyxPQUFPaEIsSUFBSSxJQUFJLEVBQUU7UUFDOUJaLE1BQU0scUJBQXFCOEQ7UUFDM0IsSUFBSSxRQUFRbEMsT0FBT1IsRUFBRSxFQUFFO1lBQ25CcEIsTUFBTTtZQUNOOEQsS0FBS3FCLElBQUksQ0FBQyxJQUFJLENBQUNHLEdBQUcsQ0FBQzFELE9BQU9SLEVBQUU7UUFDaEM7UUFDQSxJQUFJLElBQUksQ0FBQ2tHLGFBQWEsSUFBSSxJQUFJLENBQUNBLGFBQWEsQ0FBQ25ELE1BQU0sRUFBRTtZQUNqRCxNQUFNb0QsWUFBWSxJQUFJLENBQUNELGFBQWEsQ0FBQ0UsS0FBSztZQUMxQyxLQUFLLE1BQU1DLFlBQVlGLFVBQVc7Z0JBQzlCRSxTQUFTNUIsS0FBSyxDQUFDLElBQUksRUFBRS9CO1lBQ3pCO1FBQ0o7UUFDQSxJQUFJLENBQUM0RCxRQUFRLENBQUM1RDtJQUNsQjtJQUNBOzs7OztLQUtDLEdBQ0R3QixJQUFJbEUsRUFBRSxFQUFFO1FBQ0osTUFBTXVHLE9BQU8sSUFBSTtRQUNqQixJQUFJQyxPQUFPO1FBQ1gsT0FBTztZQUNILDJCQUEyQjtZQUMzQixJQUFJQSxNQUNBO1lBQ0osTUFBTTlELE9BQU93QyxNQUFNdUIsU0FBUyxDQUFDTCxLQUFLLENBQUM3QixJQUFJLENBQUNtQztZQUN4QzlILE1BQU0sa0JBQWtCOEQ7WUFDeEI2RCxLQUFLL0YsTUFBTSxDQUFDO2dCQUNSUixJQUFJQTtnQkFDSlMsTUFBTXBDLG1CQUFtQnFDLFVBQVUsQ0FBQ21GLEdBQUc7Z0JBQ3ZDckcsTUFBTWtEO1lBQ1Y7WUFDQThELE9BQU87UUFDWDtJQUNKO0lBQ0E7Ozs7S0FJQyxHQUNEVixNQUFNdEYsTUFBTSxFQUFFO1FBQ1YsTUFBTTBELE1BQU0sSUFBSSxDQUFDeEUsSUFBSSxDQUFDaUgsR0FBRyxDQUFDbkcsT0FBT1IsRUFBRTtRQUNuQyxJQUFJLGNBQWMsT0FBT2tFLEtBQUs7WUFDMUJ0RixNQUFNLDBCQUEwQjRCLE9BQU9SLEVBQUUsRUFBRVEsT0FBT2hCLElBQUk7WUFDdEQwRSxJQUFJTyxLQUFLLENBQUMsSUFBSSxFQUFFakUsT0FBT2hCLElBQUk7WUFDM0IsSUFBSSxDQUFDRSxJQUFJLENBQUM0RSxNQUFNLENBQUM5RCxPQUFPUixFQUFFO1FBQzlCLE9BQ0s7WUFDRHBCLE1BQU0sY0FBYzRCLE9BQU9SLEVBQUU7UUFDakM7SUFDSjtJQUNBOzs7O0tBSUMsR0FDRGlHLGVBQWU7UUFDWHJILE1BQU07UUFDTixJQUFJLENBQUNnSSxRQUFRLENBQUM7SUFDbEI7SUFDQTs7OztLQUlDLEdBQ0RDLFNBQVNDLEdBQUcsRUFBRTtRQUNWLHdEQUF3RDtRQUN4RCwyREFBMkQ7UUFDM0QsK0ZBQStGO1FBQy9GLGtGQUFrRjtRQUNsRixJQUFJLENBQUNDLFlBQVksQ0FBQyxTQUFTRDtJQUMvQjtJQUNBOzs7Ozs7OztLQVFDLEdBQ0RGLFNBQVNJLE1BQU0sRUFBRUMsV0FBVyxFQUFFO1FBQzFCLElBQUksQ0FBQyxJQUFJLENBQUN4SCxTQUFTLEVBQ2YsT0FBTyxJQUFJO1FBQ2ZiLE1BQU0sOEJBQThCb0k7UUFDcEMsSUFBSSxDQUFDRCxZQUFZLENBQUMsaUJBQWlCQyxRQUFRQztRQUMzQyxJQUFJLElBQUksQ0FBQ25ILE1BQU0sQ0FBQ2tCLEtBQUssQ0FBQ0MsdUJBQXVCLElBQ3pDbkMsK0JBQStCOEQsR0FBRyxDQUFDb0UsU0FBUztZQUM1Q3BJLE1BQU0sbURBQW1ELElBQUksQ0FBQ29CLEVBQUU7WUFDaEUsSUFBSSxDQUFDRCxPQUFPLENBQUNtSCxjQUFjLENBQUM7Z0JBQ3hCakgsS0FBSyxJQUFJLENBQUNELEVBQUU7Z0JBQ1pFLEtBQUssSUFBSSxDQUFDQSxHQUFHO2dCQUNiQyxPQUFPO3VCQUFJLElBQUksQ0FBQ0EsS0FBSztpQkFBQztnQkFDdEJYLE1BQU0sSUFBSSxDQUFDQSxJQUFJO1lBQ25CO1FBQ0o7UUFDQSxJQUFJLENBQUMySCxRQUFRO1FBQ2IsSUFBSSxDQUFDL0gsTUFBTSxDQUFDZ0ksT0FBTyxDQUFDLElBQUk7UUFDeEIsSUFBSSxDQUFDM0gsU0FBUyxHQUFHO1FBQ2pCLElBQUksQ0FBQ3NILFlBQVksQ0FBQyxjQUFjQyxRQUFRQztRQUN4QztJQUNKO0lBQ0E7Ozs7S0FJQyxHQUNERSxXQUFXO1FBQ1AsSUFBSSxDQUFDN0IsUUFBUTtRQUNiLElBQUksQ0FBQ25HLEdBQUcsQ0FBQ2lJLE9BQU8sQ0FBQyxJQUFJO1FBQ3JCLElBQUksQ0FBQzlHLElBQUksR0FBR3RCO0lBQ2hCO0lBQ0E7Ozs7OztLQU1DLEdBQ0RxSSxPQUFPUCxHQUFHLEVBQUU7UUFDUixJQUFJLENBQUN0RyxNQUFNLENBQUM7WUFBRUMsTUFBTXBDLG1CQUFtQnFDLFVBQVUsQ0FBQzRHLGFBQWE7WUFBRTlILE1BQU1zSDtRQUFJO0lBQy9FO0lBQ0E7Ozs7Ozs7Ozs7Ozs7O0tBY0MsR0FDRFMsV0FBV0MsUUFBUSxLQUFLLEVBQUU7UUFDdEIsSUFBSSxDQUFDLElBQUksQ0FBQy9ILFNBQVMsRUFDZixPQUFPLElBQUk7UUFDZixJQUFJK0gsT0FBTztZQUNQLElBQUksQ0FBQ3BJLE1BQU0sQ0FBQ3FJLFdBQVc7UUFDM0IsT0FDSztZQUNELElBQUksQ0FBQ2pILE1BQU0sQ0FBQztnQkFBRUMsTUFBTXBDLG1CQUFtQnFDLFVBQVUsQ0FBQ3NGLFVBQVU7WUFBQztZQUM3RCxJQUFJLENBQUNZLFFBQVEsQ0FBQztRQUNsQjtRQUNBLE9BQU8sSUFBSTtJQUNmO0lBQ0E7Ozs7Ozs7Ozs7S0FVQyxHQUNEN0IsU0FBU0EsUUFBUSxFQUFFO1FBQ2YsSUFBSSxDQUFDbEYsS0FBSyxDQUFDa0YsUUFBUSxHQUFHQTtRQUN0QixPQUFPLElBQUk7SUFDZjtJQUNBOzs7Ozs7Ozs7OztLQVdDLEdBQ0QsSUFBSTJDLFdBQVc7UUFDWCxJQUFJLENBQUM3SCxLQUFLLENBQUM2SCxRQUFRLEdBQUc7UUFDdEIsT0FBTyxJQUFJO0lBQ2Y7SUFDQTs7Ozs7Ozs7Ozs7S0FXQyxHQUNELElBQUlyRSxZQUFZO1FBQ1osT0FBTyxJQUFJLENBQUNzQixvQkFBb0I7SUFDcEM7SUFDQTs7Ozs7Ozs7OztLQVVDLEdBQ0QsSUFBSWdELFFBQVE7UUFDUixPQUFPLElBQUksQ0FBQ2hELG9CQUFvQixHQUFHZ0QsS0FBSztJQUM1QztJQUNBOzs7Ozs7Ozs7Ozs7OztLQWNDLEdBQ0RqRSxRQUFRQSxPQUFPLEVBQUU7UUFDYixJQUFJLENBQUM3RCxLQUFLLENBQUM2RCxPQUFPLEdBQUdBO1FBQ3JCLE9BQU8sSUFBSTtJQUNmO0lBQ0E7Ozs7O0tBS0MsR0FDRDRDLFNBQVNzQixLQUFLLEVBQUU7UUFDWmhKLE1BQU0sMkJBQTJCZ0o7UUFDakMsSUFBSSxDQUFDQyxHQUFHLENBQUNELE9BQU8sQ0FBQ2Q7WUFDYmdCLFFBQVFDLFFBQVEsQ0FBQztnQkFDYixJQUFJakIsS0FBSztvQkFDTCxPQUFPLElBQUksQ0FBQ0QsUUFBUSxDQUFDQztnQkFDekI7Z0JBQ0EsSUFBSSxJQUFJLENBQUNySCxTQUFTLEVBQUU7b0JBQ2hCLEtBQUssQ0FBQ3VJLFlBQVl2RCxLQUFLLENBQUMsSUFBSSxFQUFFbUQ7Z0JBQ2xDLE9BQ0s7b0JBQ0RoSixNQUFNO2dCQUNWO1lBQ0o7UUFDSjtJQUNKO0lBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7S0FzQkMsR0FDRHFKLElBQUlDLEVBQUUsRUFBRTtRQUNKLElBQUksQ0FBQ3RJLEdBQUcsQ0FBQ21FLElBQUksQ0FBQ21FO1FBQ2QsT0FBTyxJQUFJO0lBQ2Y7SUFDQTs7Ozs7O0tBTUMsR0FDREwsSUFBSUQsS0FBSyxFQUFFTSxFQUFFLEVBQUU7UUFDWCxJQUFJLENBQUMsSUFBSSxDQUFDdEksR0FBRyxDQUFDbUQsTUFBTSxFQUNoQixPQUFPbUY7UUFDWCxNQUFNdEksTUFBTSxJQUFJLENBQUNBLEdBQUcsQ0FBQ3dHLEtBQUssQ0FBQztRQUMzQixTQUFTeUIsSUFBSU0sQ0FBQztZQUNWdkksR0FBRyxDQUFDdUksRUFBRSxDQUFDUCxPQUFPLENBQUNkO2dCQUNYLDRCQUE0QjtnQkFDNUIsSUFBSUEsS0FDQSxPQUFPb0IsR0FBR3BCO2dCQUNkLHlDQUF5QztnQkFDekMsSUFBSSxDQUFDbEgsR0FBRyxDQUFDdUksSUFBSSxFQUFFLEVBQ1gsT0FBT0Q7Z0JBQ1gsZ0JBQWdCO2dCQUNoQkwsSUFBSU0sSUFBSTtZQUNaO1FBQ0o7UUFDQU4sSUFBSTtJQUNSO0lBQ0E7O0tBRUMsR0FDRCxJQUFJTyxlQUFlO1FBQ2YsT0FBTyxDQUFDLElBQUksQ0FBQzNJLFNBQVM7SUFDMUI7SUFDQTs7S0FFQyxHQUNELElBQUlpQyxVQUFVO1FBQ1YsT0FBTyxJQUFJLENBQUN0QyxNQUFNLENBQUNzQyxPQUFPO0lBQzlCO0lBQ0E7Ozs7Ozs7Ozs7O0tBV0MsR0FDRCxJQUFJZCxPQUFPO1FBQ1AsT0FBTyxJQUFJLENBQUN4QixNQUFNLENBQUN3QixJQUFJO0lBQzNCO0lBQ0E7Ozs7Ozs7Ozs7O0tBV0MsR0FDRCxJQUFJVCxRQUFRO1FBQ1IsT0FBTyxJQUFJLENBQUNKLE9BQU8sQ0FBQ3NJLFdBQVcsQ0FBQyxJQUFJLENBQUNySSxFQUFFLEtBQUssSUFBSWpCO0lBQ3BEO0lBQ0E7Ozs7Ozs7Ozs7OztLQVlDLEdBQ0R1SixNQUFNakMsUUFBUSxFQUFFO1FBQ1osSUFBSSxDQUFDSCxhQUFhLEdBQUcsSUFBSSxDQUFDQSxhQUFhLElBQUksRUFBRTtRQUM3QyxJQUFJLENBQUNBLGFBQWEsQ0FBQ25DLElBQUksQ0FBQ3NDO1FBQ3hCLE9BQU8sSUFBSTtJQUNmO0lBQ0E7Ozs7O0tBS0MsR0FDRGtDLFdBQVdsQyxRQUFRLEVBQUU7UUFDakIsSUFBSSxDQUFDSCxhQUFhLEdBQUcsSUFBSSxDQUFDQSxhQUFhLElBQUksRUFBRTtRQUM3QyxJQUFJLENBQUNBLGFBQWEsQ0FBQ3NDLE9BQU8sQ0FBQ25DO1FBQzNCLE9BQU8sSUFBSTtJQUNmO0lBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7S0FtQkMsR0FDRG9DLE9BQU9wQyxRQUFRLEVBQUU7UUFDYixJQUFJLENBQUMsSUFBSSxDQUFDSCxhQUFhLEVBQUU7WUFDckIsT0FBTyxJQUFJO1FBQ2Y7UUFDQSxJQUFJRyxVQUFVO1lBQ1YsTUFBTUYsWUFBWSxJQUFJLENBQUNELGFBQWE7WUFDcEMsSUFBSyxJQUFJaUMsSUFBSSxHQUFHQSxJQUFJaEMsVUFBVXBELE1BQU0sRUFBRW9GLElBQUs7Z0JBQ3ZDLElBQUk5QixhQUFhRixTQUFTLENBQUNnQyxFQUFFLEVBQUU7b0JBQzNCaEMsVUFBVXVDLE1BQU0sQ0FBQ1AsR0FBRztvQkFDcEIsT0FBTyxJQUFJO2dCQUNmO1lBQ0o7UUFDSixPQUNLO1lBQ0QsSUFBSSxDQUFDakMsYUFBYSxHQUFHLEVBQUU7UUFDM0I7UUFDQSxPQUFPLElBQUk7SUFDZjtJQUNBOzs7S0FHQyxHQUNEeUMsZUFBZTtRQUNYLE9BQU8sSUFBSSxDQUFDekMsYUFBYSxJQUFJLEVBQUU7SUFDbkM7SUFDQTs7Ozs7Ozs7Ozs7Ozs7S0FjQyxHQUNEMEMsY0FBY3ZDLFFBQVEsRUFBRTtRQUNwQixJQUFJLENBQUN3QyxxQkFBcUIsR0FBRyxJQUFJLENBQUNBLHFCQUFxQixJQUFJLEVBQUU7UUFDN0QsSUFBSSxDQUFDQSxxQkFBcUIsQ0FBQzlFLElBQUksQ0FBQ3NDO1FBQ2hDLE9BQU8sSUFBSTtJQUNmO0lBQ0E7Ozs7Ozs7Ozs7OztLQVlDLEdBQ0R5QyxtQkFBbUJ6QyxRQUFRLEVBQUU7UUFDekIsSUFBSSxDQUFDd0MscUJBQXFCLEdBQUcsSUFBSSxDQUFDQSxxQkFBcUIsSUFBSSxFQUFFO1FBQzdELElBQUksQ0FBQ0EscUJBQXFCLENBQUNMLE9BQU8sQ0FBQ25DO1FBQ25DLE9BQU8sSUFBSTtJQUNmO0lBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7S0FtQkMsR0FDRDBDLGVBQWUxQyxRQUFRLEVBQUU7UUFDckIsSUFBSSxDQUFDLElBQUksQ0FBQ3dDLHFCQUFxQixFQUFFO1lBQzdCLE9BQU8sSUFBSTtRQUNmO1FBQ0EsSUFBSXhDLFVBQVU7WUFDVixNQUFNRixZQUFZLElBQUksQ0FBQzBDLHFCQUFxQjtZQUM1QyxJQUFLLElBQUlWLElBQUksR0FBR0EsSUFBSWhDLFVBQVVwRCxNQUFNLEVBQUVvRixJQUFLO2dCQUN2QyxJQUFJOUIsYUFBYUYsU0FBUyxDQUFDZ0MsRUFBRSxFQUFFO29CQUMzQmhDLFVBQVV1QyxNQUFNLENBQUNQLEdBQUc7b0JBQ3BCLE9BQU8sSUFBSTtnQkFDZjtZQUNKO1FBQ0osT0FDSztZQUNELElBQUksQ0FBQ1UscUJBQXFCLEdBQUcsRUFBRTtRQUNuQztRQUNBLE9BQU8sSUFBSTtJQUNmO0lBQ0E7OztLQUdDLEdBQ0RHLHVCQUF1QjtRQUNuQixPQUFPLElBQUksQ0FBQ0gscUJBQXFCLElBQUksRUFBRTtJQUMzQztJQUNBOzs7Ozs7S0FNQyxHQUNEdEYsd0JBQXdCL0MsTUFBTSxFQUFFO1FBQzVCLElBQUksSUFBSSxDQUFDcUkscUJBQXFCLElBQUksSUFBSSxDQUFDQSxxQkFBcUIsQ0FBQzlGLE1BQU0sRUFBRTtZQUNqRSxNQUFNb0QsWUFBWSxJQUFJLENBQUMwQyxxQkFBcUIsQ0FBQ3pDLEtBQUs7WUFDbEQsS0FBSyxNQUFNQyxZQUFZRixVQUFXO2dCQUM5QkUsU0FBUzVCLEtBQUssQ0FBQyxJQUFJLEVBQUVqRSxPQUFPaEIsSUFBSTtZQUNwQztRQUNKO0lBQ0o7SUFDQW1GLHVCQUF1QjtRQUNuQixNQUFNOUUsUUFBUTdCLE9BQU9tRixNQUFNLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQ3RELEtBQUs7UUFDMUMsSUFBSSxDQUFDQSxLQUFLLEdBQUcsQ0FBQztRQUNkLE9BQU8sSUFBSW5CLHFCQUFxQnVLLGlCQUFpQixDQUFDLElBQUksQ0FBQ2xKLE9BQU8sRUFBRSxJQUFJaEIsT0FBTyxJQUFJQSxJQUFJO1lBQUMsSUFBSSxDQUFDaUIsRUFBRTtTQUFDLEdBQUdIO0lBQ25HO0FBQ0o7QUFDQTNCLGNBQWMsR0FBR0UiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9leGFtcm9zaC8uL25vZGVfbW9kdWxlcy9zb2NrZXQuaW8vZGlzdC9zb2NrZXQuanM/YWU0NyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuU29ja2V0ID0gdm9pZCAwO1xuY29uc3Qgc29ja2V0X2lvX3BhcnNlcl8xID0gcmVxdWlyZShcInNvY2tldC5pby1wYXJzZXJcIik7XG5jb25zdCBkZWJ1Z18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJkZWJ1Z1wiKSk7XG5jb25zdCB0eXBlZF9ldmVudHNfMSA9IHJlcXVpcmUoXCIuL3R5cGVkLWV2ZW50c1wiKTtcbmNvbnN0IGJhc2U2NGlkXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImJhc2U2NGlkXCIpKTtcbmNvbnN0IGJyb2FkY2FzdF9vcGVyYXRvcl8xID0gcmVxdWlyZShcIi4vYnJvYWRjYXN0LW9wZXJhdG9yXCIpO1xuY29uc3Qgc29ja2V0X3R5cGVzXzEgPSByZXF1aXJlKFwiLi9zb2NrZXQtdHlwZXNcIik7XG5jb25zdCBkZWJ1ZyA9ICgwLCBkZWJ1Z18xLmRlZmF1bHQpKFwic29ja2V0LmlvOnNvY2tldFwiKTtcbmNvbnN0IFJFQ09WRVJBQkxFX0RJU0NPTk5FQ1RfUkVBU09OUyA9IG5ldyBTZXQoW1xuICAgIFwidHJhbnNwb3J0IGVycm9yXCIsXG4gICAgXCJ0cmFuc3BvcnQgY2xvc2VcIixcbiAgICBcImZvcmNlZCBjbG9zZVwiLFxuICAgIFwicGluZyB0aW1lb3V0XCIsXG4gICAgXCJzZXJ2ZXIgc2h1dHRpbmcgZG93blwiLFxuICAgIFwiZm9yY2VkIHNlcnZlciBjbG9zZVwiLFxuXSk7XG5mdW5jdGlvbiBub29wKCkgeyB9XG4vKipcbiAqIFRoaXMgaXMgdGhlIG1haW4gb2JqZWN0IGZvciBpbnRlcmFjdGluZyB3aXRoIGEgY2xpZW50LlxuICpcbiAqIEEgU29ja2V0IGJlbG9uZ3MgdG8gYSBnaXZlbiB7QGxpbmsgTmFtZXNwYWNlfSBhbmQgdXNlcyBhbiB1bmRlcmx5aW5nIHtAbGluayBDbGllbnR9IHRvIGNvbW11bmljYXRlLlxuICpcbiAqIFdpdGhpbiBlYWNoIHtAbGluayBOYW1lc3BhY2V9LCB5b3UgY2FuIGFsc28gZGVmaW5lIGFyYml0cmFyeSBjaGFubmVscyAoY2FsbGVkIFwicm9vbXNcIikgdGhhdCB0aGUge0BsaW5rIFNvY2tldH0gY2FuXG4gKiBqb2luIGFuZCBsZWF2ZS4gVGhhdCBwcm92aWRlcyBhIGNvbnZlbmllbnQgd2F5IHRvIGJyb2FkY2FzdCB0byBhIGdyb3VwIG9mIHNvY2tldCBpbnN0YW5jZXMuXG4gKlxuICogQGV4YW1wbGVcbiAqIGlvLm9uKFwiY29ubmVjdGlvblwiLCAoc29ja2V0KSA9PiB7XG4gKiAgIGNvbnNvbGUubG9nKGBzb2NrZXQgJHtzb2NrZXQuaWR9IGNvbm5lY3RlZGApO1xuICpcbiAqICAgLy8gc2VuZCBhbiBldmVudCB0byB0aGUgY2xpZW50XG4gKiAgIHNvY2tldC5lbWl0KFwiZm9vXCIsIFwiYmFyXCIpO1xuICpcbiAqICAgc29ja2V0Lm9uKFwiZm9vYmFyXCIsICgpID0+IHtcbiAqICAgICAvLyBhbiBldmVudCB3YXMgcmVjZWl2ZWQgZnJvbSB0aGUgY2xpZW50XG4gKiAgIH0pO1xuICpcbiAqICAgLy8gam9pbiB0aGUgcm9vbSBuYW1lZCBcInJvb20xXCJcbiAqICAgc29ja2V0LmpvaW4oXCJyb29tMVwiKTtcbiAqXG4gKiAgIC8vIGJyb2FkY2FzdCB0byBldmVyeW9uZSBpbiB0aGUgcm9vbSBuYW1lZCBcInJvb20xXCJcbiAqICAgaW8udG8oXCJyb29tMVwiKS5lbWl0KFwiaGVsbG9cIik7XG4gKlxuICogICAvLyB1cG9uIGRpc2Nvbm5lY3Rpb25cbiAqICAgc29ja2V0Lm9uKFwiZGlzY29ubmVjdFwiLCAocmVhc29uKSA9PiB7XG4gKiAgICAgY29uc29sZS5sb2coYHNvY2tldCAke3NvY2tldC5pZH0gZGlzY29ubmVjdGVkIGR1ZSB0byAke3JlYXNvbn1gKTtcbiAqICAgfSk7XG4gKiB9KTtcbiAqL1xuY2xhc3MgU29ja2V0IGV4dGVuZHMgdHlwZWRfZXZlbnRzXzEuU3RyaWN0RXZlbnRFbWl0dGVyIHtcbiAgICAvKipcbiAgICAgKiBJbnRlcmZhY2UgdG8gYSBgQ2xpZW50YCBmb3IgYSBnaXZlbiBgTmFtZXNwYWNlYC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7TmFtZXNwYWNlfSBuc3BcbiAgICAgKiBAcGFyYW0ge0NsaWVudH0gY2xpZW50XG4gICAgICogQHBhcmFtIHtPYmplY3R9IGF1dGhcbiAgICAgKiBAcGFja2FnZVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKG5zcCwgY2xpZW50LCBhdXRoLCBwcmV2aW91c1Nlc3Npb24pIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5uc3AgPSBuc3A7XG4gICAgICAgIHRoaXMuY2xpZW50ID0gY2xpZW50O1xuICAgICAgICAvKipcbiAgICAgICAgICogV2hldGhlciB0aGUgY29ubmVjdGlvbiBzdGF0ZSB3YXMgcmVjb3ZlcmVkIGFmdGVyIGEgdGVtcG9yYXJ5IGRpc2Nvbm5lY3Rpb24uIEluIHRoYXQgY2FzZSwgYW55IG1pc3NlZCBwYWNrZXRzIHdpbGxcbiAgICAgICAgICogYmUgdHJhbnNtaXR0ZWQgdG8gdGhlIGNsaWVudCwgdGhlIGRhdGEgYXR0cmlidXRlIGFuZCB0aGUgcm9vbXMgd2lsbCBiZSByZXN0b3JlZC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucmVjb3ZlcmVkID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBZGRpdGlvbmFsIGluZm9ybWF0aW9uIHRoYXQgY2FuIGJlIGF0dGFjaGVkIHRvIHRoZSBTb2NrZXQgaW5zdGFuY2UgYW5kIHdoaWNoIHdpbGwgYmUgdXNlZCBpbiB0aGVcbiAgICAgICAgICoge0BsaW5rIFNlcnZlci5mZXRjaFNvY2tldHMoKX0gbWV0aG9kLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5kYXRhID0ge307XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGV0aGVyIHRoZSBzb2NrZXQgaXMgY3VycmVudGx5IGNvbm5lY3RlZCBvciBub3QuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqIGlvLnVzZSgoc29ja2V0LCBuZXh0KSA9PiB7XG4gICAgICAgICAqICAgY29uc29sZS5sb2coc29ja2V0LmNvbm5lY3RlZCk7IC8vIGZhbHNlXG4gICAgICAgICAqICAgbmV4dCgpO1xuICAgICAgICAgKiB9KTtcbiAgICAgICAgICpcbiAgICAgICAgICogaW8ub24oXCJjb25uZWN0aW9uXCIsIChzb2NrZXQpID0+IHtcbiAgICAgICAgICogICBjb25zb2xlLmxvZyhzb2NrZXQuY29ubmVjdGVkKTsgLy8gdHJ1ZVxuICAgICAgICAgKiB9KTtcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY29ubmVjdGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuYWNrcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5mbnMgPSBbXTtcbiAgICAgICAgdGhpcy5mbGFncyA9IHt9O1xuICAgICAgICB0aGlzLnNlcnZlciA9IG5zcC5zZXJ2ZXI7XG4gICAgICAgIHRoaXMuYWRhcHRlciA9IHRoaXMubnNwLmFkYXB0ZXI7XG4gICAgICAgIGlmIChwcmV2aW91c1Nlc3Npb24pIHtcbiAgICAgICAgICAgIHRoaXMuaWQgPSBwcmV2aW91c1Nlc3Npb24uc2lkO1xuICAgICAgICAgICAgdGhpcy5waWQgPSBwcmV2aW91c1Nlc3Npb24ucGlkO1xuICAgICAgICAgICAgcHJldmlvdXNTZXNzaW9uLnJvb21zLmZvckVhY2goKHJvb20pID0+IHRoaXMuam9pbihyb29tKSk7XG4gICAgICAgICAgICB0aGlzLmRhdGEgPSBwcmV2aW91c1Nlc3Npb24uZGF0YTtcbiAgICAgICAgICAgIHByZXZpb3VzU2Vzc2lvbi5taXNzZWRQYWNrZXRzLmZvckVhY2goKHBhY2tldCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMucGFja2V0KHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogc29ja2V0X2lvX3BhcnNlcl8xLlBhY2tldFR5cGUuRVZFTlQsXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IHBhY2tldCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5yZWNvdmVyZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKGNsaWVudC5jb25uLnByb3RvY29sID09PSAzKSB7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgICAgIHRoaXMuaWQgPSBuc3AubmFtZSAhPT0gXCIvXCIgPyBuc3AubmFtZSArIFwiI1wiICsgY2xpZW50LmlkIDogY2xpZW50LmlkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pZCA9IGJhc2U2NGlkXzEuZGVmYXVsdC5nZW5lcmF0ZUlkKCk7IC8vIGRvbid0IHJldXNlIHRoZSBFbmdpbmUuSU8gaWQgYmVjYXVzZSBpdCdzIHNlbnNpdGl2ZSBpbmZvcm1hdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuc2VydmVyLl9vcHRzLmNvbm5lY3Rpb25TdGF0ZVJlY292ZXJ5KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5waWQgPSBiYXNlNjRpZF8xLmRlZmF1bHQuZ2VuZXJhdGVJZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuaGFuZHNoYWtlID0gdGhpcy5idWlsZEhhbmRzaGFrZShhdXRoKTtcbiAgICAgICAgLy8gcHJldmVudHMgY3Jhc2ggd2hlbiB0aGUgc29ja2V0IHJlY2VpdmVzIGFuIFwiZXJyb3JcIiBldmVudCB3aXRob3V0IGxpc3RlbmVyXG4gICAgICAgIHRoaXMub24oXCJlcnJvclwiLCBub29wKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQnVpbGRzIHRoZSBgaGFuZHNoYWtlYCBCQyBvYmplY3RcbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgYnVpbGRIYW5kc2hha2UoYXV0aCkge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBoZWFkZXJzOiAoKF9hID0gdGhpcy5yZXF1ZXN0KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaGVhZGVycykgfHwge30sXG4gICAgICAgICAgICB0aW1lOiBuZXcgRGF0ZSgpICsgXCJcIixcbiAgICAgICAgICAgIGFkZHJlc3M6IHRoaXMuY29ubi5yZW1vdGVBZGRyZXNzLFxuICAgICAgICAgICAgeGRvbWFpbjogISEoKF9iID0gdGhpcy5yZXF1ZXN0KSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuaGVhZGVycy5vcmlnaW4pLFxuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgc2VjdXJlOiAhdGhpcy5yZXF1ZXN0IHx8ICEhdGhpcy5yZXF1ZXN0LmNvbm5lY3Rpb24uZW5jcnlwdGVkLFxuICAgICAgICAgICAgaXNzdWVkOiArbmV3IERhdGUoKSxcbiAgICAgICAgICAgIHVybDogKF9jID0gdGhpcy5yZXF1ZXN0KSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MudXJsLFxuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgcXVlcnk6ICgoX2QgPSB0aGlzLnJlcXVlc3QpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5fcXVlcnkpIHx8IHt9LFxuICAgICAgICAgICAgYXV0aCxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRW1pdHMgdG8gdGhpcyBjbGllbnQuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGlvLm9uKFwiY29ubmVjdGlvblwiLCAoc29ja2V0KSA9PiB7XG4gICAgICogICBzb2NrZXQuZW1pdChcImhlbGxvXCIsIFwid29ybGRcIik7XG4gICAgICpcbiAgICAgKiAgIC8vIGFsbCBzZXJpYWxpemFibGUgZGF0YXN0cnVjdHVyZXMgYXJlIHN1cHBvcnRlZCAobm8gbmVlZCB0byBjYWxsIEpTT04uc3RyaW5naWZ5KVxuICAgICAqICAgc29ja2V0LmVtaXQoXCJoZWxsb1wiLCAxLCBcIjJcIiwgeyAzOiBbXCI0XCJdLCA1OiBCdWZmZXIuZnJvbShbNl0pIH0pO1xuICAgICAqXG4gICAgICogICAvLyB3aXRoIGFuIGFja25vd2xlZGdlbWVudCBmcm9tIHRoZSBjbGllbnRcbiAgICAgKiAgIHNvY2tldC5lbWl0KFwiaGVsbG9cIiwgXCJ3b3JsZFwiLCAodmFsKSA9PiB7XG4gICAgICogICAgIC8vIC4uLlxuICAgICAqICAgfSk7XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBAcmV0dXJuIEFsd2F5cyByZXR1cm5zIGB0cnVlYC5cbiAgICAgKi9cbiAgICBlbWl0KGV2LCAuLi5hcmdzKSB7XG4gICAgICAgIGlmIChzb2NrZXRfdHlwZXNfMS5SRVNFUlZFRF9FVkVOVFMuaGFzKGV2KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBcIiR7U3RyaW5nKGV2KX1cIiBpcyBhIHJlc2VydmVkIGV2ZW50IG5hbWVgKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkYXRhID0gW2V2LCAuLi5hcmdzXTtcbiAgICAgICAgY29uc3QgcGFja2V0ID0ge1xuICAgICAgICAgICAgdHlwZTogc29ja2V0X2lvX3BhcnNlcl8xLlBhY2tldFR5cGUuRVZFTlQsXG4gICAgICAgICAgICBkYXRhOiBkYXRhLFxuICAgICAgICB9O1xuICAgICAgICAvLyBhY2Nlc3MgbGFzdCBhcmd1bWVudCB0byBzZWUgaWYgaXQncyBhbiBBQ0sgY2FsbGJhY2tcbiAgICAgICAgaWYgKHR5cGVvZiBkYXRhW2RhdGEubGVuZ3RoIC0gMV0gPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgY29uc3QgaWQgPSB0aGlzLm5zcC5faWRzKys7XG4gICAgICAgICAgICBkZWJ1ZyhcImVtaXR0aW5nIHBhY2tldCB3aXRoIGFjayBpZCAlZFwiLCBpZCk7XG4gICAgICAgICAgICB0aGlzLnJlZ2lzdGVyQWNrQ2FsbGJhY2soaWQsIGRhdGEucG9wKCkpO1xuICAgICAgICAgICAgcGFja2V0LmlkID0gaWQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZmxhZ3MgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLmZsYWdzKTtcbiAgICAgICAgdGhpcy5mbGFncyA9IHt9O1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIGlmICh0aGlzLm5zcC5zZXJ2ZXIub3B0cy5jb25uZWN0aW9uU3RhdGVSZWNvdmVyeSkge1xuICAgICAgICAgICAgLy8gdGhpcyBlbnN1cmVzIHRoZSBwYWNrZXQgaXMgc3RvcmVkIGFuZCBjYW4gYmUgdHJhbnNtaXR0ZWQgdXBvbiByZWNvbm5lY3Rpb25cbiAgICAgICAgICAgIHRoaXMuYWRhcHRlci5icm9hZGNhc3QocGFja2V0LCB7XG4gICAgICAgICAgICAgICAgcm9vbXM6IG5ldyBTZXQoW3RoaXMuaWRdKSxcbiAgICAgICAgICAgICAgICBleGNlcHQ6IG5ldyBTZXQoKSxcbiAgICAgICAgICAgICAgICBmbGFncyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5ub3RpZnlPdXRnb2luZ0xpc3RlbmVycyhwYWNrZXQpO1xuICAgICAgICAgICAgdGhpcy5wYWNrZXQocGFja2V0LCBmbGFncyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVtaXRzIGFuIGV2ZW50IGFuZCB3YWl0cyBmb3IgYW4gYWNrbm93bGVkZ2VtZW50XG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGlvLm9uKFwiY29ubmVjdGlvblwiLCBhc3luYyAoc29ja2V0KSA9PiB7XG4gICAgICogICAvLyB3aXRob3V0IHRpbWVvdXRcbiAgICAgKiAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgc29ja2V0LmVtaXRXaXRoQWNrKFwiaGVsbG9cIiwgXCJ3b3JsZFwiKTtcbiAgICAgKlxuICAgICAqICAgLy8gd2l0aCBhIHNwZWNpZmljIHRpbWVvdXRcbiAgICAgKiAgIHRyeSB7XG4gICAgICogICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgc29ja2V0LnRpbWVvdXQoMTAwMCkuZW1pdFdpdGhBY2soXCJoZWxsb1wiLCBcIndvcmxkXCIpO1xuICAgICAqICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICogICAgIC8vIHRoZSBjbGllbnQgZGlkIG5vdCBhY2tub3dsZWRnZSB0aGUgZXZlbnQgaW4gdGhlIGdpdmVuIGRlbGF5XG4gICAgICogICB9XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBAcmV0dXJuIGEgUHJvbWlzZSB0aGF0IHdpbGwgYmUgZnVsZmlsbGVkIHdoZW4gdGhlIGNsaWVudCBhY2tub3dsZWRnZXMgdGhlIGV2ZW50XG4gICAgICovXG4gICAgZW1pdFdpdGhBY2soZXYsIC4uLmFyZ3MpIHtcbiAgICAgICAgLy8gdGhlIHRpbWVvdXQgZmxhZyBpcyBvcHRpb25hbFxuICAgICAgICBjb25zdCB3aXRoRXJyID0gdGhpcy5mbGFncy50aW1lb3V0ICE9PSB1bmRlZmluZWQ7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBhcmdzLnB1c2goKGFyZzEsIGFyZzIpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAod2l0aEVycikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXJnMSA/IHJlamVjdChhcmcxKSA6IHJlc29sdmUoYXJnMik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZShhcmcxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuZW1pdChldiwgLi4uYXJncyk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHJlZ2lzdGVyQWNrQ2FsbGJhY2soaWQsIGFjaykge1xuICAgICAgICBjb25zdCB0aW1lb3V0ID0gdGhpcy5mbGFncy50aW1lb3V0O1xuICAgICAgICBpZiAodGltZW91dCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLmFja3Muc2V0KGlkLCBhY2spO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICBkZWJ1ZyhcImV2ZW50IHdpdGggYWNrIGlkICVkIGhhcyB0aW1lZCBvdXQgYWZ0ZXIgJWQgbXNcIiwgaWQsIHRpbWVvdXQpO1xuICAgICAgICAgICAgdGhpcy5hY2tzLmRlbGV0ZShpZCk7XG4gICAgICAgICAgICBhY2suY2FsbCh0aGlzLCBuZXcgRXJyb3IoXCJvcGVyYXRpb24gaGFzIHRpbWVkIG91dFwiKSk7XG4gICAgICAgIH0sIHRpbWVvdXQpO1xuICAgICAgICB0aGlzLmFja3Muc2V0KGlkLCAoLi4uYXJncykgPT4ge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyKTtcbiAgICAgICAgICAgIGFjay5hcHBseSh0aGlzLCBbbnVsbCwgLi4uYXJnc10pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGFyZ2V0cyBhIHJvb20gd2hlbiBicm9hZGNhc3RpbmcuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGlvLm9uKFwiY29ubmVjdGlvblwiLCAoc29ja2V0KSA9PiB7XG4gICAgICogICAvLyB0aGUg4oCcZm9v4oCdIGV2ZW50IHdpbGwgYmUgYnJvYWRjYXN0IHRvIGFsbCBjb25uZWN0ZWQgY2xpZW50cyBpbiB0aGUg4oCccm9vbS0xMDHigJ0gcm9vbSwgZXhjZXB0IHRoaXMgc29ja2V0XG4gICAgICogICBzb2NrZXQudG8oXCJyb29tLTEwMVwiKS5lbWl0KFwiZm9vXCIsIFwiYmFyXCIpO1xuICAgICAqXG4gICAgICogICAvLyB0aGUgY29kZSBhYm92ZSBpcyBlcXVpdmFsZW50IHRvOlxuICAgICAqICAgaW8udG8oXCJyb29tLTEwMVwiKS5leGNlcHQoc29ja2V0LmlkKS5lbWl0KFwiZm9vXCIsIFwiYmFyXCIpO1xuICAgICAqXG4gICAgICogICAvLyB3aXRoIGFuIGFycmF5IG9mIHJvb21zIChhIGNsaWVudCB3aWxsIGJlIG5vdGlmaWVkIGF0IG1vc3Qgb25jZSlcbiAgICAgKiAgIHNvY2tldC50byhbXCJyb29tLTEwMVwiLCBcInJvb20tMTAyXCJdKS5lbWl0KFwiZm9vXCIsIFwiYmFyXCIpO1xuICAgICAqXG4gICAgICogICAvLyB3aXRoIG11bHRpcGxlIGNoYWluZWQgY2FsbHNcbiAgICAgKiAgIHNvY2tldC50byhcInJvb20tMTAxXCIpLnRvKFwicm9vbS0xMDJcIikuZW1pdChcImZvb1wiLCBcImJhclwiKTtcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIEBwYXJhbSByb29tIC0gYSByb29tLCBvciBhbiBhcnJheSBvZiByb29tc1xuICAgICAqIEByZXR1cm4gYSBuZXcge0BsaW5rIEJyb2FkY2FzdE9wZXJhdG9yfSBpbnN0YW5jZSBmb3IgY2hhaW5pbmdcbiAgICAgKi9cbiAgICB0byhyb29tKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5ld0Jyb2FkY2FzdE9wZXJhdG9yKCkudG8ocm9vbSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRhcmdldHMgYSByb29tIHdoZW4gYnJvYWRjYXN0aW5nLiBTaW1pbGFyIHRvIGB0bygpYCwgYnV0IG1pZ2h0IGZlZWwgY2xlYXJlciBpbiBzb21lIGNhc2VzOlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBpby5vbihcImNvbm5lY3Rpb25cIiwgKHNvY2tldCkgPT4ge1xuICAgICAqICAgLy8gZGlzY29ubmVjdCBhbGwgY2xpZW50cyBpbiB0aGUgXCJyb29tLTEwMVwiIHJvb20sIGV4Y2VwdCB0aGlzIHNvY2tldFxuICAgICAqICAgc29ja2V0LmluKFwicm9vbS0xMDFcIikuZGlzY29ubmVjdFNvY2tldHMoKTtcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIEBwYXJhbSByb29tIC0gYSByb29tLCBvciBhbiBhcnJheSBvZiByb29tc1xuICAgICAqIEByZXR1cm4gYSBuZXcge0BsaW5rIEJyb2FkY2FzdE9wZXJhdG9yfSBpbnN0YW5jZSBmb3IgY2hhaW5pbmdcbiAgICAgKi9cbiAgICBpbihyb29tKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5ld0Jyb2FkY2FzdE9wZXJhdG9yKCkuaW4ocm9vbSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEV4Y2x1ZGVzIGEgcm9vbSB3aGVuIGJyb2FkY2FzdGluZy5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogaW8ub24oXCJjb25uZWN0aW9uXCIsIChzb2NrZXQpID0+IHtcbiAgICAgKiAgIC8vIHRoZSBcImZvb1wiIGV2ZW50IHdpbGwgYmUgYnJvYWRjYXN0IHRvIGFsbCBjb25uZWN0ZWQgY2xpZW50cywgZXhjZXB0IHRoZSBvbmVzIHRoYXQgYXJlIGluIHRoZSBcInJvb20tMTAxXCIgcm9vbVxuICAgICAqICAgLy8gYW5kIHRoaXMgc29ja2V0XG4gICAgICogICBzb2NrZXQuZXhjZXB0KFwicm9vbS0xMDFcIikuZW1pdChcImZvb1wiLCBcImJhclwiKTtcbiAgICAgKlxuICAgICAqICAgLy8gd2l0aCBhbiBhcnJheSBvZiByb29tc1xuICAgICAqICAgc29ja2V0LmV4Y2VwdChbXCJyb29tLTEwMVwiLCBcInJvb20tMTAyXCJdKS5lbWl0KFwiZm9vXCIsIFwiYmFyXCIpO1xuICAgICAqXG4gICAgICogICAvLyB3aXRoIG11bHRpcGxlIGNoYWluZWQgY2FsbHNcbiAgICAgKiAgIHNvY2tldC5leGNlcHQoXCJyb29tLTEwMVwiKS5leGNlcHQoXCJyb29tLTEwMlwiKS5lbWl0KFwiZm9vXCIsIFwiYmFyXCIpO1xuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogQHBhcmFtIHJvb20gLSBhIHJvb20sIG9yIGFuIGFycmF5IG9mIHJvb21zXG4gICAgICogQHJldHVybiBhIG5ldyB7QGxpbmsgQnJvYWRjYXN0T3BlcmF0b3J9IGluc3RhbmNlIGZvciBjaGFpbmluZ1xuICAgICAqL1xuICAgIGV4Y2VwdChyb29tKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5ld0Jyb2FkY2FzdE9wZXJhdG9yKCkuZXhjZXB0KHJvb20pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZW5kcyBhIGBtZXNzYWdlYCBldmVudC5cbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIG1pbWljcyB0aGUgV2ViU29ja2V0LnNlbmQoKSBtZXRob2QuXG4gICAgICpcbiAgICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9XZWJTb2NrZXQvc2VuZFxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBpby5vbihcImNvbm5lY3Rpb25cIiwgKHNvY2tldCkgPT4ge1xuICAgICAqICAgc29ja2V0LnNlbmQoXCJoZWxsb1wiKTtcbiAgICAgKlxuICAgICAqICAgLy8gdGhpcyBpcyBlcXVpdmFsZW50IHRvXG4gICAgICogICBzb2NrZXQuZW1pdChcIm1lc3NhZ2VcIiwgXCJoZWxsb1wiKTtcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIEByZXR1cm4gc2VsZlxuICAgICAqL1xuICAgIHNlbmQoLi4uYXJncykge1xuICAgICAgICB0aGlzLmVtaXQoXCJtZXNzYWdlXCIsIC4uLmFyZ3MpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VuZHMgYSBgbWVzc2FnZWAgZXZlbnQuIEFsaWFzIG9mIHtAbGluayBzZW5kfS5cbiAgICAgKlxuICAgICAqIEByZXR1cm4gc2VsZlxuICAgICAqL1xuICAgIHdyaXRlKC4uLmFyZ3MpIHtcbiAgICAgICAgdGhpcy5lbWl0KFwibWVzc2FnZVwiLCAuLi5hcmdzKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdyaXRlcyBhIHBhY2tldC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwYWNrZXQgLSBwYWNrZXQgb2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBvcHRpb25zXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBwYWNrZXQocGFja2V0LCBvcHRzID0ge30pIHtcbiAgICAgICAgcGFja2V0Lm5zcCA9IHRoaXMubnNwLm5hbWU7XG4gICAgICAgIG9wdHMuY29tcHJlc3MgPSBmYWxzZSAhPT0gb3B0cy5jb21wcmVzcztcbiAgICAgICAgdGhpcy5jbGllbnQuX3BhY2tldChwYWNrZXQsIG9wdHMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBKb2lucyBhIHJvb20uXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGlvLm9uKFwiY29ubmVjdGlvblwiLCAoc29ja2V0KSA9PiB7XG4gICAgICogICAvLyBqb2luIGEgc2luZ2xlIHJvb21cbiAgICAgKiAgIHNvY2tldC5qb2luKFwicm9vbTFcIik7XG4gICAgICpcbiAgICAgKiAgIC8vIGpvaW4gbXVsdGlwbGUgcm9vbXNcbiAgICAgKiAgIHNvY2tldC5qb2luKFtcInJvb20xXCIsIFwicm9vbTJcIl0pO1xuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd8QXJyYXl9IHJvb21zIC0gcm9vbSBvciBhcnJheSBvZiByb29tc1xuICAgICAqIEByZXR1cm4gYSBQcm9taXNlIG9yIG5vdGhpbmcsIGRlcGVuZGluZyBvbiB0aGUgYWRhcHRlclxuICAgICAqL1xuICAgIGpvaW4ocm9vbXMpIHtcbiAgICAgICAgZGVidWcoXCJqb2luIHJvb20gJXNcIiwgcm9vbXMpO1xuICAgICAgICByZXR1cm4gdGhpcy5hZGFwdGVyLmFkZEFsbCh0aGlzLmlkLCBuZXcgU2V0KEFycmF5LmlzQXJyYXkocm9vbXMpID8gcm9vbXMgOiBbcm9vbXNdKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExlYXZlcyBhIHJvb20uXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGlvLm9uKFwiY29ubmVjdGlvblwiLCAoc29ja2V0KSA9PiB7XG4gICAgICogICAvLyBsZWF2ZSBhIHNpbmdsZSByb29tXG4gICAgICogICBzb2NrZXQubGVhdmUoXCJyb29tMVwiKTtcbiAgICAgKlxuICAgICAqICAgLy8gbGVhdmUgbXVsdGlwbGUgcm9vbXNcbiAgICAgKiAgIHNvY2tldC5sZWF2ZShcInJvb20xXCIpLmxlYXZlKFwicm9vbTJcIik7XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcm9vbVxuICAgICAqIEByZXR1cm4gYSBQcm9taXNlIG9yIG5vdGhpbmcsIGRlcGVuZGluZyBvbiB0aGUgYWRhcHRlclxuICAgICAqL1xuICAgIGxlYXZlKHJvb20pIHtcbiAgICAgICAgZGVidWcoXCJsZWF2ZSByb29tICVzXCIsIHJvb20pO1xuICAgICAgICByZXR1cm4gdGhpcy5hZGFwdGVyLmRlbCh0aGlzLmlkLCByb29tKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTGVhdmUgYWxsIHJvb21zLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBsZWF2ZUFsbCgpIHtcbiAgICAgICAgdGhpcy5hZGFwdGVyLmRlbEFsbCh0aGlzLmlkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsbGVkIGJ5IGBOYW1lc3BhY2VgIHVwb24gc3VjY2Vzc2Z1bFxuICAgICAqIG1pZGRsZXdhcmUgZXhlY3V0aW9uIChpZTogYXV0aG9yaXphdGlvbikuXG4gICAgICogU29ja2V0IGlzIGFkZGVkIHRvIG5hbWVzcGFjZSBhcnJheSBiZWZvcmVcbiAgICAgKiBjYWxsIHRvIGpvaW4sIHNvIGFkYXB0ZXJzIGNhbiBhY2Nlc3MgaXQuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9vbmNvbm5lY3QoKSB7XG4gICAgICAgIGRlYnVnKFwic29ja2V0IGNvbm5lY3RlZCAtIHdyaXRpbmcgcGFja2V0XCIpO1xuICAgICAgICB0aGlzLmNvbm5lY3RlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuam9pbih0aGlzLmlkKTtcbiAgICAgICAgaWYgKHRoaXMuY29ubi5wcm90b2NvbCA9PT0gMykge1xuICAgICAgICAgICAgdGhpcy5wYWNrZXQoeyB0eXBlOiBzb2NrZXRfaW9fcGFyc2VyXzEuUGFja2V0VHlwZS5DT05ORUNUIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5wYWNrZXQoe1xuICAgICAgICAgICAgICAgIHR5cGU6IHNvY2tldF9pb19wYXJzZXJfMS5QYWNrZXRUeXBlLkNPTk5FQ1QsXG4gICAgICAgICAgICAgICAgZGF0YTogeyBzaWQ6IHRoaXMuaWQsIHBpZDogdGhpcy5waWQgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGxlZCB3aXRoIGVhY2ggcGFja2V0LiBDYWxsZWQgYnkgYENsaWVudGAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcGFja2V0XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfb25wYWNrZXQocGFja2V0KSB7XG4gICAgICAgIGRlYnVnKFwiZ290IHBhY2tldCAlalwiLCBwYWNrZXQpO1xuICAgICAgICBzd2l0Y2ggKHBhY2tldC50eXBlKSB7XG4gICAgICAgICAgICBjYXNlIHNvY2tldF9pb19wYXJzZXJfMS5QYWNrZXRUeXBlLkVWRU5UOlxuICAgICAgICAgICAgICAgIHRoaXMub25ldmVudChwYWNrZXQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBzb2NrZXRfaW9fcGFyc2VyXzEuUGFja2V0VHlwZS5CSU5BUllfRVZFTlQ6XG4gICAgICAgICAgICAgICAgdGhpcy5vbmV2ZW50KHBhY2tldCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIHNvY2tldF9pb19wYXJzZXJfMS5QYWNrZXRUeXBlLkFDSzpcbiAgICAgICAgICAgICAgICB0aGlzLm9uYWNrKHBhY2tldCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIHNvY2tldF9pb19wYXJzZXJfMS5QYWNrZXRUeXBlLkJJTkFSWV9BQ0s6XG4gICAgICAgICAgICAgICAgdGhpcy5vbmFjayhwYWNrZXQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBzb2NrZXRfaW9fcGFyc2VyXzEuUGFja2V0VHlwZS5ESVNDT05ORUNUOlxuICAgICAgICAgICAgICAgIHRoaXMub25kaXNjb25uZWN0KCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHVwb24gZXZlbnQgcGFja2V0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtQYWNrZXR9IHBhY2tldCAtIHBhY2tldCBvYmplY3RcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIG9uZXZlbnQocGFja2V0KSB7XG4gICAgICAgIGNvbnN0IGFyZ3MgPSBwYWNrZXQuZGF0YSB8fCBbXTtcbiAgICAgICAgZGVidWcoXCJlbWl0dGluZyBldmVudCAlalwiLCBhcmdzKTtcbiAgICAgICAgaWYgKG51bGwgIT0gcGFja2V0LmlkKSB7XG4gICAgICAgICAgICBkZWJ1ZyhcImF0dGFjaGluZyBhY2sgY2FsbGJhY2sgdG8gZXZlbnRcIik7XG4gICAgICAgICAgICBhcmdzLnB1c2godGhpcy5hY2socGFja2V0LmlkKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2FueUxpc3RlbmVycyAmJiB0aGlzLl9hbnlMaXN0ZW5lcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICBjb25zdCBsaXN0ZW5lcnMgPSB0aGlzLl9hbnlMaXN0ZW5lcnMuc2xpY2UoKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgbGlzdGVuZXIgb2YgbGlzdGVuZXJzKSB7XG4gICAgICAgICAgICAgICAgbGlzdGVuZXIuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kaXNwYXRjaChhcmdzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUHJvZHVjZXMgYW4gYWNrIGNhbGxiYWNrIHRvIGVtaXQgd2l0aCBhbiBldmVudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBpZCAtIHBhY2tldCBpZFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgYWNrKGlkKSB7XG4gICAgICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgICAgICBsZXQgc2VudCA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gcHJldmVudCBkb3VibGUgY2FsbGJhY2tzXG4gICAgICAgICAgICBpZiAoc2VudClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBjb25zdCBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICAgICAgICAgIGRlYnVnKFwic2VuZGluZyBhY2sgJWpcIiwgYXJncyk7XG4gICAgICAgICAgICBzZWxmLnBhY2tldCh7XG4gICAgICAgICAgICAgICAgaWQ6IGlkLFxuICAgICAgICAgICAgICAgIHR5cGU6IHNvY2tldF9pb19wYXJzZXJfMS5QYWNrZXRUeXBlLkFDSyxcbiAgICAgICAgICAgICAgICBkYXRhOiBhcmdzLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzZW50ID0gdHJ1ZTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHVwb24gYWNrIHBhY2tldC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgb25hY2socGFja2V0KSB7XG4gICAgICAgIGNvbnN0IGFjayA9IHRoaXMuYWNrcy5nZXQocGFja2V0LmlkKTtcbiAgICAgICAgaWYgKFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgYWNrKSB7XG4gICAgICAgICAgICBkZWJ1ZyhcImNhbGxpbmcgYWNrICVzIHdpdGggJWpcIiwgcGFja2V0LmlkLCBwYWNrZXQuZGF0YSk7XG4gICAgICAgICAgICBhY2suYXBwbHkodGhpcywgcGFja2V0LmRhdGEpO1xuICAgICAgICAgICAgdGhpcy5hY2tzLmRlbGV0ZShwYWNrZXQuaWQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZGVidWcoXCJiYWQgYWNrICVzXCIsIHBhY2tldC5pZCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHVwb24gY2xpZW50IGRpc2Nvbm5lY3QgcGFja2V0LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBvbmRpc2Nvbm5lY3QoKSB7XG4gICAgICAgIGRlYnVnKFwiZ290IGRpc2Nvbm5lY3QgcGFja2V0XCIpO1xuICAgICAgICB0aGlzLl9vbmNsb3NlKFwiY2xpZW50IG5hbWVzcGFjZSBkaXNjb25uZWN0XCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBIYW5kbGVzIGEgY2xpZW50IGVycm9yLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfb25lcnJvcihlcnIpIHtcbiAgICAgICAgLy8gRklYTUUgdGhlIG1lYW5pbmcgb2YgdGhlIFwiZXJyb3JcIiBldmVudCBpcyBvdmVybG9hZGVkOlxuICAgICAgICAvLyAgLSBpdCBjYW4gYmUgc2VudCBieSB0aGUgY2xpZW50IChgc29ja2V0LmVtaXQoXCJlcnJvclwiKWApXG4gICAgICAgIC8vICAtIGl0IGNhbiBiZSBlbWl0dGVkIHdoZW4gdGhlIGNvbm5lY3Rpb24gZW5jb3VudGVycyBhbiBlcnJvciAoYW4gaW52YWxpZCBwYWNrZXQgZm9yIGV4YW1wbGUpXG4gICAgICAgIC8vICAtIGl0IGNhbiBiZSBlbWl0dGVkIHdoZW4gYSBwYWNrZXQgaXMgcmVqZWN0ZWQgaW4gYSBtaWRkbGV3YXJlIChgc29ja2V0LnVzZSgpYClcbiAgICAgICAgdGhpcy5lbWl0UmVzZXJ2ZWQoXCJlcnJvclwiLCBlcnIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgdXBvbiBjbG9zaW5nLiBDYWxsZWQgYnkgYENsaWVudGAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcmVhc29uXG4gICAgICogQHBhcmFtIGRlc2NyaXB0aW9uXG4gICAgICogQHRocm93IHtFcnJvcn0gb3B0aW9uYWwgZXJyb3Igb2JqZWN0XG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9vbmNsb3NlKHJlYXNvbiwgZGVzY3JpcHRpb24pIHtcbiAgICAgICAgaWYgKCF0aGlzLmNvbm5lY3RlZClcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICBkZWJ1ZyhcImNsb3Npbmcgc29ja2V0IC0gcmVhc29uICVzXCIsIHJlYXNvbik7XG4gICAgICAgIHRoaXMuZW1pdFJlc2VydmVkKFwiZGlzY29ubmVjdGluZ1wiLCByZWFzb24sIGRlc2NyaXB0aW9uKTtcbiAgICAgICAgaWYgKHRoaXMuc2VydmVyLl9vcHRzLmNvbm5lY3Rpb25TdGF0ZVJlY292ZXJ5ICYmXG4gICAgICAgICAgICBSRUNPVkVSQUJMRV9ESVNDT05ORUNUX1JFQVNPTlMuaGFzKHJlYXNvbikpIHtcbiAgICAgICAgICAgIGRlYnVnKFwiY29ubmVjdGlvbiBzdGF0ZSByZWNvdmVyeSBpcyBlbmFibGVkIGZvciBzaWQgJXNcIiwgdGhpcy5pZCk7XG4gICAgICAgICAgICB0aGlzLmFkYXB0ZXIucGVyc2lzdFNlc3Npb24oe1xuICAgICAgICAgICAgICAgIHNpZDogdGhpcy5pZCxcbiAgICAgICAgICAgICAgICBwaWQ6IHRoaXMucGlkLFxuICAgICAgICAgICAgICAgIHJvb21zOiBbLi4udGhpcy5yb29tc10sXG4gICAgICAgICAgICAgICAgZGF0YTogdGhpcy5kYXRhLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fY2xlYW51cCgpO1xuICAgICAgICB0aGlzLmNsaWVudC5fcmVtb3ZlKHRoaXMpO1xuICAgICAgICB0aGlzLmNvbm5lY3RlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmVtaXRSZXNlcnZlZChcImRpc2Nvbm5lY3RcIiwgcmVhc29uLCBkZXNjcmlwdGlvbik7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWFrZXMgdGhlIHNvY2tldCBsZWF2ZSBhbGwgdGhlIHJvb21zIGl0IHdhcyBwYXJ0IG9mIGFuZCBwcmV2ZW50cyBpdCBmcm9tIGpvaW5pbmcgYW55IG90aGVyIHJvb21cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2NsZWFudXAoKSB7XG4gICAgICAgIHRoaXMubGVhdmVBbGwoKTtcbiAgICAgICAgdGhpcy5uc3AuX3JlbW92ZSh0aGlzKTtcbiAgICAgICAgdGhpcy5qb2luID0gbm9vcDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUHJvZHVjZXMgYW4gYGVycm9yYCBwYWNrZXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXJyIC0gZXJyb3Igb2JqZWN0XG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9lcnJvcihlcnIpIHtcbiAgICAgICAgdGhpcy5wYWNrZXQoeyB0eXBlOiBzb2NrZXRfaW9fcGFyc2VyXzEuUGFja2V0VHlwZS5DT05ORUNUX0VSUk9SLCBkYXRhOiBlcnIgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERpc2Nvbm5lY3RzIHRoaXMgY2xpZW50LlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBpby5vbihcImNvbm5lY3Rpb25cIiwgKHNvY2tldCkgPT4ge1xuICAgICAqICAgLy8gZGlzY29ubmVjdCB0aGlzIHNvY2tldCAodGhlIGNvbm5lY3Rpb24gbWlnaHQgYmUga2VwdCBhbGl2ZSBmb3Igb3RoZXIgbmFtZXNwYWNlcylcbiAgICAgKiAgIHNvY2tldC5kaXNjb25uZWN0KCk7XG4gICAgICpcbiAgICAgKiAgIC8vIGRpc2Nvbm5lY3QgdGhpcyBzb2NrZXQgYW5kIGNsb3NlIHRoZSB1bmRlcmx5aW5nIGNvbm5lY3Rpb25cbiAgICAgKiAgIHNvY2tldC5kaXNjb25uZWN0KHRydWUpO1xuICAgICAqIH0pXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGNsb3NlIC0gaWYgYHRydWVgLCBjbG9zZXMgdGhlIHVuZGVybHlpbmcgY29ubmVjdGlvblxuICAgICAqIEByZXR1cm4gc2VsZlxuICAgICAqL1xuICAgIGRpc2Nvbm5lY3QoY2xvc2UgPSBmYWxzZSkge1xuICAgICAgICBpZiAoIXRoaXMuY29ubmVjdGVkKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIGlmIChjbG9zZSkge1xuICAgICAgICAgICAgdGhpcy5jbGllbnQuX2Rpc2Nvbm5lY3QoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucGFja2V0KHsgdHlwZTogc29ja2V0X2lvX3BhcnNlcl8xLlBhY2tldFR5cGUuRElTQ09OTkVDVCB9KTtcbiAgICAgICAgICAgIHRoaXMuX29uY2xvc2UoXCJzZXJ2ZXIgbmFtZXNwYWNlIGRpc2Nvbm5lY3RcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGNvbXByZXNzIGZsYWcuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGlvLm9uKFwiY29ubmVjdGlvblwiLCAoc29ja2V0KSA9PiB7XG4gICAgICogICBzb2NrZXQuY29tcHJlc3MoZmFsc2UpLmVtaXQoXCJoZWxsb1wiKTtcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gY29tcHJlc3MgLSBpZiBgdHJ1ZWAsIGNvbXByZXNzZXMgdGhlIHNlbmRpbmcgZGF0YVxuICAgICAqIEByZXR1cm4ge1NvY2tldH0gc2VsZlxuICAgICAqL1xuICAgIGNvbXByZXNzKGNvbXByZXNzKSB7XG4gICAgICAgIHRoaXMuZmxhZ3MuY29tcHJlc3MgPSBjb21wcmVzcztcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgYSBtb2RpZmllciBmb3IgYSBzdWJzZXF1ZW50IGV2ZW50IGVtaXNzaW9uIHRoYXQgdGhlIGV2ZW50IGRhdGEgbWF5IGJlIGxvc3QgaWYgdGhlIGNsaWVudCBpcyBub3QgcmVhZHkgdG9cbiAgICAgKiByZWNlaXZlIG1lc3NhZ2VzIChiZWNhdXNlIG9mIG5ldHdvcmsgc2xvd25lc3Mgb3Igb3RoZXIgaXNzdWVzLCBvciBiZWNhdXNlIHRoZXnigJlyZSBjb25uZWN0ZWQgdGhyb3VnaCBsb25nIHBvbGxpbmdcbiAgICAgKiBhbmQgaXMgaW4gdGhlIG1pZGRsZSBvZiBhIHJlcXVlc3QtcmVzcG9uc2UgY3ljbGUpLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBpby5vbihcImNvbm5lY3Rpb25cIiwgKHNvY2tldCkgPT4ge1xuICAgICAqICAgc29ja2V0LnZvbGF0aWxlLmVtaXQoXCJoZWxsb1wiKTsgLy8gdGhlIGNsaWVudCBtYXkgb3IgbWF5IG5vdCByZWNlaXZlIGl0XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtTb2NrZXR9IHNlbGZcbiAgICAgKi9cbiAgICBnZXQgdm9sYXRpbGUoKSB7XG4gICAgICAgIHRoaXMuZmxhZ3Mudm9sYXRpbGUgPSB0cnVlO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyBhIG1vZGlmaWVyIGZvciBhIHN1YnNlcXVlbnQgZXZlbnQgZW1pc3Npb24gdGhhdCB0aGUgZXZlbnQgZGF0YSB3aWxsIG9ubHkgYmUgYnJvYWRjYXN0IHRvIGV2ZXJ5IHNvY2tldHMgYnV0IHRoZVxuICAgICAqIHNlbmRlci5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogaW8ub24oXCJjb25uZWN0aW9uXCIsIChzb2NrZXQpID0+IHtcbiAgICAgKiAgIC8vIHRoZSDigJxmb2/igJ0gZXZlbnQgd2lsbCBiZSBicm9hZGNhc3QgdG8gYWxsIGNvbm5lY3RlZCBjbGllbnRzLCBleGNlcHQgdGhpcyBzb2NrZXRcbiAgICAgKiAgIHNvY2tldC5icm9hZGNhc3QuZW1pdChcImZvb1wiLCBcImJhclwiKTtcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIEByZXR1cm4gYSBuZXcge0BsaW5rIEJyb2FkY2FzdE9wZXJhdG9yfSBpbnN0YW5jZSBmb3IgY2hhaW5pbmdcbiAgICAgKi9cbiAgICBnZXQgYnJvYWRjYXN0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5uZXdCcm9hZGNhc3RPcGVyYXRvcigpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIGEgbW9kaWZpZXIgZm9yIGEgc3Vic2VxdWVudCBldmVudCBlbWlzc2lvbiB0aGF0IHRoZSBldmVudCBkYXRhIHdpbGwgb25seSBiZSBicm9hZGNhc3QgdG8gdGhlIGN1cnJlbnQgbm9kZS5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogaW8ub24oXCJjb25uZWN0aW9uXCIsIChzb2NrZXQpID0+IHtcbiAgICAgKiAgIC8vIHRoZSDigJxmb2/igJ0gZXZlbnQgd2lsbCBiZSBicm9hZGNhc3QgdG8gYWxsIGNvbm5lY3RlZCBjbGllbnRzIG9uIHRoaXMgbm9kZSwgZXhjZXB0IHRoaXMgc29ja2V0XG4gICAgICogICBzb2NrZXQubG9jYWwuZW1pdChcImZvb1wiLCBcImJhclwiKTtcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIEByZXR1cm4gYSBuZXcge0BsaW5rIEJyb2FkY2FzdE9wZXJhdG9yfSBpbnN0YW5jZSBmb3IgY2hhaW5pbmdcbiAgICAgKi9cbiAgICBnZXQgbG9jYWwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5ld0Jyb2FkY2FzdE9wZXJhdG9yKCkubG9jYWw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgYSBtb2RpZmllciBmb3IgYSBzdWJzZXF1ZW50IGV2ZW50IGVtaXNzaW9uIHRoYXQgdGhlIGNhbGxiYWNrIHdpbGwgYmUgY2FsbGVkIHdpdGggYW4gZXJyb3Igd2hlbiB0aGVcbiAgICAgKiBnaXZlbiBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIGhhdmUgZWxhcHNlZCB3aXRob3V0IGFuIGFja25vd2xlZGdlbWVudCBmcm9tIHRoZSBjbGllbnQ6XG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGlvLm9uKFwiY29ubmVjdGlvblwiLCAoc29ja2V0KSA9PiB7XG4gICAgICogICBzb2NrZXQudGltZW91dCg1MDAwKS5lbWl0KFwibXktZXZlbnRcIiwgKGVycikgPT4ge1xuICAgICAqICAgICBpZiAoZXJyKSB7XG4gICAgICogICAgICAgLy8gdGhlIGNsaWVudCBkaWQgbm90IGFja25vd2xlZGdlIHRoZSBldmVudCBpbiB0aGUgZ2l2ZW4gZGVsYXlcbiAgICAgKiAgICAgfVxuICAgICAqICAgfSk7XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBzZWxmXG4gICAgICovXG4gICAgdGltZW91dCh0aW1lb3V0KSB7XG4gICAgICAgIHRoaXMuZmxhZ3MudGltZW91dCA9IHRpbWVvdXQ7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEaXNwYXRjaCBpbmNvbWluZyBldmVudCB0byBzb2NrZXQgbGlzdGVuZXJzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtBcnJheX0gZXZlbnQgLSBldmVudCB0aGF0IHdpbGwgZ2V0IGVtaXR0ZWRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGRpc3BhdGNoKGV2ZW50KSB7XG4gICAgICAgIGRlYnVnKFwiZGlzcGF0Y2hpbmcgYW4gZXZlbnQgJWpcIiwgZXZlbnQpO1xuICAgICAgICB0aGlzLnJ1bihldmVudCwgKGVycikgPT4ge1xuICAgICAgICAgICAgcHJvY2Vzcy5uZXh0VGljaygoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fb25lcnJvcihlcnIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jb25uZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgc3VwZXIuZW1pdFVudHlwZWQuYXBwbHkodGhpcywgZXZlbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZGVidWcoXCJpZ25vcmUgcGFja2V0IHJlY2VpdmVkIGFmdGVyIGRpc2Nvbm5lY3Rpb25cIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHVwIHNvY2tldCBtaWRkbGV3YXJlLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBpby5vbihcImNvbm5lY3Rpb25cIiwgKHNvY2tldCkgPT4ge1xuICAgICAqICAgc29ja2V0LnVzZSgoW2V2ZW50LCAuLi5hcmdzXSwgbmV4dCkgPT4ge1xuICAgICAqICAgICBpZiAoaXNVbmF1dGhvcml6ZWQoZXZlbnQpKSB7XG4gICAgICogICAgICAgcmV0dXJuIG5leHQobmV3IEVycm9yKFwidW5hdXRob3JpemVkIGV2ZW50XCIpKTtcbiAgICAgKiAgICAgfVxuICAgICAqICAgICAvLyBkbyBub3QgZm9yZ2V0IHRvIGNhbGwgbmV4dFxuICAgICAqICAgICBuZXh0KCk7XG4gICAgICogICB9KTtcbiAgICAgKlxuICAgICAqICAgc29ja2V0Lm9uKFwiZXJyb3JcIiwgKGVycikgPT4ge1xuICAgICAqICAgICBpZiAoZXJyICYmIGVyci5tZXNzYWdlID09PSBcInVuYXV0aG9yaXplZCBldmVudFwiKSB7XG4gICAgICogICAgICAgc29ja2V0LmRpc2Nvbm5lY3QoKTtcbiAgICAgKiAgICAgfVxuICAgICAqICAgfSk7XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiAtIG1pZGRsZXdhcmUgZnVuY3Rpb24gKGV2ZW50LCBuZXh0KVxuICAgICAqIEByZXR1cm4ge1NvY2tldH0gc2VsZlxuICAgICAqL1xuICAgIHVzZShmbikge1xuICAgICAgICB0aGlzLmZucy5wdXNoKGZuKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEV4ZWN1dGVzIHRoZSBtaWRkbGV3YXJlIGZvciBhbiBpbmNvbWluZyBldmVudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGV2ZW50IC0gZXZlbnQgdGhhdCB3aWxsIGdldCBlbWl0dGVkXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gLSBsYXN0IGZuIGNhbGwgaW4gdGhlIG1pZGRsZXdhcmVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHJ1bihldmVudCwgZm4pIHtcbiAgICAgICAgaWYgKCF0aGlzLmZucy5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gZm4oKTtcbiAgICAgICAgY29uc3QgZm5zID0gdGhpcy5mbnMuc2xpY2UoMCk7XG4gICAgICAgIGZ1bmN0aW9uIHJ1bihpKSB7XG4gICAgICAgICAgICBmbnNbaV0oZXZlbnQsIChlcnIpID0+IHtcbiAgICAgICAgICAgICAgICAvLyB1cG9uIGVycm9yLCBzaG9ydC1jaXJjdWl0XG4gICAgICAgICAgICAgICAgaWYgKGVycilcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZuKGVycik7XG4gICAgICAgICAgICAgICAgLy8gaWYgbm8gbWlkZGxld2FyZSBsZWZ0LCBzdW1tb24gY2FsbGJhY2tcbiAgICAgICAgICAgICAgICBpZiAoIWZuc1tpICsgMV0pXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmbigpO1xuICAgICAgICAgICAgICAgIC8vIGdvIG9uIHRvIG5leHRcbiAgICAgICAgICAgICAgICBydW4oaSArIDEpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcnVuKDApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRoZSBzb2NrZXQgaXMgY3VycmVudGx5IGRpc2Nvbm5lY3RlZFxuICAgICAqL1xuICAgIGdldCBkaXNjb25uZWN0ZWQoKSB7XG4gICAgICAgIHJldHVybiAhdGhpcy5jb25uZWN0ZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEEgcmVmZXJlbmNlIHRvIHRoZSByZXF1ZXN0IHRoYXQgb3JpZ2luYXRlZCB0aGUgdW5kZXJseWluZyBFbmdpbmUuSU8gU29ja2V0LlxuICAgICAqL1xuICAgIGdldCByZXF1ZXN0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnQucmVxdWVzdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQSByZWZlcmVuY2UgdG8gdGhlIHVuZGVybHlpbmcgQ2xpZW50IHRyYW5zcG9ydCBjb25uZWN0aW9uIChFbmdpbmUuSU8gU29ja2V0IG9iamVjdCkuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGlvLm9uKFwiY29ubmVjdGlvblwiLCAoc29ja2V0KSA9PiB7XG4gICAgICogICBjb25zb2xlLmxvZyhzb2NrZXQuY29ubi50cmFuc3BvcnQubmFtZSk7IC8vIHByaW50cyBcInBvbGxpbmdcIiBvciBcIndlYnNvY2tldFwiXG4gICAgICpcbiAgICAgKiAgIHNvY2tldC5jb25uLm9uY2UoXCJ1cGdyYWRlXCIsICgpID0+IHtcbiAgICAgKiAgICAgY29uc29sZS5sb2coc29ja2V0LmNvbm4udHJhbnNwb3J0Lm5hbWUpOyAvLyBwcmludHMgXCJ3ZWJzb2NrZXRcIlxuICAgICAqICAgfSk7XG4gICAgICogfSk7XG4gICAgICovXG4gICAgZ2V0IGNvbm4oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsaWVudC5jb25uO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSByb29tcyB0aGUgc29ja2V0IGlzIGN1cnJlbnRseSBpbi5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogaW8ub24oXCJjb25uZWN0aW9uXCIsIChzb2NrZXQpID0+IHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKHNvY2tldC5yb29tcyk7IC8vIFNldCB7IDxzb2NrZXQuaWQ+IH1cbiAgICAgKlxuICAgICAqICAgc29ja2V0LmpvaW4oXCJyb29tMVwiKTtcbiAgICAgKlxuICAgICAqICAgY29uc29sZS5sb2coc29ja2V0LnJvb21zKTsgLy8gU2V0IHsgPHNvY2tldC5pZD4sIFwicm9vbTFcIiB9XG4gICAgICogfSk7XG4gICAgICovXG4gICAgZ2V0IHJvb21zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hZGFwdGVyLnNvY2tldFJvb21zKHRoaXMuaWQpIHx8IG5ldyBTZXQoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkcyBhIGxpc3RlbmVyIHRoYXQgd2lsbCBiZSBmaXJlZCB3aGVuIGFueSBldmVudCBpcyByZWNlaXZlZC4gVGhlIGV2ZW50IG5hbWUgaXMgcGFzc2VkIGFzIHRoZSBmaXJzdCBhcmd1bWVudCB0b1xuICAgICAqIHRoZSBjYWxsYmFjay5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogaW8ub24oXCJjb25uZWN0aW9uXCIsIChzb2NrZXQpID0+IHtcbiAgICAgKiAgIHNvY2tldC5vbkFueSgoZXZlbnQsIC4uLmFyZ3MpID0+IHtcbiAgICAgKiAgICAgY29uc29sZS5sb2coYGdvdCBldmVudCAke2V2ZW50fWApO1xuICAgICAqICAgfSk7XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBAcGFyYW0gbGlzdGVuZXJcbiAgICAgKi9cbiAgICBvbkFueShsaXN0ZW5lcikge1xuICAgICAgICB0aGlzLl9hbnlMaXN0ZW5lcnMgPSB0aGlzLl9hbnlMaXN0ZW5lcnMgfHwgW107XG4gICAgICAgIHRoaXMuX2FueUxpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZHMgYSBsaXN0ZW5lciB0aGF0IHdpbGwgYmUgZmlyZWQgd2hlbiBhbnkgZXZlbnQgaXMgcmVjZWl2ZWQuIFRoZSBldmVudCBuYW1lIGlzIHBhc3NlZCBhcyB0aGUgZmlyc3QgYXJndW1lbnQgdG9cbiAgICAgKiB0aGUgY2FsbGJhY2suIFRoZSBsaXN0ZW5lciBpcyBhZGRlZCB0byB0aGUgYmVnaW5uaW5nIG9mIHRoZSBsaXN0ZW5lcnMgYXJyYXkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbGlzdGVuZXJcbiAgICAgKi9cbiAgICBwcmVwZW5kQW55KGxpc3RlbmVyKSB7XG4gICAgICAgIHRoaXMuX2FueUxpc3RlbmVycyA9IHRoaXMuX2FueUxpc3RlbmVycyB8fCBbXTtcbiAgICAgICAgdGhpcy5fYW55TGlzdGVuZXJzLnVuc2hpZnQobGlzdGVuZXIpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyB0aGUgbGlzdGVuZXIgdGhhdCB3aWxsIGJlIGZpcmVkIHdoZW4gYW55IGV2ZW50IGlzIHJlY2VpdmVkLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBpby5vbihcImNvbm5lY3Rpb25cIiwgKHNvY2tldCkgPT4ge1xuICAgICAqICAgY29uc3QgY2F0Y2hBbGxMaXN0ZW5lciA9IChldmVudCwgLi4uYXJncykgPT4ge1xuICAgICAqICAgICBjb25zb2xlLmxvZyhgZ290IGV2ZW50ICR7ZXZlbnR9YCk7XG4gICAgICogICB9XG4gICAgICpcbiAgICAgKiAgIHNvY2tldC5vbkFueShjYXRjaEFsbExpc3RlbmVyKTtcbiAgICAgKlxuICAgICAqICAgLy8gcmVtb3ZlIGEgc3BlY2lmaWMgbGlzdGVuZXJcbiAgICAgKiAgIHNvY2tldC5vZmZBbnkoY2F0Y2hBbGxMaXN0ZW5lcik7XG4gICAgICpcbiAgICAgKiAgIC8vIG9yIHJlbW92ZSBhbGwgbGlzdGVuZXJzXG4gICAgICogICBzb2NrZXQub2ZmQW55KCk7XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBAcGFyYW0gbGlzdGVuZXJcbiAgICAgKi9cbiAgICBvZmZBbnkobGlzdGVuZXIpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9hbnlMaXN0ZW5lcnMpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsaXN0ZW5lcikge1xuICAgICAgICAgICAgY29uc3QgbGlzdGVuZXJzID0gdGhpcy5fYW55TGlzdGVuZXJzO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaXN0ZW5lcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAobGlzdGVuZXIgPT09IGxpc3RlbmVyc1tpXSkge1xuICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lcnMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9hbnlMaXN0ZW5lcnMgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbiBhcnJheSBvZiBsaXN0ZW5lcnMgdGhhdCBhcmUgbGlzdGVuaW5nIGZvciBhbnkgZXZlbnQgdGhhdCBpcyBzcGVjaWZpZWQuIFRoaXMgYXJyYXkgY2FuIGJlIG1hbmlwdWxhdGVkLFxuICAgICAqIGUuZy4gdG8gcmVtb3ZlIGxpc3RlbmVycy5cbiAgICAgKi9cbiAgICBsaXN0ZW5lcnNBbnkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hbnlMaXN0ZW5lcnMgfHwgW107XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZHMgYSBsaXN0ZW5lciB0aGF0IHdpbGwgYmUgZmlyZWQgd2hlbiBhbnkgZXZlbnQgaXMgc2VudC4gVGhlIGV2ZW50IG5hbWUgaXMgcGFzc2VkIGFzIHRoZSBmaXJzdCBhcmd1bWVudCB0b1xuICAgICAqIHRoZSBjYWxsYmFjay5cbiAgICAgKlxuICAgICAqIE5vdGU6IGFja25vd2xlZGdlbWVudHMgc2VudCB0byB0aGUgY2xpZW50IGFyZSBub3QgaW5jbHVkZWQuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGlvLm9uKFwiY29ubmVjdGlvblwiLCAoc29ja2V0KSA9PiB7XG4gICAgICogICBzb2NrZXQub25BbnlPdXRnb2luZygoZXZlbnQsIC4uLmFyZ3MpID0+IHtcbiAgICAgKiAgICAgY29uc29sZS5sb2coYHNlbnQgZXZlbnQgJHtldmVudH1gKTtcbiAgICAgKiAgIH0pO1xuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogQHBhcmFtIGxpc3RlbmVyXG4gICAgICovXG4gICAgb25BbnlPdXRnb2luZyhsaXN0ZW5lcikge1xuICAgICAgICB0aGlzLl9hbnlPdXRnb2luZ0xpc3RlbmVycyA9IHRoaXMuX2FueU91dGdvaW5nTGlzdGVuZXJzIHx8IFtdO1xuICAgICAgICB0aGlzLl9hbnlPdXRnb2luZ0xpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZHMgYSBsaXN0ZW5lciB0aGF0IHdpbGwgYmUgZmlyZWQgd2hlbiBhbnkgZXZlbnQgaXMgZW1pdHRlZC4gVGhlIGV2ZW50IG5hbWUgaXMgcGFzc2VkIGFzIHRoZSBmaXJzdCBhcmd1bWVudCB0byB0aGVcbiAgICAgKiBjYWxsYmFjay4gVGhlIGxpc3RlbmVyIGlzIGFkZGVkIHRvIHRoZSBiZWdpbm5pbmcgb2YgdGhlIGxpc3RlbmVycyBhcnJheS5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogaW8ub24oXCJjb25uZWN0aW9uXCIsIChzb2NrZXQpID0+IHtcbiAgICAgKiAgIHNvY2tldC5wcmVwZW5kQW55T3V0Z29pbmcoKGV2ZW50LCAuLi5hcmdzKSA9PiB7XG4gICAgICogICAgIGNvbnNvbGUubG9nKGBzZW50IGV2ZW50ICR7ZXZlbnR9YCk7XG4gICAgICogICB9KTtcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIEBwYXJhbSBsaXN0ZW5lclxuICAgICAqL1xuICAgIHByZXBlbmRBbnlPdXRnb2luZyhsaXN0ZW5lcikge1xuICAgICAgICB0aGlzLl9hbnlPdXRnb2luZ0xpc3RlbmVycyA9IHRoaXMuX2FueU91dGdvaW5nTGlzdGVuZXJzIHx8IFtdO1xuICAgICAgICB0aGlzLl9hbnlPdXRnb2luZ0xpc3RlbmVycy51bnNoaWZ0KGxpc3RlbmVyKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgdGhlIGxpc3RlbmVyIHRoYXQgd2lsbCBiZSBmaXJlZCB3aGVuIGFueSBldmVudCBpcyBzZW50LlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBpby5vbihcImNvbm5lY3Rpb25cIiwgKHNvY2tldCkgPT4ge1xuICAgICAqICAgY29uc3QgY2F0Y2hBbGxMaXN0ZW5lciA9IChldmVudCwgLi4uYXJncykgPT4ge1xuICAgICAqICAgICBjb25zb2xlLmxvZyhgc2VudCBldmVudCAke2V2ZW50fWApO1xuICAgICAqICAgfVxuICAgICAqXG4gICAgICogICBzb2NrZXQub25BbnlPdXRnb2luZyhjYXRjaEFsbExpc3RlbmVyKTtcbiAgICAgKlxuICAgICAqICAgLy8gcmVtb3ZlIGEgc3BlY2lmaWMgbGlzdGVuZXJcbiAgICAgKiAgIHNvY2tldC5vZmZBbnlPdXRnb2luZyhjYXRjaEFsbExpc3RlbmVyKTtcbiAgICAgKlxuICAgICAqICAgLy8gb3IgcmVtb3ZlIGFsbCBsaXN0ZW5lcnNcbiAgICAgKiAgIHNvY2tldC5vZmZBbnlPdXRnb2luZygpO1xuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogQHBhcmFtIGxpc3RlbmVyIC0gdGhlIGNhdGNoLWFsbCBsaXN0ZW5lclxuICAgICAqL1xuICAgIG9mZkFueU91dGdvaW5nKGxpc3RlbmVyKSB7XG4gICAgICAgIGlmICghdGhpcy5fYW55T3V0Z29pbmdMaXN0ZW5lcnMpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsaXN0ZW5lcikge1xuICAgICAgICAgICAgY29uc3QgbGlzdGVuZXJzID0gdGhpcy5fYW55T3V0Z29pbmdMaXN0ZW5lcnM7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpc3RlbmVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChsaXN0ZW5lciA9PT0gbGlzdGVuZXJzW2ldKSB7XG4gICAgICAgICAgICAgICAgICAgIGxpc3RlbmVycy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2FueU91dGdvaW5nTGlzdGVuZXJzID0gW107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYW4gYXJyYXkgb2YgbGlzdGVuZXJzIHRoYXQgYXJlIGxpc3RlbmluZyBmb3IgYW55IGV2ZW50IHRoYXQgaXMgc3BlY2lmaWVkLiBUaGlzIGFycmF5IGNhbiBiZSBtYW5pcHVsYXRlZCxcbiAgICAgKiBlLmcuIHRvIHJlbW92ZSBsaXN0ZW5lcnMuXG4gICAgICovXG4gICAgbGlzdGVuZXJzQW55T3V0Z29pbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hbnlPdXRnb2luZ0xpc3RlbmVycyB8fCBbXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTm90aWZ5IHRoZSBsaXN0ZW5lcnMgZm9yIGVhY2ggcGFja2V0IHNlbnQgKGVtaXQgb3IgYnJvYWRjYXN0KVxuICAgICAqXG4gICAgICogQHBhcmFtIHBhY2tldFxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBub3RpZnlPdXRnb2luZ0xpc3RlbmVycyhwYWNrZXQpIHtcbiAgICAgICAgaWYgKHRoaXMuX2FueU91dGdvaW5nTGlzdGVuZXJzICYmIHRoaXMuX2FueU91dGdvaW5nTGlzdGVuZXJzLmxlbmd0aCkge1xuICAgICAgICAgICAgY29uc3QgbGlzdGVuZXJzID0gdGhpcy5fYW55T3V0Z29pbmdMaXN0ZW5lcnMuc2xpY2UoKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgbGlzdGVuZXIgb2YgbGlzdGVuZXJzKSB7XG4gICAgICAgICAgICAgICAgbGlzdGVuZXIuYXBwbHkodGhpcywgcGFja2V0LmRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIG5ld0Jyb2FkY2FzdE9wZXJhdG9yKCkge1xuICAgICAgICBjb25zdCBmbGFncyA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMuZmxhZ3MpO1xuICAgICAgICB0aGlzLmZsYWdzID0ge307XG4gICAgICAgIHJldHVybiBuZXcgYnJvYWRjYXN0X29wZXJhdG9yXzEuQnJvYWRjYXN0T3BlcmF0b3IodGhpcy5hZGFwdGVyLCBuZXcgU2V0KCksIG5ldyBTZXQoW3RoaXMuaWRdKSwgZmxhZ3MpO1xuICAgIH1cbn1cbmV4cG9ydHMuU29ja2V0ID0gU29ja2V0O1xuIl0sIm5hbWVzIjpbIl9faW1wb3J0RGVmYXVsdCIsIm1vZCIsIl9fZXNNb2R1bGUiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIlNvY2tldCIsInNvY2tldF9pb19wYXJzZXJfMSIsInJlcXVpcmUiLCJkZWJ1Z18xIiwidHlwZWRfZXZlbnRzXzEiLCJiYXNlNjRpZF8xIiwiYnJvYWRjYXN0X29wZXJhdG9yXzEiLCJzb2NrZXRfdHlwZXNfMSIsImRlYnVnIiwiZGVmYXVsdCIsIlJFQ09WRVJBQkxFX0RJU0NPTk5FQ1RfUkVBU09OUyIsIlNldCIsIm5vb3AiLCJTdHJpY3RFdmVudEVtaXR0ZXIiLCJjb25zdHJ1Y3RvciIsIm5zcCIsImNsaWVudCIsImF1dGgiLCJwcmV2aW91c1Nlc3Npb24iLCJyZWNvdmVyZWQiLCJkYXRhIiwiY29ubmVjdGVkIiwiYWNrcyIsIk1hcCIsImZucyIsImZsYWdzIiwic2VydmVyIiwiYWRhcHRlciIsImlkIiwic2lkIiwicGlkIiwicm9vbXMiLCJmb3JFYWNoIiwicm9vbSIsImpvaW4iLCJtaXNzZWRQYWNrZXRzIiwicGFja2V0IiwidHlwZSIsIlBhY2tldFR5cGUiLCJFVkVOVCIsImNvbm4iLCJwcm90b2NvbCIsIm5hbWUiLCJnZW5lcmF0ZUlkIiwiX29wdHMiLCJjb25uZWN0aW9uU3RhdGVSZWNvdmVyeSIsImhhbmRzaGFrZSIsImJ1aWxkSGFuZHNoYWtlIiwib24iLCJfYSIsIl9iIiwiX2MiLCJfZCIsImhlYWRlcnMiLCJyZXF1ZXN0IiwidGltZSIsIkRhdGUiLCJhZGRyZXNzIiwicmVtb3RlQWRkcmVzcyIsInhkb21haW4iLCJvcmlnaW4iLCJzZWN1cmUiLCJjb25uZWN0aW9uIiwiZW5jcnlwdGVkIiwiaXNzdWVkIiwidXJsIiwicXVlcnkiLCJfcXVlcnkiLCJlbWl0IiwiZXYiLCJhcmdzIiwiUkVTRVJWRURfRVZFTlRTIiwiaGFzIiwiRXJyb3IiLCJTdHJpbmciLCJsZW5ndGgiLCJfaWRzIiwicmVnaXN0ZXJBY2tDYWxsYmFjayIsInBvcCIsImFzc2lnbiIsIm9wdHMiLCJicm9hZGNhc3QiLCJleGNlcHQiLCJub3RpZnlPdXRnb2luZ0xpc3RlbmVycyIsImVtaXRXaXRoQWNrIiwid2l0aEVyciIsInRpbWVvdXQiLCJ1bmRlZmluZWQiLCJQcm9taXNlIiwicmVzb2x2ZSIsInJlamVjdCIsInB1c2giLCJhcmcxIiwiYXJnMiIsImFjayIsInNldCIsInRpbWVyIiwic2V0VGltZW91dCIsImRlbGV0ZSIsImNhbGwiLCJjbGVhclRpbWVvdXQiLCJhcHBseSIsInRvIiwibmV3QnJvYWRjYXN0T3BlcmF0b3IiLCJpbiIsInNlbmQiLCJ3cml0ZSIsImNvbXByZXNzIiwiX3BhY2tldCIsImFkZEFsbCIsIkFycmF5IiwiaXNBcnJheSIsImxlYXZlIiwiZGVsIiwibGVhdmVBbGwiLCJkZWxBbGwiLCJfb25jb25uZWN0IiwiQ09OTkVDVCIsIl9vbnBhY2tldCIsIm9uZXZlbnQiLCJCSU5BUllfRVZFTlQiLCJBQ0siLCJvbmFjayIsIkJJTkFSWV9BQ0siLCJESVNDT05ORUNUIiwib25kaXNjb25uZWN0IiwiX2FueUxpc3RlbmVycyIsImxpc3RlbmVycyIsInNsaWNlIiwibGlzdGVuZXIiLCJkaXNwYXRjaCIsInNlbGYiLCJzZW50IiwicHJvdG90eXBlIiwiYXJndW1lbnRzIiwiZ2V0IiwiX29uY2xvc2UiLCJfb25lcnJvciIsImVyciIsImVtaXRSZXNlcnZlZCIsInJlYXNvbiIsImRlc2NyaXB0aW9uIiwicGVyc2lzdFNlc3Npb24iLCJfY2xlYW51cCIsIl9yZW1vdmUiLCJfZXJyb3IiLCJDT05ORUNUX0VSUk9SIiwiZGlzY29ubmVjdCIsImNsb3NlIiwiX2Rpc2Nvbm5lY3QiLCJ2b2xhdGlsZSIsImxvY2FsIiwiZXZlbnQiLCJydW4iLCJwcm9jZXNzIiwibmV4dFRpY2siLCJlbWl0VW50eXBlZCIsInVzZSIsImZuIiwiaSIsImRpc2Nvbm5lY3RlZCIsInNvY2tldFJvb21zIiwib25BbnkiLCJwcmVwZW5kQW55IiwidW5zaGlmdCIsIm9mZkFueSIsInNwbGljZSIsImxpc3RlbmVyc0FueSIsIm9uQW55T3V0Z29pbmciLCJfYW55T3V0Z29pbmdMaXN0ZW5lcnMiLCJwcmVwZW5kQW55T3V0Z29pbmciLCJvZmZBbnlPdXRnb2luZyIsImxpc3RlbmVyc0FueU91dGdvaW5nIiwiQnJvYWRjYXN0T3BlcmF0b3IiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/socket.io/dist/socket.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/socket.io/dist/typed-events.js":
/*!*****************************************************!*\
  !*** ./node_modules/socket.io/dist/typed-events.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.StrictEventEmitter = void 0;\nconst events_1 = __webpack_require__(/*! events */ \"events\");\n/**\n * Strictly typed version of an `EventEmitter`. A `TypedEventEmitter` takes type\n * parameters for mappings of event names to event data types, and strictly\n * types method calls to the `EventEmitter` according to these event maps.\n *\n * @typeParam ListenEvents - `EventsMap` of user-defined events that can be\n * listened to with `on` or `once`\n * @typeParam EmitEvents - `EventsMap` of user-defined events that can be\n * emitted with `emit`\n * @typeParam ReservedEvents - `EventsMap` of reserved events, that can be\n * emitted by socket.io with `emitReserved`, and can be listened to with\n * `listen`.\n */ class StrictEventEmitter extends events_1.EventEmitter {\n    /**\n     * Adds the `listener` function as an event listener for `ev`.\n     *\n     * @param ev Name of the event\n     * @param listener Callback function\n     */ on(ev, listener) {\n        return super.on(ev, listener);\n    }\n    /**\n     * Adds a one-time `listener` function as an event listener for `ev`.\n     *\n     * @param ev Name of the event\n     * @param listener Callback function\n     */ once(ev, listener) {\n        return super.once(ev, listener);\n    }\n    /**\n     * Emits an event.\n     *\n     * @param ev Name of the event\n     * @param args Values to send to listeners of this event\n     */ emit(ev, ...args) {\n        return super.emit(ev, ...args);\n    }\n    /**\n     * Emits a reserved event.\n     *\n     * This method is `protected`, so that only a class extending\n     * `StrictEventEmitter` can emit its own reserved events.\n     *\n     * @param ev Reserved event name\n     * @param args Arguments to emit along with the event\n     */ emitReserved(ev, ...args) {\n        return super.emit(ev, ...args);\n    }\n    /**\n     * Emits an event.\n     *\n     * This method is `protected`, so that only a class extending\n     * `StrictEventEmitter` can get around the strict typing. This is useful for\n     * calling `emit.apply`, which can be called as `emitUntyped.apply`.\n     *\n     * @param ev Event name\n     * @param args Arguments to emit along with the event\n     */ emitUntyped(ev, ...args) {\n        return super.emit(ev, ...args);\n    }\n    /**\n     * Returns the listeners listening to an event.\n     *\n     * @param event Event name\n     * @returns Array of listeners subscribed to `event`\n     */ listeners(event) {\n        return super.listeners(event);\n    }\n}\nexports.StrictEventEmitter = StrictEventEmitter;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc29ja2V0LmlvL2Rpc3QvdHlwZWQtZXZlbnRzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCwwQkFBMEIsR0FBRyxLQUFLO0FBQ2xDLE1BQU1HLFdBQVdDLG1CQUFPQSxDQUFDLHNCQUFRO0FBQ2pDOzs7Ozs7Ozs7Ozs7Q0FZQyxHQUNELE1BQU1GLDJCQUEyQkMsU0FBU0UsWUFBWTtJQUNsRDs7Ozs7S0FLQyxHQUNEQyxHQUFHQyxFQUFFLEVBQUVDLFFBQVEsRUFBRTtRQUNiLE9BQU8sS0FBSyxDQUFDRixHQUFHQyxJQUFJQztJQUN4QjtJQUNBOzs7OztLQUtDLEdBQ0RDLEtBQUtGLEVBQUUsRUFBRUMsUUFBUSxFQUFFO1FBQ2YsT0FBTyxLQUFLLENBQUNDLEtBQUtGLElBQUlDO0lBQzFCO0lBQ0E7Ozs7O0tBS0MsR0FDREUsS0FBS0gsRUFBRSxFQUFFLEdBQUdJLElBQUksRUFBRTtRQUNkLE9BQU8sS0FBSyxDQUFDRCxLQUFLSCxPQUFPSTtJQUM3QjtJQUNBOzs7Ozs7OztLQVFDLEdBQ0RDLGFBQWFMLEVBQUUsRUFBRSxHQUFHSSxJQUFJLEVBQUU7UUFDdEIsT0FBTyxLQUFLLENBQUNELEtBQUtILE9BQU9JO0lBQzdCO0lBQ0E7Ozs7Ozs7OztLQVNDLEdBQ0RFLFlBQVlOLEVBQUUsRUFBRSxHQUFHSSxJQUFJLEVBQUU7UUFDckIsT0FBTyxLQUFLLENBQUNELEtBQUtILE9BQU9JO0lBQzdCO0lBQ0E7Ozs7O0tBS0MsR0FDREcsVUFBVUMsS0FBSyxFQUFFO1FBQ2IsT0FBTyxLQUFLLENBQUNELFVBQVVDO0lBQzNCO0FBQ0o7QUFDQWYsMEJBQTBCLEdBQUdFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZXhhbXJvc2gvLi9ub2RlX21vZHVsZXMvc29ja2V0LmlvL2Rpc3QvdHlwZWQtZXZlbnRzLmpzP2RjMjkiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlN0cmljdEV2ZW50RW1pdHRlciA9IHZvaWQgMDtcbmNvbnN0IGV2ZW50c18xID0gcmVxdWlyZShcImV2ZW50c1wiKTtcbi8qKlxuICogU3RyaWN0bHkgdHlwZWQgdmVyc2lvbiBvZiBhbiBgRXZlbnRFbWl0dGVyYC4gQSBgVHlwZWRFdmVudEVtaXR0ZXJgIHRha2VzIHR5cGVcbiAqIHBhcmFtZXRlcnMgZm9yIG1hcHBpbmdzIG9mIGV2ZW50IG5hbWVzIHRvIGV2ZW50IGRhdGEgdHlwZXMsIGFuZCBzdHJpY3RseVxuICogdHlwZXMgbWV0aG9kIGNhbGxzIHRvIHRoZSBgRXZlbnRFbWl0dGVyYCBhY2NvcmRpbmcgdG8gdGhlc2UgZXZlbnQgbWFwcy5cbiAqXG4gKiBAdHlwZVBhcmFtIExpc3RlbkV2ZW50cyAtIGBFdmVudHNNYXBgIG9mIHVzZXItZGVmaW5lZCBldmVudHMgdGhhdCBjYW4gYmVcbiAqIGxpc3RlbmVkIHRvIHdpdGggYG9uYCBvciBgb25jZWBcbiAqIEB0eXBlUGFyYW0gRW1pdEV2ZW50cyAtIGBFdmVudHNNYXBgIG9mIHVzZXItZGVmaW5lZCBldmVudHMgdGhhdCBjYW4gYmVcbiAqIGVtaXR0ZWQgd2l0aCBgZW1pdGBcbiAqIEB0eXBlUGFyYW0gUmVzZXJ2ZWRFdmVudHMgLSBgRXZlbnRzTWFwYCBvZiByZXNlcnZlZCBldmVudHMsIHRoYXQgY2FuIGJlXG4gKiBlbWl0dGVkIGJ5IHNvY2tldC5pbyB3aXRoIGBlbWl0UmVzZXJ2ZWRgLCBhbmQgY2FuIGJlIGxpc3RlbmVkIHRvIHdpdGhcbiAqIGBsaXN0ZW5gLlxuICovXG5jbGFzcyBTdHJpY3RFdmVudEVtaXR0ZXIgZXh0ZW5kcyBldmVudHNfMS5FdmVudEVtaXR0ZXIge1xuICAgIC8qKlxuICAgICAqIEFkZHMgdGhlIGBsaXN0ZW5lcmAgZnVuY3Rpb24gYXMgYW4gZXZlbnQgbGlzdGVuZXIgZm9yIGBldmAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZXYgTmFtZSBvZiB0aGUgZXZlbnRcbiAgICAgKiBAcGFyYW0gbGlzdGVuZXIgQ2FsbGJhY2sgZnVuY3Rpb25cbiAgICAgKi9cbiAgICBvbihldiwgbGlzdGVuZXIpIHtcbiAgICAgICAgcmV0dXJuIHN1cGVyLm9uKGV2LCBsaXN0ZW5lcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZHMgYSBvbmUtdGltZSBgbGlzdGVuZXJgIGZ1bmN0aW9uIGFzIGFuIGV2ZW50IGxpc3RlbmVyIGZvciBgZXZgLlxuICAgICAqXG4gICAgICogQHBhcmFtIGV2IE5hbWUgb2YgdGhlIGV2ZW50XG4gICAgICogQHBhcmFtIGxpc3RlbmVyIENhbGxiYWNrIGZ1bmN0aW9uXG4gICAgICovXG4gICAgb25jZShldiwgbGlzdGVuZXIpIHtcbiAgICAgICAgcmV0dXJuIHN1cGVyLm9uY2UoZXYsIGxpc3RlbmVyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRW1pdHMgYW4gZXZlbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZXYgTmFtZSBvZiB0aGUgZXZlbnRcbiAgICAgKiBAcGFyYW0gYXJncyBWYWx1ZXMgdG8gc2VuZCB0byBsaXN0ZW5lcnMgb2YgdGhpcyBldmVudFxuICAgICAqL1xuICAgIGVtaXQoZXYsIC4uLmFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIHN1cGVyLmVtaXQoZXYsIC4uLmFyZ3MpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFbWl0cyBhIHJlc2VydmVkIGV2ZW50LlxuICAgICAqXG4gICAgICogVGhpcyBtZXRob2QgaXMgYHByb3RlY3RlZGAsIHNvIHRoYXQgb25seSBhIGNsYXNzIGV4dGVuZGluZ1xuICAgICAqIGBTdHJpY3RFdmVudEVtaXR0ZXJgIGNhbiBlbWl0IGl0cyBvd24gcmVzZXJ2ZWQgZXZlbnRzLlxuICAgICAqXG4gICAgICogQHBhcmFtIGV2IFJlc2VydmVkIGV2ZW50IG5hbWVcbiAgICAgKiBAcGFyYW0gYXJncyBBcmd1bWVudHMgdG8gZW1pdCBhbG9uZyB3aXRoIHRoZSBldmVudFxuICAgICAqL1xuICAgIGVtaXRSZXNlcnZlZChldiwgLi4uYXJncykge1xuICAgICAgICByZXR1cm4gc3VwZXIuZW1pdChldiwgLi4uYXJncyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVtaXRzIGFuIGV2ZW50LlxuICAgICAqXG4gICAgICogVGhpcyBtZXRob2QgaXMgYHByb3RlY3RlZGAsIHNvIHRoYXQgb25seSBhIGNsYXNzIGV4dGVuZGluZ1xuICAgICAqIGBTdHJpY3RFdmVudEVtaXR0ZXJgIGNhbiBnZXQgYXJvdW5kIHRoZSBzdHJpY3QgdHlwaW5nLiBUaGlzIGlzIHVzZWZ1bCBmb3JcbiAgICAgKiBjYWxsaW5nIGBlbWl0LmFwcGx5YCwgd2hpY2ggY2FuIGJlIGNhbGxlZCBhcyBgZW1pdFVudHlwZWQuYXBwbHlgLlxuICAgICAqXG4gICAgICogQHBhcmFtIGV2IEV2ZW50IG5hbWVcbiAgICAgKiBAcGFyYW0gYXJncyBBcmd1bWVudHMgdG8gZW1pdCBhbG9uZyB3aXRoIHRoZSBldmVudFxuICAgICAqL1xuICAgIGVtaXRVbnR5cGVkKGV2LCAuLi5hcmdzKSB7XG4gICAgICAgIHJldHVybiBzdXBlci5lbWl0KGV2LCAuLi5hcmdzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbGlzdGVuZXJzIGxpc3RlbmluZyB0byBhbiBldmVudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBldmVudCBFdmVudCBuYW1lXG4gICAgICogQHJldHVybnMgQXJyYXkgb2YgbGlzdGVuZXJzIHN1YnNjcmliZWQgdG8gYGV2ZW50YFxuICAgICAqL1xuICAgIGxpc3RlbmVycyhldmVudCkge1xuICAgICAgICByZXR1cm4gc3VwZXIubGlzdGVuZXJzKGV2ZW50KTtcbiAgICB9XG59XG5leHBvcnRzLlN0cmljdEV2ZW50RW1pdHRlciA9IFN0cmljdEV2ZW50RW1pdHRlcjtcbiJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIlN0cmljdEV2ZW50RW1pdHRlciIsImV2ZW50c18xIiwicmVxdWlyZSIsIkV2ZW50RW1pdHRlciIsIm9uIiwiZXYiLCJsaXN0ZW5lciIsIm9uY2UiLCJlbWl0IiwiYXJncyIsImVtaXRSZXNlcnZlZCIsImVtaXRVbnR5cGVkIiwibGlzdGVuZXJzIiwiZXZlbnQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/socket.io/dist/typed-events.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/socket.io/dist/uws.js":
/*!********************************************!*\
  !*** ./node_modules/socket.io/dist/uws.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nvar __importDefault = (void 0) && (void 0).__importDefault || function(mod) {\n    return mod && mod.__esModule ? mod : {\n        \"default\": mod\n    };\n};\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.patchAdapter = patchAdapter;\nexports.restoreAdapter = restoreAdapter;\nexports.serveFile = serveFile;\nconst socket_io_adapter_1 = __webpack_require__(/*! socket.io-adapter */ \"(rsc)/./node_modules/socket.io-adapter/dist/index.js\");\nconst fs_1 = __webpack_require__(/*! fs */ \"fs\");\nconst debug_1 = __importDefault(__webpack_require__(/*! debug */ \"(rsc)/./node_modules/socket.io/node_modules/debug/src/index.js\"));\nconst debug = (0, debug_1.default)(\"socket.io:adapter-uws\");\nconst SEPARATOR = \"\\x1f\"; // see https://en.wikipedia.org/wiki/Delimiter#ASCII_delimited_text\nconst { addAll, del, broadcast } = socket_io_adapter_1.Adapter.prototype;\nfunction patchAdapter(app /* : TemplatedApp */ ) {\n    socket_io_adapter_1.Adapter.prototype.addAll = function(id, rooms) {\n        const isNew = !this.sids.has(id);\n        addAll.call(this, id, rooms);\n        const socket = this.nsp.sockets.get(id) || this.nsp._preConnectSockets.get(id);\n        if (!socket) {\n            return;\n        }\n        if (socket.conn.transport.name === \"websocket\") {\n            subscribe(this.nsp.name, socket, isNew, rooms);\n            return;\n        }\n        if (isNew) {\n            socket.conn.on(\"upgrade\", ()=>{\n                const rooms = this.sids.get(id);\n                if (rooms) {\n                    subscribe(this.nsp.name, socket, isNew, rooms);\n                }\n            });\n        }\n    };\n    socket_io_adapter_1.Adapter.prototype.del = function(id, room) {\n        del.call(this, id, room);\n        const socket = this.nsp.sockets.get(id) || this.nsp._preConnectSockets.get(id);\n        if (socket && socket.conn.transport.name === \"websocket\") {\n            // @ts-ignore\n            const sessionId = socket.conn.id;\n            // @ts-ignore\n            const websocket = socket.conn.transport.socket;\n            const topic = `${this.nsp.name}${SEPARATOR}${room}`;\n            debug(\"unsubscribe connection %s from topic %s\", sessionId, topic);\n            websocket.unsubscribe(topic);\n        }\n    };\n    socket_io_adapter_1.Adapter.prototype.broadcast = function(packet, opts) {\n        const useFastPublish = opts.rooms.size <= 1 && opts.except.size === 0;\n        if (!useFastPublish) {\n            broadcast.call(this, packet, opts);\n            return;\n        }\n        const flags = opts.flags || {};\n        const basePacketOpts = {\n            preEncoded: true,\n            volatile: flags.volatile,\n            compress: flags.compress\n        };\n        packet.nsp = this.nsp.name;\n        const encodedPackets = this.encoder.encode(packet);\n        const topic = opts.rooms.size === 0 ? this.nsp.name : `${this.nsp.name}${SEPARATOR}${opts.rooms.keys().next().value}`;\n        debug(\"fast publish to %s\", topic);\n        // fast publish for clients connected with WebSocket\n        encodedPackets.forEach((encodedPacket)=>{\n            const isBinary = typeof encodedPacket !== \"string\";\n            // \"4\" being the message type in the Engine.IO protocol, see https://github.com/socketio/engine.io-protocol\n            app.publish(topic, isBinary ? encodedPacket : \"4\" + encodedPacket, isBinary);\n        });\n        this.apply(opts, (socket)=>{\n            if (socket.conn.transport.name !== \"websocket\") {\n                // classic publish for clients connected with HTTP long-polling\n                socket.client.writeToEngine(encodedPackets, basePacketOpts);\n            }\n        });\n    };\n}\nfunction subscribe(namespaceName, socket, isNew, rooms) {\n    // @ts-ignore\n    const sessionId = socket.conn.id;\n    // @ts-ignore\n    const websocket = socket.conn.transport.socket;\n    if (isNew) {\n        debug(\"subscribe connection %s to topic %s\", sessionId, namespaceName);\n        websocket.subscribe(namespaceName);\n    }\n    rooms.forEach((room)=>{\n        const topic = `${namespaceName}${SEPARATOR}${room}`; // '#' can be used as wildcard\n        debug(\"subscribe connection %s to topic %s\", sessionId, topic);\n        websocket.subscribe(topic);\n    });\n}\nfunction restoreAdapter() {\n    socket_io_adapter_1.Adapter.prototype.addAll = addAll;\n    socket_io_adapter_1.Adapter.prototype.del = del;\n    socket_io_adapter_1.Adapter.prototype.broadcast = broadcast;\n}\nconst toArrayBuffer = (buffer)=>{\n    const { buffer: arrayBuffer, byteOffset, byteLength } = buffer;\n    return arrayBuffer.slice(byteOffset, byteOffset + byteLength);\n};\n// imported from https://github.com/kolodziejczak-sz/uwebsocket-serve\nfunction serveFile(res /* : HttpResponse */ , filepath) {\n    const { size } = (0, fs_1.statSync)(filepath);\n    const readStream = (0, fs_1.createReadStream)(filepath);\n    const destroyReadStream = ()=>!readStream.destroyed && readStream.destroy();\n    const onError = (error)=>{\n        destroyReadStream();\n        throw error;\n    };\n    const onDataChunk = (chunk)=>{\n        const arrayBufferChunk = toArrayBuffer(chunk);\n        res.cork(()=>{\n            const lastOffset = res.getWriteOffset();\n            const [ok, done] = res.tryEnd(arrayBufferChunk, size);\n            if (!done && !ok) {\n                readStream.pause();\n                res.onWritable((offset)=>{\n                    const [ok, done] = res.tryEnd(arrayBufferChunk.slice(offset - lastOffset), size);\n                    if (!done && ok) {\n                        readStream.resume();\n                    }\n                    return ok;\n                });\n            }\n        });\n    };\n    res.onAborted(destroyReadStream);\n    readStream.on(\"data\", onDataChunk).on(\"error\", onError).on(\"end\", destroyReadStream);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc29ja2V0LmlvL2Rpc3QvdXdzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsSUFBSUEsa0JBQWtCLENBQUMsTUFBRyxLQUFLLE9BQUcsRUFBRUEsZUFBZSxJQUFLLFNBQVVDLEdBQUc7SUFDakUsT0FBTyxPQUFRQSxJQUFJQyxVQUFVLEdBQUlELE1BQU07UUFBRSxXQUFXQTtJQUFJO0FBQzVEO0FBQ0FFLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxvQkFBb0IsR0FBR0U7QUFDdkJGLHNCQUFzQixHQUFHRztBQUN6QkgsaUJBQWlCLEdBQUdJO0FBQ3BCLE1BQU1DLHNCQUFzQkMsbUJBQU9BLENBQUMsK0VBQW1CO0FBQ3ZELE1BQU1DLE9BQU9ELG1CQUFPQSxDQUFDLGNBQUk7QUFDekIsTUFBTUUsVUFBVWIsZ0JBQWdCVyxtQkFBT0EsQ0FBQyw2RUFBTztBQUMvQyxNQUFNRyxRQUFRLENBQUMsR0FBR0QsUUFBUUUsT0FBTyxFQUFFO0FBQ25DLE1BQU1DLFlBQVksUUFBUSxtRUFBbUU7QUFDN0YsTUFBTSxFQUFFQyxNQUFNLEVBQUVDLEdBQUcsRUFBRUMsU0FBUyxFQUFFLEdBQUdULG9CQUFvQlUsT0FBTyxDQUFDQyxTQUFTO0FBQ3hFLFNBQVNkLGFBQWFlLElBQUksa0JBQWtCLEdBQW5CO0lBQ3JCWixvQkFBb0JVLE9BQU8sQ0FBQ0MsU0FBUyxDQUFDSixNQUFNLEdBQUcsU0FBVU0sRUFBRSxFQUFFQyxLQUFLO1FBQzlELE1BQU1DLFFBQVEsQ0FBQyxJQUFJLENBQUNDLElBQUksQ0FBQ0MsR0FBRyxDQUFDSjtRQUM3Qk4sT0FBT1csSUFBSSxDQUFDLElBQUksRUFBRUwsSUFBSUM7UUFDdEIsTUFBTUssU0FBUyxJQUFJLENBQUNDLEdBQUcsQ0FBQ0MsT0FBTyxDQUFDQyxHQUFHLENBQUNULE9BQU8sSUFBSSxDQUFDTyxHQUFHLENBQUNHLGtCQUFrQixDQUFDRCxHQUFHLENBQUNUO1FBQzNFLElBQUks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QyxHQUFHbkMsS0FBSytELFFBQVEsRUFBRUQ7SUFDcEMsTUFBTUUsYUFBYSxDQUFDLEdBQUdoRSxLQUFLaUUsZ0JBQWdCLEVBQUVIO0lBQzlDLE1BQU1JLG9CQUFvQixJQUFNLENBQUNGLFdBQVdHLFNBQVMsSUFBSUgsV0FBV0ksT0FBTztJQUMzRSxNQUFNQyxVQUFVLENBQUNDO1FBQ2JKO1FBQ0EsTUFBTUk7SUFDVjtJQUNBLE1BQU1DLGNBQWMsQ0FBQ0M7UUFDakIsTUFBTUMsbUJBQW1CbEIsY0FBY2lCO1FBQ3ZDWCxJQUFJYSxJQUFJLENBQUM7WUFDTCxNQUFNQyxhQUFhZCxJQUFJZSxjQUFjO1lBQ3JDLE1BQU0sQ0FBQ0MsSUFBSUMsS0FBSyxHQUFHakIsSUFBSWtCLE1BQU0sQ0FBQ04sa0JBQWtCdEM7WUFDaEQsSUFBSSxDQUFDMkMsUUFBUSxDQUFDRCxJQUFJO2dCQUNkYixXQUFXZ0IsS0FBSztnQkFDaEJuQixJQUFJb0IsVUFBVSxDQUFDLENBQUNDO29CQUNaLE1BQU0sQ0FBQ0wsSUFBSUMsS0FBSyxHQUFHakIsSUFBSWtCLE1BQU0sQ0FBQ04saUJBQWlCYixLQUFLLENBQUNzQixTQUFTUCxhQUFheEM7b0JBQzNFLElBQUksQ0FBQzJDLFFBQVFELElBQUk7d0JBQ2JiLFdBQVdtQixNQUFNO29CQUNyQjtvQkFDQSxPQUFPTjtnQkFDWDtZQUNKO1FBQ0o7SUFDSjtJQUNBaEIsSUFBSXVCLFNBQVMsQ0FBQ2xCO0lBQ2RGLFdBQ0t0QyxFQUFFLENBQUMsUUFBUTZDLGFBQ1g3QyxFQUFFLENBQUMsU0FBUzJDLFNBQ1ozQyxFQUFFLENBQUMsT0FBT3dDO0FBQ25CIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZXhhbXJvc2gvLi9ub2RlX21vZHVsZXMvc29ja2V0LmlvL2Rpc3QvdXdzLmpzPzBiZDYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnBhdGNoQWRhcHRlciA9IHBhdGNoQWRhcHRlcjtcbmV4cG9ydHMucmVzdG9yZUFkYXB0ZXIgPSByZXN0b3JlQWRhcHRlcjtcbmV4cG9ydHMuc2VydmVGaWxlID0gc2VydmVGaWxlO1xuY29uc3Qgc29ja2V0X2lvX2FkYXB0ZXJfMSA9IHJlcXVpcmUoXCJzb2NrZXQuaW8tYWRhcHRlclwiKTtcbmNvbnN0IGZzXzEgPSByZXF1aXJlKFwiZnNcIik7XG5jb25zdCBkZWJ1Z18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJkZWJ1Z1wiKSk7XG5jb25zdCBkZWJ1ZyA9ICgwLCBkZWJ1Z18xLmRlZmF1bHQpKFwic29ja2V0LmlvOmFkYXB0ZXItdXdzXCIpO1xuY29uc3QgU0VQQVJBVE9SID0gXCJcXHgxZlwiOyAvLyBzZWUgaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRGVsaW1pdGVyI0FTQ0lJX2RlbGltaXRlZF90ZXh0XG5jb25zdCB7IGFkZEFsbCwgZGVsLCBicm9hZGNhc3QgfSA9IHNvY2tldF9pb19hZGFwdGVyXzEuQWRhcHRlci5wcm90b3R5cGU7XG5mdW5jdGlvbiBwYXRjaEFkYXB0ZXIoYXBwIC8qIDogVGVtcGxhdGVkQXBwICovKSB7XG4gICAgc29ja2V0X2lvX2FkYXB0ZXJfMS5BZGFwdGVyLnByb3RvdHlwZS5hZGRBbGwgPSBmdW5jdGlvbiAoaWQsIHJvb21zKSB7XG4gICAgICAgIGNvbnN0IGlzTmV3ID0gIXRoaXMuc2lkcy5oYXMoaWQpO1xuICAgICAgICBhZGRBbGwuY2FsbCh0aGlzLCBpZCwgcm9vbXMpO1xuICAgICAgICBjb25zdCBzb2NrZXQgPSB0aGlzLm5zcC5zb2NrZXRzLmdldChpZCkgfHwgdGhpcy5uc3AuX3ByZUNvbm5lY3RTb2NrZXRzLmdldChpZCk7XG4gICAgICAgIGlmICghc29ja2V0KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNvY2tldC5jb25uLnRyYW5zcG9ydC5uYW1lID09PSBcIndlYnNvY2tldFwiKSB7XG4gICAgICAgICAgICBzdWJzY3JpYmUodGhpcy5uc3AubmFtZSwgc29ja2V0LCBpc05ldywgcm9vbXMpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc05ldykge1xuICAgICAgICAgICAgc29ja2V0LmNvbm4ub24oXCJ1cGdyYWRlXCIsICgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByb29tcyA9IHRoaXMuc2lkcy5nZXQoaWQpO1xuICAgICAgICAgICAgICAgIGlmIChyb29tcykge1xuICAgICAgICAgICAgICAgICAgICBzdWJzY3JpYmUodGhpcy5uc3AubmFtZSwgc29ja2V0LCBpc05ldywgcm9vbXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBzb2NrZXRfaW9fYWRhcHRlcl8xLkFkYXB0ZXIucHJvdG90eXBlLmRlbCA9IGZ1bmN0aW9uIChpZCwgcm9vbSkge1xuICAgICAgICBkZWwuY2FsbCh0aGlzLCBpZCwgcm9vbSk7XG4gICAgICAgIGNvbnN0IHNvY2tldCA9IHRoaXMubnNwLnNvY2tldHMuZ2V0KGlkKSB8fCB0aGlzLm5zcC5fcHJlQ29ubmVjdFNvY2tldHMuZ2V0KGlkKTtcbiAgICAgICAgaWYgKHNvY2tldCAmJiBzb2NrZXQuY29ubi50cmFuc3BvcnQubmFtZSA9PT0gXCJ3ZWJzb2NrZXRcIikge1xuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgY29uc3Qgc2Vzc2lvbklkID0gc29ja2V0LmNvbm4uaWQ7XG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICBjb25zdCB3ZWJzb2NrZXQgPSBzb2NrZXQuY29ubi50cmFuc3BvcnQuc29ja2V0O1xuICAgICAgICAgICAgY29uc3QgdG9waWMgPSBgJHt0aGlzLm5zcC5uYW1lfSR7U0VQQVJBVE9SfSR7cm9vbX1gO1xuICAgICAgICAgICAgZGVidWcoXCJ1bnN1YnNjcmliZSBjb25uZWN0aW9uICVzIGZyb20gdG9waWMgJXNcIiwgc2Vzc2lvbklkLCB0b3BpYyk7XG4gICAgICAgICAgICB3ZWJzb2NrZXQudW5zdWJzY3JpYmUodG9waWMpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBzb2NrZXRfaW9fYWRhcHRlcl8xLkFkYXB0ZXIucHJvdG90eXBlLmJyb2FkY2FzdCA9IGZ1bmN0aW9uIChwYWNrZXQsIG9wdHMpIHtcbiAgICAgICAgY29uc3QgdXNlRmFzdFB1Ymxpc2ggPSBvcHRzLnJvb21zLnNpemUgPD0gMSAmJiBvcHRzLmV4Y2VwdC5zaXplID09PSAwO1xuICAgICAgICBpZiAoIXVzZUZhc3RQdWJsaXNoKSB7XG4gICAgICAgICAgICBicm9hZGNhc3QuY2FsbCh0aGlzLCBwYWNrZXQsIG9wdHMpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGZsYWdzID0gb3B0cy5mbGFncyB8fCB7fTtcbiAgICAgICAgY29uc3QgYmFzZVBhY2tldE9wdHMgPSB7XG4gICAgICAgICAgICBwcmVFbmNvZGVkOiB0cnVlLFxuICAgICAgICAgICAgdm9sYXRpbGU6IGZsYWdzLnZvbGF0aWxlLFxuICAgICAgICAgICAgY29tcHJlc3M6IGZsYWdzLmNvbXByZXNzLFxuICAgICAgICB9O1xuICAgICAgICBwYWNrZXQubnNwID0gdGhpcy5uc3AubmFtZTtcbiAgICAgICAgY29uc3QgZW5jb2RlZFBhY2tldHMgPSB0aGlzLmVuY29kZXIuZW5jb2RlKHBhY2tldCk7XG4gICAgICAgIGNvbnN0IHRvcGljID0gb3B0cy5yb29tcy5zaXplID09PSAwXG4gICAgICAgICAgICA/IHRoaXMubnNwLm5hbWVcbiAgICAgICAgICAgIDogYCR7dGhpcy5uc3AubmFtZX0ke1NFUEFSQVRPUn0ke29wdHMucm9vbXMua2V5cygpLm5leHQoKS52YWx1ZX1gO1xuICAgICAgICBkZWJ1ZyhcImZhc3QgcHVibGlzaCB0byAlc1wiLCB0b3BpYyk7XG4gICAgICAgIC8vIGZhc3QgcHVibGlzaCBmb3IgY2xpZW50cyBjb25uZWN0ZWQgd2l0aCBXZWJTb2NrZXRcbiAgICAgICAgZW5jb2RlZFBhY2tldHMuZm9yRWFjaCgoZW5jb2RlZFBhY2tldCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgaXNCaW5hcnkgPSB0eXBlb2YgZW5jb2RlZFBhY2tldCAhPT0gXCJzdHJpbmdcIjtcbiAgICAgICAgICAgIC8vIFwiNFwiIGJlaW5nIHRoZSBtZXNzYWdlIHR5cGUgaW4gdGhlIEVuZ2luZS5JTyBwcm90b2NvbCwgc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9zb2NrZXRpby9lbmdpbmUuaW8tcHJvdG9jb2xcbiAgICAgICAgICAgIGFwcC5wdWJsaXNoKHRvcGljLCBpc0JpbmFyeSA/IGVuY29kZWRQYWNrZXQgOiBcIjRcIiArIGVuY29kZWRQYWNrZXQsIGlzQmluYXJ5KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuYXBwbHkob3B0cywgKHNvY2tldCkgPT4ge1xuICAgICAgICAgICAgaWYgKHNvY2tldC5jb25uLnRyYW5zcG9ydC5uYW1lICE9PSBcIndlYnNvY2tldFwiKSB7XG4gICAgICAgICAgICAgICAgLy8gY2xhc3NpYyBwdWJsaXNoIGZvciBjbGllbnRzIGNvbm5lY3RlZCB3aXRoIEhUVFAgbG9uZy1wb2xsaW5nXG4gICAgICAgICAgICAgICAgc29ja2V0LmNsaWVudC53cml0ZVRvRW5naW5lKGVuY29kZWRQYWNrZXRzLCBiYXNlUGFja2V0T3B0cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG59XG5mdW5jdGlvbiBzdWJzY3JpYmUobmFtZXNwYWNlTmFtZSwgc29ja2V0LCBpc05ldywgcm9vbXMpIHtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgY29uc3Qgc2Vzc2lvbklkID0gc29ja2V0LmNvbm4uaWQ7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIGNvbnN0IHdlYnNvY2tldCA9IHNvY2tldC5jb25uLnRyYW5zcG9ydC5zb2NrZXQ7XG4gICAgaWYgKGlzTmV3KSB7XG4gICAgICAgIGRlYnVnKFwic3Vic2NyaWJlIGNvbm5lY3Rpb24gJXMgdG8gdG9waWMgJXNcIiwgc2Vzc2lvbklkLCBuYW1lc3BhY2VOYW1lKTtcbiAgICAgICAgd2Vic29ja2V0LnN1YnNjcmliZShuYW1lc3BhY2VOYW1lKTtcbiAgICB9XG4gICAgcm9vbXMuZm9yRWFjaCgocm9vbSkgPT4ge1xuICAgICAgICBjb25zdCB0b3BpYyA9IGAke25hbWVzcGFjZU5hbWV9JHtTRVBBUkFUT1J9JHtyb29tfWA7IC8vICcjJyBjYW4gYmUgdXNlZCBhcyB3aWxkY2FyZFxuICAgICAgICBkZWJ1ZyhcInN1YnNjcmliZSBjb25uZWN0aW9uICVzIHRvIHRvcGljICVzXCIsIHNlc3Npb25JZCwgdG9waWMpO1xuICAgICAgICB3ZWJzb2NrZXQuc3Vic2NyaWJlKHRvcGljKTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIHJlc3RvcmVBZGFwdGVyKCkge1xuICAgIHNvY2tldF9pb19hZGFwdGVyXzEuQWRhcHRlci5wcm90b3R5cGUuYWRkQWxsID0gYWRkQWxsO1xuICAgIHNvY2tldF9pb19hZGFwdGVyXzEuQWRhcHRlci5wcm90b3R5cGUuZGVsID0gZGVsO1xuICAgIHNvY2tldF9pb19hZGFwdGVyXzEuQWRhcHRlci5wcm90b3R5cGUuYnJvYWRjYXN0ID0gYnJvYWRjYXN0O1xufVxuY29uc3QgdG9BcnJheUJ1ZmZlciA9IChidWZmZXIpID0+IHtcbiAgICBjb25zdCB7IGJ1ZmZlcjogYXJyYXlCdWZmZXIsIGJ5dGVPZmZzZXQsIGJ5dGVMZW5ndGggfSA9IGJ1ZmZlcjtcbiAgICByZXR1cm4gYXJyYXlCdWZmZXIuc2xpY2UoYnl0ZU9mZnNldCwgYnl0ZU9mZnNldCArIGJ5dGVMZW5ndGgpO1xufTtcbi8vIGltcG9ydGVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2tvbG9kemllamN6YWstc3ovdXdlYnNvY2tldC1zZXJ2ZVxuZnVuY3Rpb24gc2VydmVGaWxlKHJlcyAvKiA6IEh0dHBSZXNwb25zZSAqLywgZmlsZXBhdGgpIHtcbiAgICBjb25zdCB7IHNpemUgfSA9ICgwLCBmc18xLnN0YXRTeW5jKShmaWxlcGF0aCk7XG4gICAgY29uc3QgcmVhZFN0cmVhbSA9ICgwLCBmc18xLmNyZWF0ZVJlYWRTdHJlYW0pKGZpbGVwYXRoKTtcbiAgICBjb25zdCBkZXN0cm95UmVhZFN0cmVhbSA9ICgpID0+ICFyZWFkU3RyZWFtLmRlc3Ryb3llZCAmJiByZWFkU3RyZWFtLmRlc3Ryb3koKTtcbiAgICBjb25zdCBvbkVycm9yID0gKGVycm9yKSA9PiB7XG4gICAgICAgIGRlc3Ryb3lSZWFkU3RyZWFtKCk7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgIH07XG4gICAgY29uc3Qgb25EYXRhQ2h1bmsgPSAoY2h1bmspID0+IHtcbiAgICAgICAgY29uc3QgYXJyYXlCdWZmZXJDaHVuayA9IHRvQXJyYXlCdWZmZXIoY2h1bmspO1xuICAgICAgICByZXMuY29yaygoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBsYXN0T2Zmc2V0ID0gcmVzLmdldFdyaXRlT2Zmc2V0KCk7XG4gICAgICAgICAgICBjb25zdCBbb2ssIGRvbmVdID0gcmVzLnRyeUVuZChhcnJheUJ1ZmZlckNodW5rLCBzaXplKTtcbiAgICAgICAgICAgIGlmICghZG9uZSAmJiAhb2spIHtcbiAgICAgICAgICAgICAgICByZWFkU3RyZWFtLnBhdXNlKCk7XG4gICAgICAgICAgICAgICAgcmVzLm9uV3JpdGFibGUoKG9mZnNldCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBbb2ssIGRvbmVdID0gcmVzLnRyeUVuZChhcnJheUJ1ZmZlckNodW5rLnNsaWNlKG9mZnNldCAtIGxhc3RPZmZzZXQpLCBzaXplKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFkb25lICYmIG9rKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWFkU3RyZWFtLnJlc3VtZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvaztcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICByZXMub25BYm9ydGVkKGRlc3Ryb3lSZWFkU3RyZWFtKTtcbiAgICByZWFkU3RyZWFtXG4gICAgICAgIC5vbihcImRhdGFcIiwgb25EYXRhQ2h1bmspXG4gICAgICAgIC5vbihcImVycm9yXCIsIG9uRXJyb3IpXG4gICAgICAgIC5vbihcImVuZFwiLCBkZXN0cm95UmVhZFN0cmVhbSk7XG59XG4iXSwibmFtZXMiOlsiX19pbXBvcnREZWZhdWx0IiwibW9kIiwiX19lc01vZHVsZSIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwicGF0Y2hBZGFwdGVyIiwicmVzdG9yZUFkYXB0ZXIiLCJzZXJ2ZUZpbGUiLCJzb2NrZXRfaW9fYWRhcHRlcl8xIiwicmVxdWlyZSIsImZzXzEiLCJkZWJ1Z18xIiwiZGVidWciLCJkZWZhdWx0IiwiU0VQQVJBVE9SIiwiYWRkQWxsIiwiZGVsIiwiYnJvYWRjYXN0IiwiQWRhcHRlciIsInByb3RvdHlwZSIsImFwcCIsImlkIiwicm9vbXMiLCJpc05ldyIsInNpZHMiLCJoYXMiLCJjYWxsIiwic29ja2V0IiwibnNwIiwic29ja2V0cyIsImdldCIsIl9wcmVDb25uZWN0U29ja2V0cyIsImNvbm4iLCJ0cmFuc3BvcnQiLCJuYW1lIiwic3Vic2NyaWJlIiwib24iLCJyb29tIiwic2Vzc2lvbklkIiwid2Vic29ja2V0IiwidG9waWMiLCJ1bnN1YnNjcmliZSIsInBhY2tldCIsIm9wdHMiLCJ1c2VGYXN0UHVibGlzaCIsInNpemUiLCJleGNlcHQiLCJmbGFncyIsImJhc2VQYWNrZXRPcHRzIiwicHJlRW5jb2RlZCIsInZvbGF0aWxlIiwiY29tcHJlc3MiLCJlbmNvZGVkUGFja2V0cyIsImVuY29kZXIiLCJlbmNvZGUiLCJrZXlzIiwibmV4dCIsImZvckVhY2giLCJlbmNvZGVkUGFja2V0IiwiaXNCaW5hcnkiLCJwdWJsaXNoIiwiYXBwbHkiLCJjbGllbnQiLCJ3cml0ZVRvRW5naW5lIiwibmFtZXNwYWNlTmFtZSIsInRvQXJyYXlCdWZmZXIiLCJidWZmZXIiLCJhcnJheUJ1ZmZlciIsImJ5dGVPZmZzZXQiLCJieXRlTGVuZ3RoIiwic2xpY2UiLCJyZXMiLCJmaWxlcGF0aCIsInN0YXRTeW5jIiwicmVhZFN0cmVhbSIsImNyZWF0ZVJlYWRTdHJlYW0iLCJkZXN0cm95UmVhZFN0cmVhbSIsImRlc3Ryb3llZCIsImRlc3Ryb3kiLCJvbkVycm9yIiwiZXJyb3IiLCJvbkRhdGFDaHVuayIsImNodW5rIiwiYXJyYXlCdWZmZXJDaHVuayIsImNvcmsiLCJsYXN0T2Zmc2V0IiwiZ2V0V3JpdGVPZmZzZXQiLCJvayIsImRvbmUiLCJ0cnlFbmQiLCJwYXVzZSIsIm9uV3JpdGFibGUiLCJvZmZzZXQiLCJyZXN1bWUiLCJvbkFib3J0ZWQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/socket.io/dist/uws.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/socket.io/wrapper.mjs":
/*!********************************************!*\
  !*** ./node_modules/socket.io/wrapper.mjs ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Namespace: () => (/* binding */ Namespace),\n/* harmony export */   Server: () => (/* binding */ Server),\n/* harmony export */   Socket: () => (/* binding */ Socket)\n/* harmony export */ });\n/* harmony import */ var _dist_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dist/index.js */ \"(rsc)/./node_modules/socket.io/dist/index.js\");\n\nconst { Server, Namespace, Socket } = _dist_index_js__WEBPACK_IMPORTED_MODULE_0__;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc29ja2V0LmlvL3dyYXBwZXIubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBaUM7QUFFMUIsTUFBTSxFQUFDQyxNQUFNLEVBQUVDLFNBQVMsRUFBRUMsTUFBTSxFQUFDLEdBQUdILDJDQUFFQSxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZXhhbXJvc2gvLi9ub2RlX21vZHVsZXMvc29ja2V0LmlvL3dyYXBwZXIubWpzPzFkOTEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGlvIGZyb20gXCIuL2Rpc3QvaW5kZXguanNcIjtcblxuZXhwb3J0IGNvbnN0IHtTZXJ2ZXIsIE5hbWVzcGFjZSwgU29ja2V0fSA9IGlvO1xuIl0sIm5hbWVzIjpbImlvIiwiU2VydmVyIiwiTmFtZXNwYWNlIiwiU29ja2V0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/socket.io/wrapper.mjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/socket.io/package.json":
/*!*********************************************!*\
  !*** ./node_modules/socket.io/package.json ***!
  \*********************************************/
/***/ ((module) => {

module.exports = JSON.parse('{"name":"socket.io","version":"4.8.1","description":"node.js realtime framework server","keywords":["realtime","framework","websocket","tcp","events","socket","io"],"files":["dist/","client-dist/","wrapper.mjs","!**/*.tsbuildinfo"],"directories":{"doc":"docs/","example":"example/","lib":"lib/","test":"test/"},"type":"commonjs","main":"./dist/index.js","exports":{"types":"./dist/index.d.ts","import":"./wrapper.mjs","require":"./dist/index.js"},"types":"./dist/index.d.ts","license":"MIT","homepage":"https://github.com/socketio/socket.io/tree/main/packages/socket.io#readme","repository":{"type":"git","url":"git+https://github.com/socketio/socket.io.git"},"bugs":{"url":"https://github.com/socketio/socket.io/issues"},"scripts":{"compile":"rimraf ./dist && tsc","test":"npm run format:check && npm run compile && npm run test:types && npm run test:unit","test:types":"tsd","test:unit":"nyc mocha --require ts-node/register --reporter spec --slow 200 --bail --timeout 10000 test/index.ts","format:check":"prettier --check \\"lib/**/*.ts\\" \\"test/**/*.ts\\"","format:fix":"prettier --write \\"lib/**/*.ts\\" \\"test/**/*.ts\\"","prepack":"npm run compile"},"dependencies":{"accepts":"~1.3.4","base64id":"~2.0.0","cors":"~2.8.5","debug":"~4.3.2","engine.io":"~6.6.0","socket.io-adapter":"~2.5.2","socket.io-parser":"~4.2.4"},"contributors":[{"name":"Guillermo Rauch","email":"rauchg@gmail.com"},{"name":"Arnout Kazemier","email":"info@3rd-eden.com"},{"name":"Vladimir Dronnikov","email":"dronnikov@gmail.com"},{"name":"Einar Otto Stangvik","email":"einaros@gmail.com"}],"engines":{"node":">=10.2.0"},"tsd":{"directory":"test"}}');

/***/ })

};
;