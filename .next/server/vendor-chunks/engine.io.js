"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/engine.io";
exports.ids = ["vendor-chunks/engine.io"];
exports.modules = {

/***/ "(rsc)/./node_modules/engine.io/node_modules/debug/src/browser.js":
/*!******************************************************************!*\
  !*** ./node_modules/engine.io/node_modules/debug/src/browser.js ***!
  \******************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("/* eslint-env browser */ /**\n * This is the web browser implementation of `debug()`.\n */ \nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\nexports.storage = localstorage();\nexports.destroy = (()=>{\n    let warned = false;\n    return ()=>{\n        if (!warned) {\n            warned = true;\n            console.warn(\"Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.\");\n        }\n    };\n})();\n/**\n * Colors.\n */ exports.colors = [\n    \"#0000CC\",\n    \"#0000FF\",\n    \"#0033CC\",\n    \"#0033FF\",\n    \"#0066CC\",\n    \"#0066FF\",\n    \"#0099CC\",\n    \"#0099FF\",\n    \"#00CC00\",\n    \"#00CC33\",\n    \"#00CC66\",\n    \"#00CC99\",\n    \"#00CCCC\",\n    \"#00CCFF\",\n    \"#3300CC\",\n    \"#3300FF\",\n    \"#3333CC\",\n    \"#3333FF\",\n    \"#3366CC\",\n    \"#3366FF\",\n    \"#3399CC\",\n    \"#3399FF\",\n    \"#33CC00\",\n    \"#33CC33\",\n    \"#33CC66\",\n    \"#33CC99\",\n    \"#33CCCC\",\n    \"#33CCFF\",\n    \"#6600CC\",\n    \"#6600FF\",\n    \"#6633CC\",\n    \"#6633FF\",\n    \"#66CC00\",\n    \"#66CC33\",\n    \"#9900CC\",\n    \"#9900FF\",\n    \"#9933CC\",\n    \"#9933FF\",\n    \"#99CC00\",\n    \"#99CC33\",\n    \"#CC0000\",\n    \"#CC0033\",\n    \"#CC0066\",\n    \"#CC0099\",\n    \"#CC00CC\",\n    \"#CC00FF\",\n    \"#CC3300\",\n    \"#CC3333\",\n    \"#CC3366\",\n    \"#CC3399\",\n    \"#CC33CC\",\n    \"#CC33FF\",\n    \"#CC6600\",\n    \"#CC6633\",\n    \"#CC9900\",\n    \"#CC9933\",\n    \"#CCCC00\",\n    \"#CCCC33\",\n    \"#FF0000\",\n    \"#FF0033\",\n    \"#FF0066\",\n    \"#FF0099\",\n    \"#FF00CC\",\n    \"#FF00FF\",\n    \"#FF3300\",\n    \"#FF3333\",\n    \"#FF3366\",\n    \"#FF3399\",\n    \"#FF33CC\",\n    \"#FF33FF\",\n    \"#FF6600\",\n    \"#FF6633\",\n    \"#FF9900\",\n    \"#FF9933\",\n    \"#FFCC00\",\n    \"#FFCC33\"\n];\n/**\n * Currently only WebKit-based Web Inspectors, Firefox >= v31,\n * and the Firebug extension (any Firefox version) are known\n * to support \"%c\" CSS customizations.\n *\n * TODO: add a `localStorage` variable to explicitly enable/disable colors\n */ // eslint-disable-next-line complexity\nfunction useColors() {\n    // NB: In an Electron preload script, document will be defined but not fully\n    // initialized. Since we know we're in Chrome, we'll just detect this case\n    // explicitly\n    if (false) {}\n    // Internet Explorer and Edge do not support colors.\n    if (typeof navigator !== \"undefined\" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\\/(\\d+)/)) {\n        return false;\n    }\n    let m;\n    // Is webkit? http://stackoverflow.com/a/16459606/376773\n    // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632\n    return typeof document !== \"undefined\" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773\n     false && (0) || // Is firefox >= v31?\n    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\n    typeof navigator !== \"undefined\" && navigator.userAgent && (m = navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/)) && parseInt(m[1], 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker\n    typeof navigator !== \"undefined\" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\\/(\\d+)/);\n}\n/**\n * Colorize log arguments if enabled.\n *\n * @api public\n */ function formatArgs(args) {\n    args[0] = (this.useColors ? \"%c\" : \"\") + this.namespace + (this.useColors ? \" %c\" : \" \") + args[0] + (this.useColors ? \"%c \" : \" \") + \"+\" + module.exports.humanize(this.diff);\n    if (!this.useColors) {\n        return;\n    }\n    const c = \"color: \" + this.color;\n    args.splice(1, 0, c, \"color: inherit\");\n    // The final \"%c\" is somewhat tricky, because there could be other\n    // arguments passed either before or after the %c, so we need to\n    // figure out the correct index to insert the CSS into\n    let index = 0;\n    let lastC = 0;\n    args[0].replace(/%[a-zA-Z%]/g, (match)=>{\n        if (match === \"%%\") {\n            return;\n        }\n        index++;\n        if (match === \"%c\") {\n            // We only are interested in the *last* %c\n            // (the user may have provided their own)\n            lastC = index;\n        }\n    });\n    args.splice(lastC, 0, c);\n}\n/**\n * Invokes `console.debug()` when available.\n * No-op when `console.debug` is not a \"function\".\n * If `console.debug` is not available, falls back\n * to `console.log`.\n *\n * @api public\n */ exports.log = console.debug || console.log || (()=>{});\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */ function save(namespaces) {\n    try {\n        if (namespaces) {\n            exports.storage.setItem(\"debug\", namespaces);\n        } else {\n            exports.storage.removeItem(\"debug\");\n        }\n    } catch (error) {\n    // Swallow\n    // XXX (@Qix-) should we be logging these?\n    }\n}\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */ function load() {\n    let r;\n    try {\n        r = exports.storage.getItem(\"debug\");\n    } catch (error) {\n    // Swallow\n    // XXX (@Qix-) should we be logging these?\n    }\n    // If debug isn't set in LS, and we're in Electron, try to load $DEBUG\n    if (!r && typeof process !== \"undefined\" && \"env\" in process) {\n        r = process.env.DEBUG;\n    }\n    return r;\n}\n/**\n * Localstorage attempts to return the localstorage.\n *\n * This is necessary because safari throws\n * when a user disables cookies/localstorage\n * and you attempt to access it.\n *\n * @return {LocalStorage}\n * @api private\n */ function localstorage() {\n    try {\n        // TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context\n        // The Browser also has localStorage in the global context.\n        return localStorage;\n    } catch (error) {\n    // Swallow\n    // XXX (@Qix-) should we be logging these?\n    }\n}\nmodule.exports = __webpack_require__(/*! ./common */ \"(rsc)/./node_modules/engine.io/node_modules/debug/src/common.js\")(exports);\nconst { formatters } = module.exports;\n/**\n * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\n */ formatters.j = function(v) {\n    try {\n        return JSON.stringify(v);\n    } catch (error) {\n        return \"[UnexpectedJSONParseError]: \" + error.message;\n    }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZW5naW5lLmlvL25vZGVfbW9kdWxlcy9kZWJ1Zy9zcmMvYnJvd3Nlci5qcyIsIm1hcHBpbmdzIjoiQUFBQSxzQkFBc0IsR0FFdEI7O0NBRUM7QUFFREEsa0JBQWtCLEdBQUdDO0FBQ3JCRCxZQUFZLEdBQUdFO0FBQ2ZGLFlBQVksR0FBR0c7QUFDZkgsaUJBQWlCLEdBQUdJO0FBQ3BCSixlQUFlLEdBQUdNO0FBQ2xCTixlQUFlLEdBQUcsQ0FBQztJQUNsQixJQUFJUSxTQUFTO0lBRWIsT0FBTztRQUNOLElBQUksQ0FBQ0EsUUFBUTtZQUNaQSxTQUFTO1lBQ1RDLFFBQVFDLElBQUksQ0FBQztRQUNkO0lBQ0Q7QUFDRDtBQUVBOztDQUVDLEdBRURWLGNBQWMsR0FBRztJQUNoQjtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtDQUNBO0FBRUQ7Ozs7OztDQU1DLEdBRUQsc0NBQXNDO0FBQ3RDLFNBQVNJO0lBQ1IsNEVBQTRFO0lBQzVFLDBFQUEwRTtJQUMxRSxhQUFhO0lBQ2IsSUFBSSxLQUFnSCxFQUFFLEVBRXJIO0lBRUQsb0RBQW9EO0lBQ3BELElBQUksT0FBT1ksY0FBYyxlQUFlQSxVQUFVQyxTQUFTLElB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RDtRQUMzRCxPQUFPNEM7SUFDUixFQUFFLE9BQU9MLE9BQU87SUFDZixVQUFVO0lBQ1YsMENBQTBDO0lBQzNDO0FBQ0Q7QUFFQWQsT0FBTy9CLE9BQU8sR0FBR21ELG1CQUFPQSxDQUFDLG1GQUFZbkQ7QUFFckMsTUFBTSxFQUFDb0QsVUFBVSxFQUFDLEdBQUdyQixPQUFPL0IsT0FBTztBQUVuQzs7Q0FFQyxHQUVEb0QsV0FBV0MsQ0FBQyxHQUFHLFNBQVVDLENBQUM7SUFDekIsSUFBSTtRQUNILE9BQU9DLEtBQUtDLFNBQVMsQ0FBQ0Y7SUFDdkIsRUFBRSxPQUFPVCxPQUFPO1FBQ2YsT0FBTyxpQ0FBaUNBLE1BQU1ZLE9BQU87SUFDdEQ7QUFDRCIsInNvdXJjZXMiOlsid2VicGFjazovL2V4YW1yb3NoLy4vbm9kZV9tb2R1bGVzL2VuZ2luZS5pby9ub2RlX21vZHVsZXMvZGVidWcvc3JjL2Jyb3dzZXIuanM/NWNhMCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiBlc2xpbnQtZW52IGJyb3dzZXIgKi9cblxuLyoqXG4gKiBUaGlzIGlzIHRoZSB3ZWIgYnJvd3NlciBpbXBsZW1lbnRhdGlvbiBvZiBgZGVidWcoKWAuXG4gKi9cblxuZXhwb3J0cy5mb3JtYXRBcmdzID0gZm9ybWF0QXJncztcbmV4cG9ydHMuc2F2ZSA9IHNhdmU7XG5leHBvcnRzLmxvYWQgPSBsb2FkO1xuZXhwb3J0cy51c2VDb2xvcnMgPSB1c2VDb2xvcnM7XG5leHBvcnRzLnN0b3JhZ2UgPSBsb2NhbHN0b3JhZ2UoKTtcbmV4cG9ydHMuZGVzdHJveSA9ICgoKSA9PiB7XG5cdGxldCB3YXJuZWQgPSBmYWxzZTtcblxuXHRyZXR1cm4gKCkgPT4ge1xuXHRcdGlmICghd2FybmVkKSB7XG5cdFx0XHR3YXJuZWQgPSB0cnVlO1xuXHRcdFx0Y29uc29sZS53YXJuKCdJbnN0YW5jZSBtZXRob2QgYGRlYnVnLmRlc3Ryb3koKWAgaXMgZGVwcmVjYXRlZCBhbmQgbm8gbG9uZ2VyIGRvZXMgYW55dGhpbmcuIEl0IHdpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgbmV4dCBtYWpvciB2ZXJzaW9uIG9mIGBkZWJ1Z2AuJyk7XG5cdFx0fVxuXHR9O1xufSkoKTtcblxuLyoqXG4gKiBDb2xvcnMuXG4gKi9cblxuZXhwb3J0cy5jb2xvcnMgPSBbXG5cdCcjMDAwMENDJyxcblx0JyMwMDAwRkYnLFxuXHQnIzAwMzNDQycsXG5cdCcjMDAzM0ZGJyxcblx0JyMwMDY2Q0MnLFxuXHQnIzAwNjZGRicsXG5cdCcjMDA5OUNDJyxcblx0JyMwMDk5RkYnLFxuXHQnIzAwQ0MwMCcsXG5cdCcjMDBDQzMzJyxcblx0JyMwMENDNjYnLFxuXHQnIzAwQ0M5OScsXG5cdCcjMDBDQ0NDJyxcblx0JyMwMENDRkYnLFxuXHQnIzMzMDBDQycsXG5cdCcjMzMwMEZGJyxcblx0JyMzMzMzQ0MnLFxuXHQnIzMzMzNGRicsXG5cdCcjMzM2NkNDJyxcblx0JyMzMzY2RkYnLFxuXHQnIzMzOTlDQycsXG5cdCcjMzM5OUZGJyxcblx0JyMzM0NDMDAnLFxuXHQnIzMzQ0MzMycsXG5cdCcjMzNDQzY2Jyxcblx0JyMzM0NDOTknLFxuXHQnIzMzQ0NDQycsXG5cdCcjMzNDQ0ZGJyxcblx0JyM2NjAwQ0MnLFxuXHQnIzY2MDBGRicsXG5cdCcjNjYzM0NDJyxcblx0JyM2NjMzRkYnLFxuXHQnIzY2Q0MwMCcsXG5cdCcjNjZDQzMzJyxcblx0JyM5OTAwQ0MnLFxuXHQnIzk5MDBGRicsXG5cdCcjOTkzM0NDJyxcblx0JyM5OTMzRkYnLFxuXHQnIzk5Q0MwMCcsXG5cdCcjOTlDQzMzJyxcblx0JyNDQzAwMDAnLFxuXHQnI0NDMDAzMycsXG5cdCcjQ0MwMDY2Jyxcblx0JyNDQzAwOTknLFxuXHQnI0NDMDBDQycsXG5cdCcjQ0MwMEZGJyxcblx0JyNDQzMzMDAnLFxuXHQnI0NDMzMzMycsXG5cdCcjQ0MzMzY2Jyxcblx0JyNDQzMzOTknLFxuXHQnI0NDMzNDQycsXG5cdCcjQ0MzM0ZGJyxcblx0JyNDQzY2MDAnLFxuXHQnI0NDNjYzMycsXG5cdCcjQ0M5OTAwJyxcblx0JyNDQzk5MzMnLFxuXHQnI0NDQ0MwMCcsXG5cdCcjQ0NDQzMzJyxcblx0JyNGRjAwMDAnLFxuXHQnI0ZGMDAzMycsXG5cdCcjRkYwMDY2Jyxcblx0JyNGRjAwOTknLFxuXHQnI0ZGMDBDQycsXG5cdCcjRkYwMEZGJyxcblx0JyNGRjMzMDAnLFxuXHQnI0ZGMzMzMycsXG5cdCcjRkYzMzY2Jyxcblx0JyNGRjMzOTknLFxuXHQnI0ZGMzNDQycsXG5cdCcjRkYzM0ZGJyxcblx0JyNGRjY2MDAnLFxuXHQnI0ZGNjYzMycsXG5cdCcjRkY5OTAwJyxcblx0JyNGRjk5MzMnLFxuXHQnI0ZGQ0MwMCcsXG5cdCcjRkZDQzMzJ1xuXTtcblxuLyoqXG4gKiBDdXJyZW50bHkgb25seSBXZWJLaXQtYmFzZWQgV2ViIEluc3BlY3RvcnMsIEZpcmVmb3ggPj0gdjMxLFxuICogYW5kIHRoZSBGaXJlYnVnIGV4dGVuc2lvbiAoYW55IEZpcmVmb3ggdmVyc2lvbikgYXJlIGtub3duXG4gKiB0byBzdXBwb3J0IFwiJWNcIiBDU1MgY3VzdG9taXphdGlvbnMuXG4gKlxuICogVE9ETzogYWRkIGEgYGxvY2FsU3RvcmFnZWAgdmFyaWFibGUgdG8gZXhwbGljaXRseSBlbmFibGUvZGlzYWJsZSBjb2xvcnNcbiAqL1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29tcGxleGl0eVxuZnVuY3Rpb24gdXNlQ29sb3JzKCkge1xuXHQvLyBOQjogSW4gYW4gRWxlY3Ryb24gcHJlbG9hZCBzY3JpcHQsIGRvY3VtZW50IHdpbGwgYmUgZGVmaW5lZCBidXQgbm90IGZ1bGx5XG5cdC8vIGluaXRpYWxpemVkLiBTaW5jZSB3ZSBrbm93IHdlJ3JlIGluIENocm9tZSwgd2UnbGwganVzdCBkZXRlY3QgdGhpcyBjYXNlXG5cdC8vIGV4cGxpY2l0bHlcblx0aWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5wcm9jZXNzICYmICh3aW5kb3cucHJvY2Vzcy50eXBlID09PSAncmVuZGVyZXInIHx8IHdpbmRvdy5wcm9jZXNzLl9fbndqcykpIHtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXG5cdC8vIEludGVybmV0IEV4cGxvcmVyIGFuZCBFZGdlIGRvIG5vdCBzdXBwb3J0IGNvbG9ycy5cblx0aWYgKHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIG5hdmlnYXRvci51c2VyQWdlbnQgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLm1hdGNoKC8oZWRnZXx0cmlkZW50KVxcLyhcXGQrKS8pKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cblx0bGV0IG07XG5cblx0Ly8gSXMgd2Via2l0PyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8xNjQ1OTYwNi8zNzY3NzNcblx0Ly8gZG9jdW1lbnQgaXMgdW5kZWZpbmVkIGluIHJlYWN0LW5hdGl2ZTogaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0LW5hdGl2ZS9wdWxsLzE2MzJcblx0cmV0dXJuICh0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlLldlYmtpdEFwcGVhcmFuY2UpIHx8XG5cdFx0Ly8gSXMgZmlyZWJ1Zz8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMzk4MTIwLzM3Njc3M1xuXHRcdCh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuY29uc29sZSAmJiAod2luZG93LmNvbnNvbGUuZmlyZWJ1ZyB8fCAod2luZG93LmNvbnNvbGUuZXhjZXB0aW9uICYmIHdpbmRvdy5jb25zb2xlLnRhYmxlKSkpIHx8XG5cdFx0Ly8gSXMgZmlyZWZveCA+PSB2MzE/XG5cdFx0Ly8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9Ub29scy9XZWJfQ29uc29sZSNTdHlsaW5nX21lc3NhZ2VzXG5cdFx0KHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIG5hdmlnYXRvci51c2VyQWdlbnQgJiYgKG0gPSBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkubWF0Y2goL2ZpcmVmb3hcXC8oXFxkKykvKSkgJiYgcGFyc2VJbnQobVsxXSwgMTApID49IDMxKSB8fFxuXHRcdC8vIERvdWJsZSBjaGVjayB3ZWJraXQgaW4gdXNlckFnZW50IGp1c3QgaW4gY2FzZSB3ZSBhcmUgaW4gYSB3b3JrZXJcblx0XHQodHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudCAmJiBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkubWF0Y2goL2FwcGxld2Via2l0XFwvKFxcZCspLykpO1xufVxuXG4vKipcbiAqIENvbG9yaXplIGxvZyBhcmd1bWVudHMgaWYgZW5hYmxlZC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGZvcm1hdEFyZ3MoYXJncykge1xuXHRhcmdzWzBdID0gKHRoaXMudXNlQ29sb3JzID8gJyVjJyA6ICcnKSArXG5cdFx0dGhpcy5uYW1lc3BhY2UgK1xuXHRcdCh0aGlzLnVzZUNvbG9ycyA/ICcgJWMnIDogJyAnKSArXG5cdFx0YXJnc1swXSArXG5cdFx0KHRoaXMudXNlQ29sb3JzID8gJyVjICcgOiAnICcpICtcblx0XHQnKycgKyBtb2R1bGUuZXhwb3J0cy5odW1hbml6ZSh0aGlzLmRpZmYpO1xuXG5cdGlmICghdGhpcy51c2VDb2xvcnMpIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHRjb25zdCBjID0gJ2NvbG9yOiAnICsgdGhpcy5jb2xvcjtcblx0YXJncy5zcGxpY2UoMSwgMCwgYywgJ2NvbG9yOiBpbmhlcml0Jyk7XG5cblx0Ly8gVGhlIGZpbmFsIFwiJWNcIiBpcyBzb21ld2hhdCB0cmlja3ksIGJlY2F1c2UgdGhlcmUgY291bGQgYmUgb3RoZXJcblx0Ly8gYXJndW1lbnRzIHBhc3NlZCBlaXRoZXIgYmVmb3JlIG9yIGFmdGVyIHRoZSAlYywgc28gd2UgbmVlZCB0b1xuXHQvLyBmaWd1cmUgb3V0IHRoZSBjb3JyZWN0IGluZGV4IHRvIGluc2VydCB0aGUgQ1NTIGludG9cblx0bGV0IGluZGV4ID0gMDtcblx0bGV0IGxhc3RDID0gMDtcblx0YXJnc1swXS5yZXBsYWNlKC8lW2EtekEtWiVdL2csIG1hdGNoID0+IHtcblx0XHRpZiAobWF0Y2ggPT09ICclJScpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0aW5kZXgrKztcblx0XHRpZiAobWF0Y2ggPT09ICclYycpIHtcblx0XHRcdC8vIFdlIG9ubHkgYXJlIGludGVyZXN0ZWQgaW4gdGhlICpsYXN0KiAlY1xuXHRcdFx0Ly8gKHRoZSB1c2VyIG1heSBoYXZlIHByb3ZpZGVkIHRoZWlyIG93bilcblx0XHRcdGxhc3RDID0gaW5kZXg7XG5cdFx0fVxuXHR9KTtcblxuXHRhcmdzLnNwbGljZShsYXN0QywgMCwgYyk7XG59XG5cbi8qKlxuICogSW52b2tlcyBgY29uc29sZS5kZWJ1ZygpYCB3aGVuIGF2YWlsYWJsZS5cbiAqIE5vLW9wIHdoZW4gYGNvbnNvbGUuZGVidWdgIGlzIG5vdCBhIFwiZnVuY3Rpb25cIi5cbiAqIElmIGBjb25zb2xlLmRlYnVnYCBpcyBub3QgYXZhaWxhYmxlLCBmYWxscyBiYWNrXG4gKiB0byBgY29uc29sZS5sb2dgLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cbmV4cG9ydHMubG9nID0gY29uc29sZS5kZWJ1ZyB8fCBjb25zb2xlLmxvZyB8fCAoKCkgPT4ge30pO1xuXG4vKipcbiAqIFNhdmUgYG5hbWVzcGFjZXNgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gc2F2ZShuYW1lc3BhY2VzKSB7XG5cdHRyeSB7XG5cdFx0aWYgKG5hbWVzcGFjZXMpIHtcblx0XHRcdGV4cG9ydHMuc3RvcmFnZS5zZXRJdGVtKCdkZWJ1ZycsIG5hbWVzcGFjZXMpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRleHBvcnRzLnN0b3JhZ2UucmVtb3ZlSXRlbSgnZGVidWcnKTtcblx0XHR9XG5cdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0Ly8gU3dhbGxvd1xuXHRcdC8vIFhYWCAoQFFpeC0pIHNob3VsZCB3ZSBiZSBsb2dnaW5nIHRoZXNlP1xuXHR9XG59XG5cbi8qKlxuICogTG9hZCBgbmFtZXNwYWNlc2AuXG4gKlxuICogQHJldHVybiB7U3RyaW5nfSByZXR1cm5zIHRoZSBwcmV2aW91c2x5IHBlcnNpc3RlZCBkZWJ1ZyBtb2Rlc1xuICogQGFwaSBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGxvYWQoKSB7XG5cdGxldCByO1xuXHR0cnkge1xuXHRcdHIgPSBleHBvcnRzLnN0b3JhZ2UuZ2V0SXRlbSgnZGVidWcnKTtcblx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHQvLyBTd2FsbG93XG5cdFx0Ly8gWFhYIChAUWl4LSkgc2hvdWxkIHdlIGJlIGxvZ2dpbmcgdGhlc2U/XG5cdH1cblxuXHQvLyBJZiBkZWJ1ZyBpc24ndCBzZXQgaW4gTFMsIGFuZCB3ZSdyZSBpbiBFbGVjdHJvbiwgdHJ5IHRvIGxvYWQgJERFQlVHXG5cdGlmICghciAmJiB0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiYgJ2VudicgaW4gcHJvY2Vzcykge1xuXHRcdHIgPSBwcm9jZXNzLmVudi5ERUJVRztcblx0fVxuXG5cdHJldHVybiByO1xufVxuXG4vKipcbiAqIExvY2Fsc3RvcmFnZSBhdHRlbXB0cyB0byByZXR1cm4gdGhlIGxvY2Fsc3RvcmFnZS5cbiAqXG4gKiBUaGlzIGlzIG5lY2Vzc2FyeSBiZWNhdXNlIHNhZmFyaSB0aHJvd3NcbiAqIHdoZW4gYSB1c2VyIGRpc2FibGVzIGNvb2tpZXMvbG9jYWxzdG9yYWdlXG4gKiBhbmQgeW91IGF0dGVtcHQgdG8gYWNjZXNzIGl0LlxuICpcbiAqIEByZXR1cm4ge0xvY2FsU3RvcmFnZX1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGxvY2Fsc3RvcmFnZSgpIHtcblx0dHJ5IHtcblx0XHQvLyBUVk1MS2l0IChBcHBsZSBUViBKUyBSdW50aW1lKSBkb2VzIG5vdCBoYXZlIGEgd2luZG93IG9iamVjdCwganVzdCBsb2NhbFN0b3JhZ2UgaW4gdGhlIGdsb2JhbCBjb250ZXh0XG5cdFx0Ly8gVGhlIEJyb3dzZXIgYWxzbyBoYXMgbG9jYWxTdG9yYWdlIGluIHRoZSBnbG9iYWwgY29udGV4dC5cblx0XHRyZXR1cm4gbG9jYWxTdG9yYWdlO1xuXHR9IGNhdGNoIChlcnJvcikge1xuXHRcdC8vIFN3YWxsb3dcblx0XHQvLyBYWFggKEBRaXgtKSBzaG91bGQgd2UgYmUgbG9nZ2luZyB0aGVzZT9cblx0fVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY29tbW9uJykoZXhwb3J0cyk7XG5cbmNvbnN0IHtmb3JtYXR0ZXJzfSA9IG1vZHVsZS5leHBvcnRzO1xuXG4vKipcbiAqIE1hcCAlaiB0byBgSlNPTi5zdHJpbmdpZnkoKWAsIHNpbmNlIG5vIFdlYiBJbnNwZWN0b3JzIGRvIHRoYXQgYnkgZGVmYXVsdC5cbiAqL1xuXG5mb3JtYXR0ZXJzLmogPSBmdW5jdGlvbiAodikge1xuXHR0cnkge1xuXHRcdHJldHVybiBKU09OLnN0cmluZ2lmeSh2KTtcblx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRyZXR1cm4gJ1tVbmV4cGVjdGVkSlNPTlBhcnNlRXJyb3JdOiAnICsgZXJyb3IubWVzc2FnZTtcblx0fVxufTtcbiJdLCJuYW1lcyI6WyJleHBvcnRzIiwiZm9ybWF0QXJncyIsInNhdmUiLCJsb2FkIiwidXNlQ29sb3JzIiwic3RvcmFnZSIsImxvY2Fsc3RvcmFnZSIsImRlc3Ryb3kiLCJ3YXJuZWQiLCJjb25zb2xlIiwid2FybiIsImNvbG9ycyIsIndpbmRvdyIsInByb2Nlc3MiLCJ0eXBlIiwiX19ud2pzIiwibmF2aWdhdG9yIiwidXNlckFnZW50IiwidG9Mb3dlckNhc2UiLCJtYXRjaCIsIm0iLCJkb2N1bWVudCIsImRvY3VtZW50RWxlbWVudCIsInN0eWxlIiwiV2Via2l0QXBwZWFyYW5jZSIsImZpcmVidWciLCJleGNlcHRpb24iLCJ0YWJsZSIsInBhcnNlSW50IiwiYXJncyIsIm5hbWVzcGFjZSIsIm1vZHVsZSIsImh1bWFuaXplIiwiZGlmZiIsImMiLCJjb2xvciIsInNwbGljZSIsImluZGV4IiwibGFzdEMiLCJyZXBsYWNlIiwibG9nIiwiZGVidWciLCJuYW1lc3BhY2VzIiwic2V0SXRlbSIsInJlbW92ZUl0ZW0iLCJlcnJvciIsInIiLCJnZXRJdGVtIiwiZW52IiwiREVCVUciLCJsb2NhbFN0b3JhZ2UiLCJyZXF1aXJlIiwiZm9ybWF0dGVycyIsImoiLCJ2IiwiSlNPTiIsInN0cmluZ2lmeSIsIm1lc3NhZ2UiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/engine.io/node_modules/debug/src/browser.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/engine.io/node_modules/debug/src/common.js":
/*!*****************************************************************!*\
  !*** ./node_modules/engine.io/node_modules/debug/src/common.js ***!
  \*****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * This is the common logic for both the Node.js and web browser\n * implementations of `debug()`.\n */ \nfunction setup(env) {\n    createDebug.debug = createDebug;\n    createDebug.default = createDebug;\n    createDebug.coerce = coerce;\n    createDebug.disable = disable;\n    createDebug.enable = enable;\n    createDebug.enabled = enabled;\n    createDebug.humanize = __webpack_require__(/*! ms */ \"(rsc)/./node_modules/ms/index.js\");\n    createDebug.destroy = destroy;\n    Object.keys(env).forEach((key)=>{\n        createDebug[key] = env[key];\n    });\n    /**\n\t* The currently active debug mode names, and names to skip.\n\t*/ createDebug.names = [];\n    createDebug.skips = [];\n    /**\n\t* Map of special \"%n\" handling functions, for the debug \"format\" argument.\n\t*\n\t* Valid key names are a single, lower or upper-case letter, i.e. \"n\" and \"N\".\n\t*/ createDebug.formatters = {};\n    /**\n\t* Selects a color for a debug namespace\n\t* @param {String} namespace The namespace string for the debug instance to be colored\n\t* @return {Number|String} An ANSI color code for the given namespace\n\t* @api private\n\t*/ function selectColor(namespace) {\n        let hash = 0;\n        for(let i = 0; i < namespace.length; i++){\n            hash = (hash << 5) - hash + namespace.charCodeAt(i);\n            hash |= 0; // Convert to 32bit integer\n        }\n        return createDebug.colors[Math.abs(hash) % createDebug.colors.length];\n    }\n    createDebug.selectColor = selectColor;\n    /**\n\t* Create a debugger with the given `namespace`.\n\t*\n\t* @param {String} namespace\n\t* @return {Function}\n\t* @api public\n\t*/ function createDebug(namespace) {\n        let prevTime;\n        let enableOverride = null;\n        let namespacesCache;\n        let enabledCache;\n        function debug(...args) {\n            // Disabled?\n            if (!debug.enabled) {\n                return;\n            }\n            const self = debug;\n            // Set `diff` timestamp\n            const curr = Number(new Date());\n            const ms = curr - (prevTime || curr);\n            self.diff = ms;\n            self.prev = prevTime;\n            self.curr = curr;\n            prevTime = curr;\n            args[0] = createDebug.coerce(args[0]);\n            if (typeof args[0] !== \"string\") {\n                // Anything else let's inspect with %O\n                args.unshift(\"%O\");\n            }\n            // Apply any `formatters` transformations\n            let index = 0;\n            args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format)=>{\n                // If we encounter an escaped % then don't increase the array index\n                if (match === \"%%\") {\n                    return \"%\";\n                }\n                index++;\n                const formatter = createDebug.formatters[format];\n                if (typeof formatter === \"function\") {\n                    const val = args[index];\n                    match = formatter.call(self, val);\n                    // Now we need to remove `args[index]` since it's inlined in the `format`\n                    args.splice(index, 1);\n                    index--;\n                }\n                return match;\n            });\n            // Apply env-specific formatting (colors, etc.)\n            createDebug.formatArgs.call(self, args);\n            const logFn = self.log || createDebug.log;\n            logFn.apply(self, args);\n        }\n        debug.namespace = namespace;\n        debug.useColors = createDebug.useColors();\n        debug.color = createDebug.selectColor(namespace);\n        debug.extend = extend;\n        debug.destroy = createDebug.destroy; // XXX Temporary. Will be removed in the next major release.\n        Object.defineProperty(debug, \"enabled\", {\n            enumerable: true,\n            configurable: false,\n            get: ()=>{\n                if (enableOverride !== null) {\n                    return enableOverride;\n                }\n                if (namespacesCache !== createDebug.namespaces) {\n                    namespacesCache = createDebug.namespaces;\n                    enabledCache = createDebug.enabled(namespace);\n                }\n                return enabledCache;\n            },\n            set: (v)=>{\n                enableOverride = v;\n            }\n        });\n        // Env-specific initialization logic for debug instances\n        if (typeof createDebug.init === \"function\") {\n            createDebug.init(debug);\n        }\n        return debug;\n    }\n    function extend(namespace, delimiter) {\n        const newDebug = createDebug(this.namespace + (typeof delimiter === \"undefined\" ? \":\" : delimiter) + namespace);\n        newDebug.log = this.log;\n        return newDebug;\n    }\n    /**\n\t* Enables a debug mode by namespaces. This can include modes\n\t* separated by a colon and wildcards.\n\t*\n\t* @param {String} namespaces\n\t* @api public\n\t*/ function enable(namespaces) {\n        createDebug.save(namespaces);\n        createDebug.namespaces = namespaces;\n        createDebug.names = [];\n        createDebug.skips = [];\n        let i;\n        const split = (typeof namespaces === \"string\" ? namespaces : \"\").split(/[\\s,]+/);\n        const len = split.length;\n        for(i = 0; i < len; i++){\n            if (!split[i]) {\n                continue;\n            }\n            namespaces = split[i].replace(/\\*/g, \".*?\");\n            if (namespaces[0] === \"-\") {\n                createDebug.skips.push(new RegExp(\"^\" + namespaces.slice(1) + \"$\"));\n            } else {\n                createDebug.names.push(new RegExp(\"^\" + namespaces + \"$\"));\n            }\n        }\n    }\n    /**\n\t* Disable debug output.\n\t*\n\t* @return {String} namespaces\n\t* @api public\n\t*/ function disable() {\n        const namespaces = [\n            ...createDebug.names.map(toNamespace),\n            ...createDebug.skips.map(toNamespace).map((namespace)=>\"-\" + namespace)\n        ].join(\",\");\n        createDebug.enable(\"\");\n        return namespaces;\n    }\n    /**\n\t* Returns true if the given mode name is enabled, false otherwise.\n\t*\n\t* @param {String} name\n\t* @return {Boolean}\n\t* @api public\n\t*/ function enabled(name) {\n        if (name[name.length - 1] === \"*\") {\n            return true;\n        }\n        let i;\n        let len;\n        for(i = 0, len = createDebug.skips.length; i < len; i++){\n            if (createDebug.skips[i].test(name)) {\n                return false;\n            }\n        }\n        for(i = 0, len = createDebug.names.length; i < len; i++){\n            if (createDebug.names[i].test(name)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    /**\n\t* Convert regexp to namespace\n\t*\n\t* @param {RegExp} regxep\n\t* @return {String} namespace\n\t* @api private\n\t*/ function toNamespace(regexp) {\n        return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\\.\\*\\?$/, \"*\");\n    }\n    /**\n\t* Coerce `val`.\n\t*\n\t* @param {Mixed} val\n\t* @return {Mixed}\n\t* @api private\n\t*/ function coerce(val) {\n        if (val instanceof Error) {\n            return val.stack || val.message;\n        }\n        return val;\n    }\n    /**\n\t* XXX DO NOT USE. This is a temporary stub function.\n\t* XXX It WILL be removed in the next major release.\n\t*/ function destroy() {\n        console.warn(\"Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.\");\n    }\n    createDebug.enable(createDebug.load());\n    return createDebug;\n}\nmodule.exports = setup;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZW5naW5lLmlvL25vZGVfbW9kdWxlcy9kZWJ1Zy9zcmMvY29tbW9uLmpzIiwibWFwcGluZ3MiOiJBQUNBOzs7Q0FHQztBQUVELFNBQVNBLE1BQU1DLEdBQUc7SUFDakJDLFlBQVlDLEtBQUssR0FBR0Q7SUFDcEJBLFlBQVlFLE9BQU8sR0FBR0Y7SUFDdEJBLFlBQVlHLE1BQU0sR0FBR0E7SUFDckJILFlBQVlJLE9BQU8sR0FBR0E7SUFDdEJKLFlBQVlLLE1BQU0sR0FBR0E7SUFDckJMLFlBQVlNLE9BQU8sR0FBR0E7SUFDdEJOLFlBQVlPLFFBQVEsR0FBR0MsbUJBQU9BLENBQUM7SUFDL0JSLFlBQVlTLE9BQU8sR0FBR0E7SUFFdEJDLE9BQU9DLElBQUksQ0FBQ1osS0FBS2EsT0FBTyxDQUFDQyxDQUFBQTtRQUN4QmIsV0FBVyxDQUFDYSxJQUFJLEdBQUdkLEdBQUcsQ0FBQ2MsSUFBSTtJQUM1QjtJQUVBOztDQUVBLEdBRUFiLFlBQVljLEtBQUssR0FBRyxFQUFFO0lBQ3RCZCxZQUFZZSxLQUFLLEdBQUcsRUFBRTtJQUV0Qjs7OztDQUlBLEdBQ0FmLFlBQVlnQixVQUFVLEdBQUcsQ0FBQztJQUUxQjs7Ozs7Q0FLQSxHQUNBLFNBQVNDLFlBQVlDLFNBQVM7UUFDN0IsSUFBSUMsT0FBTztRQUVYLElBQUssSUFBSUMsSUFBSSxHQUFHQSxJQUFJRixVQUFVRyxNQUFNLEVBQUVELElBQUs7WUFDMUNELE9BQU8sQ0FBRUEsUUFBUSxLQUFLQSxPQUFRRCxVQUFVSSxVQUFVLENBQUNGO1lBQ25ERCxRQUFRLEdBQUcsMkJBQTJCO1FBQ3ZDO1FBRUEsT0FBT25CLFlBQVl1QixNQUFNLENBQUNDLEtBQUtDLEdBQUcsQ0FBQ04sUUFBUW5CLFlBQVl1QixNQUFNLENBQUNGLE1BQU0sQ0FBQztJQUN0RTtJQUNBckIsWUFBWWlCLFdBQVcsR0FBR0E7SUFFMUI7Ozs7OztDQU1BLEdBQ0EsU0FBU2pCLFlBQVlrQixTQUFTO1FBQzdCLElBQUlRO1FB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QU1sRSxZQUFZZSxLQUFLLENBQUNNLE1BQU0sRUFBRUQsSUFBSThDLEtBQUs5QyxJQUFLO1lBQ3pELElBQUlwQixZQUFZZSxLQUFLLENBQUNLLEVBQUUsQ0FBQ3NELElBQUksQ0FBQ0QsT0FBTztnQkFDcEMsT0FBTztZQUNSO1FBQ0Q7UUFFQSxJQUFLckQsSUFBSSxHQUFHOEMsTUFBTWxFLFlBQVljLEtBQUssQ0FBQ08sTUFBTSxFQUFFRCxJQUFJOEMsS0FBSzlDLElBQUs7WUFDekQsSUFBSXBCLFlBQVljLEtBQUssQ0FBQ00sRUFBRSxDQUFDc0QsSUFBSSxDQUFDRCxPQUFPO2dCQUNwQyxPQUFPO1lBQ1I7UUFDRDtRQUVBLE9BQU87SUFDUjtJQUVBOzs7Ozs7Q0FNQSxHQUNBLFNBQVNGLFlBQVlJLE1BQU07UUFDMUIsT0FBT0EsT0FBT0MsUUFBUSxHQUNwQkMsU0FBUyxDQUFDLEdBQUdGLE9BQU9DLFFBQVEsR0FBR3ZELE1BQU0sR0FBRyxHQUN4Q21CLE9BQU8sQ0FBQyxXQUFXO0lBQ3RCO0lBRUE7Ozs7OztDQU1BLEdBQ0EsU0FBU3JDLE9BQU95QyxHQUFHO1FBQ2xCLElBQUlBLGVBQWVrQyxPQUFPO1lBQ3pCLE9BQU9sQyxJQUFJbUMsS0FBSyxJQUFJbkMsSUFBSW9DLE9BQU87UUFDaEM7UUFDQSxPQUFPcEM7SUFDUjtJQUVBOzs7Q0FHQSxHQUNBLFNBQVNuQztRQUNSd0UsUUFBUUMsSUFBSSxDQUFDO0lBQ2Q7SUFFQWxGLFlBQVlLLE1BQU0sQ0FBQ0wsWUFBWW1GLElBQUk7SUFFbkMsT0FBT25GO0FBQ1I7QUFFQW9GLE9BQU9DLE9BQU8sR0FBR3ZGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZXhhbXJvc2gvLi9ub2RlX21vZHVsZXMvZW5naW5lLmlvL25vZGVfbW9kdWxlcy9kZWJ1Zy9zcmMvY29tbW9uLmpzPzVhOTkiXSwic291cmNlc0NvbnRlbnQiOlsiXG4vKipcbiAqIFRoaXMgaXMgdGhlIGNvbW1vbiBsb2dpYyBmb3IgYm90aCB0aGUgTm9kZS5qcyBhbmQgd2ViIGJyb3dzZXJcbiAqIGltcGxlbWVudGF0aW9ucyBvZiBgZGVidWcoKWAuXG4gKi9cblxuZnVuY3Rpb24gc2V0dXAoZW52KSB7XG5cdGNyZWF0ZURlYnVnLmRlYnVnID0gY3JlYXRlRGVidWc7XG5cdGNyZWF0ZURlYnVnLmRlZmF1bHQgPSBjcmVhdGVEZWJ1Zztcblx0Y3JlYXRlRGVidWcuY29lcmNlID0gY29lcmNlO1xuXHRjcmVhdGVEZWJ1Zy5kaXNhYmxlID0gZGlzYWJsZTtcblx0Y3JlYXRlRGVidWcuZW5hYmxlID0gZW5hYmxlO1xuXHRjcmVhdGVEZWJ1Zy5lbmFibGVkID0gZW5hYmxlZDtcblx0Y3JlYXRlRGVidWcuaHVtYW5pemUgPSByZXF1aXJlKCdtcycpO1xuXHRjcmVhdGVEZWJ1Zy5kZXN0cm95ID0gZGVzdHJveTtcblxuXHRPYmplY3Qua2V5cyhlbnYpLmZvckVhY2goa2V5ID0+IHtcblx0XHRjcmVhdGVEZWJ1Z1trZXldID0gZW52W2tleV07XG5cdH0pO1xuXG5cdC8qKlxuXHQqIFRoZSBjdXJyZW50bHkgYWN0aXZlIGRlYnVnIG1vZGUgbmFtZXMsIGFuZCBuYW1lcyB0byBza2lwLlxuXHQqL1xuXG5cdGNyZWF0ZURlYnVnLm5hbWVzID0gW107XG5cdGNyZWF0ZURlYnVnLnNraXBzID0gW107XG5cblx0LyoqXG5cdCogTWFwIG9mIHNwZWNpYWwgXCIlblwiIGhhbmRsaW5nIGZ1bmN0aW9ucywgZm9yIHRoZSBkZWJ1ZyBcImZvcm1hdFwiIGFyZ3VtZW50LlxuXHQqXG5cdCogVmFsaWQga2V5IG5hbWVzIGFyZSBhIHNpbmdsZSwgbG93ZXIgb3IgdXBwZXItY2FzZSBsZXR0ZXIsIGkuZS4gXCJuXCIgYW5kIFwiTlwiLlxuXHQqL1xuXHRjcmVhdGVEZWJ1Zy5mb3JtYXR0ZXJzID0ge307XG5cblx0LyoqXG5cdCogU2VsZWN0cyBhIGNvbG9yIGZvciBhIGRlYnVnIG5hbWVzcGFjZVxuXHQqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2UgVGhlIG5hbWVzcGFjZSBzdHJpbmcgZm9yIHRoZSBkZWJ1ZyBpbnN0YW5jZSB0byBiZSBjb2xvcmVkXG5cdCogQHJldHVybiB7TnVtYmVyfFN0cmluZ30gQW4gQU5TSSBjb2xvciBjb2RlIGZvciB0aGUgZ2l2ZW4gbmFtZXNwYWNlXG5cdCogQGFwaSBwcml2YXRlXG5cdCovXG5cdGZ1bmN0aW9uIHNlbGVjdENvbG9yKG5hbWVzcGFjZSkge1xuXHRcdGxldCBoYXNoID0gMDtcblxuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgbmFtZXNwYWNlLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRoYXNoID0gKChoYXNoIDw8IDUpIC0gaGFzaCkgKyBuYW1lc3BhY2UuY2hhckNvZGVBdChpKTtcblx0XHRcdGhhc2ggfD0gMDsgLy8gQ29udmVydCB0byAzMmJpdCBpbnRlZ2VyXG5cdFx0fVxuXG5cdFx0cmV0dXJuIGNyZWF0ZURlYnVnLmNvbG9yc1tNYXRoLmFicyhoYXNoKSAlIGNyZWF0ZURlYnVnLmNvbG9ycy5sZW5ndGhdO1xuXHR9XG5cdGNyZWF0ZURlYnVnLnNlbGVjdENvbG9yID0gc2VsZWN0Q29sb3I7XG5cblx0LyoqXG5cdCogQ3JlYXRlIGEgZGVidWdnZXIgd2l0aCB0aGUgZ2l2ZW4gYG5hbWVzcGFjZWAuXG5cdCpcblx0KiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlXG5cdCogQHJldHVybiB7RnVuY3Rpb259XG5cdCogQGFwaSBwdWJsaWNcblx0Ki9cblx0ZnVuY3Rpb24gY3JlYXRlRGVidWcobmFtZXNwYWNlKSB7XG5cdFx0bGV0IHByZXZUaW1lO1xuXHRcdGxldCBlbmFibGVPdmVycmlkZSA9IG51bGw7XG5cdFx0bGV0IG5hbWVzcGFjZXNDYWNoZTtcblx0XHRsZXQgZW5hYmxlZENhY2hlO1xuXG5cdFx0ZnVuY3Rpb24gZGVidWcoLi4uYXJncykge1xuXHRcdFx0Ly8gRGlzYWJsZWQ/XG5cdFx0XHRpZiAoIWRlYnVnLmVuYWJsZWQpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCBzZWxmID0gZGVidWc7XG5cblx0XHRcdC8vIFNldCBgZGlmZmAgdGltZXN0YW1wXG5cdFx0XHRjb25zdCBjdXJyID0gTnVtYmVyKG5ldyBEYXRlKCkpO1xuXHRcdFx0Y29uc3QgbXMgPSBjdXJyIC0gKHByZXZUaW1lIHx8IGN1cnIpO1xuXHRcdFx0c2VsZi5kaWZmID0gbXM7XG5cdFx0XHRzZWxmLnByZXYgPSBwcmV2VGltZTtcblx0XHRcdHNlbGYuY3VyciA9IGN1cnI7XG5cdFx0XHRwcmV2VGltZSA9IGN1cnI7XG5cblx0XHRcdGFyZ3NbMF0gPSBjcmVhdGVEZWJ1Zy5jb2VyY2UoYXJnc1swXSk7XG5cblx0XHRcdGlmICh0eXBlb2YgYXJnc1swXSAhPT0gJ3N0cmluZycpIHtcblx0XHRcdFx0Ly8gQW55dGhpbmcgZWxzZSBsZXQncyBpbnNwZWN0IHdpdGggJU9cblx0XHRcdFx0YXJncy51bnNoaWZ0KCclTycpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBBcHBseSBhbnkgYGZvcm1hdHRlcnNgIHRyYW5zZm9ybWF0aW9uc1xuXHRcdFx0bGV0IGluZGV4ID0gMDtcblx0XHRcdGFyZ3NbMF0gPSBhcmdzWzBdLnJlcGxhY2UoLyUoW2EtekEtWiVdKS9nLCAobWF0Y2gsIGZvcm1hdCkgPT4ge1xuXHRcdFx0XHQvLyBJZiB3ZSBlbmNvdW50ZXIgYW4gZXNjYXBlZCAlIHRoZW4gZG9uJ3QgaW5jcmVhc2UgdGhlIGFycmF5IGluZGV4XG5cdFx0XHRcdGlmIChtYXRjaCA9PT0gJyUlJykge1xuXHRcdFx0XHRcdHJldHVybiAnJSc7XG5cdFx0XHRcdH1cblx0XHRcdFx0aW5kZXgrKztcblx0XHRcdFx0Y29uc3QgZm9ybWF0dGVyID0gY3JlYXRlRGVidWcuZm9ybWF0dGVyc1tmb3JtYXRdO1xuXHRcdFx0XHRpZiAodHlwZW9mIGZvcm1hdHRlciA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0XHRcdGNvbnN0IHZhbCA9IGFyZ3NbaW5kZXhdO1xuXHRcdFx0XHRcdG1hdGNoID0gZm9ybWF0dGVyLmNhbGwoc2VsZiwgdmFsKTtcblxuXHRcdFx0XHRcdC8vIE5vdyB3ZSBuZWVkIHRvIHJlbW92ZSBgYXJnc1tpbmRleF1gIHNpbmNlIGl0J3MgaW5saW5lZCBpbiB0aGUgYGZvcm1hdGBcblx0XHRcdFx0XHRhcmdzLnNwbGljZShpbmRleCwgMSk7XG5cdFx0XHRcdFx0aW5kZXgtLTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gbWF0Y2g7XG5cdFx0XHR9KTtcblxuXHRcdFx0Ly8gQXBwbHkgZW52LXNwZWNpZmljIGZvcm1hdHRpbmcgKGNvbG9ycywgZXRjLilcblx0XHRcdGNyZWF0ZURlYnVnLmZvcm1hdEFyZ3MuY2FsbChzZWxmLCBhcmdzKTtcblxuXHRcdFx0Y29uc3QgbG9nRm4gPSBzZWxmLmxvZyB8fCBjcmVhdGVEZWJ1Zy5sb2c7XG5cdFx0XHRsb2dGbi5hcHBseShzZWxmLCBhcmdzKTtcblx0XHR9XG5cblx0XHRkZWJ1Zy5uYW1lc3BhY2UgPSBuYW1lc3BhY2U7XG5cdFx0ZGVidWcudXNlQ29sb3JzID0gY3JlYXRlRGVidWcudXNlQ29sb3JzKCk7XG5cdFx0ZGVidWcuY29sb3IgPSBjcmVhdGVEZWJ1Zy5zZWxlY3RDb2xvcihuYW1lc3BhY2UpO1xuXHRcdGRlYnVnLmV4dGVuZCA9IGV4dGVuZDtcblx0XHRkZWJ1Zy5kZXN0cm95ID0gY3JlYXRlRGVidWcuZGVzdHJveTsgLy8gWFhYIFRlbXBvcmFyeS4gV2lsbCBiZSByZW1vdmVkIGluIHRoZSBuZXh0IG1ham9yIHJlbGVhc2UuXG5cblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZGVidWcsICdlbmFibGVkJywge1xuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRcdGNvbmZpZ3VyYWJsZTogZmFsc2UsXG5cdFx0XHRnZXQ6ICgpID0+IHtcblx0XHRcdFx0aWYgKGVuYWJsZU92ZXJyaWRlICE9PSBudWxsKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGVuYWJsZU92ZXJyaWRlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChuYW1lc3BhY2VzQ2FjaGUgIT09IGNyZWF0ZURlYnVnLm5hbWVzcGFjZXMpIHtcblx0XHRcdFx0XHRuYW1lc3BhY2VzQ2FjaGUgPSBjcmVhdGVEZWJ1Zy5uYW1lc3BhY2VzO1xuXHRcdFx0XHRcdGVuYWJsZWRDYWNoZSA9IGNyZWF0ZURlYnVnLmVuYWJsZWQobmFtZXNwYWNlKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBlbmFibGVkQ2FjaGU7XG5cdFx0XHR9LFxuXHRcdFx0c2V0OiB2ID0+IHtcblx0XHRcdFx0ZW5hYmxlT3ZlcnJpZGUgPSB2O1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0Ly8gRW52LXNwZWNpZmljIGluaXRpYWxpemF0aW9uIGxvZ2ljIGZvciBkZWJ1ZyBpbnN0YW5jZXNcblx0XHRpZiAodHlwZW9mIGNyZWF0ZURlYnVnLmluaXQgPT09ICdmdW5jdGlvbicpIHtcblx0XHRcdGNyZWF0ZURlYnVnLmluaXQoZGVidWcpO1xuXHRcdH1cblxuXHRcdHJldHVybiBkZWJ1Zztcblx0fVxuXG5cdGZ1bmN0aW9uIGV4dGVuZChuYW1lc3BhY2UsIGRlbGltaXRlcikge1xuXHRcdGNvbnN0IG5ld0RlYnVnID0gY3JlYXRlRGVidWcodGhpcy5uYW1lc3BhY2UgKyAodHlwZW9mIGRlbGltaXRlciA9PT0gJ3VuZGVmaW5lZCcgPyAnOicgOiBkZWxpbWl0ZXIpICsgbmFtZXNwYWNlKTtcblx0XHRuZXdEZWJ1Zy5sb2cgPSB0aGlzLmxvZztcblx0XHRyZXR1cm4gbmV3RGVidWc7XG5cdH1cblxuXHQvKipcblx0KiBFbmFibGVzIGEgZGVidWcgbW9kZSBieSBuYW1lc3BhY2VzLiBUaGlzIGNhbiBpbmNsdWRlIG1vZGVzXG5cdCogc2VwYXJhdGVkIGJ5IGEgY29sb24gYW5kIHdpbGRjYXJkcy5cblx0KlxuXHQqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VzXG5cdCogQGFwaSBwdWJsaWNcblx0Ki9cblx0ZnVuY3Rpb24gZW5hYmxlKG5hbWVzcGFjZXMpIHtcblx0XHRjcmVhdGVEZWJ1Zy5zYXZlKG5hbWVzcGFjZXMpO1xuXHRcdGNyZWF0ZURlYnVnLm5hbWVzcGFjZXMgPSBuYW1lc3BhY2VzO1xuXG5cdFx0Y3JlYXRlRGVidWcubmFtZXMgPSBbXTtcblx0XHRjcmVhdGVEZWJ1Zy5za2lwcyA9IFtdO1xuXG5cdFx0bGV0IGk7XG5cdFx0Y29uc3Qgc3BsaXQgPSAodHlwZW9mIG5hbWVzcGFjZXMgPT09ICdzdHJpbmcnID8gbmFtZXNwYWNlcyA6ICcnKS5zcGxpdCgvW1xccyxdKy8pO1xuXHRcdGNvbnN0IGxlbiA9IHNwbGl0Lmxlbmd0aDtcblxuXHRcdGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0aWYgKCFzcGxpdFtpXSkge1xuXHRcdFx0XHQvLyBpZ25vcmUgZW1wdHkgc3RyaW5nc1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblxuXHRcdFx0bmFtZXNwYWNlcyA9IHNwbGl0W2ldLnJlcGxhY2UoL1xcKi9nLCAnLio/Jyk7XG5cblx0XHRcdGlmIChuYW1lc3BhY2VzWzBdID09PSAnLScpIHtcblx0XHRcdFx0Y3JlYXRlRGVidWcuc2tpcHMucHVzaChuZXcgUmVnRXhwKCdeJyArIG5hbWVzcGFjZXMuc2xpY2UoMSkgKyAnJCcpKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGNyZWF0ZURlYnVnLm5hbWVzLnB1c2gobmV3IFJlZ0V4cCgnXicgKyBuYW1lc3BhY2VzICsgJyQnKSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCogRGlzYWJsZSBkZWJ1ZyBvdXRwdXQuXG5cdCpcblx0KiBAcmV0dXJuIHtTdHJpbmd9IG5hbWVzcGFjZXNcblx0KiBAYXBpIHB1YmxpY1xuXHQqL1xuXHRmdW5jdGlvbiBkaXNhYmxlKCkge1xuXHRcdGNvbnN0IG5hbWVzcGFjZXMgPSBbXG5cdFx0XHQuLi5jcmVhdGVEZWJ1Zy5uYW1lcy5tYXAodG9OYW1lc3BhY2UpLFxuXHRcdFx0Li4uY3JlYXRlRGVidWcuc2tpcHMubWFwKHRvTmFtZXNwYWNlKS5tYXAobmFtZXNwYWNlID0+ICctJyArIG5hbWVzcGFjZSlcblx0XHRdLmpvaW4oJywnKTtcblx0XHRjcmVhdGVEZWJ1Zy5lbmFibGUoJycpO1xuXHRcdHJldHVybiBuYW1lc3BhY2VzO1xuXHR9XG5cblx0LyoqXG5cdCogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBtb2RlIG5hbWUgaXMgZW5hYmxlZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuXHQqXG5cdCogQHBhcmFtIHtTdHJpbmd9IG5hbWVcblx0KiBAcmV0dXJuIHtCb29sZWFufVxuXHQqIEBhcGkgcHVibGljXG5cdCovXG5cdGZ1bmN0aW9uIGVuYWJsZWQobmFtZSkge1xuXHRcdGlmIChuYW1lW25hbWUubGVuZ3RoIC0gMV0gPT09ICcqJykge1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXG5cdFx0bGV0IGk7XG5cdFx0bGV0IGxlbjtcblxuXHRcdGZvciAoaSA9IDAsIGxlbiA9IGNyZWF0ZURlYnVnLnNraXBzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRpZiAoY3JlYXRlRGVidWcuc2tpcHNbaV0udGVzdChuYW1lKSkge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Zm9yIChpID0gMCwgbGVuID0gY3JlYXRlRGVidWcubmFtZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdGlmIChjcmVhdGVEZWJ1Zy5uYW1lc1tpXS50ZXN0KG5hbWUpKSB7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdC8qKlxuXHQqIENvbnZlcnQgcmVnZXhwIHRvIG5hbWVzcGFjZVxuXHQqXG5cdCogQHBhcmFtIHtSZWdFeHB9IHJlZ3hlcFxuXHQqIEByZXR1cm4ge1N0cmluZ30gbmFtZXNwYWNlXG5cdCogQGFwaSBwcml2YXRlXG5cdCovXG5cdGZ1bmN0aW9uIHRvTmFtZXNwYWNlKHJlZ2V4cCkge1xuXHRcdHJldHVybiByZWdleHAudG9TdHJpbmcoKVxuXHRcdFx0LnN1YnN0cmluZygyLCByZWdleHAudG9TdHJpbmcoKS5sZW5ndGggLSAyKVxuXHRcdFx0LnJlcGxhY2UoL1xcLlxcKlxcPyQvLCAnKicpO1xuXHR9XG5cblx0LyoqXG5cdCogQ29lcmNlIGB2YWxgLlxuXHQqXG5cdCogQHBhcmFtIHtNaXhlZH0gdmFsXG5cdCogQHJldHVybiB7TWl4ZWR9XG5cdCogQGFwaSBwcml2YXRlXG5cdCovXG5cdGZ1bmN0aW9uIGNvZXJjZSh2YWwpIHtcblx0XHRpZiAodmFsIGluc3RhbmNlb2YgRXJyb3IpIHtcblx0XHRcdHJldHVybiB2YWwuc3RhY2sgfHwgdmFsLm1lc3NhZ2U7XG5cdFx0fVxuXHRcdHJldHVybiB2YWw7XG5cdH1cblxuXHQvKipcblx0KiBYWFggRE8gTk9UIFVTRS4gVGhpcyBpcyBhIHRlbXBvcmFyeSBzdHViIGZ1bmN0aW9uLlxuXHQqIFhYWCBJdCBXSUxMIGJlIHJlbW92ZWQgaW4gdGhlIG5leHQgbWFqb3IgcmVsZWFzZS5cblx0Ki9cblx0ZnVuY3Rpb24gZGVzdHJveSgpIHtcblx0XHRjb25zb2xlLndhcm4oJ0luc3RhbmNlIG1ldGhvZCBgZGVidWcuZGVzdHJveSgpYCBpcyBkZXByZWNhdGVkIGFuZCBubyBsb25nZXIgZG9lcyBhbnl0aGluZy4gSXQgd2lsbCBiZSByZW1vdmVkIGluIHRoZSBuZXh0IG1ham9yIHZlcnNpb24gb2YgYGRlYnVnYC4nKTtcblx0fVxuXG5cdGNyZWF0ZURlYnVnLmVuYWJsZShjcmVhdGVEZWJ1Zy5sb2FkKCkpO1xuXG5cdHJldHVybiBjcmVhdGVEZWJ1Zztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzZXR1cDtcbiJdLCJuYW1lcyI6WyJzZXR1cCIsImVudiIsImNyZWF0ZURlYnVnIiwiZGVidWciLCJkZWZhdWx0IiwiY29lcmNlIiwiZGlzYWJsZSIsImVuYWJsZSIsImVuYWJsZWQiLCJodW1hbml6ZSIsInJlcXVpcmUiLCJkZXN0cm95IiwiT2JqZWN0Iiwia2V5cyIsImZvckVhY2giLCJrZXkiLCJuYW1lcyIsInNraXBzIiwiZm9ybWF0dGVycyIsInNlbGVjdENvbG9yIiwibmFtZXNwYWNlIiwiaGFzaCIsImkiLCJsZW5ndGgiLCJjaGFyQ29kZUF0IiwiY29sb3JzIiwiTWF0aCIsImFicyIsInByZXZUaW1lIiwiZW5hYmxlT3ZlcnJpZGUiLCJuYW1lc3BhY2VzQ2FjaGUiLCJlbmFibGVkQ2FjaGUiLCJhcmdzIiwic2VsZiIsImN1cnIiLCJOdW1iZXIiLCJEYXRlIiwibXMiLCJkaWZmIiwicHJldiIsInVuc2hpZnQiLCJpbmRleCIsInJlcGxhY2UiLCJtYXRjaCIsImZvcm1hdCIsImZvcm1hdHRlciIsInZhbCIsImNhbGwiLCJzcGxpY2UiLCJmb3JtYXRBcmdzIiwibG9nRm4iLCJsb2ciLCJhcHBseSIsInVzZUNvbG9ycyIsImNvbG9yIiwiZXh0ZW5kIiwiZGVmaW5lUHJvcGVydHkiLCJlbnVtZXJhYmxlIiwiY29uZmlndXJhYmxlIiwiZ2V0IiwibmFtZXNwYWNlcyIsInNldCIsInYiLCJpbml0IiwiZGVsaW1pdGVyIiwibmV3RGVidWciLCJzYXZlIiwic3BsaXQiLCJsZW4iLCJwdXNoIiwiUmVnRXhwIiwic2xpY2UiLCJtYXAiLCJ0b05hbWVzcGFjZSIsImpvaW4iLCJuYW1lIiwidGVzdCIsInJlZ2V4cCIsInRvU3RyaW5nIiwic3Vic3RyaW5nIiwiRXJyb3IiLCJzdGFjayIsIm1lc3NhZ2UiLCJjb25zb2xlIiwid2FybiIsImxvYWQiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/engine.io/node_modules/debug/src/common.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/engine.io/node_modules/debug/src/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/engine.io/node_modules/debug/src/index.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * Detect Electron renderer / nwjs process, which is node, but we should\n * treat as a browser.\n */ \nif (typeof process === \"undefined\" || process.type === \"renderer\" || false === true || process.__nwjs) {\n    module.exports = __webpack_require__(/*! ./browser.js */ \"(rsc)/./node_modules/engine.io/node_modules/debug/src/browser.js\");\n} else {\n    module.exports = __webpack_require__(/*! ./node.js */ \"(rsc)/./node_modules/engine.io/node_modules/debug/src/node.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZW5naW5lLmlvL25vZGVfbW9kdWxlcy9kZWJ1Zy9zcmMvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQUE7OztDQUdDO0FBRUQsSUFBSSxPQUFPQSxZQUFZLGVBQWVBLFFBQVFDLElBQUksS0FBSyxjQUFjRCxLQUFlLEtBQUssUUFBUUEsUUFBUUcsTUFBTSxFQUFFO0lBQ2hIQyw0SEFBeUI7QUFDMUIsT0FBTztJQUNOQSxzSEFBeUI7QUFDMUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9leGFtcm9zaC8uL25vZGVfbW9kdWxlcy9lbmdpbmUuaW8vbm9kZV9tb2R1bGVzL2RlYnVnL3NyYy9pbmRleC5qcz9kMWQ2Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogRGV0ZWN0IEVsZWN0cm9uIHJlbmRlcmVyIC8gbndqcyBwcm9jZXNzLCB3aGljaCBpcyBub2RlLCBidXQgd2Ugc2hvdWxkXG4gKiB0cmVhdCBhcyBhIGJyb3dzZXIuXG4gKi9cblxuaWYgKHR5cGVvZiBwcm9jZXNzID09PSAndW5kZWZpbmVkJyB8fCBwcm9jZXNzLnR5cGUgPT09ICdyZW5kZXJlcicgfHwgcHJvY2Vzcy5icm93c2VyID09PSB0cnVlIHx8IHByb2Nlc3MuX19ud2pzKSB7XG5cdG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9icm93c2VyLmpzJyk7XG59IGVsc2Uge1xuXHRtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbm9kZS5qcycpO1xufVxuIl0sIm5hbWVzIjpbInByb2Nlc3MiLCJ0eXBlIiwiYnJvd3NlciIsIl9fbndqcyIsIm1vZHVsZSIsImV4cG9ydHMiLCJyZXF1aXJlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/engine.io/node_modules/debug/src/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/engine.io/node_modules/debug/src/node.js":
/*!***************************************************************!*\
  !*** ./node_modules/engine.io/node_modules/debug/src/node.js ***!
  \***************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("/**\n * Module dependencies.\n */ \nconst tty = __webpack_require__(/*! tty */ \"tty\");\nconst util = __webpack_require__(/*! util */ \"util\");\n/**\n * This is the Node.js implementation of `debug()`.\n */ exports.init = init;\nexports.log = log;\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\nexports.destroy = util.deprecate(()=>{}, \"Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.\");\n/**\n * Colors.\n */ exports.colors = [\n    6,\n    2,\n    3,\n    4,\n    5,\n    1\n];\ntry {\n    // Optional dependency (as in, doesn't need to be installed, NOT like optionalDependencies in package.json)\n    // eslint-disable-next-line import/no-extraneous-dependencies\n    const supportsColor = __webpack_require__(/*! supports-color */ \"(rsc)/./node_modules/supports-color/index.js\");\n    if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {\n        exports.colors = [\n            20,\n            21,\n            26,\n            27,\n            32,\n            33,\n            38,\n            39,\n            40,\n            41,\n            42,\n            43,\n            44,\n            45,\n            56,\n            57,\n            62,\n            63,\n            68,\n            69,\n            74,\n            75,\n            76,\n            77,\n            78,\n            79,\n            80,\n            81,\n            92,\n            93,\n            98,\n            99,\n            112,\n            113,\n            128,\n            129,\n            134,\n            135,\n            148,\n            149,\n            160,\n            161,\n            162,\n            163,\n            164,\n            165,\n            166,\n            167,\n            168,\n            169,\n            170,\n            171,\n            172,\n            173,\n            178,\n            179,\n            184,\n            185,\n            196,\n            197,\n            198,\n            199,\n            200,\n            201,\n            202,\n            203,\n            204,\n            205,\n            206,\n            207,\n            208,\n            209,\n            214,\n            215,\n            220,\n            221\n        ];\n    }\n} catch (error) {\n// Swallow - we only care if `supports-color` is available; it doesn't have to be.\n}\n/**\n * Build up the default `inspectOpts` object from the environment variables.\n *\n *   $ DEBUG_COLORS=no DEBUG_DEPTH=10 DEBUG_SHOW_HIDDEN=enabled node script.js\n */ exports.inspectOpts = Object.keys(process.env).filter((key)=>{\n    return /^debug_/i.test(key);\n}).reduce((obj, key)=>{\n    // Camel-case\n    const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_, k)=>{\n        return k.toUpperCase();\n    });\n    // Coerce string value into JS value\n    let val = process.env[key];\n    if (/^(yes|on|true|enabled)$/i.test(val)) {\n        val = true;\n    } else if (/^(no|off|false|disabled)$/i.test(val)) {\n        val = false;\n    } else if (val === \"null\") {\n        val = null;\n    } else {\n        val = Number(val);\n    }\n    obj[prop] = val;\n    return obj;\n}, {});\n/**\n * Is stdout a TTY? Colored output is enabled when `true`.\n */ function useColors() {\n    return \"colors\" in exports.inspectOpts ? Boolean(exports.inspectOpts.colors) : tty.isatty(process.stderr.fd);\n}\n/**\n * Adds ANSI color escape codes if enabled.\n *\n * @api public\n */ function formatArgs(args) {\n    const { namespace: name, useColors } = this;\n    if (useColors) {\n        const c = this.color;\n        const colorCode = \"\\x1b[3\" + (c < 8 ? c : \"8;5;\" + c);\n        const prefix = `  ${colorCode};1m${name} \\u001B[0m`;\n        args[0] = prefix + args[0].split(\"\\n\").join(\"\\n\" + prefix);\n        args.push(colorCode + \"m+\" + module.exports.humanize(this.diff) + \"\\x1b[0m\");\n    } else {\n        args[0] = getDate() + name + \" \" + args[0];\n    }\n}\nfunction getDate() {\n    if (exports.inspectOpts.hideDate) {\n        return \"\";\n    }\n    return new Date().toISOString() + \" \";\n}\n/**\n * Invokes `util.formatWithOptions()` with the specified arguments and writes to stderr.\n */ function log(...args) {\n    return process.stderr.write(util.formatWithOptions(exports.inspectOpts, ...args) + \"\\n\");\n}\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */ function save(namespaces) {\n    if (namespaces) {\n        process.env.DEBUG = namespaces;\n    } else {\n        // If you set a process.env field to null or undefined, it gets cast to the\n        // string 'null' or 'undefined'. Just delete instead.\n        delete process.env.DEBUG;\n    }\n}\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */ function load() {\n    return process.env.DEBUG;\n}\n/**\n * Init logic for `debug` instances.\n *\n * Create a new `inspectOpts` object in case `useColors` is set\n * differently for a particular `debug` instance.\n */ function init(debug) {\n    debug.inspectOpts = {};\n    const keys = Object.keys(exports.inspectOpts);\n    for(let i = 0; i < keys.length; i++){\n        debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];\n    }\n}\nmodule.exports = __webpack_require__(/*! ./common */ \"(rsc)/./node_modules/engine.io/node_modules/debug/src/common.js\")(exports);\nconst { formatters } = module.exports;\n/**\n * Map %o to `util.inspect()`, all on a single line.\n */ formatters.o = function(v) {\n    this.inspectOpts.colors = this.useColors;\n    return util.inspect(v, this.inspectOpts).split(\"\\n\").map((str)=>str.trim()).join(\" \");\n};\n/**\n * Map %O to `util.inspect()`, allowing multiple lines if needed.\n */ formatters.O = function(v) {\n    this.inspectOpts.colors = this.useColors;\n    return util.inspect(v, this.inspectOpts);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZW5naW5lLmlvL25vZGVfbW9kdWxlcy9kZWJ1Zy9zcmMvbm9kZS5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7Q0FFQztBQUVELE1BQU1BLE1BQU1DLG1CQUFPQSxDQUFDO0FBQ3BCLE1BQU1DLE9BQU9ELG1CQUFPQSxDQUFDO0FBRXJCOztDQUVDLEdBRURFLFlBQVksR0FBR0M7QUFDZkQsV0FBVyxHQUFHRTtBQUNkRixrQkFBa0IsR0FBR0c7QUFDckJILFlBQVksR0FBR0k7QUFDZkosWUFBWSxHQUFHSztBQUNmTCxpQkFBaUIsR0FBR007QUFDcEJOLGVBQWUsR0FBR0QsS0FBS1MsU0FBUyxDQUMvQixLQUFPLEdBQ1A7QUFHRDs7Q0FFQyxHQUVEUixjQUFjLEdBQUc7SUFBQztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7Q0FBRTtBQUVuQyxJQUFJO0lBQ0gsMkdBQTJHO0lBQzNHLDZEQUE2RDtJQUM3RCxNQUFNVSxnQkFBZ0JaLG1CQUFPQSxDQUFDO0lBRTlCLElBQUlZLGlCQUFpQixDQUFDQSxjQUFjQyxNQUFNLElBQUlELGFBQVksRUFBR0UsS0FBSyxJQUFJLEdBQUc7UUFDeEVaLGNBQWMsR0FBRztZQUNoQjtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZQUNB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QUFXLEdBQUcsQ0FBQztJQUVyQixNQUFNRSxPQUFPRCxPQUFPQyxJQUFJLENBQUNoQixRQUFRYyxXQUFXO0lBQzVDLElBQUssSUFBSTRDLElBQUksR0FBR0EsSUFBSTFDLEtBQUsyQyxNQUFNLEVBQUVELElBQUs7UUFDckNELE1BQU0zQyxXQUFXLENBQUNFLElBQUksQ0FBQzBDLEVBQUUsQ0FBQyxHQUFHMUQsUUFBUWMsV0FBVyxDQUFDRSxJQUFJLENBQUMwQyxFQUFFLENBQUM7SUFDMUQ7QUFDRDtBQUVBWixPQUFPOUMsT0FBTyxHQUFHRixtQkFBT0EsQ0FBQyxtRkFBWUU7QUFFckMsTUFBTSxFQUFDNEQsVUFBVSxFQUFDLEdBQUdkLE9BQU85QyxPQUFPO0FBRW5DOztDQUVDLEdBRUQ0RCxXQUFXQyxDQUFDLEdBQUcsU0FBVUMsQ0FBQztJQUN6QixJQUFJLENBQUNoRCxXQUFXLENBQUNMLE1BQU0sR0FBRyxJQUFJLENBQUNILFNBQVM7SUFDeEMsT0FBT1AsS0FBS2dFLE9BQU8sQ0FBQ0QsR0FBRyxJQUFJLENBQUNoRCxXQUFXLEVBQ3JDNkIsS0FBSyxDQUFDLE1BQ05xQixHQUFHLENBQUNDLENBQUFBLE1BQU9BLElBQUlDLElBQUksSUFDbkJ0QixJQUFJLENBQUM7QUFDUjtBQUVBOztDQUVDLEdBRURnQixXQUFXTyxDQUFDLEdBQUcsU0FBVUwsQ0FBQztJQUN6QixJQUFJLENBQUNoRCxXQUFXLENBQUNMLE1BQU0sR0FBRyxJQUFJLENBQUNILFNBQVM7SUFDeEMsT0FBT1AsS0FBS2dFLE9BQU8sQ0FBQ0QsR0FBRyxJQUFJLENBQUNoRCxXQUFXO0FBQ3hDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZXhhbXJvc2gvLi9ub2RlX21vZHVsZXMvZW5naW5lLmlvL25vZGVfbW9kdWxlcy9kZWJ1Zy9zcmMvbm9kZS5qcz83ODFkIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG5jb25zdCB0dHkgPSByZXF1aXJlKCd0dHknKTtcbmNvbnN0IHV0aWwgPSByZXF1aXJlKCd1dGlsJyk7XG5cbi8qKlxuICogVGhpcyBpcyB0aGUgTm9kZS5qcyBpbXBsZW1lbnRhdGlvbiBvZiBgZGVidWcoKWAuXG4gKi9cblxuZXhwb3J0cy5pbml0ID0gaW5pdDtcbmV4cG9ydHMubG9nID0gbG9nO1xuZXhwb3J0cy5mb3JtYXRBcmdzID0gZm9ybWF0QXJncztcbmV4cG9ydHMuc2F2ZSA9IHNhdmU7XG5leHBvcnRzLmxvYWQgPSBsb2FkO1xuZXhwb3J0cy51c2VDb2xvcnMgPSB1c2VDb2xvcnM7XG5leHBvcnRzLmRlc3Ryb3kgPSB1dGlsLmRlcHJlY2F0ZShcblx0KCkgPT4ge30sXG5cdCdJbnN0YW5jZSBtZXRob2QgYGRlYnVnLmRlc3Ryb3koKWAgaXMgZGVwcmVjYXRlZCBhbmQgbm8gbG9uZ2VyIGRvZXMgYW55dGhpbmcuIEl0IHdpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgbmV4dCBtYWpvciB2ZXJzaW9uIG9mIGBkZWJ1Z2AuJ1xuKTtcblxuLyoqXG4gKiBDb2xvcnMuXG4gKi9cblxuZXhwb3J0cy5jb2xvcnMgPSBbNiwgMiwgMywgNCwgNSwgMV07XG5cbnRyeSB7XG5cdC8vIE9wdGlvbmFsIGRlcGVuZGVuY3kgKGFzIGluLCBkb2Vzbid0IG5lZWQgdG8gYmUgaW5zdGFsbGVkLCBOT1QgbGlrZSBvcHRpb25hbERlcGVuZGVuY2llcyBpbiBwYWNrYWdlLmpzb24pXG5cdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tZXh0cmFuZW91cy1kZXBlbmRlbmNpZXNcblx0Y29uc3Qgc3VwcG9ydHNDb2xvciA9IHJlcXVpcmUoJ3N1cHBvcnRzLWNvbG9yJyk7XG5cblx0aWYgKHN1cHBvcnRzQ29sb3IgJiYgKHN1cHBvcnRzQ29sb3Iuc3RkZXJyIHx8IHN1cHBvcnRzQ29sb3IpLmxldmVsID49IDIpIHtcblx0XHRleHBvcnRzLmNvbG9ycyA9IFtcblx0XHRcdDIwLFxuXHRcdFx0MjEsXG5cdFx0XHQyNixcblx0XHRcdDI3LFxuXHRcdFx0MzIsXG5cdFx0XHQzMyxcblx0XHRcdDM4LFxuXHRcdFx0MzksXG5cdFx0XHQ0MCxcblx0XHRcdDQxLFxuXHRcdFx0NDIsXG5cdFx0XHQ0Myxcblx0XHRcdDQ0LFxuXHRcdFx0NDUsXG5cdFx0XHQ1Nixcblx0XHRcdDU3LFxuXHRcdFx0NjIsXG5cdFx0XHQ2Myxcblx0XHRcdDY4LFxuXHRcdFx0NjksXG5cdFx0XHQ3NCxcblx0XHRcdDc1LFxuXHRcdFx0NzYsXG5cdFx0XHQ3Nyxcblx0XHRcdDc4LFxuXHRcdFx0NzksXG5cdFx0XHQ4MCxcblx0XHRcdDgxLFxuXHRcdFx0OTIsXG5cdFx0XHQ5Myxcblx0XHRcdDk4LFxuXHRcdFx0OTksXG5cdFx0XHQxMTIsXG5cdFx0XHQxMTMsXG5cdFx0XHQxMjgsXG5cdFx0XHQxMjksXG5cdFx0XHQxMzQsXG5cdFx0XHQxMzUsXG5cdFx0XHQxNDgsXG5cdFx0XHQxNDksXG5cdFx0XHQxNjAsXG5cdFx0XHQxNjEsXG5cdFx0XHQxNjIsXG5cdFx0XHQxNjMsXG5cdFx0XHQxNjQsXG5cdFx0XHQxNjUsXG5cdFx0XHQxNjYsXG5cdFx0XHQxNjcsXG5cdFx0XHQxNjgsXG5cdFx0XHQxNjksXG5cdFx0XHQxNzAsXG5cdFx0XHQxNzEsXG5cdFx0XHQxNzIsXG5cdFx0XHQxNzMsXG5cdFx0XHQxNzgsXG5cdFx0XHQxNzksXG5cdFx0XHQxODQsXG5cdFx0XHQxODUsXG5cdFx0XHQxOTYsXG5cdFx0XHQxOTcsXG5cdFx0XHQxOTgsXG5cdFx0XHQxOTksXG5cdFx0XHQyMDAsXG5cdFx0XHQyMDEsXG5cdFx0XHQyMDIsXG5cdFx0XHQyMDMsXG5cdFx0XHQyMDQsXG5cdFx0XHQyMDUsXG5cdFx0XHQyMDYsXG5cdFx0XHQyMDcsXG5cdFx0XHQyMDgsXG5cdFx0XHQyMDksXG5cdFx0XHQyMTQsXG5cdFx0XHQyMTUsXG5cdFx0XHQyMjAsXG5cdFx0XHQyMjFcblx0XHRdO1xuXHR9XG59IGNhdGNoIChlcnJvcikge1xuXHQvLyBTd2FsbG93IC0gd2Ugb25seSBjYXJlIGlmIGBzdXBwb3J0cy1jb2xvcmAgaXMgYXZhaWxhYmxlOyBpdCBkb2Vzbid0IGhhdmUgdG8gYmUuXG59XG5cbi8qKlxuICogQnVpbGQgdXAgdGhlIGRlZmF1bHQgYGluc3BlY3RPcHRzYCBvYmplY3QgZnJvbSB0aGUgZW52aXJvbm1lbnQgdmFyaWFibGVzLlxuICpcbiAqICAgJCBERUJVR19DT0xPUlM9bm8gREVCVUdfREVQVEg9MTAgREVCVUdfU0hPV19ISURERU49ZW5hYmxlZCBub2RlIHNjcmlwdC5qc1xuICovXG5cbmV4cG9ydHMuaW5zcGVjdE9wdHMgPSBPYmplY3Qua2V5cyhwcm9jZXNzLmVudikuZmlsdGVyKGtleSA9PiB7XG5cdHJldHVybiAvXmRlYnVnXy9pLnRlc3Qoa2V5KTtcbn0pLnJlZHVjZSgob2JqLCBrZXkpID0+IHtcblx0Ly8gQ2FtZWwtY2FzZVxuXHRjb25zdCBwcm9wID0ga2V5XG5cdFx0LnN1YnN0cmluZyg2KVxuXHRcdC50b0xvd2VyQ2FzZSgpXG5cdFx0LnJlcGxhY2UoL18oW2Etel0pL2csIChfLCBrKSA9PiB7XG5cdFx0XHRyZXR1cm4gay50b1VwcGVyQ2FzZSgpO1xuXHRcdH0pO1xuXG5cdC8vIENvZXJjZSBzdHJpbmcgdmFsdWUgaW50byBKUyB2YWx1ZVxuXHRsZXQgdmFsID0gcHJvY2Vzcy5lbnZba2V5XTtcblx0aWYgKC9eKHllc3xvbnx0cnVlfGVuYWJsZWQpJC9pLnRlc3QodmFsKSkge1xuXHRcdHZhbCA9IHRydWU7XG5cdH0gZWxzZSBpZiAoL14obm98b2ZmfGZhbHNlfGRpc2FibGVkKSQvaS50ZXN0KHZhbCkpIHtcblx0XHR2YWwgPSBmYWxzZTtcblx0fSBlbHNlIGlmICh2YWwgPT09ICdudWxsJykge1xuXHRcdHZhbCA9IG51bGw7XG5cdH0gZWxzZSB7XG5cdFx0dmFsID0gTnVtYmVyKHZhbCk7XG5cdH1cblxuXHRvYmpbcHJvcF0gPSB2YWw7XG5cdHJldHVybiBvYmo7XG59LCB7fSk7XG5cbi8qKlxuICogSXMgc3Rkb3V0IGEgVFRZPyBDb2xvcmVkIG91dHB1dCBpcyBlbmFibGVkIHdoZW4gYHRydWVgLlxuICovXG5cbmZ1bmN0aW9uIHVzZUNvbG9ycygpIHtcblx0cmV0dXJuICdjb2xvcnMnIGluIGV4cG9ydHMuaW5zcGVjdE9wdHMgP1xuXHRcdEJvb2xlYW4oZXhwb3J0cy5pbnNwZWN0T3B0cy5jb2xvcnMpIDpcblx0XHR0dHkuaXNhdHR5KHByb2Nlc3Muc3RkZXJyLmZkKTtcbn1cblxuLyoqXG4gKiBBZGRzIEFOU0kgY29sb3IgZXNjYXBlIGNvZGVzIGlmIGVuYWJsZWQuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBmb3JtYXRBcmdzKGFyZ3MpIHtcblx0Y29uc3Qge25hbWVzcGFjZTogbmFtZSwgdXNlQ29sb3JzfSA9IHRoaXM7XG5cblx0aWYgKHVzZUNvbG9ycykge1xuXHRcdGNvbnN0IGMgPSB0aGlzLmNvbG9yO1xuXHRcdGNvbnN0IGNvbG9yQ29kZSA9ICdcXHUwMDFCWzMnICsgKGMgPCA4ID8gYyA6ICc4OzU7JyArIGMpO1xuXHRcdGNvbnN0IHByZWZpeCA9IGAgICR7Y29sb3JDb2RlfTsxbSR7bmFtZX0gXFx1MDAxQlswbWA7XG5cblx0XHRhcmdzWzBdID0gcHJlZml4ICsgYXJnc1swXS5zcGxpdCgnXFxuJykuam9pbignXFxuJyArIHByZWZpeCk7XG5cdFx0YXJncy5wdXNoKGNvbG9yQ29kZSArICdtKycgKyBtb2R1bGUuZXhwb3J0cy5odW1hbml6ZSh0aGlzLmRpZmYpICsgJ1xcdTAwMUJbMG0nKTtcblx0fSBlbHNlIHtcblx0XHRhcmdzWzBdID0gZ2V0RGF0ZSgpICsgbmFtZSArICcgJyArIGFyZ3NbMF07XG5cdH1cbn1cblxuZnVuY3Rpb24gZ2V0RGF0ZSgpIHtcblx0aWYgKGV4cG9ydHMuaW5zcGVjdE9wdHMuaGlkZURhdGUpIHtcblx0XHRyZXR1cm4gJyc7XG5cdH1cblx0cmV0dXJuIG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSArICcgJztcbn1cblxuLyoqXG4gKiBJbnZva2VzIGB1dGlsLmZvcm1hdFdpdGhPcHRpb25zKClgIHdpdGggdGhlIHNwZWNpZmllZCBhcmd1bWVudHMgYW5kIHdyaXRlcyB0byBzdGRlcnIuXG4gKi9cblxuZnVuY3Rpb24gbG9nKC4uLmFyZ3MpIHtcblx0cmV0dXJuIHByb2Nlc3Muc3RkZXJyLndyaXRlKHV0aWwuZm9ybWF0V2l0aE9wdGlvbnMoZXhwb3J0cy5pbnNwZWN0T3B0cywgLi4uYXJncykgKyAnXFxuJyk7XG59XG5cbi8qKlxuICogU2F2ZSBgbmFtZXNwYWNlc2AuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZXNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBzYXZlKG5hbWVzcGFjZXMpIHtcblx0aWYgKG5hbWVzcGFjZXMpIHtcblx0XHRwcm9jZXNzLmVudi5ERUJVRyA9IG5hbWVzcGFjZXM7XG5cdH0gZWxzZSB7XG5cdFx0Ly8gSWYgeW91IHNldCBhIHByb2Nlc3MuZW52IGZpZWxkIHRvIG51bGwgb3IgdW5kZWZpbmVkLCBpdCBnZXRzIGNhc3QgdG8gdGhlXG5cdFx0Ly8gc3RyaW5nICdudWxsJyBvciAndW5kZWZpbmVkJy4gSnVzdCBkZWxldGUgaW5zdGVhZC5cblx0XHRkZWxldGUgcHJvY2Vzcy5lbnYuREVCVUc7XG5cdH1cbn1cblxuLyoqXG4gKiBMb2FkIGBuYW1lc3BhY2VzYC5cbiAqXG4gKiBAcmV0dXJuIHtTdHJpbmd9IHJldHVybnMgdGhlIHByZXZpb3VzbHkgcGVyc2lzdGVkIGRlYnVnIG1vZGVzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBsb2FkKCkge1xuXHRyZXR1cm4gcHJvY2Vzcy5lbnYuREVCVUc7XG59XG5cbi8qKlxuICogSW5pdCBsb2dpYyBmb3IgYGRlYnVnYCBpbnN0YW5jZXMuXG4gKlxuICogQ3JlYXRlIGEgbmV3IGBpbnNwZWN0T3B0c2Agb2JqZWN0IGluIGNhc2UgYHVzZUNvbG9yc2AgaXMgc2V0XG4gKiBkaWZmZXJlbnRseSBmb3IgYSBwYXJ0aWN1bGFyIGBkZWJ1Z2AgaW5zdGFuY2UuXG4gKi9cblxuZnVuY3Rpb24gaW5pdChkZWJ1Zykge1xuXHRkZWJ1Zy5pbnNwZWN0T3B0cyA9IHt9O1xuXG5cdGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhleHBvcnRzLmluc3BlY3RPcHRzKTtcblx0Zm9yIChsZXQgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG5cdFx0ZGVidWcuaW5zcGVjdE9wdHNba2V5c1tpXV0gPSBleHBvcnRzLmluc3BlY3RPcHRzW2tleXNbaV1dO1xuXHR9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9jb21tb24nKShleHBvcnRzKTtcblxuY29uc3Qge2Zvcm1hdHRlcnN9ID0gbW9kdWxlLmV4cG9ydHM7XG5cbi8qKlxuICogTWFwICVvIHRvIGB1dGlsLmluc3BlY3QoKWAsIGFsbCBvbiBhIHNpbmdsZSBsaW5lLlxuICovXG5cbmZvcm1hdHRlcnMubyA9IGZ1bmN0aW9uICh2KSB7XG5cdHRoaXMuaW5zcGVjdE9wdHMuY29sb3JzID0gdGhpcy51c2VDb2xvcnM7XG5cdHJldHVybiB1dGlsLmluc3BlY3QodiwgdGhpcy5pbnNwZWN0T3B0cylcblx0XHQuc3BsaXQoJ1xcbicpXG5cdFx0Lm1hcChzdHIgPT4gc3RyLnRyaW0oKSlcblx0XHQuam9pbignICcpO1xufTtcblxuLyoqXG4gKiBNYXAgJU8gdG8gYHV0aWwuaW5zcGVjdCgpYCwgYWxsb3dpbmcgbXVsdGlwbGUgbGluZXMgaWYgbmVlZGVkLlxuICovXG5cbmZvcm1hdHRlcnMuTyA9IGZ1bmN0aW9uICh2KSB7XG5cdHRoaXMuaW5zcGVjdE9wdHMuY29sb3JzID0gdGhpcy51c2VDb2xvcnM7XG5cdHJldHVybiB1dGlsLmluc3BlY3QodiwgdGhpcy5pbnNwZWN0T3B0cyk7XG59O1xuIl0sIm5hbWVzIjpbInR0eSIsInJlcXVpcmUiLCJ1dGlsIiwiZXhwb3J0cyIsImluaXQiLCJsb2ciLCJmb3JtYXRBcmdzIiwic2F2ZSIsImxvYWQiLCJ1c2VDb2xvcnMiLCJkZXN0cm95IiwiZGVwcmVjYXRlIiwiY29sb3JzIiwic3VwcG9ydHNDb2xvciIsInN0ZGVyciIsImxldmVsIiwiZXJyb3IiLCJpbnNwZWN0T3B0cyIsIk9iamVjdCIsImtleXMiLCJwcm9jZXNzIiwiZW52IiwiZmlsdGVyIiwia2V5IiwidGVzdCIsInJlZHVjZSIsIm9iaiIsInByb3AiLCJzdWJzdHJpbmciLCJ0b0xvd2VyQ2FzZSIsInJlcGxhY2UiLCJfIiwiayIsInRvVXBwZXJDYXNlIiwidmFsIiwiTnVtYmVyIiwiQm9vbGVhbiIsImlzYXR0eSIsImZkIiwiYXJncyIsIm5hbWVzcGFjZSIsIm5hbWUiLCJjIiwiY29sb3IiLCJjb2xvckNvZGUiLCJwcmVmaXgiLCJzcGxpdCIsImpvaW4iLCJwdXNoIiwibW9kdWxlIiwiaHVtYW5pemUiLCJkaWZmIiwiZ2V0RGF0ZSIsImhpZGVEYXRlIiwiRGF0ZSIsInRvSVNPU3RyaW5nIiwid3JpdGUiLCJmb3JtYXRXaXRoT3B0aW9ucyIsIm5hbWVzcGFjZXMiLCJERUJVRyIsImRlYnVnIiwiaSIsImxlbmd0aCIsImZvcm1hdHRlcnMiLCJvIiwidiIsImluc3BlY3QiLCJtYXAiLCJzdHIiLCJ0cmltIiwiTyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/engine.io/node_modules/debug/src/node.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/engine.io/build/engine.io.js":
/*!***************************************************!*\
  !*** ./node_modules/engine.io/build/engine.io.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.protocol = exports.Transport = exports.Socket = exports.uServer = exports.parser = exports.transports = exports.Server = void 0;\nexports.listen = listen;\nexports.attach = attach;\nconst http_1 = __webpack_require__(/*! http */ \"http\");\nconst server_1 = __webpack_require__(/*! ./server */ \"(rsc)/./node_modules/engine.io/build/server.js\");\nObject.defineProperty(exports, \"Server\", ({\n    enumerable: true,\n    get: function() {\n        return server_1.Server;\n    }\n}));\nconst index_1 = __webpack_require__(/*! ./transports/index */ \"(rsc)/./node_modules/engine.io/build/transports/index.js\");\nexports.transports = index_1.default;\nconst parser = __webpack_require__(/*! engine.io-parser */ \"(rsc)/./node_modules/engine.io-parser/build/cjs/index.js\");\nexports.parser = parser;\nvar userver_1 = __webpack_require__(/*! ./userver */ \"(rsc)/./node_modules/engine.io/build/userver.js\");\nObject.defineProperty(exports, \"uServer\", ({\n    enumerable: true,\n    get: function() {\n        return userver_1.uServer;\n    }\n}));\nvar socket_1 = __webpack_require__(/*! ./socket */ \"(rsc)/./node_modules/engine.io/build/socket.js\");\nObject.defineProperty(exports, \"Socket\", ({\n    enumerable: true,\n    get: function() {\n        return socket_1.Socket;\n    }\n}));\nvar transport_1 = __webpack_require__(/*! ./transport */ \"(rsc)/./node_modules/engine.io/build/transport.js\");\nObject.defineProperty(exports, \"Transport\", ({\n    enumerable: true,\n    get: function() {\n        return transport_1.Transport;\n    }\n}));\nexports.protocol = parser.protocol;\n/**\n * Creates an http.Server exclusively used for WS upgrades.\n *\n * @param {Number} port\n * @param {Function} callback\n * @param {Object} options\n * @return {Server} websocket.io server\n */ function listen(port, options, fn) {\n    if (\"function\" === typeof options) {\n        fn = options;\n        options = {};\n    }\n    const server = (0, http_1.createServer)(function(req, res) {\n        res.writeHead(501);\n        res.end(\"Not Implemented\");\n    });\n    // create engine server\n    const engine = attach(server, options);\n    engine.httpServer = server;\n    server.listen(port, fn);\n    return engine;\n}\n/**\n * Captures upgrade requests for a http.Server.\n *\n * @param {http.Server} server\n * @param {Object} options\n * @return {Server} engine server\n */ function attach(server, options) {\n    const engine = new server_1.Server(options);\n    engine.attach(server, options);\n    return engine;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZW5naW5lLmlvL2J1aWxkL2VuZ2luZS5pby5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsZ0JBQWdCLEdBQUdBLGlCQUFpQixHQUFHQSxjQUFjLEdBQUdBLGVBQWUsR0FBR0EsY0FBYyxHQUFHQSxrQkFBa0IsR0FBR0EsY0FBYyxHQUFHLEtBQUs7QUFDdElBLGNBQWMsR0FBR1M7QUFDakJULGNBQWMsR0FBR1U7QUFDakIsTUFBTUMsU0FBU0MsbUJBQU9BLENBQUMsa0JBQU07QUFDN0IsTUFBTUMsV0FBV0QsbUJBQU9BLENBQUMsZ0VBQVU7QUFDbkNkLDBDQUF5QztJQUFFZ0IsWUFBWTtJQUFNQyxLQUFLO1FBQWMsT0FBT0YsU0FBU0wsTUFBTTtJQUFFO0FBQUUsQ0FBQyxFQUFDO0FBQzVHLE1BQU1RLFVBQVVKLG1CQUFPQSxDQUFDLG9GQUFvQjtBQUM1Q1osa0JBQWtCLEdBQUdnQixRQUFRQyxPQUFPO0FBQ3BDLE1BQU1YLFNBQVNNLG1CQUFPQSxDQUFDLGtGQUFrQjtBQUN6Q1osY0FBYyxHQUFHTTtBQUNqQixJQUFJWSxZQUFZTixtQkFBT0EsQ0FBQyxrRUFBVztBQUNuQ2QsMkNBQTBDO0lBQUVnQixZQUFZO0lBQU1DLEtBQUs7UUFBYyxPQUFPRyxVQUFVYixPQUFPO0lBQUU7QUFBRSxDQUFDLEVBQUM7QUFDL0csSUFBSWMsV0FBV1AsbUJBQU9BLENBQUMsZ0VBQVU7QUFDakNkLDBDQUF5QztJQUFFZ0IsWUFBWTtJQUFNQyxLQUFLO1FBQWMsT0FBT0ksU0FBU2YsTUFBTTtJQUFFO0FBQUUsQ0FBQyxFQUFDO0FBQzVHLElBQUlnQixjQUFjUixtQkFBT0EsQ0FBQyxzRUFBYTtBQUN2Q2QsNkNBQTRDO0lBQUVnQixZQUFZO0lBQU1DLEtBQUs7UUFBYyxPQUFPSyxZQUFZakIsU0FBUztJQUFFO0FBQUUsQ0FBQyxFQUFDO0FBQ3JISCxnQkFBZ0IsR0FBR00sT0FBT0osUUFBUTtBQUNsQzs7Ozs7OztDQU9DLEdBQ0QsU0FBU08sT0FBT1ksSUFBSSxFQUFFQyxPQUFPLEVBQUVDLEVBQUU7SUFDN0IsSUFBSSxlQUFlLE9BQU9ELFNBQVM7UUFDL0JDLEtBQUtEO1FBQ0xBLFVBQVUsQ0FBQztJQUNmO0lBQ0EsTUFBTUUsU0FBUyxDQUFDLEdBQUdiLE9BQU9jLFlBQVksRUFBRSxTQUFVQyxHQUFHLEVBQUVDLEdBQUc7UUFDdERBLElBQUlDLFNBQVMsQ0FBQztRQUNkRCxJQUFJRSxHQUFHLENBQUM7SUFDWjtJQUNBLHVCQUF1QjtJQUN2QixNQUFNQyxTQUFTcEIsT0FBT2MsUUFBUUY7SUFDOUJRLE9BQU9DLFVBQVUsR0FBR1A7SUFDcEJBLE9BQU9mLE1BQU0sQ0FBQ1ksTUFBTUU7SUFDcEIsT0FBT087QUFDWDtBQUNBOzs7Ozs7Q0FNQyxHQUNELFNBQVNwQixPQUFPYyxNQUFNLEVBQUVGLE9BQU87SUFDM0IsTUFBTVEsU0FBUyxJQUFJakIsU0FBU0wsTUFBTSxDQUFDYztJQUNuQ1EsT0FBT3BCLE1BQU0sQ0FBQ2MsUUFBUUY7SUFDdEIsT0FBT1E7QUFDWCIsInNvdXJjZXMiOlsid2VicGFjazovL2V4YW1yb3NoLy4vbm9kZV9tb2R1bGVzL2VuZ2luZS5pby9idWlsZC9lbmdpbmUuaW8uanM/YjA5ZiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMucHJvdG9jb2wgPSBleHBvcnRzLlRyYW5zcG9ydCA9IGV4cG9ydHMuU29ja2V0ID0gZXhwb3J0cy51U2VydmVyID0gZXhwb3J0cy5wYXJzZXIgPSBleHBvcnRzLnRyYW5zcG9ydHMgPSBleHBvcnRzLlNlcnZlciA9IHZvaWQgMDtcbmV4cG9ydHMubGlzdGVuID0gbGlzdGVuO1xuZXhwb3J0cy5hdHRhY2ggPSBhdHRhY2g7XG5jb25zdCBodHRwXzEgPSByZXF1aXJlKFwiaHR0cFwiKTtcbmNvbnN0IHNlcnZlcl8xID0gcmVxdWlyZShcIi4vc2VydmVyXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiU2VydmVyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBzZXJ2ZXJfMS5TZXJ2ZXI7IH0gfSk7XG5jb25zdCBpbmRleF8xID0gcmVxdWlyZShcIi4vdHJhbnNwb3J0cy9pbmRleFwiKTtcbmV4cG9ydHMudHJhbnNwb3J0cyA9IGluZGV4XzEuZGVmYXVsdDtcbmNvbnN0IHBhcnNlciA9IHJlcXVpcmUoXCJlbmdpbmUuaW8tcGFyc2VyXCIpO1xuZXhwb3J0cy5wYXJzZXIgPSBwYXJzZXI7XG52YXIgdXNlcnZlcl8xID0gcmVxdWlyZShcIi4vdXNlcnZlclwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInVTZXJ2ZXJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHVzZXJ2ZXJfMS51U2VydmVyOyB9IH0pO1xudmFyIHNvY2tldF8xID0gcmVxdWlyZShcIi4vc29ja2V0XCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiU29ja2V0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBzb2NrZXRfMS5Tb2NrZXQ7IH0gfSk7XG52YXIgdHJhbnNwb3J0XzEgPSByZXF1aXJlKFwiLi90cmFuc3BvcnRcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJUcmFuc3BvcnRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRyYW5zcG9ydF8xLlRyYW5zcG9ydDsgfSB9KTtcbmV4cG9ydHMucHJvdG9jb2wgPSBwYXJzZXIucHJvdG9jb2w7XG4vKipcbiAqIENyZWF0ZXMgYW4gaHR0cC5TZXJ2ZXIgZXhjbHVzaXZlbHkgdXNlZCBmb3IgV1MgdXBncmFkZXMuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IHBvcnRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQHJldHVybiB7U2VydmVyfSB3ZWJzb2NrZXQuaW8gc2VydmVyXG4gKi9cbmZ1bmN0aW9uIGxpc3Rlbihwb3J0LCBvcHRpb25zLCBmbikge1xuICAgIGlmIChcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBvcHRpb25zKSB7XG4gICAgICAgIGZuID0gb3B0aW9ucztcbiAgICAgICAgb3B0aW9ucyA9IHt9O1xuICAgIH1cbiAgICBjb25zdCBzZXJ2ZXIgPSAoMCwgaHR0cF8xLmNyZWF0ZVNlcnZlcikoZnVuY3Rpb24gKHJlcSwgcmVzKSB7XG4gICAgICAgIHJlcy53cml0ZUhlYWQoNTAxKTtcbiAgICAgICAgcmVzLmVuZChcIk5vdCBJbXBsZW1lbnRlZFwiKTtcbiAgICB9KTtcbiAgICAvLyBjcmVhdGUgZW5naW5lIHNlcnZlclxuICAgIGNvbnN0IGVuZ2luZSA9IGF0dGFjaChzZXJ2ZXIsIG9wdGlvbnMpO1xuICAgIGVuZ2luZS5odHRwU2VydmVyID0gc2VydmVyO1xuICAgIHNlcnZlci5saXN0ZW4ocG9ydCwgZm4pO1xuICAgIHJldHVybiBlbmdpbmU7XG59XG4vKipcbiAqIENhcHR1cmVzIHVwZ3JhZGUgcmVxdWVzdHMgZm9yIGEgaHR0cC5TZXJ2ZXIuXG4gKlxuICogQHBhcmFtIHtodHRwLlNlcnZlcn0gc2VydmVyXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQHJldHVybiB7U2VydmVyfSBlbmdpbmUgc2VydmVyXG4gKi9cbmZ1bmN0aW9uIGF0dGFjaChzZXJ2ZXIsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBlbmdpbmUgPSBuZXcgc2VydmVyXzEuU2VydmVyKG9wdGlvbnMpO1xuICAgIGVuZ2luZS5hdHRhY2goc2VydmVyLCBvcHRpb25zKTtcbiAgICByZXR1cm4gZW5naW5lO1xufVxuIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwicHJvdG9jb2wiLCJUcmFuc3BvcnQiLCJTb2NrZXQiLCJ1U2VydmVyIiwicGFyc2VyIiwidHJhbnNwb3J0cyIsIlNlcnZlciIsImxpc3RlbiIsImF0dGFjaCIsImh0dHBfMSIsInJlcXVpcmUiLCJzZXJ2ZXJfMSIsImVudW1lcmFibGUiLCJnZXQiLCJpbmRleF8xIiwiZGVmYXVsdCIsInVzZXJ2ZXJfMSIsInNvY2tldF8xIiwidHJhbnNwb3J0XzEiLCJwb3J0Iiwib3B0aW9ucyIsImZuIiwic2VydmVyIiwiY3JlYXRlU2VydmVyIiwicmVxIiwicmVzIiwid3JpdGVIZWFkIiwiZW5kIiwiZW5naW5lIiwiaHR0cFNlcnZlciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/engine.io/build/engine.io.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/engine.io/build/parser-v3/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/engine.io/build/parser-v3/index.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n// imported from https://github.com/socketio/engine.io-parser/tree/2.2.x\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.packets = exports.protocol = void 0;\nexports.encodePacket = encodePacket;\nexports.encodeBase64Packet = encodeBase64Packet;\nexports.decodePacket = decodePacket;\nexports.decodeBase64Packet = decodeBase64Packet;\nexports.encodePayload = encodePayload;\nexports.decodePayload = decodePayload;\nexports.encodePayloadAsBinary = encodePayloadAsBinary;\nexports.decodePayloadAsBinary = decodePayloadAsBinary;\n/**\n * Module dependencies.\n */ var utf8 = __webpack_require__(/*! ./utf8 */ \"(rsc)/./node_modules/engine.io/build/parser-v3/utf8.js\");\n/**\n * Current protocol version.\n */ exports.protocol = 3;\nconst hasBinary = (packets)=>{\n    for (const packet of packets){\n        if (packet.data instanceof ArrayBuffer || ArrayBuffer.isView(packet.data)) {\n            return true;\n        }\n    }\n    return false;\n};\n/**\n * Packet types.\n */ exports.packets = {\n    open: 0 // non-ws\n    ,\n    close: 1 // non-ws\n    ,\n    ping: 2,\n    pong: 3,\n    message: 4,\n    upgrade: 5,\n    noop: 6\n};\nvar packetslist = Object.keys(exports.packets);\n/**\n * Premade error packet.\n */ var err = {\n    type: \"error\",\n    data: \"parser error\"\n};\nconst EMPTY_BUFFER = Buffer.concat([]);\n/**\n * Encodes a packet.\n *\n *     <packet type id> [ <data> ]\n *\n * Example:\n *\n *     5hello world\n *     3\n *     4\n *\n * Binary is encoded in an identical principle\n *\n * @api private\n */ function encodePacket(packet, supportsBinary, utf8encode, callback) {\n    if (typeof supportsBinary === \"function\") {\n        callback = supportsBinary;\n        supportsBinary = null;\n    }\n    if (typeof utf8encode === \"function\") {\n        callback = utf8encode;\n        utf8encode = null;\n    }\n    if (Buffer.isBuffer(packet.data)) {\n        return encodeBuffer(packet, supportsBinary, callback);\n    } else if (packet.data && (packet.data.buffer || packet.data) instanceof ArrayBuffer) {\n        return encodeBuffer({\n            type: packet.type,\n            data: arrayBufferToBuffer(packet.data)\n        }, supportsBinary, callback);\n    }\n    // Sending data as a utf-8 string\n    var encoded = exports.packets[packet.type];\n    // data fragment is optional\n    if (undefined !== packet.data) {\n        encoded += utf8encode ? utf8.encode(String(packet.data), {\n            strict: false\n        }) : String(packet.data);\n    }\n    return callback(\"\" + encoded);\n}\n/**\n * Encode Buffer data\n */ function encodeBuffer(packet, supportsBinary, callback) {\n    if (!supportsBinary) {\n        return encodeBase64Packet(packet, callback);\n    }\n    var data = packet.data;\n    var typeBuffer = Buffer.allocUnsafe(1);\n    typeBuffer[0] = exports.packets[packet.type];\n    return callback(Buffer.concat([\n        typeBuffer,\n        data\n    ]));\n}\n/**\n * Encodes a packet with binary data in a base64 string\n *\n * @param {Object} packet, has `type` and `data`\n * @return {String} base64 encoded message\n */ function encodeBase64Packet(packet, callback) {\n    var data = Buffer.isBuffer(packet.data) ? packet.data : arrayBufferToBuffer(packet.data);\n    var message = \"b\" + exports.packets[packet.type];\n    message += data.toString(\"base64\");\n    return callback(message);\n}\n/**\n * Decodes a packet. Data also available as an ArrayBuffer if requested.\n *\n * @return {Object} with `type` and `data` (if any)\n * @api private\n */ function decodePacket(data, binaryType, utf8decode) {\n    if (data === undefined) {\n        return err;\n    }\n    var type;\n    // String data\n    if (typeof data === \"string\") {\n        type = data.charAt(0);\n        if (type === \"b\") {\n            return decodeBase64Packet(data.slice(1), binaryType);\n        }\n        if (utf8decode) {\n            data = tryDecode(data);\n            if (data === false) {\n                return err;\n            }\n        }\n        if (Number(type) != type || !packetslist[type]) {\n            return err;\n        }\n        if (data.length > 1) {\n            return {\n                type: packetslist[type],\n                data: data.slice(1)\n            };\n        } else {\n            return {\n                type: packetslist[type]\n            };\n        }\n    }\n    // Binary data\n    if (binaryType === \"arraybuffer\") {\n        // wrap Buffer/ArrayBuffer data into an Uint8Array\n        var intArray = new Uint8Array(data);\n        type = intArray[0];\n        return {\n            type: packetslist[type],\n            data: intArray.buffer.slice(1)\n        };\n    }\n    if (data instanceof ArrayBuffer) {\n        data = arrayBufferToBuffer(data);\n    }\n    type = data[0];\n    return {\n        type: packetslist[type],\n        data: data.slice(1)\n    };\n}\nfunction tryDecode(data) {\n    try {\n        data = utf8.decode(data, {\n            strict: false\n        });\n    } catch (e) {\n        return false;\n    }\n    return data;\n}\n/**\n * Decodes a packet encoded in a base64 string.\n *\n * @param {String} base64 encoded message\n * @return {Object} with `type` and `data` (if any)\n */ function decodeBase64Packet(msg, binaryType) {\n    var type = packetslist[msg.charAt(0)];\n    var data = Buffer.from(msg.slice(1), \"base64\");\n    if (binaryType === \"arraybuffer\") {\n        var abv = new Uint8Array(data.length);\n        for(var i = 0; i < abv.length; i++){\n            abv[i] = data[i];\n        }\n        // @ts-ignore\n        data = abv.buffer;\n    }\n    return {\n        type: type,\n        data: data\n    };\n}\n/**\n * Encodes multiple messages (payload).\n *\n *     <length>:data\n *\n * Example:\n *\n *     11:hello world2:hi\n *\n * If any contents are binary, they will be encoded as base64 strings. Base64\n * encoded strings are marked with a b before the length specifier\n *\n * @param {Array} packets\n * @api private\n */ function encodePayload(packets, supportsBinary, callback) {\n    if (typeof supportsBinary === \"function\") {\n        callback = supportsBinary;\n        supportsBinary = null;\n    }\n    if (supportsBinary && hasBinary(packets)) {\n        return encodePayloadAsBinary(packets, callback);\n    }\n    if (!packets.length) {\n        return callback(\"0:\");\n    }\n    function encodeOne(packet, doneCallback) {\n        encodePacket(packet, supportsBinary, false, function(message) {\n            doneCallback(null, setLengthHeader(message));\n        });\n    }\n    map(packets, encodeOne, function(err, results) {\n        return callback(results.join(\"\"));\n    });\n}\nfunction setLengthHeader(message) {\n    return message.length + \":\" + message;\n}\n/**\n * Async array map using after\n */ function map(ary, each, done) {\n    const results = new Array(ary.length);\n    let count = 0;\n    for(let i = 0; i < ary.length; i++){\n        each(ary[i], (error, msg)=>{\n            results[i] = msg;\n            if (++count === ary.length) {\n                done(null, results);\n            }\n        });\n    }\n}\n/*\n * Decodes data when a payload is maybe expected. Possible binary contents are\n * decoded from their base64 representation\n *\n * @param {String} data, callback method\n * @api public\n */ function decodePayload(data, binaryType, callback) {\n    if (typeof data !== \"string\") {\n        return decodePayloadAsBinary(data, binaryType, callback);\n    }\n    if (typeof binaryType === \"function\") {\n        callback = binaryType;\n        binaryType = null;\n    }\n    if (data === \"\") {\n        // parser error - ignoring payload\n        return callback(err, 0, 1);\n    }\n    var length = \"\", n, msg, packet;\n    for(var i = 0, l = data.length; i < l; i++){\n        var chr = data.charAt(i);\n        if (chr !== \":\") {\n            length += chr;\n            continue;\n        }\n        // @ts-ignore\n        if (length === \"\" || length != (n = Number(length))) {\n            // parser error - ignoring payload\n            return callback(err, 0, 1);\n        }\n        msg = data.slice(i + 1, i + 1 + n);\n        if (length != msg.length) {\n            // parser error - ignoring payload\n            return callback(err, 0, 1);\n        }\n        if (msg.length) {\n            packet = decodePacket(msg, binaryType, false);\n            if (err.type === packet.type && err.data === packet.data) {\n                // parser error in individual packet - ignoring payload\n                return callback(err, 0, 1);\n            }\n            var more = callback(packet, i + n, l);\n            if (false === more) return;\n        }\n        // advance cursor\n        i += n;\n        length = \"\";\n    }\n    if (length !== \"\") {\n        // parser error - ignoring payload\n        return callback(err, 0, 1);\n    }\n}\n/**\n *\n * Converts a buffer to a utf8.js encoded string\n *\n * @api private\n */ function bufferToString(buffer) {\n    var str = \"\";\n    for(var i = 0, l = buffer.length; i < l; i++){\n        str += String.fromCharCode(buffer[i]);\n    }\n    return str;\n}\n/**\n *\n * Converts a utf8.js encoded string to a buffer\n *\n * @api private\n */ function stringToBuffer(string) {\n    var buf = Buffer.allocUnsafe(string.length);\n    for(var i = 0, l = string.length; i < l; i++){\n        buf.writeUInt8(string.charCodeAt(i), i);\n    }\n    return buf;\n}\n/**\n *\n * Converts an ArrayBuffer to a Buffer\n *\n * @api private\n */ function arrayBufferToBuffer(data) {\n    // data is either an ArrayBuffer or ArrayBufferView.\n    var length = data.byteLength || data.length;\n    var offset = data.byteOffset || 0;\n    return Buffer.from(data.buffer || data, offset, length);\n}\n/**\n * Encodes multiple messages (payload) as binary.\n *\n * <1 = binary, 0 = string><number from 0-9><number from 0-9>[...]<number\n * 255><data>\n *\n * Example:\n * 1 3 255 1 2 3, if the binary contents are interpreted as 8 bit integers\n *\n * @param {Array} packets\n * @return {Buffer} encoded payload\n * @api private\n */ function encodePayloadAsBinary(packets, callback) {\n    if (!packets.length) {\n        return callback(EMPTY_BUFFER);\n    }\n    map(packets, encodeOneBinaryPacket, function(err, results) {\n        return callback(Buffer.concat(results));\n    });\n}\nfunction encodeOneBinaryPacket(p, doneCallback) {\n    function onBinaryPacketEncode(packet) {\n        var encodingLength = \"\" + packet.length;\n        var sizeBuffer;\n        if (typeof packet === \"string\") {\n            sizeBuffer = Buffer.allocUnsafe(encodingLength.length + 2);\n            sizeBuffer[0] = 0; // is a string (not true binary = 0)\n            for(var i = 0; i < encodingLength.length; i++){\n                sizeBuffer[i + 1] = parseInt(encodingLength[i], 10);\n            }\n            sizeBuffer[sizeBuffer.length - 1] = 255;\n            return doneCallback(null, Buffer.concat([\n                sizeBuffer,\n                stringToBuffer(packet)\n            ]));\n        }\n        sizeBuffer = Buffer.allocUnsafe(encodingLength.length + 2);\n        sizeBuffer[0] = 1; // is binary (true binary = 1)\n        for(var i = 0; i < encodingLength.length; i++){\n            sizeBuffer[i + 1] = parseInt(encodingLength[i], 10);\n        }\n        sizeBuffer[sizeBuffer.length - 1] = 255;\n        doneCallback(null, Buffer.concat([\n            sizeBuffer,\n            packet\n        ]));\n    }\n    encodePacket(p, true, true, onBinaryPacketEncode);\n}\n/*\n * Decodes data when a payload is maybe expected. Strings are decoded by\n * interpreting each byte as a key code for entries marked to start with 0. See\n * description of encodePayloadAsBinary\n\n * @param {Buffer} data, callback method\n * @api public\n */ function decodePayloadAsBinary(data, binaryType, callback) {\n    if (typeof binaryType === \"function\") {\n        callback = binaryType;\n        binaryType = null;\n    }\n    var bufferTail = data;\n    var buffers = [];\n    var i;\n    while(bufferTail.length > 0){\n        var strLen = \"\";\n        var isString = bufferTail[0] === 0;\n        for(i = 1;; i++){\n            if (bufferTail[i] === 255) break;\n            // 310 = char length of Number.MAX_VALUE\n            if (strLen.length > 310) {\n                return callback(err, 0, 1);\n            }\n            strLen += \"\" + bufferTail[i];\n        }\n        bufferTail = bufferTail.slice(strLen.length + 1);\n        var msgLength = parseInt(strLen, 10);\n        var msg = bufferTail.slice(1, msgLength + 1);\n        if (isString) msg = bufferToString(msg);\n        buffers.push(msg);\n        bufferTail = bufferTail.slice(msgLength + 1);\n    }\n    var total = buffers.length;\n    for(i = 0; i < total; i++){\n        var buffer = buffers[i];\n        callback(decodePacket(buffer, binaryType, true), i, total);\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZW5naW5lLmlvL2J1aWxkL3BhcnNlci12My9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLHdFQUF3RTtBQUN4RUEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELGVBQWUsR0FBR0EsZ0JBQWdCLEdBQUcsS0FBSztBQUMxQ0Esb0JBQW9CLEdBQUdJO0FBQ3ZCSiwwQkFBMEIsR0FBR0s7QUFDN0JMLG9CQUFvQixHQUFHTTtBQUN2Qk4sMEJBQTBCLEdBQUdPO0FBQzdCUCxxQkFBcUIsR0FBR1E7QUFDeEJSLHFCQUFxQixHQUFHUztBQUN4QlQsNkJBQTZCLEdBQUdVO0FBQ2hDViw2QkFBNkIsR0FBR1c7QUFDaEM7O0NBRUMsR0FDRCxJQUFJQyxPQUFPQyxtQkFBT0EsQ0FBQztBQUNuQjs7Q0FFQyxHQUNEYixnQkFBZ0IsR0FBRztBQUNuQixNQUFNYyxZQUFZLENBQUNaO0lBQ2YsS0FBSyxNQUFNYSxVQUFVYixRQUFTO1FBQzFCLElBQUlhLE9BQU9DLElBQUksWUFBWUMsZUFBZUEsWUFBWUMsTUFBTSxDQUFDSCxPQUFPQyxJQUFJLEdBQUc7WUFDdkUsT0FBTztRQUNYO0lBQ0o7SUFDQSxPQUFPO0FBQ1g7QUFDQTs7Q0FFQyxHQUNEaEIsZUFBZSxHQUFHO0lBQ2RtQixNQUFNLEVBQUUsU0FBUzs7SUFFakJDLE9BQU8sRUFBRSxTQUFTOztJQUVsQkMsTUFBTTtJQUNOQyxNQUFNO0lBQ05DLFNBQVM7SUFDVEMsU0FBUztJQUNUQyxNQUFNO0FBQ1Y7QUFDQSxJQUFJQyxjQUFjNUIsT0FBTzZCLElBQUksQ0FBQzNCLFFBQVFFLE9BQU87QUFDN0M7O0NBRUMsR0FDRCxJQUFJMEIsTUFBTTtJQUFFQyxNQUFNO0lBQVNiLE1BQU07QUFBZTtBQUNoRCxNQUFNYyxlQUFlQyxPQUFPQyxNQUFNLENBQUMsRUFBRTtBQUNyQzs7Ozs7Ozs7Ozs7Ozs7Q0FjQyxHQUNELFNBQVM1QixhQUFhVyxNQUFNLEVBQUVrQixj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c291cmNlcyI6WyJ3ZWJwYWNrOi8vZXhhbXJvc2gvLi9ub2RlX21vZHVsZXMvZW5naW5lLmlvL2J1aWxkL3BhcnNlci12My9pbmRleC5qcz9mYTBhIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLy8gaW1wb3J0ZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vc29ja2V0aW8vZW5naW5lLmlvLXBhcnNlci90cmVlLzIuMi54XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnBhY2tldHMgPSBleHBvcnRzLnByb3RvY29sID0gdm9pZCAwO1xuZXhwb3J0cy5lbmNvZGVQYWNrZXQgPSBlbmNvZGVQYWNrZXQ7XG5leHBvcnRzLmVuY29kZUJhc2U2NFBhY2tldCA9IGVuY29kZUJhc2U2NFBhY2tldDtcbmV4cG9ydHMuZGVjb2RlUGFja2V0ID0gZGVjb2RlUGFja2V0O1xuZXhwb3J0cy5kZWNvZGVCYXNlNjRQYWNrZXQgPSBkZWNvZGVCYXNlNjRQYWNrZXQ7XG5leHBvcnRzLmVuY29kZVBheWxvYWQgPSBlbmNvZGVQYXlsb2FkO1xuZXhwb3J0cy5kZWNvZGVQYXlsb2FkID0gZGVjb2RlUGF5bG9hZDtcbmV4cG9ydHMuZW5jb2RlUGF5bG9hZEFzQmluYXJ5ID0gZW5jb2RlUGF5bG9hZEFzQmluYXJ5O1xuZXhwb3J0cy5kZWNvZGVQYXlsb2FkQXNCaW5hcnkgPSBkZWNvZGVQYXlsb2FkQXNCaW5hcnk7XG4vKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cbnZhciB1dGY4ID0gcmVxdWlyZSgnLi91dGY4Jyk7XG4vKipcbiAqIEN1cnJlbnQgcHJvdG9jb2wgdmVyc2lvbi5cbiAqL1xuZXhwb3J0cy5wcm90b2NvbCA9IDM7XG5jb25zdCBoYXNCaW5hcnkgPSAocGFja2V0cykgPT4ge1xuICAgIGZvciAoY29uc3QgcGFja2V0IG9mIHBhY2tldHMpIHtcbiAgICAgICAgaWYgKHBhY2tldC5kYXRhIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIgfHwgQXJyYXlCdWZmZXIuaXNWaWV3KHBhY2tldC5kYXRhKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufTtcbi8qKlxuICogUGFja2V0IHR5cGVzLlxuICovXG5leHBvcnRzLnBhY2tldHMgPSB7XG4gICAgb3BlbjogMCAvLyBub24td3NcbiAgICAsXG4gICAgY2xvc2U6IDEgLy8gbm9uLXdzXG4gICAgLFxuICAgIHBpbmc6IDIsXG4gICAgcG9uZzogMyxcbiAgICBtZXNzYWdlOiA0LFxuICAgIHVwZ3JhZGU6IDUsXG4gICAgbm9vcDogNlxufTtcbnZhciBwYWNrZXRzbGlzdCA9IE9iamVjdC5rZXlzKGV4cG9ydHMucGFja2V0cyk7XG4vKipcbiAqIFByZW1hZGUgZXJyb3IgcGFja2V0LlxuICovXG52YXIgZXJyID0geyB0eXBlOiAnZXJyb3InLCBkYXRhOiAncGFyc2VyIGVycm9yJyB9O1xuY29uc3QgRU1QVFlfQlVGRkVSID0gQnVmZmVyLmNvbmNhdChbXSk7XG4vKipcbiAqIEVuY29kZXMgYSBwYWNrZXQuXG4gKlxuICogICAgIDxwYWNrZXQgdHlwZSBpZD4gWyA8ZGF0YT4gXVxuICpcbiAqIEV4YW1wbGU6XG4gKlxuICogICAgIDVoZWxsbyB3b3JsZFxuICogICAgIDNcbiAqICAgICA0XG4gKlxuICogQmluYXJ5IGlzIGVuY29kZWQgaW4gYW4gaWRlbnRpY2FsIHByaW5jaXBsZVxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBlbmNvZGVQYWNrZXQocGFja2V0LCBzdXBwb3J0c0JpbmFyeSwgdXRmOGVuY29kZSwgY2FsbGJhY2spIHtcbiAgICBpZiAodHlwZW9mIHN1cHBvcnRzQmluYXJ5ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGNhbGxiYWNrID0gc3VwcG9ydHNCaW5hcnk7XG4gICAgICAgIHN1cHBvcnRzQmluYXJ5ID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB1dGY4ZW5jb2RlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGNhbGxiYWNrID0gdXRmOGVuY29kZTtcbiAgICAgICAgdXRmOGVuY29kZSA9IG51bGw7XG4gICAgfVxuICAgIGlmIChCdWZmZXIuaXNCdWZmZXIocGFja2V0LmRhdGEpKSB7XG4gICAgICAgIHJldHVybiBlbmNvZGVCdWZmZXIocGFja2V0LCBzdXBwb3J0c0JpbmFyeSwgY2FsbGJhY2spO1xuICAgIH1cbiAgICBlbHNlIGlmIChwYWNrZXQuZGF0YSAmJiAocGFja2V0LmRhdGEuYnVmZmVyIHx8IHBhY2tldC5kYXRhKSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgICAgIHJldHVybiBlbmNvZGVCdWZmZXIoeyB0eXBlOiBwYWNrZXQudHlwZSwgZGF0YTogYXJyYXlCdWZmZXJUb0J1ZmZlcihwYWNrZXQuZGF0YSkgfSwgc3VwcG9ydHNCaW5hcnksIGNhbGxiYWNrKTtcbiAgICB9XG4gICAgLy8gU2VuZGluZyBkYXRhIGFzIGEgdXRmLTggc3RyaW5nXG4gICAgdmFyIGVuY29kZWQgPSBleHBvcnRzLnBhY2tldHNbcGFja2V0LnR5cGVdO1xuICAgIC8vIGRhdGEgZnJhZ21lbnQgaXMgb3B0aW9uYWxcbiAgICBpZiAodW5kZWZpbmVkICE9PSBwYWNrZXQuZGF0YSkge1xuICAgICAgICBlbmNvZGVkICs9IHV0ZjhlbmNvZGUgPyB1dGY4LmVuY29kZShTdHJpbmcocGFja2V0LmRhdGEpLCB7IHN0cmljdDogZmFsc2UgfSkgOiBTdHJpbmcocGFja2V0LmRhdGEpO1xuICAgIH1cbiAgICByZXR1cm4gY2FsbGJhY2soJycgKyBlbmNvZGVkKTtcbn1cbjtcbi8qKlxuICogRW5jb2RlIEJ1ZmZlciBkYXRhXG4gKi9cbmZ1bmN0aW9uIGVuY29kZUJ1ZmZlcihwYWNrZXQsIHN1cHBvcnRzQmluYXJ5LCBjYWxsYmFjaykge1xuICAgIGlmICghc3VwcG9ydHNCaW5hcnkpIHtcbiAgICAgICAgcmV0dXJuIGVuY29kZUJhc2U2NFBhY2tldChwYWNrZXQsIGNhbGxiYWNrKTtcbiAgICB9XG4gICAgdmFyIGRhdGEgPSBwYWNrZXQuZGF0YTtcbiAgICB2YXIgdHlwZUJ1ZmZlciA9IEJ1ZmZlci5hbGxvY1Vuc2FmZSgxKTtcbiAgICB0eXBlQnVmZmVyWzBdID0gZXhwb3J0cy5wYWNrZXRzW3BhY2tldC50eXBlXTtcbiAgICByZXR1cm4gY2FsbGJhY2soQnVmZmVyLmNvbmNhdChbdHlwZUJ1ZmZlciwgZGF0YV0pKTtcbn1cbi8qKlxuICogRW5jb2RlcyBhIHBhY2tldCB3aXRoIGJpbmFyeSBkYXRhIGluIGEgYmFzZTY0IHN0cmluZ1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYWNrZXQsIGhhcyBgdHlwZWAgYW5kIGBkYXRhYFxuICogQHJldHVybiB7U3RyaW5nfSBiYXNlNjQgZW5jb2RlZCBtZXNzYWdlXG4gKi9cbmZ1bmN0aW9uIGVuY29kZUJhc2U2NFBhY2tldChwYWNrZXQsIGNhbGxiYWNrKSB7XG4gICAgdmFyIGRhdGEgPSBCdWZmZXIuaXNCdWZmZXIocGFja2V0LmRhdGEpID8gcGFja2V0LmRhdGEgOiBhcnJheUJ1ZmZlclRvQnVmZmVyKHBhY2tldC5kYXRhKTtcbiAgICB2YXIgbWVzc2FnZSA9ICdiJyArIGV4cG9ydHMucGFja2V0c1twYWNrZXQudHlwZV07XG4gICAgbWVzc2FnZSArPSBkYXRhLnRvU3RyaW5nKCdiYXNlNjQnKTtcbiAgICByZXR1cm4gY2FsbGJhY2sobWVzc2FnZSk7XG59XG47XG4vKipcbiAqIERlY29kZXMgYSBwYWNrZXQuIERhdGEgYWxzbyBhdmFpbGFibGUgYXMgYW4gQXJyYXlCdWZmZXIgaWYgcmVxdWVzdGVkLlxuICpcbiAqIEByZXR1cm4ge09iamVjdH0gd2l0aCBgdHlwZWAgYW5kIGBkYXRhYCAoaWYgYW55KVxuICogQGFwaSBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGRlY29kZVBhY2tldChkYXRhLCBiaW5hcnlUeXBlLCB1dGY4ZGVjb2RlKSB7XG4gICAgaWYgKGRhdGEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gZXJyO1xuICAgIH1cbiAgICB2YXIgdHlwZTtcbiAgICAvLyBTdHJpbmcgZGF0YVxuICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdHlwZSA9IGRhdGEuY2hhckF0KDApO1xuICAgICAgICBpZiAodHlwZSA9PT0gJ2InKSB7XG4gICAgICAgICAgICByZXR1cm4gZGVjb2RlQmFzZTY0UGFja2V0KGRhdGEuc2xpY2UoMSksIGJpbmFyeVR5cGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1dGY4ZGVjb2RlKSB7XG4gICAgICAgICAgICBkYXRhID0gdHJ5RGVjb2RlKGRhdGEpO1xuICAgICAgICAgICAgaWYgKGRhdGEgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVycjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoTnVtYmVyKHR5cGUpICE9IHR5cGUgfHwgIXBhY2tldHNsaXN0W3R5cGVdKSB7XG4gICAgICAgICAgICByZXR1cm4gZXJyO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkYXRhLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHR5cGU6IHBhY2tldHNsaXN0W3R5cGVdLCBkYXRhOiBkYXRhLnNsaWNlKDEpIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4geyB0eXBlOiBwYWNrZXRzbGlzdFt0eXBlXSB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIEJpbmFyeSBkYXRhXG4gICAgaWYgKGJpbmFyeVR5cGUgPT09ICdhcnJheWJ1ZmZlcicpIHtcbiAgICAgICAgLy8gd3JhcCBCdWZmZXIvQXJyYXlCdWZmZXIgZGF0YSBpbnRvIGFuIFVpbnQ4QXJyYXlcbiAgICAgICAgdmFyIGludEFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoZGF0YSk7XG4gICAgICAgIHR5cGUgPSBpbnRBcnJheVswXTtcbiAgICAgICAgcmV0dXJuIHsgdHlwZTogcGFja2V0c2xpc3RbdHlwZV0sIGRhdGE6IGludEFycmF5LmJ1ZmZlci5zbGljZSgxKSB9O1xuICAgIH1cbiAgICBpZiAoZGF0YSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgICAgIGRhdGEgPSBhcnJheUJ1ZmZlclRvQnVmZmVyKGRhdGEpO1xuICAgIH1cbiAgICB0eXBlID0gZGF0YVswXTtcbiAgICByZXR1cm4geyB0eXBlOiBwYWNrZXRzbGlzdFt0eXBlXSwgZGF0YTogZGF0YS5zbGljZSgxKSB9O1xufVxuO1xuZnVuY3Rpb24gdHJ5RGVjb2RlKGRhdGEpIHtcbiAgICB0cnkge1xuICAgICAgICBkYXRhID0gdXRmOC5kZWNvZGUoZGF0YSwgeyBzdHJpY3Q6IGZhbHNlIH0pO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBkYXRhO1xufVxuLyoqXG4gKiBEZWNvZGVzIGEgcGFja2V0IGVuY29kZWQgaW4gYSBiYXNlNjQgc3RyaW5nLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBiYXNlNjQgZW5jb2RlZCBtZXNzYWdlXG4gKiBAcmV0dXJuIHtPYmplY3R9IHdpdGggYHR5cGVgIGFuZCBgZGF0YWAgKGlmIGFueSlcbiAqL1xuZnVuY3Rpb24gZGVjb2RlQmFzZTY0UGFja2V0KG1zZywgYmluYXJ5VHlwZSkge1xuICAgIHZhciB0eXBlID0gcGFja2V0c2xpc3RbbXNnLmNoYXJBdCgwKV07XG4gICAgdmFyIGRhdGEgPSBCdWZmZXIuZnJvbShtc2cuc2xpY2UoMSksICdiYXNlNjQnKTtcbiAgICBpZiAoYmluYXJ5VHlwZSA9PT0gJ2FycmF5YnVmZmVyJykge1xuICAgICAgICB2YXIgYWJ2ID0gbmV3IFVpbnQ4QXJyYXkoZGF0YS5sZW5ndGgpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFidi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYWJ2W2ldID0gZGF0YVtpXTtcbiAgICAgICAgfVxuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIGRhdGEgPSBhYnYuYnVmZmVyO1xuICAgIH1cbiAgICByZXR1cm4geyB0eXBlOiB0eXBlLCBkYXRhOiBkYXRhIH07XG59XG47XG4vKipcbiAqIEVuY29kZXMgbXVsdGlwbGUgbWVzc2FnZXMgKHBheWxvYWQpLlxuICpcbiAqICAgICA8bGVuZ3RoPjpkYXRhXG4gKlxuICogRXhhbXBsZTpcbiAqXG4gKiAgICAgMTE6aGVsbG8gd29ybGQyOmhpXG4gKlxuICogSWYgYW55IGNvbnRlbnRzIGFyZSBiaW5hcnksIHRoZXkgd2lsbCBiZSBlbmNvZGVkIGFzIGJhc2U2NCBzdHJpbmdzLiBCYXNlNjRcbiAqIGVuY29kZWQgc3RyaW5ncyBhcmUgbWFya2VkIHdpdGggYSBiIGJlZm9yZSB0aGUgbGVuZ3RoIHNwZWNpZmllclxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IHBhY2tldHNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBlbmNvZGVQYXlsb2FkKHBhY2tldHMsIHN1cHBvcnRzQmluYXJ5LCBjYWxsYmFjaykge1xuICAgIGlmICh0eXBlb2Ygc3VwcG9ydHNCaW5hcnkgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgY2FsbGJhY2sgPSBzdXBwb3J0c0JpbmFyeTtcbiAgICAgICAgc3VwcG9ydHNCaW5hcnkgPSBudWxsO1xuICAgIH1cbiAgICBpZiAoc3VwcG9ydHNCaW5hcnkgJiYgaGFzQmluYXJ5KHBhY2tldHMpKSB7XG4gICAgICAgIHJldHVybiBlbmNvZGVQYXlsb2FkQXNCaW5hcnkocGFja2V0cywgY2FsbGJhY2spO1xuICAgIH1cbiAgICBpZiAoIXBhY2tldHMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjaygnMDonKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZW5jb2RlT25lKHBhY2tldCwgZG9uZUNhbGxiYWNrKSB7XG4gICAgICAgIGVuY29kZVBhY2tldChwYWNrZXQsIHN1cHBvcnRzQmluYXJ5LCBmYWxzZSwgZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgICAgICAgICAgIGRvbmVDYWxsYmFjayhudWxsLCBzZXRMZW5ndGhIZWFkZXIobWVzc2FnZSkpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgbWFwKHBhY2tldHMsIGVuY29kZU9uZSwgZnVuY3Rpb24gKGVyciwgcmVzdWx0cykge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2socmVzdWx0cy5qb2luKCcnKSk7XG4gICAgfSk7XG59XG47XG5mdW5jdGlvbiBzZXRMZW5ndGhIZWFkZXIobWVzc2FnZSkge1xuICAgIHJldHVybiBtZXNzYWdlLmxlbmd0aCArICc6JyArIG1lc3NhZ2U7XG59XG4vKipcbiAqIEFzeW5jIGFycmF5IG1hcCB1c2luZyBhZnRlclxuICovXG5mdW5jdGlvbiBtYXAoYXJ5LCBlYWNoLCBkb25lKSB7XG4gICAgY29uc3QgcmVzdWx0cyA9IG5ldyBBcnJheShhcnkubGVuZ3RoKTtcbiAgICBsZXQgY291bnQgPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJ5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGVhY2goYXJ5W2ldLCAoZXJyb3IsIG1zZykgPT4ge1xuICAgICAgICAgICAgcmVzdWx0c1tpXSA9IG1zZztcbiAgICAgICAgICAgIGlmICgrK2NvdW50ID09PSBhcnkubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgZG9uZShudWxsLCByZXN1bHRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxufVxuLypcbiAqIERlY29kZXMgZGF0YSB3aGVuIGEgcGF5bG9hZCBpcyBtYXliZSBleHBlY3RlZC4gUG9zc2libGUgYmluYXJ5IGNvbnRlbnRzIGFyZVxuICogZGVjb2RlZCBmcm9tIHRoZWlyIGJhc2U2NCByZXByZXNlbnRhdGlvblxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhLCBjYWxsYmFjayBtZXRob2RcbiAqIEBhcGkgcHVibGljXG4gKi9cbmZ1bmN0aW9uIGRlY29kZVBheWxvYWQoZGF0YSwgYmluYXJ5VHlwZSwgY2FsbGJhY2spIHtcbiAgICBpZiAodHlwZW9mIGRhdGEgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBkZWNvZGVQYXlsb2FkQXNCaW5hcnkoZGF0YSwgYmluYXJ5VHlwZSwgY2FsbGJhY2spO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGJpbmFyeVR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgY2FsbGJhY2sgPSBiaW5hcnlUeXBlO1xuICAgICAgICBiaW5hcnlUeXBlID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKGRhdGEgPT09ICcnKSB7XG4gICAgICAgIC8vIHBhcnNlciBlcnJvciAtIGlnbm9yaW5nIHBheWxvYWRcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVyciwgMCwgMSk7XG4gICAgfVxuICAgIHZhciBsZW5ndGggPSAnJywgbiwgbXNnLCBwYWNrZXQ7XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBkYXRhLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICB2YXIgY2hyID0gZGF0YS5jaGFyQXQoaSk7XG4gICAgICAgIGlmIChjaHIgIT09ICc6Jykge1xuICAgICAgICAgICAgbGVuZ3RoICs9IGNocjtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgaWYgKGxlbmd0aCA9PT0gJycgfHwgKGxlbmd0aCAhPSAobiA9IE51bWJlcihsZW5ndGgpKSkpIHtcbiAgICAgICAgICAgIC8vIHBhcnNlciBlcnJvciAtIGlnbm9yaW5nIHBheWxvYWRcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIsIDAsIDEpO1xuICAgICAgICB9XG4gICAgICAgIG1zZyA9IGRhdGEuc2xpY2UoaSArIDEsIGkgKyAxICsgbik7XG4gICAgICAgIGlmIChsZW5ndGggIT0gbXNnLmxlbmd0aCkge1xuICAgICAgICAgICAgLy8gcGFyc2VyIGVycm9yIC0gaWdub3JpbmcgcGF5bG9hZFxuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVyciwgMCwgMSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1zZy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHBhY2tldCA9IGRlY29kZVBhY2tldChtc2csIGJpbmFyeVR5cGUsIGZhbHNlKTtcbiAgICAgICAgICAgIGlmIChlcnIudHlwZSA9PT0gcGFja2V0LnR5cGUgJiYgZXJyLmRhdGEgPT09IHBhY2tldC5kYXRhKSB7XG4gICAgICAgICAgICAgICAgLy8gcGFyc2VyIGVycm9yIGluIGluZGl2aWR1YWwgcGFja2V0IC0gaWdub3JpbmcgcGF5bG9hZFxuICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIsIDAsIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIG1vcmUgPSBjYWxsYmFjayhwYWNrZXQsIGkgKyBuLCBsKTtcbiAgICAgICAgICAgIGlmIChmYWxzZSA9PT0gbW9yZSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gYWR2YW5jZSBjdXJzb3JcbiAgICAgICAgaSArPSBuO1xuICAgICAgICBsZW5ndGggPSAnJztcbiAgICB9XG4gICAgaWYgKGxlbmd0aCAhPT0gJycpIHtcbiAgICAgICAgLy8gcGFyc2VyIGVycm9yIC0gaWdub3JpbmcgcGF5bG9hZFxuICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyLCAwLCAxKTtcbiAgICB9XG59XG47XG4vKipcbiAqXG4gKiBDb252ZXJ0cyBhIGJ1ZmZlciB0byBhIHV0ZjguanMgZW5jb2RlZCBzdHJpbmdcbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gYnVmZmVyVG9TdHJpbmcoYnVmZmVyKSB7XG4gICAgdmFyIHN0ciA9ICcnO1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gYnVmZmVyLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICBzdHIgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZmZXJbaV0pO1xuICAgIH1cbiAgICByZXR1cm4gc3RyO1xufVxuLyoqXG4gKlxuICogQ29udmVydHMgYSB1dGY4LmpzIGVuY29kZWQgc3RyaW5nIHRvIGEgYnVmZmVyXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHN0cmluZ1RvQnVmZmVyKHN0cmluZykge1xuICAgIHZhciBidWYgPSBCdWZmZXIuYWxsb2NVbnNhZmUoc3RyaW5nLmxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBzdHJpbmcubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIGJ1Zi53cml0ZVVJbnQ4KHN0cmluZy5jaGFyQ29kZUF0KGkpLCBpKTtcbiAgICB9XG4gICAgcmV0dXJuIGJ1Zjtcbn1cbi8qKlxuICpcbiAqIENvbnZlcnRzIGFuIEFycmF5QnVmZmVyIHRvIGEgQnVmZmVyXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGFycmF5QnVmZmVyVG9CdWZmZXIoZGF0YSkge1xuICAgIC8vIGRhdGEgaXMgZWl0aGVyIGFuIEFycmF5QnVmZmVyIG9yIEFycmF5QnVmZmVyVmlldy5cbiAgICB2YXIgbGVuZ3RoID0gZGF0YS5ieXRlTGVuZ3RoIHx8IGRhdGEubGVuZ3RoO1xuICAgIHZhciBvZmZzZXQgPSBkYXRhLmJ5dGVPZmZzZXQgfHwgMDtcbiAgICByZXR1cm4gQnVmZmVyLmZyb20oZGF0YS5idWZmZXIgfHwgZGF0YSwgb2Zmc2V0LCBsZW5ndGgpO1xufVxuLyoqXG4gKiBFbmNvZGVzIG11bHRpcGxlIG1lc3NhZ2VzIChwYXlsb2FkKSBhcyBiaW5hcnkuXG4gKlxuICogPDEgPSBiaW5hcnksIDAgPSBzdHJpbmc+PG51bWJlciBmcm9tIDAtOT48bnVtYmVyIGZyb20gMC05PlsuLi5dPG51bWJlclxuICogMjU1PjxkYXRhPlxuICpcbiAqIEV4YW1wbGU6XG4gKiAxIDMgMjU1IDEgMiAzLCBpZiB0aGUgYmluYXJ5IGNvbnRlbnRzIGFyZSBpbnRlcnByZXRlZCBhcyA4IGJpdCBpbnRlZ2Vyc1xuICpcbiAqIEBwYXJhbSB7QXJyYXl9IHBhY2tldHNcbiAqIEByZXR1cm4ge0J1ZmZlcn0gZW5jb2RlZCBwYXlsb2FkXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZW5jb2RlUGF5bG9hZEFzQmluYXJ5KHBhY2tldHMsIGNhbGxiYWNrKSB7XG4gICAgaWYgKCFwYWNrZXRzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2soRU1QVFlfQlVGRkVSKTtcbiAgICB9XG4gICAgbWFwKHBhY2tldHMsIGVuY29kZU9uZUJpbmFyeVBhY2tldCwgZnVuY3Rpb24gKGVyciwgcmVzdWx0cykge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2soQnVmZmVyLmNvbmNhdChyZXN1bHRzKSk7XG4gICAgfSk7XG59XG47XG5mdW5jdGlvbiBlbmNvZGVPbmVCaW5hcnlQYWNrZXQocCwgZG9uZUNhbGxiYWNrKSB7XG4gICAgZnVuY3Rpb24gb25CaW5hcnlQYWNrZXRFbmNvZGUocGFja2V0KSB7XG4gICAgICAgIHZhciBlbmNvZGluZ0xlbmd0aCA9ICcnICsgcGFja2V0Lmxlbmd0aDtcbiAgICAgICAgdmFyIHNpemVCdWZmZXI7XG4gICAgICAgIGlmICh0eXBlb2YgcGFja2V0ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgc2l6ZUJ1ZmZlciA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShlbmNvZGluZ0xlbmd0aC5sZW5ndGggKyAyKTtcbiAgICAgICAgICAgIHNpemVCdWZmZXJbMF0gPSAwOyAvLyBpcyBhIHN0cmluZyAobm90IHRydWUgYmluYXJ5ID0gMClcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZW5jb2RpbmdMZW5ndGgubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBzaXplQnVmZmVyW2kgKyAxXSA9IHBhcnNlSW50KGVuY29kaW5nTGVuZ3RoW2ldLCAxMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzaXplQnVmZmVyW3NpemVCdWZmZXIubGVuZ3RoIC0gMV0gPSAyNTU7XG4gICAgICAgICAgICByZXR1cm4gZG9uZUNhbGxiYWNrKG51bGwsIEJ1ZmZlci5jb25jYXQoW3NpemVCdWZmZXIsIHN0cmluZ1RvQnVmZmVyKHBhY2tldCldKSk7XG4gICAgICAgIH1cbiAgICAgICAgc2l6ZUJ1ZmZlciA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShlbmNvZGluZ0xlbmd0aC5sZW5ndGggKyAyKTtcbiAgICAgICAgc2l6ZUJ1ZmZlclswXSA9IDE7IC8vIGlzIGJpbmFyeSAodHJ1ZSBiaW5hcnkgPSAxKVxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVuY29kaW5nTGVuZ3RoLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBzaXplQnVmZmVyW2kgKyAxXSA9IHBhcnNlSW50KGVuY29kaW5nTGVuZ3RoW2ldLCAxMCk7XG4gICAgICAgIH1cbiAgICAgICAgc2l6ZUJ1ZmZlcltzaXplQnVmZmVyLmxlbmd0aCAtIDFdID0gMjU1O1xuICAgICAgICBkb25lQ2FsbGJhY2sobnVsbCwgQnVmZmVyLmNvbmNhdChbc2l6ZUJ1ZmZlciwgcGFja2V0XSkpO1xuICAgIH1cbiAgICBlbmNvZGVQYWNrZXQocCwgdHJ1ZSwgdHJ1ZSwgb25CaW5hcnlQYWNrZXRFbmNvZGUpO1xufVxuLypcbiAqIERlY29kZXMgZGF0YSB3aGVuIGEgcGF5bG9hZCBpcyBtYXliZSBleHBlY3RlZC4gU3RyaW5ncyBhcmUgZGVjb2RlZCBieVxuICogaW50ZXJwcmV0aW5nIGVhY2ggYnl0ZSBhcyBhIGtleSBjb2RlIGZvciBlbnRyaWVzIG1hcmtlZCB0byBzdGFydCB3aXRoIDAuIFNlZVxuICogZGVzY3JpcHRpb24gb2YgZW5jb2RlUGF5bG9hZEFzQmluYXJ5XG5cbiAqIEBwYXJhbSB7QnVmZmVyfSBkYXRhLCBjYWxsYmFjayBtZXRob2RcbiAqIEBhcGkgcHVibGljXG4gKi9cbmZ1bmN0aW9uIGRlY29kZVBheWxvYWRBc0JpbmFyeShkYXRhLCBiaW5hcnlUeXBlLCBjYWxsYmFjaykge1xuICAgIGlmICh0eXBlb2YgYmluYXJ5VHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBjYWxsYmFjayA9IGJpbmFyeVR5cGU7XG4gICAgICAgIGJpbmFyeVR5cGUgPSBudWxsO1xuICAgIH1cbiAgICB2YXIgYnVmZmVyVGFpbCA9IGRhdGE7XG4gICAgdmFyIGJ1ZmZlcnMgPSBbXTtcbiAgICB2YXIgaTtcbiAgICB3aGlsZSAoYnVmZmVyVGFpbC5sZW5ndGggPiAwKSB7XG4gICAgICAgIHZhciBzdHJMZW4gPSAnJztcbiAgICAgICAgdmFyIGlzU3RyaW5nID0gYnVmZmVyVGFpbFswXSA9PT0gMDtcbiAgICAgICAgZm9yIChpID0gMTs7IGkrKykge1xuICAgICAgICAgICAgaWYgKGJ1ZmZlclRhaWxbaV0gPT09IDI1NSlcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIC8vIDMxMCA9IGNoYXIgbGVuZ3RoIG9mIE51bWJlci5NQVhfVkFMVUVcbiAgICAgICAgICAgIGlmIChzdHJMZW4ubGVuZ3RoID4gMzEwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVyciwgMCwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdHJMZW4gKz0gJycgKyBidWZmZXJUYWlsW2ldO1xuICAgICAgICB9XG4gICAgICAgIGJ1ZmZlclRhaWwgPSBidWZmZXJUYWlsLnNsaWNlKHN0ckxlbi5sZW5ndGggKyAxKTtcbiAgICAgICAgdmFyIG1zZ0xlbmd0aCA9IHBhcnNlSW50KHN0ckxlbiwgMTApO1xuICAgICAgICB2YXIgbXNnID0gYnVmZmVyVGFpbC5zbGljZSgxLCBtc2dMZW5ndGggKyAxKTtcbiAgICAgICAgaWYgKGlzU3RyaW5nKVxuICAgICAgICAgICAgbXNnID0gYnVmZmVyVG9TdHJpbmcobXNnKTtcbiAgICAgICAgYnVmZmVycy5wdXNoKG1zZyk7XG4gICAgICAgIGJ1ZmZlclRhaWwgPSBidWZmZXJUYWlsLnNsaWNlKG1zZ0xlbmd0aCArIDEpO1xuICAgIH1cbiAgICB2YXIgdG90YWwgPSBidWZmZXJzLmxlbmd0aDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgdG90YWw7IGkrKykge1xuICAgICAgICB2YXIgYnVmZmVyID0gYnVmZmVyc1tpXTtcbiAgICAgICAgY2FsbGJhY2soZGVjb2RlUGFja2V0KGJ1ZmZlciwgYmluYXJ5VHlwZSwgdHJ1ZSksIGksIHRvdGFsKTtcbiAgICB9XG59XG47XG4iXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJwYWNrZXRzIiwicHJvdG9jb2wiLCJlbmNvZGVQYWNrZXQiLCJlbmNvZGVCYXNlNjRQYWNrZXQiLCJkZWNvZGVQYWNrZXQiLCJkZWNvZGVCYXNlNjRQYWNrZXQiLCJlbmNvZGVQYXlsb2FkIiwiZGVjb2RlUGF5bG9hZCIsImVuY29kZVBheWxvYWRBc0JpbmFyeSIsImRlY29kZVBheWxvYWRBc0JpbmFyeSIsInV0ZjgiLCJyZXF1aXJlIiwiaGFzQmluYXJ5IiwicGFja2V0IiwiZGF0YSIsIkFycmF5QnVmZmVyIiwiaXNWaWV3Iiwib3BlbiIsImNsb3NlIiwicGluZyIsInBvbmciLCJtZXNzYWdlIiwidXBncmFkZSIsIm5vb3AiLCJwYWNrZXRzbGlzdCIsImtleXMiLCJlcnIiLCJ0eXBlIiwiRU1QVFlfQlVGRkVSIiwiQnVmZmVyIiwiY29uY2F0Iiwic3VwcG9ydHNCaW5hcnkiLCJ1dGY4ZW5jb2RlIiwiY2FsbGJhY2siLCJpc0J1ZmZlciIsImVuY29kZUJ1ZmZlciIsImJ1ZmZlciIsImFycmF5QnVmZmVyVG9CdWZmZXIiLCJlbmNvZGVkIiwidW5kZWZpbmVkIiwiZW5jb2RlIiwiU3RyaW5nIiwic3RyaWN0IiwidHlwZUJ1ZmZlciIsImFsbG9jVW5zYWZlIiwidG9TdHJpbmciLCJiaW5hcnlUeXBlIiwidXRmOGRlY29kZSIsImNoYXJBdCIsInNsaWNlIiwidHJ5RGVjb2RlIiwiTnVtYmVyIiwibGVuZ3RoIiwiaW50QXJyYXkiLCJVaW50OEFycmF5IiwiZGVjb2RlIiwiZSIsIm1zZyIsImZyb20iLCJhYnYiLCJpIiwiZW5jb2RlT25lIiwiZG9uZUNhbGxiYWNrIiwic2V0TGVuZ3RoSGVhZGVyIiwibWFwIiwicmVzdWx0cyIsImpvaW4iLCJhcnkiLCJlYWNoIiwiZG9uZSIsIkFycmF5IiwiY291bnQiLCJlcnJvciIsIm4iLCJsIiwiY2hyIiwibW9yZSIsImJ1ZmZlclRvU3RyaW5nIiwic3RyIiwiZnJvbUNoYXJDb2RlIiwic3RyaW5nVG9CdWZmZXIiLCJzdHJpbmciLCJidWYiLCJ3cml0ZVVJbnQ4IiwiY2hhckNvZGVBdCIsImJ5dGVMZW5ndGgiLCJvZmZzZXQiLCJieXRlT2Zmc2V0IiwiZW5jb2RlT25lQmluYXJ5UGFja2V0IiwicCIsIm9uQmluYXJ5UGFja2V0RW5jb2RlIiwiZW5jb2RpbmdMZW5ndGgiLCJzaXplQnVmZmVyIiwicGFyc2VJbnQiLCJidWZmZXJUYWlsIiwiYnVmZmVycyIsInN0ckxlbiIsImlzU3RyaW5nIiwibXNnTGVuZ3RoIiwicHVzaCIsInRvdGFsIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/engine.io/build/parser-v3/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/engine.io/build/parser-v3/utf8.js":
/*!********************************************************!*\
  !*** ./node_modules/engine.io/build/parser-v3/utf8.js ***!
  \********************************************************/
/***/ ((module) => {

eval("/*! https://mths.be/utf8js v2.1.2 by @mathias */ \nvar stringFromCharCode = String.fromCharCode;\n// Taken from https://mths.be/punycode\nfunction ucs2decode(string) {\n    var output = [];\n    var counter = 0;\n    var length = string.length;\n    var value;\n    var extra;\n    while(counter < length){\n        value = string.charCodeAt(counter++);\n        if (value >= 0xD800 && value <= 0xDBFF && counter < length) {\n            // high surrogate, and there is a next character\n            extra = string.charCodeAt(counter++);\n            if ((extra & 0xFC00) == 0xDC00) {\n                output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);\n            } else {\n                // unmatched surrogate; only append this code unit, in case the next\n                // code unit is the high surrogate of a surrogate pair\n                output.push(value);\n                counter--;\n            }\n        } else {\n            output.push(value);\n        }\n    }\n    return output;\n}\n// Taken from https://mths.be/punycode\nfunction ucs2encode(array) {\n    var length = array.length;\n    var index = -1;\n    var value;\n    var output = \"\";\n    while(++index < length){\n        value = array[index];\n        if (value > 0xFFFF) {\n            value -= 0x10000;\n            output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);\n            value = 0xDC00 | value & 0x3FF;\n        }\n        output += stringFromCharCode(value);\n    }\n    return output;\n}\nfunction checkScalarValue(codePoint, strict) {\n    if (codePoint >= 0xD800 && codePoint <= 0xDFFF) {\n        if (strict) {\n            throw Error(\"Lone surrogate U+\" + codePoint.toString(16).toUpperCase() + \" is not a scalar value\");\n        }\n        return false;\n    }\n    return true;\n}\n/*--------------------------------------------------------------------------*/ function createByte(codePoint, shift) {\n    return stringFromCharCode(codePoint >> shift & 0x3F | 0x80);\n}\nfunction encodeCodePoint(codePoint, strict) {\n    if ((codePoint & 0xFFFFFF80) == 0) {\n        return stringFromCharCode(codePoint);\n    }\n    var symbol = \"\";\n    if ((codePoint & 0xFFFFF800) == 0) {\n        symbol = stringFromCharCode(codePoint >> 6 & 0x1F | 0xC0);\n    } else if ((codePoint & 0xFFFF0000) == 0) {\n        if (!checkScalarValue(codePoint, strict)) {\n            codePoint = 0xFFFD;\n        }\n        symbol = stringFromCharCode(codePoint >> 12 & 0x0F | 0xE0);\n        symbol += createByte(codePoint, 6);\n    } else if ((codePoint & 0xFFE00000) == 0) {\n        symbol = stringFromCharCode(codePoint >> 18 & 0x07 | 0xF0);\n        symbol += createByte(codePoint, 12);\n        symbol += createByte(codePoint, 6);\n    }\n    symbol += stringFromCharCode(codePoint & 0x3F | 0x80);\n    return symbol;\n}\nfunction utf8encode(string, opts) {\n    opts = opts || {};\n    var strict = false !== opts.strict;\n    var codePoints = ucs2decode(string);\n    var length = codePoints.length;\n    var index = -1;\n    var codePoint;\n    var byteString = \"\";\n    while(++index < length){\n        codePoint = codePoints[index];\n        byteString += encodeCodePoint(codePoint, strict);\n    }\n    return byteString;\n}\n/*--------------------------------------------------------------------------*/ function readContinuationByte() {\n    if (byteIndex >= byteCount) {\n        throw Error(\"Invalid byte index\");\n    }\n    var continuationByte = byteArray[byteIndex] & 0xFF;\n    byteIndex++;\n    if ((continuationByte & 0xC0) == 0x80) {\n        return continuationByte & 0x3F;\n    }\n    // If we end up here, its not a continuation byte\n    throw Error(\"Invalid continuation byte\");\n}\nfunction decodeSymbol(strict) {\n    var byte1;\n    var byte2;\n    var byte3;\n    var byte4;\n    var codePoint;\n    if (byteIndex > byteCount) {\n        throw Error(\"Invalid byte index\");\n    }\n    if (byteIndex == byteCount) {\n        return false;\n    }\n    // Read first byte\n    byte1 = byteArray[byteIndex] & 0xFF;\n    byteIndex++;\n    // 1-byte sequence (no continuation bytes)\n    if ((byte1 & 0x80) == 0) {\n        return byte1;\n    }\n    // 2-byte sequence\n    if ((byte1 & 0xE0) == 0xC0) {\n        byte2 = readContinuationByte();\n        codePoint = (byte1 & 0x1F) << 6 | byte2;\n        if (codePoint >= 0x80) {\n            return codePoint;\n        } else {\n            throw Error(\"Invalid continuation byte\");\n        }\n    }\n    // 3-byte sequence (may include unpaired surrogates)\n    if ((byte1 & 0xF0) == 0xE0) {\n        byte2 = readContinuationByte();\n        byte3 = readContinuationByte();\n        codePoint = (byte1 & 0x0F) << 12 | byte2 << 6 | byte3;\n        if (codePoint >= 0x0800) {\n            return checkScalarValue(codePoint, strict) ? codePoint : 0xFFFD;\n        } else {\n            throw Error(\"Invalid continuation byte\");\n        }\n    }\n    // 4-byte sequence\n    if ((byte1 & 0xF8) == 0xF0) {\n        byte2 = readContinuationByte();\n        byte3 = readContinuationByte();\n        byte4 = readContinuationByte();\n        codePoint = (byte1 & 0x07) << 0x12 | byte2 << 0x0C | byte3 << 0x06 | byte4;\n        if (codePoint >= 0x010000 && codePoint <= 0x10FFFF) {\n            return codePoint;\n        }\n    }\n    throw Error(\"Invalid UTF-8 detected\");\n}\nvar byteArray;\nvar byteCount;\nvar byteIndex;\nfunction utf8decode(byteString, opts) {\n    opts = opts || {};\n    var strict = false !== opts.strict;\n    byteArray = ucs2decode(byteString);\n    byteCount = byteArray.length;\n    byteIndex = 0;\n    var codePoints = [];\n    var tmp;\n    while((tmp = decodeSymbol(strict)) !== false){\n        codePoints.push(tmp);\n    }\n    return ucs2encode(codePoints);\n}\nmodule.exports = {\n    version: \"2.1.2\",\n    encode: utf8encode,\n    decode: utf8decode\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZW5naW5lLmlvL2J1aWxkL3BhcnNlci12My91dGY4LmpzIiwibWFwcGluZ3MiOiJBQUFBLDhDQUE4QztBQUM5QyxJQUFJQSxxQkFBcUJDLE9BQU9DLFlBQVk7QUFDNUMsc0NBQXNDO0FBQ3RDLFNBQVNDLFdBQVdDLE1BQU07SUFDdEIsSUFBSUMsU0FBUyxFQUFFO0lBQ2YsSUFBSUMsVUFBVTtJQUNkLElBQUlDLFNBQVNILE9BQU9HLE1BQU07SUFDMUIsSUFBSUM7SUFDSixJQUFJQztJQUNKLE1BQU9ILFVBQVVDLE9BQVE7UUFDckJDLFFBQVFKLE9BQU9NLFVBQVUsQ0FBQ0o7UUFDMUIsSUFBSUUsU0FBUyxVQUFVQSxTQUFTLFVBQVVGLFVBQVVDLFFBQVE7WUFDeEQsZ0RBQWdEO1lBQ2hERSxRQUFRTCxPQUFPTSxVQUFVLENBQUNKO1lBQzFCLElBQUksQ0FBQ0csUUFBUSxNQUFLLEtBQU0sUUFBUTtnQkFDNUJKLE9BQU9NLElBQUksQ0FBQyxDQUFDLENBQUNILFFBQVEsS0FBSSxLQUFNLEVBQUMsSUFBTUMsQ0FBQUEsUUFBUSxLQUFJLElBQUs7WUFDNUQsT0FDSztnQkFDRCxvRUFBb0U7Z0JBQ3BFLHNEQUFzRDtnQkFDdERKLE9BQU9NLElBQUksQ0FBQ0g7Z0JBQ1pGO1lBQ0o7UUFDSixPQUNLO1lBQ0RELE9BQU9NLElBQUksQ0FBQ0g7UUFDaEI7SUFDSjtJQUNBLE9BQU9IO0FBQ1g7QUFDQSxzQ0FBc0M7QUFDdEMsU0FBU08sV0FBV0MsS0FBSztJQUNyQixJQUFJTixTQUFTTSxNQUFNTixNQUFNO0lBQ3pCLElBQUlPLFFBQVEsQ0FBQztJQUNiLElBQUlOO0lBQ0osSUFBSUgsU0FBUztJQUNiLE1BQU8sRUFBRVMsUUFBUVAsT0FBUTtRQUNyQkMsUUFBUUssS0FBSyxDQUFDQyxNQUFNO1FBQ3BCLElBQUlOLFFBQVEsUUFBUTtZQUNoQkEsU0FBUztZQUNUSCxVQUFVTCxtQkFBbUJRLFVBQVUsS0FBSyxRQUFRO1lBQ3BEQSxRQUFR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ZXMvZW5naW5lLmlvL2J1aWxkL3BhcnNlci12My91dGY4LmpzP2E5ZjQiXSwic291cmNlc0NvbnRlbnQiOlsiLyohIGh0dHBzOi8vbXRocy5iZS91dGY4anMgdjIuMS4yIGJ5IEBtYXRoaWFzICovXG52YXIgc3RyaW5nRnJvbUNoYXJDb2RlID0gU3RyaW5nLmZyb21DaGFyQ29kZTtcbi8vIFRha2VuIGZyb20gaHR0cHM6Ly9tdGhzLmJlL3B1bnljb2RlXG5mdW5jdGlvbiB1Y3MyZGVjb2RlKHN0cmluZykge1xuICAgIHZhciBvdXRwdXQgPSBbXTtcbiAgICB2YXIgY291bnRlciA9IDA7XG4gICAgdmFyIGxlbmd0aCA9IHN0cmluZy5sZW5ndGg7XG4gICAgdmFyIHZhbHVlO1xuICAgIHZhciBleHRyYTtcbiAgICB3aGlsZSAoY291bnRlciA8IGxlbmd0aCkge1xuICAgICAgICB2YWx1ZSA9IHN0cmluZy5jaGFyQ29kZUF0KGNvdW50ZXIrKyk7XG4gICAgICAgIGlmICh2YWx1ZSA+PSAweEQ4MDAgJiYgdmFsdWUgPD0gMHhEQkZGICYmIGNvdW50ZXIgPCBsZW5ndGgpIHtcbiAgICAgICAgICAgIC8vIGhpZ2ggc3Vycm9nYXRlLCBhbmQgdGhlcmUgaXMgYSBuZXh0IGNoYXJhY3RlclxuICAgICAgICAgICAgZXh0cmEgPSBzdHJpbmcuY2hhckNvZGVBdChjb3VudGVyKyspO1xuICAgICAgICAgICAgaWYgKChleHRyYSAmIDB4RkMwMCkgPT0gMHhEQzAwKSB7IC8vIGxvdyBzdXJyb2dhdGVcbiAgICAgICAgICAgICAgICBvdXRwdXQucHVzaCgoKHZhbHVlICYgMHgzRkYpIDw8IDEwKSArIChleHRyYSAmIDB4M0ZGKSArIDB4MTAwMDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gdW5tYXRjaGVkIHN1cnJvZ2F0ZTsgb25seSBhcHBlbmQgdGhpcyBjb2RlIHVuaXQsIGluIGNhc2UgdGhlIG5leHRcbiAgICAgICAgICAgICAgICAvLyBjb2RlIHVuaXQgaXMgdGhlIGhpZ2ggc3Vycm9nYXRlIG9mIGEgc3Vycm9nYXRlIHBhaXJcbiAgICAgICAgICAgICAgICBvdXRwdXQucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgY291bnRlci0tO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgb3V0cHV0LnB1c2godmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvdXRwdXQ7XG59XG4vLyBUYWtlbiBmcm9tIGh0dHBzOi8vbXRocy5iZS9wdW55Y29kZVxuZnVuY3Rpb24gdWNzMmVuY29kZShhcnJheSkge1xuICAgIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG4gICAgdmFyIGluZGV4ID0gLTE7XG4gICAgdmFyIHZhbHVlO1xuICAgIHZhciBvdXRwdXQgPSAnJztcbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YWx1ZSA9IGFycmF5W2luZGV4XTtcbiAgICAgICAgaWYgKHZhbHVlID4gMHhGRkZGKSB7XG4gICAgICAgICAgICB2YWx1ZSAtPSAweDEwMDAwO1xuICAgICAgICAgICAgb3V0cHV0ICs9IHN0cmluZ0Zyb21DaGFyQ29kZSh2YWx1ZSA+Pj4gMTAgJiAweDNGRiB8IDB4RDgwMCk7XG4gICAgICAgICAgICB2YWx1ZSA9IDB4REMwMCB8IHZhbHVlICYgMHgzRkY7XG4gICAgICAgIH1cbiAgICAgICAgb3V0cHV0ICs9IHN0cmluZ0Zyb21DaGFyQ29kZSh2YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiBvdXRwdXQ7XG59XG5mdW5jdGlvbiBjaGVja1NjYWxhclZhbHVlKGNvZGVQb2ludCwgc3RyaWN0KSB7XG4gICAgaWYgKGNvZGVQb2ludCA+PSAweEQ4MDAgJiYgY29kZVBvaW50IDw9IDB4REZGRikge1xuICAgICAgICBpZiAoc3RyaWN0KSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcignTG9uZSBzdXJyb2dhdGUgVSsnICsgY29kZVBvaW50LnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpICtcbiAgICAgICAgICAgICAgICAnIGlzIG5vdCBhIHNjYWxhciB2YWx1ZScpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG4vKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbmZ1bmN0aW9uIGNyZWF0ZUJ5dGUoY29kZVBvaW50LCBzaGlmdCkge1xuICAgIHJldHVybiBzdHJpbmdGcm9tQ2hhckNvZGUoKChjb2RlUG9pbnQgPj4gc2hpZnQpICYgMHgzRikgfCAweDgwKTtcbn1cbmZ1bmN0aW9uIGVuY29kZUNvZGVQb2ludChjb2RlUG9pbnQsIHN0cmljdCkge1xuICAgIGlmICgoY29kZVBvaW50ICYgMHhGRkZGRkY4MCkgPT0gMCkgeyAvLyAxLWJ5dGUgc2VxdWVuY2VcbiAgICAgICAgcmV0dXJuIHN0cmluZ0Zyb21DaGFyQ29kZShjb2RlUG9pbnQpO1xuICAgIH1cbiAgICB2YXIgc3ltYm9sID0gJyc7XG4gICAgaWYgKChjb2RlUG9pbnQgJiAweEZGRkZGODAwKSA9PSAwKSB7IC8vIDItYnl0ZSBzZXF1ZW5jZVxuICAgICAgICBzeW1ib2wgPSBzdHJpbmdGcm9tQ2hhckNvZGUoKChjb2RlUG9pbnQgPj4gNikgJiAweDFGKSB8IDB4QzApO1xuICAgIH1cbiAgICBlbHNlIGlmICgoY29kZVBvaW50ICYgMHhGRkZGMDAwMCkgPT0gMCkgeyAvLyAzLWJ5dGUgc2VxdWVuY2VcbiAgICAgICAgaWYgKCFjaGVja1NjYWxhclZhbHVlKGNvZGVQb2ludCwgc3RyaWN0KSkge1xuICAgICAgICAgICAgY29kZVBvaW50ID0gMHhGRkZEO1xuICAgICAgICB9XG4gICAgICAgIHN5bWJvbCA9IHN0cmluZ0Zyb21DaGFyQ29kZSgoKGNvZGVQb2ludCA+PiAxMikgJiAweDBGKSB8IDB4RTApO1xuICAgICAgICBzeW1ib2wgKz0gY3JlYXRlQnl0ZShjb2RlUG9pbnQsIDYpO1xuICAgIH1cbiAgICBlbHNlIGlmICgoY29kZVBvaW50ICYgMHhGRkUwMDAwMCkgPT0gMCkgeyAvLyA0LWJ5dGUgc2VxdWVuY2VcbiAgICAgICAgc3ltYm9sID0gc3RyaW5nRnJvbUNoYXJDb2RlKCgoY29kZVBvaW50ID4+IDE4KSAmIDB4MDcpIHwgMHhGMCk7XG4gICAgICAgIHN5bWJvbCArPSBjcmVhdGVCeXRlKGNvZGVQb2ludCwgMTIpO1xuICAgICAgICBzeW1ib2wgKz0gY3JlYXRlQnl0ZShjb2RlUG9pbnQsIDYpO1xuICAgIH1cbiAgICBzeW1ib2wgKz0gc3RyaW5nRnJvbUNoYXJDb2RlKChjb2RlUG9pbnQgJiAweDNGKSB8IDB4ODApO1xuICAgIHJldHVybiBzeW1ib2w7XG59XG5mdW5jdGlvbiB1dGY4ZW5jb2RlKHN0cmluZywgb3B0cykge1xuICAgIG9wdHMgPSBvcHRzIHx8IHt9O1xuICAgIHZhciBzdHJpY3QgPSBmYWxzZSAhPT0gb3B0cy5zdHJpY3Q7XG4gICAgdmFyIGNvZGVQb2ludHMgPSB1Y3MyZGVjb2RlKHN0cmluZyk7XG4gICAgdmFyIGxlbmd0aCA9IGNvZGVQb2ludHMubGVuZ3RoO1xuICAgIHZhciBpbmRleCA9IC0xO1xuICAgIHZhciBjb2RlUG9pbnQ7XG4gICAgdmFyIGJ5dGVTdHJpbmcgPSAnJztcbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICBjb2RlUG9pbnQgPSBjb2RlUG9pbnRzW2luZGV4XTtcbiAgICAgICAgYnl0ZVN0cmluZyArPSBlbmNvZGVDb2RlUG9pbnQoY29kZVBvaW50LCBzdHJpY3QpO1xuICAgIH1cbiAgICByZXR1cm4gYnl0ZVN0cmluZztcbn1cbi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuZnVuY3Rpb24gcmVhZENvbnRpbnVhdGlvbkJ5dGUoKSB7XG4gICAgaWYgKGJ5dGVJbmRleCA+PSBieXRlQ291bnQpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoJ0ludmFsaWQgYnl0ZSBpbmRleCcpO1xuICAgIH1cbiAgICB2YXIgY29udGludWF0aW9uQnl0ZSA9IGJ5dGVBcnJheVtieXRlSW5kZXhdICYgMHhGRjtcbiAgICBieXRlSW5kZXgrKztcbiAgICBpZiAoKGNvbnRpbnVhdGlvbkJ5dGUgJiAweEMwKSA9PSAweDgwKSB7XG4gICAgICAgIHJldHVybiBjb250aW51YXRpb25CeXRlICYgMHgzRjtcbiAgICB9XG4gICAgLy8gSWYgd2UgZW5kIHVwIGhlcmUsIGl04oCZcyBub3QgYSBjb250aW51YXRpb24gYnl0ZVxuICAgIHRocm93IEVycm9yKCdJbnZhbGlkIGNvbnRpbnVhdGlvbiBieXRlJyk7XG59XG5mdW5jdGlvbiBkZWNvZGVTeW1ib2woc3RyaWN0KSB7XG4gICAgdmFyIGJ5dGUxO1xuICAgIHZhciBieXRlMjtcbiAgICB2YXIgYnl0ZTM7XG4gICAgdmFyIGJ5dGU0O1xuICAgIHZhciBjb2RlUG9pbnQ7XG4gICAgaWYgKGJ5dGVJbmRleCA+IGJ5dGVDb3VudCkge1xuICAgICAgICB0aHJvdyBFcnJvcignSW52YWxpZCBieXRlIGluZGV4Jyk7XG4gICAgfVxuICAgIGlmIChieXRlSW5kZXggPT0gYnl0ZUNvdW50KSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLy8gUmVhZCBmaXJzdCBieXRlXG4gICAgYnl0ZTEgPSBieXRlQXJyYXlbYnl0ZUluZGV4XSAmIDB4RkY7XG4gICAgYnl0ZUluZGV4Kys7XG4gICAgLy8gMS1ieXRlIHNlcXVlbmNlIChubyBjb250aW51YXRpb24gYnl0ZXMpXG4gICAgaWYgKChieXRlMSAmIDB4ODApID09IDApIHtcbiAgICAgICAgcmV0dXJuIGJ5dGUxO1xuICAgIH1cbiAgICAvLyAyLWJ5dGUgc2VxdWVuY2VcbiAgICBpZiAoKGJ5dGUxICYgMHhFMCkgPT0gMHhDMCkge1xuICAgICAgICBieXRlMiA9IHJlYWRDb250aW51YXRpb25CeXRlKCk7XG4gICAgICAgIGNvZGVQb2ludCA9ICgoYnl0ZTEgJiAweDFGKSA8PCA2KSB8IGJ5dGUyO1xuICAgICAgICBpZiAoY29kZVBvaW50ID49IDB4ODApIHtcbiAgICAgICAgICAgIHJldHVybiBjb2RlUG9pbnQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcignSW52YWxpZCBjb250aW51YXRpb24gYnl0ZScpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIDMtYnl0ZSBzZXF1ZW5jZSAobWF5IGluY2x1ZGUgdW5wYWlyZWQgc3Vycm9nYXRlcylcbiAgICBpZiAoKGJ5dGUxICYgMHhGMCkgPT0gMHhFMCkge1xuICAgICAgICBieXRlMiA9IHJlYWRDb250aW51YXRpb25CeXRlKCk7XG4gICAgICAgIGJ5dGUzID0gcmVhZENvbnRpbnVhdGlvbkJ5dGUoKTtcbiAgICAgICAgY29kZVBvaW50ID0gKChieXRlMSAmIDB4MEYpIDw8IDEyKSB8IChieXRlMiA8PCA2KSB8IGJ5dGUzO1xuICAgICAgICBpZiAoY29kZVBvaW50ID49IDB4MDgwMCkge1xuICAgICAgICAgICAgcmV0dXJuIGNoZWNrU2NhbGFyVmFsdWUoY29kZVBvaW50LCBzdHJpY3QpID8gY29kZVBvaW50IDogMHhGRkZEO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoJ0ludmFsaWQgY29udGludWF0aW9uIGJ5dGUnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyA0LWJ5dGUgc2VxdWVuY2VcbiAgICBpZiAoKGJ5dGUxICYgMHhGOCkgPT0gMHhGMCkge1xuICAgICAgICBieXRlMiA9IHJlYWRDb250aW51YXRpb25CeXRlKCk7XG4gICAgICAgIGJ5dGUzID0gcmVhZENvbnRpbnVhdGlvbkJ5dGUoKTtcbiAgICAgICAgYnl0ZTQgPSByZWFkQ29udGludWF0aW9uQnl0ZSgpO1xuICAgICAgICBjb2RlUG9pbnQgPSAoKGJ5dGUxICYgMHgwNykgPDwgMHgxMikgfCAoYnl0ZTIgPDwgMHgwQykgfFxuICAgICAgICAgICAgKGJ5dGUzIDw8IDB4MDYpIHwgYnl0ZTQ7XG4gICAgICAgIGlmIChjb2RlUG9pbnQgPj0gMHgwMTAwMDAgJiYgY29kZVBvaW50IDw9IDB4MTBGRkZGKSB7XG4gICAgICAgICAgICByZXR1cm4gY29kZVBvaW50O1xuICAgICAgICB9XG4gICAgfVxuICAgIHRocm93IEVycm9yKCdJbnZhbGlkIFVURi04IGRldGVjdGVkJyk7XG59XG52YXIgYnl0ZUFycmF5O1xudmFyIGJ5dGVDb3VudDtcbnZhciBieXRlSW5kZXg7XG5mdW5jdGlvbiB1dGY4ZGVjb2RlKGJ5dGVTdHJpbmcsIG9wdHMpIHtcbiAgICBvcHRzID0gb3B0cyB8fCB7fTtcbiAgICB2YXIgc3RyaWN0ID0gZmFsc2UgIT09IG9wdHMuc3RyaWN0O1xuICAgIGJ5dGVBcnJheSA9IHVjczJkZWNvZGUoYnl0ZVN0cmluZyk7XG4gICAgYnl0ZUNvdW50ID0gYnl0ZUFycmF5Lmxlbmd0aDtcbiAgICBieXRlSW5kZXggPSAwO1xuICAgIHZhciBjb2RlUG9pbnRzID0gW107XG4gICAgdmFyIHRtcDtcbiAgICB3aGlsZSAoKHRtcCA9IGRlY29kZVN5bWJvbChzdHJpY3QpKSAhPT0gZmFsc2UpIHtcbiAgICAgICAgY29kZVBvaW50cy5wdXNoKHRtcCk7XG4gICAgfVxuICAgIHJldHVybiB1Y3MyZW5jb2RlKGNvZGVQb2ludHMpO1xufVxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgdmVyc2lvbjogJzIuMS4yJyxcbiAgICBlbmNvZGU6IHV0ZjhlbmNvZGUsXG4gICAgZGVjb2RlOiB1dGY4ZGVjb2RlXG59O1xuIl0sIm5hbWVzIjpbInN0cmluZ0Zyb21DaGFyQ29kZSIsIlN0cmluZyIsImZyb21DaGFyQ29kZSIsInVjczJkZWNvZGUiLCJzdHJpbmciLCJvdXRwdXQiLCJjb3VudGVyIiwibGVuZ3RoIiwidmFsdWUiLCJleHRyYSIsImNoYXJDb2RlQXQiLCJwdXNoIiwidWNzMmVuY29kZSIsImFycmF5IiwiaW5kZXgiLCJjaGVja1NjYWxhclZhbHVlIiwiY29kZVBvaW50Iiwic3RyaWN0IiwiRXJyb3IiLCJ0b1N0cmluZyIsInRvVXBwZXJDYXNlIiwiY3JlYXRlQnl0ZSIsInNoaWZ0IiwiZW5jb2RlQ29kZVBvaW50Iiwic3ltYm9sIiwidXRmOGVuY29kZSIsIm9wdHMiLCJjb2RlUG9pbnRzIiwiYnl0ZVN0cmluZyIsInJlYWRDb250aW51YXRpb25CeXRlIiwiYnl0ZUluZGV4IiwiYnl0ZUNvdW50IiwiY29udGludWF0aW9uQnl0ZSIsImJ5dGVBcnJheSIsImRlY29kZVN5bWJvbCIsImJ5dGUxIiwiYnl0ZTIiLCJieXRlMyIsImJ5dGU0IiwidXRmOGRlY29kZSIsInRtcCIsIm1vZHVsZSIsImV4cG9ydHMiLCJ2ZXJzaW9uIiwiZW5jb2RlIiwiZGVjb2RlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/engine.io/build/parser-v3/utf8.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/engine.io/build/server.js":
/*!************************************************!*\
  !*** ./node_modules/engine.io/build/server.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.Server = exports.BaseServer = void 0;\nconst qs = __webpack_require__(/*! querystring */ \"querystring\");\nconst url_1 = __webpack_require__(/*! url */ \"url\");\nconst base64id = __webpack_require__(/*! base64id */ \"(rsc)/./node_modules/base64id/lib/base64id.js\");\nconst transports_1 = __webpack_require__(/*! ./transports */ \"(rsc)/./node_modules/engine.io/build/transports/index.js\");\nconst events_1 = __webpack_require__(/*! events */ \"events\");\nconst socket_1 = __webpack_require__(/*! ./socket */ \"(rsc)/./node_modules/engine.io/build/socket.js\");\nconst debug_1 = __webpack_require__(/*! debug */ \"(rsc)/./node_modules/engine.io/node_modules/debug/src/index.js\");\nconst cookie_1 = __webpack_require__(/*! cookie */ \"(rsc)/./node_modules/cookie/index.js\");\nconst ws_1 = __webpack_require__(/*! ws */ \"(rsc)/./node_modules/ws/index.js\");\nconst webtransport_1 = __webpack_require__(/*! ./transports/webtransport */ \"(rsc)/./node_modules/engine.io/build/transports/webtransport.js\");\nconst engine_io_parser_1 = __webpack_require__(/*! engine.io-parser */ \"(rsc)/./node_modules/engine.io-parser/build/cjs/index.js\");\nconst debug = (0, debug_1.default)(\"engine\");\nconst kResponseHeaders = Symbol(\"responseHeaders\");\nfunction parseSessionId(data) {\n    try {\n        const parsed = JSON.parse(data);\n        if (typeof parsed.sid === \"string\") {\n            return parsed.sid;\n        }\n    } catch (e) {}\n}\nclass BaseServer extends events_1.EventEmitter {\n    /**\n     * Server constructor.\n     *\n     * @param {Object} opts - options\n     */ constructor(opts = {}){\n        super();\n        this.middlewares = [];\n        this.clients = {};\n        this.clientsCount = 0;\n        this.opts = Object.assign({\n            wsEngine: ws_1.Server,\n            pingTimeout: 20000,\n            pingInterval: 25000,\n            upgradeTimeout: 10000,\n            maxHttpBufferSize: 1e6,\n            transports: [\n                \"polling\",\n                \"websocket\"\n            ],\n            allowUpgrades: true,\n            httpCompression: {\n                threshold: 1024\n            },\n            cors: false,\n            allowEIO3: false\n        }, opts);\n        if (opts.cookie) {\n            this.opts.cookie = Object.assign({\n                name: \"io\",\n                path: \"/\",\n                // @ts-ignore\n                httpOnly: opts.cookie.path !== false,\n                sameSite: \"lax\"\n            }, opts.cookie);\n        }\n        if (this.opts.cors) {\n            this.use(__webpack_require__(/*! cors */ \"(rsc)/./node_modules/cors/lib/index.js\")(this.opts.cors));\n        }\n        if (opts.perMessageDeflate) {\n            this.opts.perMessageDeflate = Object.assign({\n                threshold: 1024\n            }, opts.perMessageDeflate);\n        }\n        this.init();\n    }\n    /**\n     * Compute the pathname of the requests that are handled by the server\n     * @param options\n     * @protected\n     */ _computePath(options) {\n        let path = (options.path || \"/engine.io\").replace(/\\/$/, \"\");\n        if (options.addTrailingSlash !== false) {\n            // normalize path\n            path += \"/\";\n        }\n        return path;\n    }\n    /**\n     * Returns a list of available transports for upgrade given a certain transport.\n     *\n     * @return {Array}\n     */ upgrades(transport) {\n        if (!this.opts.allowUpgrades) return [];\n        return transports_1.default[transport].upgradesTo || [];\n    }\n    /**\n     * Verifies a request.\n     *\n     * @param {EngineRequest} req\n     * @param upgrade - whether it's an upgrade request\n     * @param fn\n     * @protected\n     */ verify(req, upgrade, fn) {\n        // transport check\n        const transport = req._query.transport;\n        // WebTransport does not go through the verify() method, see the onWebTransportSession() method\n        if (!~this.opts.transports.indexOf(transport) || transport === \"webtransport\") {\n            debug('unknown transport \"%s\"', transport);\n            return fn(Server.errors.UNKNOWN_TRANSPORT, {\n                transport\n            });\n        }\n        // 'Origin' header check\n        const isOriginInvalid = checkInvalidHeaderChar(req.headers.origin);\n        if (isOriginInvalid) {\n            const origin = req.headers.origin;\n            req.headers.origin = null;\n            debug(\"origin header invalid\");\n            return fn(Server.errors.BAD_REQUEST, {\n                name: \"INVALID_ORIGIN\",\n                origin\n            });\n        }\n        // sid check\n        const sid = req._query.sid;\n        if (sid) {\n            if (!this.clients.hasOwnProperty(sid)) {\n                debug('unknown sid \"%s\"', sid);\n                return fn(Server.errors.UNKNOWN_SID, {\n                    sid\n                });\n            }\n            const previousTransport = this.clients[sid].transport.name;\n            if (!upgrade && previousTransport !== transport) {\n                debug(\"bad request: unexpected transport without upgrade\");\n                return fn(Server.errors.BAD_REQUEST, {\n                    name: \"TRANSPORT_MISMATCH\",\n                    transport,\n                    previousTransport\n                });\n            }\n        } else {\n            // handshake is GET only\n            if (\"GET\" !== req.method) {\n                return fn(Server.errors.BAD_HANDSHAKE_METHOD, {\n                    method: req.method\n                });\n            }\n            if (transport === \"websocket\" && !upgrade) {\n                debug(\"invalid transport upgrade\");\n                return fn(Server.errors.BAD_REQUEST, {\n                    name: \"TRANSPORT_HANDSHAKE_ERROR\"\n                });\n            }\n            if (!this.opts.allowRequest) return fn();\n            return this.opts.allowRequest(req, (message, success)=>{\n                if (!success) {\n                    return fn(Server.errors.FORBIDDEN, {\n                        message\n                    });\n                }\n                fn();\n            });\n        }\n        fn();\n    }\n    /**\n     * Adds a new middleware.\n     *\n     * @example\n     * import helmet from \"helmet\";\n     *\n     * engine.use(helmet());\n     *\n     * @param fn\n     */ use(fn) {\n        this.middlewares.push(fn);\n    }\n    /**\n     * Apply the middlewares to the request.\n     *\n     * @param req\n     * @param res\n     * @param callback\n     * @protected\n     */ _applyMiddlewares(req, res, callback) {\n        if (this.middlewares.length === 0) {\n            debug(\"no middleware to apply, skipping\");\n            return callback();\n        }\n        const apply = (i)=>{\n            debug(\"applying middleware n\\xb0%d\", i + 1);\n            this.middlewares[i](req, res, (err)=>{\n                if (err) {\n                    return callback(err);\n                }\n                if (i + 1 < this.middlewares.length) {\n                    apply(i + 1);\n                } else {\n                    callback();\n                }\n            });\n        };\n        apply(0);\n    }\n    /**\n     * Closes all clients.\n     */ close() {\n        debug(\"closing all open clients\");\n        for(let i in this.clients){\n            if (this.clients.hasOwnProperty(i)) {\n                this.clients[i].close(true);\n            }\n        }\n        this.cleanup();\n        return this;\n    }\n    /**\n     * generate a socket id.\n     * Overwrite this method to generate your custom socket id\n     *\n     * @param {IncomingMessage} req - the request object\n     */ generateId(req) {\n        return base64id.generateId();\n    }\n    /**\n     * Handshakes a new client.\n     *\n     * @param {String} transportName\n     * @param {Object} req - the request object\n     * @param {Function} closeConnection\n     *\n     * @protected\n     */ async handshake(transportName, req, closeConnection) {\n        const protocol = req._query.EIO === \"4\" ? 4 : 3; // 3rd revision by default\n        if (protocol === 3 && !this.opts.allowEIO3) {\n            debug(\"unsupported protocol version\");\n            this.emit(\"connection_error\", {\n                req,\n                code: Server.errors.UNSUPPORTED_PROTOCOL_VERSION,\n                message: Server.errorMessages[Server.errors.UNSUPPORTED_PROTOCOL_VERSION],\n                context: {\n                    protocol\n                }\n            });\n            closeConnection(Server.errors.UNSUPPORTED_PROTOCOL_VERSION);\n            return;\n        }\n        let id;\n        try {\n            id = await this.generateId(req);\n        } catch (e) {\n            debug(\"error while generating an id\");\n            this.emit(\"connection_error\", {\n                req,\n                code: Server.errors.BAD_REQUEST,\n                message: Server.errorMessages[Server.errors.BAD_REQUEST],\n                context: {\n                    name: \"ID_GENERATION_ERROR\",\n                    error: e\n                }\n            });\n            closeConnection(Server.errors.BAD_REQUEST);\n            return;\n        }\n        debug('handshaking client \"%s\"', id);\n        try {\n            var transport = this.createTransport(transportName, req);\n            if (\"polling\" === transportName) {\n                transport.maxHttpBufferSize = this.opts.maxHttpBufferSize;\n                transport.httpCompression = this.opts.httpCompression;\n            } else if (\"websocket\" === transportName) {\n                transport.perMessageDeflate = this.opts.perMessageDeflate;\n            }\n        } catch (e) {\n            debug('error handshaking to transport \"%s\"', transportName);\n            this.emit(\"connection_error\", {\n                req,\n                code: Server.errors.BAD_REQUEST,\n                message: Server.errorMessages[Server.errors.BAD_REQUEST],\n                context: {\n                    name: \"TRANSPORT_HANDSHAKE_ERROR\",\n                    error: e\n                }\n            });\n            closeConnection(Server.errors.BAD_REQUEST);\n            return;\n        }\n        const socket = new socket_1.Socket(id, this, transport, req, protocol);\n        transport.on(\"headers\", (headers, req)=>{\n            const isInitialRequest = !req._query.sid;\n            if (isInitialRequest) {\n                if (this.opts.cookie) {\n                    headers[\"Set-Cookie\"] = [\n                        // @ts-ignore\n                        (0, cookie_1.serialize)(this.opts.cookie.name, id, this.opts.cookie)\n                    ];\n                }\n                this.emit(\"initial_headers\", headers, req);\n            }\n            this.emit(\"headers\", headers, req);\n        });\n        transport.onRequest(req);\n        this.clients[id] = socket;\n        this.clientsCount++;\n        socket.once(\"close\", ()=>{\n            delete this.clients[id];\n            this.clientsCount--;\n        });\n        this.emit(\"connection\", socket);\n        return transport;\n    }\n    async onWebTransportSession(session) {\n        const timeout = setTimeout(()=>{\n            debug(\"the client failed to establish a bidirectional stream in the given period\");\n            session.close();\n        }, this.opts.upgradeTimeout);\n        const streamReader = session.incomingBidirectionalStreams.getReader();\n        const result = await streamReader.read();\n        if (result.done) {\n            debug(\"session is closed\");\n            return;\n        }\n        const stream = result.value;\n        const transformStream = (0, engine_io_parser_1.createPacketDecoderStream)(this.opts.maxHttpBufferSize, \"nodebuffer\");\n        const reader = stream.readable.pipeThrough(transformStream).getReader();\n        // reading the first packet of the stream\n        const { value, done } = await reader.read();\n        if (done) {\n            debug(\"stream is closed\");\n            return;\n        }\n        clearTimeout(timeout);\n        if (value.type !== \"open\") {\n            debug(\"invalid WebTransport handshake\");\n            return session.close();\n        }\n        if (value.data === undefined) {\n            const transport = new webtransport_1.WebTransport(session, stream, reader);\n            // note: we cannot use \"this.generateId()\", because there is no \"req\" argument\n            const id = base64id.generateId();\n            debug('handshaking client \"%s\" (WebTransport)', id);\n            const socket = new socket_1.Socket(id, this, transport, null, 4);\n            this.clients[id] = socket;\n            this.clientsCount++;\n            socket.once(\"close\", ()=>{\n                delete this.clients[id];\n                this.clientsCount--;\n            });\n            this.emit(\"connection\", socket);\n            return;\n        }\n        const sid = parseSessionId(value.data);\n        if (!sid) {\n            debug(\"invalid WebTransport handshake\");\n            return session.close();\n        }\n        const client = this.clients[sid];\n        if (!client) {\n            debug(\"upgrade attempt for closed client\");\n            session.close();\n        } else if (client.upgrading) {\n            debug(\"transport has already been trying to upgrade\");\n            session.close();\n        } else if (client.upgraded) {\n            debug(\"transport had already been upgraded\");\n            session.close();\n        } else {\n            debug(\"upgrading existing transport\");\n            const transport = new webtransport_1.WebTransport(session, stream, reader);\n            client._maybeUpgrade(transport);\n        }\n    }\n}\nexports.BaseServer = BaseServer;\n/**\n * Protocol errors mappings.\n */ BaseServer.errors = {\n    UNKNOWN_TRANSPORT: 0,\n    UNKNOWN_SID: 1,\n    BAD_HANDSHAKE_METHOD: 2,\n    BAD_REQUEST: 3,\n    FORBIDDEN: 4,\n    UNSUPPORTED_PROTOCOL_VERSION: 5\n};\nBaseServer.errorMessages = {\n    0: \"Transport unknown\",\n    1: \"Session ID unknown\",\n    2: \"Bad handshake method\",\n    3: \"Bad request\",\n    4: \"Forbidden\",\n    5: \"Unsupported protocol version\"\n};\n/**\n * Exposes a subset of the http.ServerResponse interface, in order to be able to apply the middlewares to an upgrade\n * request.\n *\n * @see https://nodejs.org/api/http.html#class-httpserverresponse\n */ class WebSocketResponse {\n    constructor(req, socket){\n        this.req = req;\n        this.socket = socket;\n        // temporarily store the response headers on the req object (see the \"headers\" event)\n        req[kResponseHeaders] = {};\n    }\n    setHeader(name, value) {\n        this.req[kResponseHeaders][name] = value;\n    }\n    getHeader(name) {\n        return this.req[kResponseHeaders][name];\n    }\n    removeHeader(name) {\n        delete this.req[kResponseHeaders][name];\n    }\n    write() {}\n    writeHead() {}\n    end() {\n        // we could return a proper error code, but the WebSocket client will emit an \"error\" event anyway.\n        this.socket.destroy();\n    }\n}\n/**\n * An Engine.IO server based on Node.js built-in HTTP server and the `ws` package for WebSocket connections.\n */ class Server extends BaseServer {\n    /**\n     * Initialize websocket server\n     *\n     * @protected\n     */ init() {\n        if (!~this.opts.transports.indexOf(\"websocket\")) return;\n        if (this.ws) this.ws.close();\n        this.ws = new this.opts.wsEngine({\n            noServer: true,\n            clientTracking: false,\n            perMessageDeflate: this.opts.perMessageDeflate,\n            maxPayload: this.opts.maxHttpBufferSize\n        });\n        if (typeof this.ws.on === \"function\") {\n            this.ws.on(\"headers\", (headersArray, req)=>{\n                // note: 'ws' uses an array of headers, while Engine.IO uses an object (response.writeHead() accepts both formats)\n                // we could also try to parse the array and then sync the values, but that will be error-prone\n                const additionalHeaders = req[kResponseHeaders] || {};\n                delete req[kResponseHeaders];\n                const isInitialRequest = !req._query.sid;\n                if (isInitialRequest) {\n                    this.emit(\"initial_headers\", additionalHeaders, req);\n                }\n                this.emit(\"headers\", additionalHeaders, req);\n                debug(\"writing headers: %j\", additionalHeaders);\n                Object.keys(additionalHeaders).forEach((key)=>{\n                    headersArray.push(`${key}: ${additionalHeaders[key]}`);\n                });\n            });\n        }\n    }\n    cleanup() {\n        if (this.ws) {\n            debug(\"closing webSocketServer\");\n            this.ws.close();\n        // don't delete this.ws because it can be used again if the http server starts listening again\n        }\n    }\n    /**\n     * Prepares a request by processing the query string.\n     *\n     * @private\n     */ prepare(req) {\n        // try to leverage pre-existing `req._query` (e.g: from connect)\n        if (!req._query) {\n            req._query = ~req.url.indexOf(\"?\") ? qs.parse((0, url_1.parse)(req.url).query) : {};\n        }\n    }\n    createTransport(transportName, req) {\n        return new transports_1.default[transportName](req);\n    }\n    /**\n     * Handles an Engine.IO HTTP request.\n     *\n     * @param {EngineRequest} req\n     * @param {ServerResponse} res\n     */ handleRequest(req, res) {\n        debug('handling \"%s\" http request \"%s\"', req.method, req.url);\n        this.prepare(req);\n        req.res = res;\n        const callback = (errorCode, errorContext)=>{\n            if (errorCode !== undefined) {\n                this.emit(\"connection_error\", {\n                    req,\n                    code: errorCode,\n                    message: Server.errorMessages[errorCode],\n                    context: errorContext\n                });\n                abortRequest(res, errorCode, errorContext);\n                return;\n            }\n            if (req._query.sid) {\n                debug(\"setting new request for existing client\");\n                this.clients[req._query.sid].transport.onRequest(req);\n            } else {\n                const closeConnection = (errorCode, errorContext)=>abortRequest(res, errorCode, errorContext);\n                this.handshake(req._query.transport, req, closeConnection);\n            }\n        };\n        this._applyMiddlewares(req, res, (err)=>{\n            if (err) {\n                callback(Server.errors.BAD_REQUEST, {\n                    name: \"MIDDLEWARE_FAILURE\"\n                });\n            } else {\n                this.verify(req, false, callback);\n            }\n        });\n    }\n    /**\n     * Handles an Engine.IO HTTP Upgrade.\n     */ handleUpgrade(req, socket, upgradeHead) {\n        this.prepare(req);\n        const res = new WebSocketResponse(req, socket);\n        const callback = (errorCode, errorContext)=>{\n            if (errorCode !== undefined) {\n                this.emit(\"connection_error\", {\n                    req,\n                    code: errorCode,\n                    message: Server.errorMessages[errorCode],\n                    context: errorContext\n                });\n                abortUpgrade(socket, errorCode, errorContext);\n                return;\n            }\n            const head = Buffer.from(upgradeHead);\n            upgradeHead = null;\n            // some middlewares (like express-session) wait for the writeHead() call to flush their headers\n            // see https://github.com/expressjs/session/blob/1010fadc2f071ddf2add94235d72224cf65159c6/index.js#L220-L244\n            res.writeHead();\n            // delegate to ws\n            this.ws.handleUpgrade(req, socket, head, (websocket)=>{\n                this.onWebSocket(req, socket, websocket);\n            });\n        };\n        this._applyMiddlewares(req, res, (err)=>{\n            if (err) {\n                callback(Server.errors.BAD_REQUEST, {\n                    name: \"MIDDLEWARE_FAILURE\"\n                });\n            } else {\n                this.verify(req, true, callback);\n            }\n        });\n    }\n    /**\n     * Called upon a ws.io connection.\n     *\n     * @param {ws.Socket} websocket\n     * @private\n     */ onWebSocket(req, socket, websocket) {\n        websocket.on(\"error\", onUpgradeError);\n        if (transports_1.default[req._query.transport] !== undefined && !transports_1.default[req._query.transport].prototype.handlesUpgrades) {\n            debug(\"transport doesnt handle upgraded requests\");\n            websocket.close();\n            return;\n        }\n        // get client id\n        const id = req._query.sid;\n        // keep a reference to the ws.Socket\n        req.websocket = websocket;\n        if (id) {\n            const client = this.clients[id];\n            if (!client) {\n                debug(\"upgrade attempt for closed client\");\n                websocket.close();\n            } else if (client.upgrading) {\n                debug(\"transport has already been trying to upgrade\");\n                websocket.close();\n            } else if (client.upgraded) {\n                debug(\"transport had already been upgraded\");\n                websocket.close();\n            } else {\n                debug(\"upgrading existing transport\");\n                // transport error handling takes over\n                websocket.removeListener(\"error\", onUpgradeError);\n                const transport = this.createTransport(req._query.transport, req);\n                transport.perMessageDeflate = this.opts.perMessageDeflate;\n                client._maybeUpgrade(transport);\n            }\n        } else {\n            const closeConnection = (errorCode, errorContext)=>abortUpgrade(socket, errorCode, errorContext);\n            this.handshake(req._query.transport, req, closeConnection);\n        }\n        function onUpgradeError() {\n            debug(\"websocket error before upgrade\");\n        // websocket.close() not needed\n        }\n    }\n    /**\n     * Captures upgrade requests for a http.Server.\n     *\n     * @param {http.Server} server\n     * @param {Object} options\n     */ attach(server, options = {}) {\n        const path = this._computePath(options);\n        const destroyUpgradeTimeout = options.destroyUpgradeTimeout || 1000;\n        function check(req) {\n            // TODO use `path === new URL(...).pathname` in the next major release (ref: https://nodejs.org/api/url.html)\n            return path === req.url.slice(0, path.length);\n        }\n        // cache and clean up listeners\n        const listeners = server.listeners(\"request\").slice(0);\n        server.removeAllListeners(\"request\");\n        server.on(\"close\", this.close.bind(this));\n        server.on(\"listening\", this.init.bind(this));\n        // add request handler\n        server.on(\"request\", (req, res)=>{\n            if (check(req)) {\n                debug('intercepting request for path \"%s\"', path);\n                this.handleRequest(req, res);\n            } else {\n                let i = 0;\n                const l = listeners.length;\n                for(; i < l; i++){\n                    listeners[i].call(server, req, res);\n                }\n            }\n        });\n        if (~this.opts.transports.indexOf(\"websocket\")) {\n            server.on(\"upgrade\", (req, socket, head)=>{\n                if (check(req)) {\n                    this.handleUpgrade(req, socket, head);\n                } else if (false !== options.destroyUpgrade) {\n                    // default node behavior is to disconnect when no handlers\n                    // but by adding a handler, we prevent that\n                    // and if no eio thing handles the upgrade\n                    // then the socket needs to die!\n                    setTimeout(function() {\n                        // @ts-ignore\n                        if (socket.writable && socket.bytesWritten <= 0) {\n                            socket.on(\"error\", (e)=>{\n                                debug(\"error while destroying upgrade: %s\", e.message);\n                            });\n                            return socket.end();\n                        }\n                    }, destroyUpgradeTimeout);\n                }\n            });\n        }\n    }\n}\nexports.Server = Server;\n/**\n * Close the HTTP long-polling request\n *\n * @param res - the response object\n * @param errorCode - the error code\n * @param errorContext - additional error context\n *\n * @private\n */ function abortRequest(res, errorCode, errorContext) {\n    const statusCode = errorCode === Server.errors.FORBIDDEN ? 403 : 400;\n    const message = errorContext && errorContext.message ? errorContext.message : Server.errorMessages[errorCode];\n    res.writeHead(statusCode, {\n        \"Content-Type\": \"application/json\"\n    });\n    res.end(JSON.stringify({\n        code: errorCode,\n        message\n    }));\n}\n/**\n * Close the WebSocket connection\n *\n * @param {net.Socket} socket\n * @param {string} errorCode - the error code\n * @param {object} errorContext - additional error context\n */ function abortUpgrade(socket, errorCode, errorContext = {}) {\n    socket.on(\"error\", ()=>{\n        debug(\"ignoring error from closed connection\");\n    });\n    if (socket.writable) {\n        const message = errorContext.message || Server.errorMessages[errorCode];\n        const length = Buffer.byteLength(message);\n        socket.write(\"HTTP/1.1 400 Bad Request\\r\\n\" + \"Connection: close\\r\\n\" + \"Content-type: text/html\\r\\n\" + \"Content-Length: \" + length + \"\\r\\n\" + \"\\r\\n\" + message);\n    }\n    socket.destroy();\n}\n/* eslint-disable */ /**\n * From https://github.com/nodejs/node/blob/v8.4.0/lib/_http_common.js#L303-L354\n *\n * True if val contains an invalid field-vchar\n *  field-value    = *( field-content / obs-fold )\n *  field-content  = field-vchar [ 1*( SP / HTAB ) field-vchar ]\n *  field-vchar    = VCHAR / obs-text\n *\n * checkInvalidHeaderChar() is currently designed to be inlinable by v8,\n * so take care when making changes to the implementation so that the source\n * code size does not exceed v8's default max_inlined_source_size setting.\n **/ // prettier-ignore\nconst validHdrChars = [\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    1,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    0,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1 // ... 255\n];\nfunction checkInvalidHeaderChar(val) {\n    val += \"\";\n    if (val.length < 1) return false;\n    if (!validHdrChars[val.charCodeAt(0)]) {\n        debug('invalid header, index 0, char \"%s\"', val.charCodeAt(0));\n        return true;\n    }\n    if (val.length < 2) return false;\n    if (!validHdrChars[val.charCodeAt(1)]) {\n        debug('invalid header, index 1, char \"%s\"', val.charCodeAt(1));\n        return true;\n    }\n    if (val.length < 3) return false;\n    if (!validHdrChars[val.charCodeAt(2)]) {\n        debug('invalid header, index 2, char \"%s\"', val.charCodeAt(2));\n        return true;\n    }\n    if (val.length < 4) return false;\n    if (!validHdrChars[val.charCodeAt(3)]) {\n        debug('invalid header, index 3, char \"%s\"', val.charCodeAt(3));\n        return true;\n    }\n    for(let i = 4; i < val.length; ++i){\n        if (!validHdrChars[val.charCodeAt(i)]) {\n            debug('invalid header, index \"%i\", char \"%s\"', i, val.charCodeAt(i));\n            return true;\n        }\n    }\n    return false;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZW5naW5lLmlvL2J1aWxkL3NlcnZlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsY0FBYyxHQUFHQSxrQkFBa0IsR0FBRyxLQUFLO0FBQzNDLE1BQU1JLEtBQUtDLG1CQUFPQSxDQUFDLGdDQUFhO0FBQ2hDLE1BQU1DLFFBQVFELG1CQUFPQSxDQUFDLGdCQUFLO0FBQzNCLE1BQU1FLFdBQVdGLG1CQUFPQSxDQUFDLCtEQUFVO0FBQ25DLE1BQU1HLGVBQWVILG1CQUFPQSxDQUFDLDhFQUFjO0FBQzNDLE1BQU1JLFdBQVdKLG1CQUFPQSxDQUFDLHNCQUFRO0FBQ2pDLE1BQU1LLFdBQVdMLG1CQUFPQSxDQUFDLGdFQUFVO0FBQ25DLE1BQU1NLFVBQVVOLG1CQUFPQSxDQUFDLDZFQUFPO0FBQy9CLE1BQU1PLFdBQVdQLG1CQUFPQSxDQUFDLG9EQUFRO0FBQ2pDLE1BQU1RLE9BQU9SLG1CQUFPQSxDQUFDLDRDQUFJO0FBQ3pCLE1BQU1TLGlCQUFpQlQsbUJBQU9BLENBQUMsa0dBQTJCO0FBQzFELE1BQU1VLHFCQUFxQlYsbUJBQU9BLENBQUMsa0ZBQWtCO0FBQ3JELE1BQU1XLFFBQVEsQ0FBQyxHQUFHTCxRQUFRTSxPQUFPLEVBQUU7QUFDbkMsTUFBTUMsbUJBQW1CQyxPQUFPO0FBQ2hDLFNBQVNDLGVBQWVDLElBQUk7SUFDeEIsSUFBSTtRQUNBLE1BQU1DLFNBQVNDLEtBQUtDLEtBQUssQ0FBQ0g7UUFDMUIsSUFBSSxPQUFPQyxPQUFPRyxHQUFHLEtBQUssVUFBVTtZQUNoQyxPQUFPSCxPQUFPRyxHQUFHO1FBQ3JCO0lBQ0osRUFDQSxPQUFPQyxHQUFHLENBQUU7QUFDaEI7QUFDQSxNQUFNdkIsbUJBQW1CTSxTQUFTa0IsWUFBWTtJQUMxQzs7OztLQUlDLEdBQ0RDLFlBQVlDLE9BQU8sQ0FBQyxDQUFDLENBQUU7UUFDbkIsS0FBSztRQUNMLElBQUksQ0FB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O0lBQzdDO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQzdDO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQzdDO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQzdDO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQzdDO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQzdDO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQzdDO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQzdDO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQzdDO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQzdDO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHLEVBQUUsVUFBVTtDQUM1RDtBQUNELFNBQVN4SCx1QkFBdUJ5SCxHQUFHO0lBQy9CQSxPQUFPO0lBQ1AsSUFBSUEsSUFBSXhHLE1BQU0sR0FBRyxHQUNiLE9BQU87SUFDWCxJQUFJLENBQUN1RyxhQUFhLENBQUNDLElBQUlDLFVBQVUsQ0FBQyxHQUFHLEVBQUU7UUFDbkMvSyxNQUFNLHNDQUFzQzhLLElBQUlDLFVBQVUsQ0FBQztRQUMzRCxPQUFPO0lBQ1g7SUFDQSxJQUFJRCxJQUFJeEcsTUFBTSxHQUFHLEdBQ2IsT0FBTztJQUNYLElBQUksQ0FBQ3VHLGFBQWEsQ0FBQ0MsSUFBSUMsVUFBVSxDQUFDLEdBQUcsRUFBRTtRQUNuQy9LLE1BQU0sc0NBQXNDOEssSUFBSUMsVUFBVSxDQUFDO1FBQzNELE9BQU87SUFDWDtJQUNBLElBQUlELElBQUl4RyxNQUFNLEdBQUcsR0FDYixPQUFPO0lBQ1gsSUFBSSxDQUFDdUcsYUFBYSxDQUFDQyxJQUFJQyxVQUFVLENBQUMsR0FBRyxFQUFFO1FBQ25DL0ssTUFBTSxzQ0FBc0M4SyxJQUFJQyxVQUFVLENBQUM7UUFDM0QsT0FBTztJQUNYO0lBQ0EsSUFBSUQsSUFBSXhHLE1BQU0sR0FBRyxHQUNiLE9BQU87SUFDWCxJQUFJLENBQUN1RyxhQUFhLENBQUNDLElBQUlDLFVBQVUsQ0FBQyxHQUFHLEVBQUU7UUFDbkMvSyxNQUFNLHNDQUFzQzhLLElBQUlDLFVBQVUsQ0FBQztRQUMzRCxPQUFPO0lBQ1g7SUFDQSxJQUFLLElBQUl2RyxJQUFJLEdBQUdBLElBQUlzRyxJQUFJeEcsTUFBTSxFQUFFLEVBQUVFLEVBQUc7UUFDakMsSUFBSSxDQUFDcUcsYUFBYSxDQUFDQyxJQUFJQyxVQUFVLENBQUN2RyxHQUFHLEVBQUU7WUFDbkN4RSxNQUFNLHlDQUF5Q3dFLEdBQUdzRyxJQUFJQyxVQUFVLENBQUN2RztZQUNqRSxPQUFPO1FBQ1g7SUFDSjtJQUNBLE9BQU87QUFDWCIsInNvdXJjZXMiOlsid2VicGFjazovL2V4YW1yb3NoLy4vbm9kZV9tb2R1bGVzL2VuZ2luZS5pby9idWlsZC9zZXJ2ZXIuanM/NjU5ZCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuU2VydmVyID0gZXhwb3J0cy5CYXNlU2VydmVyID0gdm9pZCAwO1xuY29uc3QgcXMgPSByZXF1aXJlKFwicXVlcnlzdHJpbmdcIik7XG5jb25zdCB1cmxfMSA9IHJlcXVpcmUoXCJ1cmxcIik7XG5jb25zdCBiYXNlNjRpZCA9IHJlcXVpcmUoXCJiYXNlNjRpZFwiKTtcbmNvbnN0IHRyYW5zcG9ydHNfMSA9IHJlcXVpcmUoXCIuL3RyYW5zcG9ydHNcIik7XG5jb25zdCBldmVudHNfMSA9IHJlcXVpcmUoXCJldmVudHNcIik7XG5jb25zdCBzb2NrZXRfMSA9IHJlcXVpcmUoXCIuL3NvY2tldFwiKTtcbmNvbnN0IGRlYnVnXzEgPSByZXF1aXJlKFwiZGVidWdcIik7XG5jb25zdCBjb29raWVfMSA9IHJlcXVpcmUoXCJjb29raWVcIik7XG5jb25zdCB3c18xID0gcmVxdWlyZShcIndzXCIpO1xuY29uc3Qgd2VidHJhbnNwb3J0XzEgPSByZXF1aXJlKFwiLi90cmFuc3BvcnRzL3dlYnRyYW5zcG9ydFwiKTtcbmNvbnN0IGVuZ2luZV9pb19wYXJzZXJfMSA9IHJlcXVpcmUoXCJlbmdpbmUuaW8tcGFyc2VyXCIpO1xuY29uc3QgZGVidWcgPSAoMCwgZGVidWdfMS5kZWZhdWx0KShcImVuZ2luZVwiKTtcbmNvbnN0IGtSZXNwb25zZUhlYWRlcnMgPSBTeW1ib2woXCJyZXNwb25zZUhlYWRlcnNcIik7XG5mdW5jdGlvbiBwYXJzZVNlc3Npb25JZChkYXRhKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcGFyc2VkID0gSlNPTi5wYXJzZShkYXRhKTtcbiAgICAgICAgaWYgKHR5cGVvZiBwYXJzZWQuc2lkID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VkLnNpZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjYXRjaCAoZSkgeyB9XG59XG5jbGFzcyBCYXNlU2VydmVyIGV4dGVuZHMgZXZlbnRzXzEuRXZlbnRFbWl0dGVyIHtcbiAgICAvKipcbiAgICAgKiBTZXJ2ZXIgY29uc3RydWN0b3IuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIG9wdGlvbnNcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihvcHRzID0ge30pIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5taWRkbGV3YXJlcyA9IFtdO1xuICAgICAgICB0aGlzLmNsaWVudHMgPSB7fTtcbiAgICAgICAgdGhpcy5jbGllbnRzQ291bnQgPSAwO1xuICAgICAgICB0aGlzLm9wdHMgPSBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgICAgIHdzRW5naW5lOiB3c18xLlNlcnZlcixcbiAgICAgICAgICAgIHBpbmdUaW1lb3V0OiAyMDAwMCxcbiAgICAgICAgICAgIHBpbmdJbnRlcnZhbDogMjUwMDAsXG4gICAgICAgICAgICB1cGdyYWRlVGltZW91dDogMTAwMDAsXG4gICAgICAgICAgICBtYXhIdHRwQnVmZmVyU2l6ZTogMWU2LFxuICAgICAgICAgICAgdHJhbnNwb3J0czogW1wicG9sbGluZ1wiLCBcIndlYnNvY2tldFwiXSwgLy8gV2ViVHJhbnNwb3J0IGlzIGRpc2FibGVkIGJ5IGRlZmF1bHRcbiAgICAgICAgICAgIGFsbG93VXBncmFkZXM6IHRydWUsXG4gICAgICAgICAgICBodHRwQ29tcHJlc3Npb246IHtcbiAgICAgICAgICAgICAgICB0aHJlc2hvbGQ6IDEwMjQsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY29yczogZmFsc2UsXG4gICAgICAgICAgICBhbGxvd0VJTzM6IGZhbHNlLFxuICAgICAgICB9LCBvcHRzKTtcbiAgICAgICAgaWYgKG9wdHMuY29va2llKSB7XG4gICAgICAgICAgICB0aGlzLm9wdHMuY29va2llID0gT2JqZWN0LmFzc2lnbih7XG4gICAgICAgICAgICAgICAgbmFtZTogXCJpb1wiLFxuICAgICAgICAgICAgICAgIHBhdGg6IFwiL1wiLFxuICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgICAgICBodHRwT25seTogb3B0cy5jb29raWUucGF0aCAhPT0gZmFsc2UsXG4gICAgICAgICAgICAgICAgc2FtZVNpdGU6IFwibGF4XCIsXG4gICAgICAgICAgICB9LCBvcHRzLmNvb2tpZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMub3B0cy5jb3JzKSB7XG4gICAgICAgICAgICB0aGlzLnVzZShyZXF1aXJlKFwiY29yc1wiKSh0aGlzLm9wdHMuY29ycykpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRzLnBlck1lc3NhZ2VEZWZsYXRlKSB7XG4gICAgICAgICAgICB0aGlzLm9wdHMucGVyTWVzc2FnZURlZmxhdGUgPSBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgICAgICAgICB0aHJlc2hvbGQ6IDEwMjQsXG4gICAgICAgICAgICB9LCBvcHRzLnBlck1lc3NhZ2VEZWZsYXRlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmluaXQoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29tcHV0ZSB0aGUgcGF0aG5hbWUgb2YgdGhlIHJlcXVlc3RzIHRoYXQgYXJlIGhhbmRsZWQgYnkgdGhlIHNlcnZlclxuICAgICAqIEBwYXJhbSBvcHRpb25zXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIF9jb21wdXRlUGF0aChvcHRpb25zKSB7XG4gICAgICAgIGxldCBwYXRoID0gKG9wdGlvbnMucGF0aCB8fCBcIi9lbmdpbmUuaW9cIikucmVwbGFjZSgvXFwvJC8sIFwiXCIpO1xuICAgICAgICBpZiAob3B0aW9ucy5hZGRUcmFpbGluZ1NsYXNoICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgLy8gbm9ybWFsaXplIHBhdGhcbiAgICAgICAgICAgIHBhdGggKz0gXCIvXCI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhdGg7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBsaXN0IG9mIGF2YWlsYWJsZSB0cmFuc3BvcnRzIGZvciB1cGdyYWRlIGdpdmVuIGEgY2VydGFpbiB0cmFuc3BvcnQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtBcnJheX1cbiAgICAgKi9cbiAgICB1cGdyYWRlcyh0cmFuc3BvcnQpIHtcbiAgICAgICAgaWYgKCF0aGlzLm9wdHMuYWxsb3dVcGdyYWRlcylcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgcmV0dXJuIHRyYW5zcG9ydHNfMS5kZWZhdWx0W3RyYW5zcG9ydF0udXBncmFkZXNUbyB8fCBbXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVmVyaWZpZXMgYSByZXF1ZXN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtFbmdpbmVSZXF1ZXN0fSByZXFcbiAgICAgKiBAcGFyYW0gdXBncmFkZSAtIHdoZXRoZXIgaXQncyBhbiB1cGdyYWRlIHJlcXVlc3RcbiAgICAgKiBAcGFyYW0gZm5cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgdmVyaWZ5KHJlcSwgdXBncmFkZSwgZm4pIHtcbiAgICAgICAgLy8gdHJhbnNwb3J0IGNoZWNrXG4gICAgICAgIGNvbnN0IHRyYW5zcG9ydCA9IHJlcS5fcXVlcnkudHJhbnNwb3J0O1xuICAgICAgICAvLyBXZWJUcmFuc3BvcnQgZG9lcyBub3QgZ28gdGhyb3VnaCB0aGUgdmVyaWZ5KCkgbWV0aG9kLCBzZWUgdGhlIG9uV2ViVHJhbnNwb3J0U2Vzc2lvbigpIG1ldGhvZFxuICAgICAgICBpZiAoIX50aGlzLm9wdHMudHJhbnNwb3J0cy5pbmRleE9mKHRyYW5zcG9ydCkgfHxcbiAgICAgICAgICAgIHRyYW5zcG9ydCA9PT0gXCJ3ZWJ0cmFuc3BvcnRcIikge1xuICAgICAgICAgICAgZGVidWcoJ3Vua25vd24gdHJhbnNwb3J0IFwiJXNcIicsIHRyYW5zcG9ydCk7XG4gICAgICAgICAgICByZXR1cm4gZm4oU2VydmVyLmVycm9ycy5VTktOT1dOX1RSQU5TUE9SVCwgeyB0cmFuc3BvcnQgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gJ09yaWdpbicgaGVhZGVyIGNoZWNrXG4gICAgICAgIGNvbnN0IGlzT3JpZ2luSW52YWxpZCA9IGNoZWNrSW52YWxpZEhlYWRlckNoYXIocmVxLmhlYWRlcnMub3JpZ2luKTtcbiAgICAgICAgaWYgKGlzT3JpZ2luSW52YWxpZCkge1xuICAgICAgICAgICAgY29uc3Qgb3JpZ2luID0gcmVxLmhlYWRlcnMub3JpZ2luO1xuICAgICAgICAgICAgcmVxLmhlYWRlcnMub3JpZ2luID0gbnVsbDtcbiAgICAgICAgICAgIGRlYnVnKFwib3JpZ2luIGhlYWRlciBpbnZhbGlkXCIpO1xuICAgICAgICAgICAgcmV0dXJuIGZuKFNlcnZlci5lcnJvcnMuQkFEX1JFUVVFU1QsIHtcbiAgICAgICAgICAgICAgICBuYW1lOiBcIklOVkFMSURfT1JJR0lOXCIsXG4gICAgICAgICAgICAgICAgb3JpZ2luLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gc2lkIGNoZWNrXG4gICAgICAgIGNvbnN0IHNpZCA9IHJlcS5fcXVlcnkuc2lkO1xuICAgICAgICBpZiAoc2lkKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuY2xpZW50cy5oYXNPd25Qcm9wZXJ0eShzaWQpKSB7XG4gICAgICAgICAgICAgICAgZGVidWcoJ3Vua25vd24gc2lkIFwiJXNcIicsIHNpZCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZuKFNlcnZlci5lcnJvcnMuVU5LTk9XTl9TSUQsIHtcbiAgICAgICAgICAgICAgICAgICAgc2lkLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcHJldmlvdXNUcmFuc3BvcnQgPSB0aGlzLmNsaWVudHNbc2lkXS50cmFuc3BvcnQubmFtZTtcbiAgICAgICAgICAgIGlmICghdXBncmFkZSAmJiBwcmV2aW91c1RyYW5zcG9ydCAhPT0gdHJhbnNwb3J0KSB7XG4gICAgICAgICAgICAgICAgZGVidWcoXCJiYWQgcmVxdWVzdDogdW5leHBlY3RlZCB0cmFuc3BvcnQgd2l0aG91dCB1cGdyYWRlXCIpO1xuICAgICAgICAgICAgICAgIHJldHVybiBmbihTZXJ2ZXIuZXJyb3JzLkJBRF9SRVFVRVNULCB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IFwiVFJBTlNQT1JUX01JU01BVENIXCIsXG4gICAgICAgICAgICAgICAgICAgIHRyYW5zcG9ydCxcbiAgICAgICAgICAgICAgICAgICAgcHJldmlvdXNUcmFuc3BvcnQsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBoYW5kc2hha2UgaXMgR0VUIG9ubHlcbiAgICAgICAgICAgIGlmIChcIkdFVFwiICE9PSByZXEubWV0aG9kKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZuKFNlcnZlci5lcnJvcnMuQkFEX0hBTkRTSEFLRV9NRVRIT0QsIHtcbiAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiByZXEubWV0aG9kLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRyYW5zcG9ydCA9PT0gXCJ3ZWJzb2NrZXRcIiAmJiAhdXBncmFkZSkge1xuICAgICAgICAgICAgICAgIGRlYnVnKFwiaW52YWxpZCB0cmFuc3BvcnQgdXBncmFkZVwiKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZm4oU2VydmVyLmVycm9ycy5CQURfUkVRVUVTVCwge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBcIlRSQU5TUE9SVF9IQU5EU0hBS0VfRVJST1JcIixcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdGhpcy5vcHRzLmFsbG93UmVxdWVzdClcbiAgICAgICAgICAgICAgICByZXR1cm4gZm4oKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm9wdHMuYWxsb3dSZXF1ZXN0KHJlcSwgKG1lc3NhZ2UsIHN1Y2Nlc3MpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIXN1Y2Nlc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZuKFNlcnZlci5lcnJvcnMuRk9SQklEREVOLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm4oKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGZuKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZHMgYSBuZXcgbWlkZGxld2FyZS5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogaW1wb3J0IGhlbG1ldCBmcm9tIFwiaGVsbWV0XCI7XG4gICAgICpcbiAgICAgKiBlbmdpbmUudXNlKGhlbG1ldCgpKTtcbiAgICAgKlxuICAgICAqIEBwYXJhbSBmblxuICAgICAqL1xuICAgIHVzZShmbikge1xuICAgICAgICB0aGlzLm1pZGRsZXdhcmVzLnB1c2goZm4pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBcHBseSB0aGUgbWlkZGxld2FyZXMgdG8gdGhlIHJlcXVlc3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcmVxXG4gICAgICogQHBhcmFtIHJlc1xuICAgICAqIEBwYXJhbSBjYWxsYmFja1xuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBfYXBwbHlNaWRkbGV3YXJlcyhyZXEsIHJlcywgY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKHRoaXMubWlkZGxld2FyZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBkZWJ1ZyhcIm5vIG1pZGRsZXdhcmUgdG8gYXBwbHksIHNraXBwaW5nXCIpO1xuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYXBwbHkgPSAoaSkgPT4ge1xuICAgICAgICAgICAgZGVidWcoXCJhcHBseWluZyBtaWRkbGV3YXJlIG7CsCVkXCIsIGkgKyAxKTtcbiAgICAgICAgICAgIHRoaXMubWlkZGxld2FyZXNbaV0ocmVxLCByZXMsIChlcnIpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaSArIDEgPCB0aGlzLm1pZGRsZXdhcmVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBhcHBseShpICsgMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICBhcHBseSgwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2xvc2VzIGFsbCBjbGllbnRzLlxuICAgICAqL1xuICAgIGNsb3NlKCkge1xuICAgICAgICBkZWJ1ZyhcImNsb3NpbmcgYWxsIG9wZW4gY2xpZW50c1wiKTtcbiAgICAgICAgZm9yIChsZXQgaSBpbiB0aGlzLmNsaWVudHMpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmNsaWVudHMuaGFzT3duUHJvcGVydHkoaSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNsaWVudHNbaV0uY2xvc2UodHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jbGVhbnVwKCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBnZW5lcmF0ZSBhIHNvY2tldCBpZC5cbiAgICAgKiBPdmVyd3JpdGUgdGhpcyBtZXRob2QgdG8gZ2VuZXJhdGUgeW91ciBjdXN0b20gc29ja2V0IGlkXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0luY29taW5nTWVzc2FnZX0gcmVxIC0gdGhlIHJlcXVlc3Qgb2JqZWN0XG4gICAgICovXG4gICAgZ2VuZXJhdGVJZChyZXEpIHtcbiAgICAgICAgcmV0dXJuIGJhc2U2NGlkLmdlbmVyYXRlSWQoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSGFuZHNoYWtlcyBhIG5ldyBjbGllbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdHJhbnNwb3J0TmFtZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSByZXEgLSB0aGUgcmVxdWVzdCBvYmplY3RcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjbG9zZUNvbm5lY3Rpb25cbiAgICAgKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhc3luYyBoYW5kc2hha2UodHJhbnNwb3J0TmFtZSwgcmVxLCBjbG9zZUNvbm5lY3Rpb24pIHtcbiAgICAgICAgY29uc3QgcHJvdG9jb2wgPSByZXEuX3F1ZXJ5LkVJTyA9PT0gXCI0XCIgPyA0IDogMzsgLy8gM3JkIHJldmlzaW9uIGJ5IGRlZmF1bHRcbiAgICAgICAgaWYgKHByb3RvY29sID09PSAzICYmICF0aGlzLm9wdHMuYWxsb3dFSU8zKSB7XG4gICAgICAgICAgICBkZWJ1ZyhcInVuc3VwcG9ydGVkIHByb3RvY29sIHZlcnNpb25cIik7XG4gICAgICAgICAgICB0aGlzLmVtaXQoXCJjb25uZWN0aW9uX2Vycm9yXCIsIHtcbiAgICAgICAgICAgICAgICByZXEsXG4gICAgICAgICAgICAgICAgY29kZTogU2VydmVyLmVycm9ycy5VTlNVUFBPUlRFRF9QUk9UT0NPTF9WRVJTSU9OLFxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IFNlcnZlci5lcnJvck1lc3NhZ2VzW1NlcnZlci5lcnJvcnMuVU5TVVBQT1JURURfUFJPVE9DT0xfVkVSU0lPTl0sXG4gICAgICAgICAgICAgICAgY29udGV4dDoge1xuICAgICAgICAgICAgICAgICAgICBwcm90b2NvbCxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjbG9zZUNvbm5lY3Rpb24oU2VydmVyLmVycm9ycy5VTlNVUFBPUlRFRF9QUk9UT0NPTF9WRVJTSU9OKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgaWQ7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZCA9IGF3YWl0IHRoaXMuZ2VuZXJhdGVJZChyZXEpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBkZWJ1ZyhcImVycm9yIHdoaWxlIGdlbmVyYXRpbmcgYW4gaWRcIik7XG4gICAgICAgICAgICB0aGlzLmVtaXQoXCJjb25uZWN0aW9uX2Vycm9yXCIsIHtcbiAgICAgICAgICAgICAgICByZXEsXG4gICAgICAgICAgICAgICAgY29kZTogU2VydmVyLmVycm9ycy5CQURfUkVRVUVTVCxcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiBTZXJ2ZXIuZXJyb3JNZXNzYWdlc1tTZXJ2ZXIuZXJyb3JzLkJBRF9SRVFVRVNUXSxcbiAgICAgICAgICAgICAgICBjb250ZXh0OiB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IFwiSURfR0VORVJBVElPTl9FUlJPUlwiLFxuICAgICAgICAgICAgICAgICAgICBlcnJvcjogZSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjbG9zZUNvbm5lY3Rpb24oU2VydmVyLmVycm9ycy5CQURfUkVRVUVTVCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZGVidWcoJ2hhbmRzaGFraW5nIGNsaWVudCBcIiVzXCInLCBpZCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YXIgdHJhbnNwb3J0ID0gdGhpcy5jcmVhdGVUcmFuc3BvcnQodHJhbnNwb3J0TmFtZSwgcmVxKTtcbiAgICAgICAgICAgIGlmIChcInBvbGxpbmdcIiA9PT0gdHJhbnNwb3J0TmFtZSkge1xuICAgICAgICAgICAgICAgIHRyYW5zcG9ydC5tYXhIdHRwQnVmZmVyU2l6ZSA9IHRoaXMub3B0cy5tYXhIdHRwQnVmZmVyU2l6ZTtcbiAgICAgICAgICAgICAgICB0cmFuc3BvcnQuaHR0cENvbXByZXNzaW9uID0gdGhpcy5vcHRzLmh0dHBDb21wcmVzc2lvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKFwid2Vic29ja2V0XCIgPT09IHRyYW5zcG9ydE5hbWUpIHtcbiAgICAgICAgICAgICAgICB0cmFuc3BvcnQucGVyTWVzc2FnZURlZmxhdGUgPSB0aGlzLm9wdHMucGVyTWVzc2FnZURlZmxhdGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGRlYnVnKCdlcnJvciBoYW5kc2hha2luZyB0byB0cmFuc3BvcnQgXCIlc1wiJywgdHJhbnNwb3J0TmFtZSk7XG4gICAgICAgICAgICB0aGlzLmVtaXQoXCJjb25uZWN0aW9uX2Vycm9yXCIsIHtcbiAgICAgICAgICAgICAgICByZXEsXG4gICAgICAgICAgICAgICAgY29kZTogU2VydmVyLmVycm9ycy5CQURfUkVRVUVTVCxcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiBTZXJ2ZXIuZXJyb3JNZXNzYWdlc1tTZXJ2ZXIuZXJyb3JzLkJBRF9SRVFVRVNUXSxcbiAgICAgICAgICAgICAgICBjb250ZXh0OiB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IFwiVFJBTlNQT1JUX0hBTkRTSEFLRV9FUlJPUlwiLFxuICAgICAgICAgICAgICAgICAgICBlcnJvcjogZSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjbG9zZUNvbm5lY3Rpb24oU2VydmVyLmVycm9ycy5CQURfUkVRVUVTVCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc29ja2V0ID0gbmV3IHNvY2tldF8xLlNvY2tldChpZCwgdGhpcywgdHJhbnNwb3J0LCByZXEsIHByb3RvY29sKTtcbiAgICAgICAgdHJhbnNwb3J0Lm9uKFwiaGVhZGVyc1wiLCAoaGVhZGVycywgcmVxKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBpc0luaXRpYWxSZXF1ZXN0ID0gIXJlcS5fcXVlcnkuc2lkO1xuICAgICAgICAgICAgaWYgKGlzSW5pdGlhbFJlcXVlc3QpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5vcHRzLmNvb2tpZSkge1xuICAgICAgICAgICAgICAgICAgICBoZWFkZXJzW1wiU2V0LUNvb2tpZVwiXSA9IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgICAgICAgICAgICAgICgwLCBjb29raWVfMS5zZXJpYWxpemUpKHRoaXMub3B0cy5jb29raWUubmFtZSwgaWQsIHRoaXMub3B0cy5jb29raWUpLFxuICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJpbml0aWFsX2hlYWRlcnNcIiwgaGVhZGVycywgcmVxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZW1pdChcImhlYWRlcnNcIiwgaGVhZGVycywgcmVxKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRyYW5zcG9ydC5vblJlcXVlc3QocmVxKTtcbiAgICAgICAgdGhpcy5jbGllbnRzW2lkXSA9IHNvY2tldDtcbiAgICAgICAgdGhpcy5jbGllbnRzQ291bnQrKztcbiAgICAgICAgc29ja2V0Lm9uY2UoXCJjbG9zZVwiLCAoKSA9PiB7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5jbGllbnRzW2lkXTtcbiAgICAgICAgICAgIHRoaXMuY2xpZW50c0NvdW50LS07XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmVtaXQoXCJjb25uZWN0aW9uXCIsIHNvY2tldCk7XG4gICAgICAgIHJldHVybiB0cmFuc3BvcnQ7XG4gICAgfVxuICAgIGFzeW5jIG9uV2ViVHJhbnNwb3J0U2Vzc2lvbihzZXNzaW9uKSB7XG4gICAgICAgIGNvbnN0IHRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIGRlYnVnKFwidGhlIGNsaWVudCBmYWlsZWQgdG8gZXN0YWJsaXNoIGEgYmlkaXJlY3Rpb25hbCBzdHJlYW0gaW4gdGhlIGdpdmVuIHBlcmlvZFwiKTtcbiAgICAgICAgICAgIHNlc3Npb24uY2xvc2UoKTtcbiAgICAgICAgfSwgdGhpcy5vcHRzLnVwZ3JhZGVUaW1lb3V0KTtcbiAgICAgICAgY29uc3Qgc3RyZWFtUmVhZGVyID0gc2Vzc2lvbi5pbmNvbWluZ0JpZGlyZWN0aW9uYWxTdHJlYW1zLmdldFJlYWRlcigpO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBzdHJlYW1SZWFkZXIucmVhZCgpO1xuICAgICAgICBpZiAocmVzdWx0LmRvbmUpIHtcbiAgICAgICAgICAgIGRlYnVnKFwic2Vzc2lvbiBpcyBjbG9zZWRcIik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3RyZWFtID0gcmVzdWx0LnZhbHVlO1xuICAgICAgICBjb25zdCB0cmFuc2Zvcm1TdHJlYW0gPSAoMCwgZW5naW5lX2lvX3BhcnNlcl8xLmNyZWF0ZVBhY2tldERlY29kZXJTdHJlYW0pKHRoaXMub3B0cy5tYXhIdHRwQnVmZmVyU2l6ZSwgXCJub2RlYnVmZmVyXCIpO1xuICAgICAgICBjb25zdCByZWFkZXIgPSBzdHJlYW0ucmVhZGFibGUucGlwZVRocm91Z2godHJhbnNmb3JtU3RyZWFtKS5nZXRSZWFkZXIoKTtcbiAgICAgICAgLy8gcmVhZGluZyB0aGUgZmlyc3QgcGFja2V0IG9mIHRoZSBzdHJlYW1cbiAgICAgICAgY29uc3QgeyB2YWx1ZSwgZG9uZSB9ID0gYXdhaXQgcmVhZGVyLnJlYWQoKTtcbiAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICAgIGRlYnVnKFwic3RyZWFtIGlzIGNsb3NlZFwiKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICAgIGlmICh2YWx1ZS50eXBlICE9PSBcIm9wZW5cIikge1xuICAgICAgICAgICAgZGVidWcoXCJpbnZhbGlkIFdlYlRyYW5zcG9ydCBoYW5kc2hha2VcIik7XG4gICAgICAgICAgICByZXR1cm4gc2Vzc2lvbi5jbG9zZSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YWx1ZS5kYXRhID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRyYW5zcG9ydCA9IG5ldyB3ZWJ0cmFuc3BvcnRfMS5XZWJUcmFuc3BvcnQoc2Vzc2lvbiwgc3RyZWFtLCByZWFkZXIpO1xuICAgICAgICAgICAgLy8gbm90ZTogd2UgY2Fubm90IHVzZSBcInRoaXMuZ2VuZXJhdGVJZCgpXCIsIGJlY2F1c2UgdGhlcmUgaXMgbm8gXCJyZXFcIiBhcmd1bWVudFxuICAgICAgICAgICAgY29uc3QgaWQgPSBiYXNlNjRpZC5nZW5lcmF0ZUlkKCk7XG4gICAgICAgICAgICBkZWJ1ZygnaGFuZHNoYWtpbmcgY2xpZW50IFwiJXNcIiAoV2ViVHJhbnNwb3J0KScsIGlkKTtcbiAgICAgICAgICAgIGNvbnN0IHNvY2tldCA9IG5ldyBzb2NrZXRfMS5Tb2NrZXQoaWQsIHRoaXMsIHRyYW5zcG9ydCwgbnVsbCwgNCk7XG4gICAgICAgICAgICB0aGlzLmNsaWVudHNbaWRdID0gc29ja2V0O1xuICAgICAgICAgICAgdGhpcy5jbGllbnRzQ291bnQrKztcbiAgICAgICAgICAgIHNvY2tldC5vbmNlKFwiY2xvc2VcIiwgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmNsaWVudHNbaWRdO1xuICAgICAgICAgICAgICAgIHRoaXMuY2xpZW50c0NvdW50LS07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuZW1pdChcImNvbm5lY3Rpb25cIiwgc29ja2V0KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzaWQgPSBwYXJzZVNlc3Npb25JZCh2YWx1ZS5kYXRhKTtcbiAgICAgICAgaWYgKCFzaWQpIHtcbiAgICAgICAgICAgIGRlYnVnKFwiaW52YWxpZCBXZWJUcmFuc3BvcnQgaGFuZHNoYWtlXCIpO1xuICAgICAgICAgICAgcmV0dXJuIHNlc3Npb24uY2xvc2UoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjbGllbnQgPSB0aGlzLmNsaWVudHNbc2lkXTtcbiAgICAgICAgaWYgKCFjbGllbnQpIHtcbiAgICAgICAgICAgIGRlYnVnKFwidXBncmFkZSBhdHRlbXB0IGZvciBjbG9zZWQgY2xpZW50XCIpO1xuICAgICAgICAgICAgc2Vzc2lvbi5jbG9zZSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNsaWVudC51cGdyYWRpbmcpIHtcbiAgICAgICAgICAgIGRlYnVnKFwidHJhbnNwb3J0IGhhcyBhbHJlYWR5IGJlZW4gdHJ5aW5nIHRvIHVwZ3JhZGVcIik7XG4gICAgICAgICAgICBzZXNzaW9uLmNsb3NlKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY2xpZW50LnVwZ3JhZGVkKSB7XG4gICAgICAgICAgICBkZWJ1ZyhcInRyYW5zcG9ydCBoYWQgYWxyZWFkeSBiZWVuIHVwZ3JhZGVkXCIpO1xuICAgICAgICAgICAgc2Vzc2lvbi5jbG9zZSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZGVidWcoXCJ1cGdyYWRpbmcgZXhpc3RpbmcgdHJhbnNwb3J0XCIpO1xuICAgICAgICAgICAgY29uc3QgdHJhbnNwb3J0ID0gbmV3IHdlYnRyYW5zcG9ydF8xLldlYlRyYW5zcG9ydChzZXNzaW9uLCBzdHJlYW0sIHJlYWRlcik7XG4gICAgICAgICAgICBjbGllbnQuX21heWJlVXBncmFkZSh0cmFuc3BvcnQpO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5CYXNlU2VydmVyID0gQmFzZVNlcnZlcjtcbi8qKlxuICogUHJvdG9jb2wgZXJyb3JzIG1hcHBpbmdzLlxuICovXG5CYXNlU2VydmVyLmVycm9ycyA9IHtcbiAgICBVTktOT1dOX1RSQU5TUE9SVDogMCxcbiAgICBVTktOT1dOX1NJRDogMSxcbiAgICBCQURfSEFORFNIQUtFX01FVEhPRDogMixcbiAgICBCQURfUkVRVUVTVDogMyxcbiAgICBGT1JCSURERU46IDQsXG4gICAgVU5TVVBQT1JURURfUFJPVE9DT0xfVkVSU0lPTjogNSxcbn07XG5CYXNlU2VydmVyLmVycm9yTWVzc2FnZXMgPSB7XG4gICAgMDogXCJUcmFuc3BvcnQgdW5rbm93blwiLFxuICAgIDE6IFwiU2Vzc2lvbiBJRCB1bmtub3duXCIsXG4gICAgMjogXCJCYWQgaGFuZHNoYWtlIG1ldGhvZFwiLFxuICAgIDM6IFwiQmFkIHJlcXVlc3RcIixcbiAgICA0OiBcIkZvcmJpZGRlblwiLFxuICAgIDU6IFwiVW5zdXBwb3J0ZWQgcHJvdG9jb2wgdmVyc2lvblwiLFxufTtcbi8qKlxuICogRXhwb3NlcyBhIHN1YnNldCBvZiB0aGUgaHR0cC5TZXJ2ZXJSZXNwb25zZSBpbnRlcmZhY2UsIGluIG9yZGVyIHRvIGJlIGFibGUgdG8gYXBwbHkgdGhlIG1pZGRsZXdhcmVzIHRvIGFuIHVwZ3JhZGVcbiAqIHJlcXVlc3QuXG4gKlxuICogQHNlZSBodHRwczovL25vZGVqcy5vcmcvYXBpL2h0dHAuaHRtbCNjbGFzcy1odHRwc2VydmVycmVzcG9uc2VcbiAqL1xuY2xhc3MgV2ViU29ja2V0UmVzcG9uc2Uge1xuICAgIGNvbnN0cnVjdG9yKHJlcSwgc29ja2V0KSB7XG4gICAgICAgIHRoaXMucmVxID0gcmVxO1xuICAgICAgICB0aGlzLnNvY2tldCA9IHNvY2tldDtcbiAgICAgICAgLy8gdGVtcG9yYXJpbHkgc3RvcmUgdGhlIHJlc3BvbnNlIGhlYWRlcnMgb24gdGhlIHJlcSBvYmplY3QgKHNlZSB0aGUgXCJoZWFkZXJzXCIgZXZlbnQpXG4gICAgICAgIHJlcVtrUmVzcG9uc2VIZWFkZXJzXSA9IHt9O1xuICAgIH1cbiAgICBzZXRIZWFkZXIobmFtZSwgdmFsdWUpIHtcbiAgICAgICAgdGhpcy5yZXFba1Jlc3BvbnNlSGVhZGVyc11bbmFtZV0gPSB2YWx1ZTtcbiAgICB9XG4gICAgZ2V0SGVhZGVyKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVxW2tSZXNwb25zZUhlYWRlcnNdW25hbWVdO1xuICAgIH1cbiAgICByZW1vdmVIZWFkZXIobmFtZSkge1xuICAgICAgICBkZWxldGUgdGhpcy5yZXFba1Jlc3BvbnNlSGVhZGVyc11bbmFtZV07XG4gICAgfVxuICAgIHdyaXRlKCkgeyB9XG4gICAgd3JpdGVIZWFkKCkgeyB9XG4gICAgZW5kKCkge1xuICAgICAgICAvLyB3ZSBjb3VsZCByZXR1cm4gYSBwcm9wZXIgZXJyb3IgY29kZSwgYnV0IHRoZSBXZWJTb2NrZXQgY2xpZW50IHdpbGwgZW1pdCBhbiBcImVycm9yXCIgZXZlbnQgYW55d2F5LlxuICAgICAgICB0aGlzLnNvY2tldC5kZXN0cm95KCk7XG4gICAgfVxufVxuLyoqXG4gKiBBbiBFbmdpbmUuSU8gc2VydmVyIGJhc2VkIG9uIE5vZGUuanMgYnVpbHQtaW4gSFRUUCBzZXJ2ZXIgYW5kIHRoZSBgd3NgIHBhY2thZ2UgZm9yIFdlYlNvY2tldCBjb25uZWN0aW9ucy5cbiAqL1xuY2xhc3MgU2VydmVyIGV4dGVuZHMgQmFzZVNlcnZlciB7XG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZSB3ZWJzb2NrZXQgc2VydmVyXG4gICAgICpcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgaW5pdCgpIHtcbiAgICAgICAgaWYgKCF+dGhpcy5vcHRzLnRyYW5zcG9ydHMuaW5kZXhPZihcIndlYnNvY2tldFwiKSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKHRoaXMud3MpXG4gICAgICAgICAgICB0aGlzLndzLmNsb3NlKCk7XG4gICAgICAgIHRoaXMud3MgPSBuZXcgdGhpcy5vcHRzLndzRW5naW5lKHtcbiAgICAgICAgICAgIG5vU2VydmVyOiB0cnVlLFxuICAgICAgICAgICAgY2xpZW50VHJhY2tpbmc6IGZhbHNlLFxuICAgICAgICAgICAgcGVyTWVzc2FnZURlZmxhdGU6IHRoaXMub3B0cy5wZXJNZXNzYWdlRGVmbGF0ZSxcbiAgICAgICAgICAgIG1heFBheWxvYWQ6IHRoaXMub3B0cy5tYXhIdHRwQnVmZmVyU2l6ZSxcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy53cy5vbiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICB0aGlzLndzLm9uKFwiaGVhZGVyc1wiLCAoaGVhZGVyc0FycmF5LCByZXEpID0+IHtcbiAgICAgICAgICAgICAgICAvLyBub3RlOiAnd3MnIHVzZXMgYW4gYXJyYXkgb2YgaGVhZGVycywgd2hpbGUgRW5naW5lLklPIHVzZXMgYW4gb2JqZWN0IChyZXNwb25zZS53cml0ZUhlYWQoKSBhY2NlcHRzIGJvdGggZm9ybWF0cylcbiAgICAgICAgICAgICAgICAvLyB3ZSBjb3VsZCBhbHNvIHRyeSB0byBwYXJzZSB0aGUgYXJyYXkgYW5kIHRoZW4gc3luYyB0aGUgdmFsdWVzLCBidXQgdGhhdCB3aWxsIGJlIGVycm9yLXByb25lXG4gICAgICAgICAgICAgICAgY29uc3QgYWRkaXRpb25hbEhlYWRlcnMgPSByZXFba1Jlc3BvbnNlSGVhZGVyc10gfHwge307XG4gICAgICAgICAgICAgICAgZGVsZXRlIHJlcVtrUmVzcG9uc2VIZWFkZXJzXTtcbiAgICAgICAgICAgICAgICBjb25zdCBpc0luaXRpYWxSZXF1ZXN0ID0gIXJlcS5fcXVlcnkuc2lkO1xuICAgICAgICAgICAgICAgIGlmIChpc0luaXRpYWxSZXF1ZXN0KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcImluaXRpYWxfaGVhZGVyc1wiLCBhZGRpdGlvbmFsSGVhZGVycywgcmVxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwiaGVhZGVyc1wiLCBhZGRpdGlvbmFsSGVhZGVycywgcmVxKTtcbiAgICAgICAgICAgICAgICBkZWJ1ZyhcIndyaXRpbmcgaGVhZGVyczogJWpcIiwgYWRkaXRpb25hbEhlYWRlcnMpO1xuICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKGFkZGl0aW9uYWxIZWFkZXJzKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyc0FycmF5LnB1c2goYCR7a2V5fTogJHthZGRpdGlvbmFsSGVhZGVyc1trZXldfWApO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2xlYW51cCgpIHtcbiAgICAgICAgaWYgKHRoaXMud3MpIHtcbiAgICAgICAgICAgIGRlYnVnKFwiY2xvc2luZyB3ZWJTb2NrZXRTZXJ2ZXJcIik7XG4gICAgICAgICAgICB0aGlzLndzLmNsb3NlKCk7XG4gICAgICAgICAgICAvLyBkb24ndCBkZWxldGUgdGhpcy53cyBiZWNhdXNlIGl0IGNhbiBiZSB1c2VkIGFnYWluIGlmIHRoZSBodHRwIHNlcnZlciBzdGFydHMgbGlzdGVuaW5nIGFnYWluXG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUHJlcGFyZXMgYSByZXF1ZXN0IGJ5IHByb2Nlc3NpbmcgdGhlIHF1ZXJ5IHN0cmluZy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgcHJlcGFyZShyZXEpIHtcbiAgICAgICAgLy8gdHJ5IHRvIGxldmVyYWdlIHByZS1leGlzdGluZyBgcmVxLl9xdWVyeWAgKGUuZzogZnJvbSBjb25uZWN0KVxuICAgICAgICBpZiAoIXJlcS5fcXVlcnkpIHtcbiAgICAgICAgICAgIHJlcS5fcXVlcnkgPSAofnJlcS51cmwuaW5kZXhPZihcIj9cIikgPyBxcy5wYXJzZSgoMCwgdXJsXzEucGFyc2UpKHJlcS51cmwpLnF1ZXJ5KSA6IHt9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjcmVhdGVUcmFuc3BvcnQodHJhbnNwb3J0TmFtZSwgcmVxKSB7XG4gICAgICAgIHJldHVybiBuZXcgdHJhbnNwb3J0c18xLmRlZmF1bHRbdHJhbnNwb3J0TmFtZV0ocmVxKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSGFuZGxlcyBhbiBFbmdpbmUuSU8gSFRUUCByZXF1ZXN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtFbmdpbmVSZXF1ZXN0fSByZXFcbiAgICAgKiBAcGFyYW0ge1NlcnZlclJlc3BvbnNlfSByZXNcbiAgICAgKi9cbiAgICBoYW5kbGVSZXF1ZXN0KHJlcSwgcmVzKSB7XG4gICAgICAgIGRlYnVnKCdoYW5kbGluZyBcIiVzXCIgaHR0cCByZXF1ZXN0IFwiJXNcIicsIHJlcS5tZXRob2QsIHJlcS51cmwpO1xuICAgICAgICB0aGlzLnByZXBhcmUocmVxKTtcbiAgICAgICAgcmVxLnJlcyA9IHJlcztcbiAgICAgICAgY29uc3QgY2FsbGJhY2sgPSAoZXJyb3JDb2RlLCBlcnJvckNvbnRleHQpID0+IHtcbiAgICAgICAgICAgIGlmIChlcnJvckNvZGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcImNvbm5lY3Rpb25fZXJyb3JcIiwge1xuICAgICAgICAgICAgICAgICAgICByZXEsXG4gICAgICAgICAgICAgICAgICAgIGNvZGU6IGVycm9yQ29kZSxcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogU2VydmVyLmVycm9yTWVzc2FnZXNbZXJyb3JDb2RlXSxcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dDogZXJyb3JDb250ZXh0LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGFib3J0UmVxdWVzdChyZXMsIGVycm9yQ29kZSwgZXJyb3JDb250ZXh0KTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVxLl9xdWVyeS5zaWQpIHtcbiAgICAgICAgICAgICAgICBkZWJ1ZyhcInNldHRpbmcgbmV3IHJlcXVlc3QgZm9yIGV4aXN0aW5nIGNsaWVudFwiKTtcbiAgICAgICAgICAgICAgICB0aGlzLmNsaWVudHNbcmVxLl9xdWVyeS5zaWRdLnRyYW5zcG9ydC5vblJlcXVlc3QocmVxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNsb3NlQ29ubmVjdGlvbiA9IChlcnJvckNvZGUsIGVycm9yQ29udGV4dCkgPT4gYWJvcnRSZXF1ZXN0KHJlcywgZXJyb3JDb2RlLCBlcnJvckNvbnRleHQpO1xuICAgICAgICAgICAgICAgIHRoaXMuaGFuZHNoYWtlKHJlcS5fcXVlcnkudHJhbnNwb3J0LCByZXEsIGNsb3NlQ29ubmVjdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX2FwcGx5TWlkZGxld2FyZXMocmVxLCByZXMsIChlcnIpID0+IHtcbiAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhTZXJ2ZXIuZXJyb3JzLkJBRF9SRVFVRVNULCB7IG5hbWU6IFwiTUlERExFV0FSRV9GQUlMVVJFXCIgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnZlcmlmeShyZXEsIGZhbHNlLCBjYWxsYmFjayk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBIYW5kbGVzIGFuIEVuZ2luZS5JTyBIVFRQIFVwZ3JhZGUuXG4gICAgICovXG4gICAgaGFuZGxlVXBncmFkZShyZXEsIHNvY2tldCwgdXBncmFkZUhlYWQpIHtcbiAgICAgICAgdGhpcy5wcmVwYXJlKHJlcSk7XG4gICAgICAgIGNvbnN0IHJlcyA9IG5ldyBXZWJTb2NrZXRSZXNwb25zZShyZXEsIHNvY2tldCk7XG4gICAgICAgIGNvbnN0IGNhbGxiYWNrID0gKGVycm9yQ29kZSwgZXJyb3JDb250ZXh0KSA9PiB7XG4gICAgICAgICAgICBpZiAoZXJyb3JDb2RlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJjb25uZWN0aW9uX2Vycm9yXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgcmVxLFxuICAgICAgICAgICAgICAgICAgICBjb2RlOiBlcnJvckNvZGUsXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IFNlcnZlci5lcnJvck1lc3NhZ2VzW2Vycm9yQ29kZV0sXG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQ6IGVycm9yQ29udGV4dCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBhYm9ydFVwZ3JhZGUoc29ja2V0LCBlcnJvckNvZGUsIGVycm9yQ29udGV4dCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgaGVhZCA9IEJ1ZmZlci5mcm9tKHVwZ3JhZGVIZWFkKTtcbiAgICAgICAgICAgIHVwZ3JhZGVIZWFkID0gbnVsbDtcbiAgICAgICAgICAgIC8vIHNvbWUgbWlkZGxld2FyZXMgKGxpa2UgZXhwcmVzcy1zZXNzaW9uKSB3YWl0IGZvciB0aGUgd3JpdGVIZWFkKCkgY2FsbCB0byBmbHVzaCB0aGVpciBoZWFkZXJzXG4gICAgICAgICAgICAvLyBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2V4cHJlc3Nqcy9zZXNzaW9uL2Jsb2IvMTAxMGZhZGMyZjA3MWRkZjJhZGQ5NDIzNWQ3MjIyNGNmNjUxNTljNi9pbmRleC5qcyNMMjIwLUwyNDRcbiAgICAgICAgICAgIHJlcy53cml0ZUhlYWQoKTtcbiAgICAgICAgICAgIC8vIGRlbGVnYXRlIHRvIHdzXG4gICAgICAgICAgICB0aGlzLndzLmhhbmRsZVVwZ3JhZGUocmVxLCBzb2NrZXQsIGhlYWQsICh3ZWJzb2NrZXQpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLm9uV2ViU29ja2V0KHJlcSwgc29ja2V0LCB3ZWJzb2NrZXQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX2FwcGx5TWlkZGxld2FyZXMocmVxLCByZXMsIChlcnIpID0+IHtcbiAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhTZXJ2ZXIuZXJyb3JzLkJBRF9SRVFVRVNULCB7IG5hbWU6IFwiTUlERExFV0FSRV9GQUlMVVJFXCIgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnZlcmlmeShyZXEsIHRydWUsIGNhbGxiYWNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGxlZCB1cG9uIGEgd3MuaW8gY29ubmVjdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7d3MuU29ja2V0fSB3ZWJzb2NrZXRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIG9uV2ViU29ja2V0KHJlcSwgc29ja2V0LCB3ZWJzb2NrZXQpIHtcbiAgICAgICAgd2Vic29ja2V0Lm9uKFwiZXJyb3JcIiwgb25VcGdyYWRlRXJyb3IpO1xuICAgICAgICBpZiAodHJhbnNwb3J0c18xLmRlZmF1bHRbcmVxLl9xdWVyeS50cmFuc3BvcnRdICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgICF0cmFuc3BvcnRzXzEuZGVmYXVsdFtyZXEuX3F1ZXJ5LnRyYW5zcG9ydF0ucHJvdG90eXBlLmhhbmRsZXNVcGdyYWRlcykge1xuICAgICAgICAgICAgZGVidWcoXCJ0cmFuc3BvcnQgZG9lc250IGhhbmRsZSB1cGdyYWRlZCByZXF1ZXN0c1wiKTtcbiAgICAgICAgICAgIHdlYnNvY2tldC5jbG9zZSgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIGdldCBjbGllbnQgaWRcbiAgICAgICAgY29uc3QgaWQgPSByZXEuX3F1ZXJ5LnNpZDtcbiAgICAgICAgLy8ga2VlcCBhIHJlZmVyZW5jZSB0byB0aGUgd3MuU29ja2V0XG4gICAgICAgIHJlcS53ZWJzb2NrZXQgPSB3ZWJzb2NrZXQ7XG4gICAgICAgIGlmIChpZCkge1xuICAgICAgICAgICAgY29uc3QgY2xpZW50ID0gdGhpcy5jbGllbnRzW2lkXTtcbiAgICAgICAgICAgIGlmICghY2xpZW50KSB7XG4gICAgICAgICAgICAgICAgZGVidWcoXCJ1cGdyYWRlIGF0dGVtcHQgZm9yIGNsb3NlZCBjbGllbnRcIik7XG4gICAgICAgICAgICAgICAgd2Vic29ja2V0LmNsb3NlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjbGllbnQudXBncmFkaW5nKSB7XG4gICAgICAgICAgICAgICAgZGVidWcoXCJ0cmFuc3BvcnQgaGFzIGFscmVhZHkgYmVlbiB0cnlpbmcgdG8gdXBncmFkZVwiKTtcbiAgICAgICAgICAgICAgICB3ZWJzb2NrZXQuY2xvc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNsaWVudC51cGdyYWRlZCkge1xuICAgICAgICAgICAgICAgIGRlYnVnKFwidHJhbnNwb3J0IGhhZCBhbHJlYWR5IGJlZW4gdXBncmFkZWRcIik7XG4gICAgICAgICAgICAgICAgd2Vic29ja2V0LmNsb3NlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBkZWJ1ZyhcInVwZ3JhZGluZyBleGlzdGluZyB0cmFuc3BvcnRcIik7XG4gICAgICAgICAgICAgICAgLy8gdHJhbnNwb3J0IGVycm9yIGhhbmRsaW5nIHRha2VzIG92ZXJcbiAgICAgICAgICAgICAgICB3ZWJzb2NrZXQucmVtb3ZlTGlzdGVuZXIoXCJlcnJvclwiLCBvblVwZ3JhZGVFcnJvcik7XG4gICAgICAgICAgICAgICAgY29uc3QgdHJhbnNwb3J0ID0gdGhpcy5jcmVhdGVUcmFuc3BvcnQocmVxLl9xdWVyeS50cmFuc3BvcnQsIHJlcSk7XG4gICAgICAgICAgICAgICAgdHJhbnNwb3J0LnBlck1lc3NhZ2VEZWZsYXRlID0gdGhpcy5vcHRzLnBlck1lc3NhZ2VEZWZsYXRlO1xuICAgICAgICAgICAgICAgIGNsaWVudC5fbWF5YmVVcGdyYWRlKHRyYW5zcG9ydCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBjbG9zZUNvbm5lY3Rpb24gPSAoZXJyb3JDb2RlLCBlcnJvckNvbnRleHQpID0+IGFib3J0VXBncmFkZShzb2NrZXQsIGVycm9yQ29kZSwgZXJyb3JDb250ZXh0KTtcbiAgICAgICAgICAgIHRoaXMuaGFuZHNoYWtlKHJlcS5fcXVlcnkudHJhbnNwb3J0LCByZXEsIGNsb3NlQ29ubmVjdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gb25VcGdyYWRlRXJyb3IoKSB7XG4gICAgICAgICAgICBkZWJ1ZyhcIndlYnNvY2tldCBlcnJvciBiZWZvcmUgdXBncmFkZVwiKTtcbiAgICAgICAgICAgIC8vIHdlYnNvY2tldC5jbG9zZSgpIG5vdCBuZWVkZWRcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYXB0dXJlcyB1cGdyYWRlIHJlcXVlc3RzIGZvciBhIGh0dHAuU2VydmVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtodHRwLlNlcnZlcn0gc2VydmVyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICAgKi9cbiAgICBhdHRhY2goc2VydmVyLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgY29uc3QgcGF0aCA9IHRoaXMuX2NvbXB1dGVQYXRoKG9wdGlvbnMpO1xuICAgICAgICBjb25zdCBkZXN0cm95VXBncmFkZVRpbWVvdXQgPSBvcHRpb25zLmRlc3Ryb3lVcGdyYWRlVGltZW91dCB8fCAxMDAwO1xuICAgICAgICBmdW5jdGlvbiBjaGVjayhyZXEpIHtcbiAgICAgICAgICAgIC8vIFRPRE8gdXNlIGBwYXRoID09PSBuZXcgVVJMKC4uLikucGF0aG5hbWVgIGluIHRoZSBuZXh0IG1ham9yIHJlbGVhc2UgKHJlZjogaHR0cHM6Ly9ub2RlanMub3JnL2FwaS91cmwuaHRtbClcbiAgICAgICAgICAgIHJldHVybiBwYXRoID09PSByZXEudXJsLnNsaWNlKDAsIHBhdGgubGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBjYWNoZSBhbmQgY2xlYW4gdXAgbGlzdGVuZXJzXG4gICAgICAgIGNvbnN0IGxpc3RlbmVycyA9IHNlcnZlci5saXN0ZW5lcnMoXCJyZXF1ZXN0XCIpLnNsaWNlKDApO1xuICAgICAgICBzZXJ2ZXIucmVtb3ZlQWxsTGlzdGVuZXJzKFwicmVxdWVzdFwiKTtcbiAgICAgICAgc2VydmVyLm9uKFwiY2xvc2VcIiwgdGhpcy5jbG9zZS5iaW5kKHRoaXMpKTtcbiAgICAgICAgc2VydmVyLm9uKFwibGlzdGVuaW5nXCIsIHRoaXMuaW5pdC5iaW5kKHRoaXMpKTtcbiAgICAgICAgLy8gYWRkIHJlcXVlc3QgaGFuZGxlclxuICAgICAgICBzZXJ2ZXIub24oXCJyZXF1ZXN0XCIsIChyZXEsIHJlcykgPT4ge1xuICAgICAgICAgICAgaWYgKGNoZWNrKHJlcSkpIHtcbiAgICAgICAgICAgICAgICBkZWJ1ZygnaW50ZXJjZXB0aW5nIHJlcXVlc3QgZm9yIHBhdGggXCIlc1wiJywgcGF0aCk7XG4gICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVSZXF1ZXN0KHJlcSwgcmVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgICAgICAgICBjb25zdCBsID0gbGlzdGVuZXJzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBmb3IgKDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lcnNbaV0uY2FsbChzZXJ2ZXIsIHJlcSwgcmVzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAofnRoaXMub3B0cy50cmFuc3BvcnRzLmluZGV4T2YoXCJ3ZWJzb2NrZXRcIikpIHtcbiAgICAgICAgICAgIHNlcnZlci5vbihcInVwZ3JhZGVcIiwgKHJlcSwgc29ja2V0LCBoZWFkKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGNoZWNrKHJlcSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVVcGdyYWRlKHJlcSwgc29ja2V0LCBoZWFkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoZmFsc2UgIT09IG9wdGlvbnMuZGVzdHJveVVwZ3JhZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZGVmYXVsdCBub2RlIGJlaGF2aW9yIGlzIHRvIGRpc2Nvbm5lY3Qgd2hlbiBubyBoYW5kbGVyc1xuICAgICAgICAgICAgICAgICAgICAvLyBidXQgYnkgYWRkaW5nIGEgaGFuZGxlciwgd2UgcHJldmVudCB0aGF0XG4gICAgICAgICAgICAgICAgICAgIC8vIGFuZCBpZiBubyBlaW8gdGhpbmcgaGFuZGxlcyB0aGUgdXBncmFkZVxuICAgICAgICAgICAgICAgICAgICAvLyB0aGVuIHRoZSBzb2NrZXQgbmVlZHMgdG8gZGllIVxuICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzb2NrZXQud3JpdGFibGUgJiYgc29ja2V0LmJ5dGVzV3JpdHRlbiA8PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc29ja2V0Lm9uKFwiZXJyb3JcIiwgKGUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVidWcoXCJlcnJvciB3aGlsZSBkZXN0cm95aW5nIHVwZ3JhZGU6ICVzXCIsIGUubWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNvY2tldC5lbmQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSwgZGVzdHJveVVwZ3JhZGVUaW1lb3V0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuU2VydmVyID0gU2VydmVyO1xuLyoqXG4gKiBDbG9zZSB0aGUgSFRUUCBsb25nLXBvbGxpbmcgcmVxdWVzdFxuICpcbiAqIEBwYXJhbSByZXMgLSB0aGUgcmVzcG9uc2Ugb2JqZWN0XG4gKiBAcGFyYW0gZXJyb3JDb2RlIC0gdGhlIGVycm9yIGNvZGVcbiAqIEBwYXJhbSBlcnJvckNvbnRleHQgLSBhZGRpdGlvbmFsIGVycm9yIGNvbnRleHRcbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBhYm9ydFJlcXVlc3QocmVzLCBlcnJvckNvZGUsIGVycm9yQ29udGV4dCkge1xuICAgIGNvbnN0IHN0YXR1c0NvZGUgPSBlcnJvckNvZGUgPT09IFNlcnZlci5lcnJvcnMuRk9SQklEREVOID8gNDAzIDogNDAwO1xuICAgIGNvbnN0IG1lc3NhZ2UgPSBlcnJvckNvbnRleHQgJiYgZXJyb3JDb250ZXh0Lm1lc3NhZ2VcbiAgICAgICAgPyBlcnJvckNvbnRleHQubWVzc2FnZVxuICAgICAgICA6IFNlcnZlci5lcnJvck1lc3NhZ2VzW2Vycm9yQ29kZV07XG4gICAgcmVzLndyaXRlSGVhZChzdGF0dXNDb2RlLCB7IFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiIH0pO1xuICAgIHJlcy5lbmQoSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICBjb2RlOiBlcnJvckNvZGUsXG4gICAgICAgIG1lc3NhZ2UsXG4gICAgfSkpO1xufVxuLyoqXG4gKiBDbG9zZSB0aGUgV2ViU29ja2V0IGNvbm5lY3Rpb25cbiAqXG4gKiBAcGFyYW0ge25ldC5Tb2NrZXR9IHNvY2tldFxuICogQHBhcmFtIHtzdHJpbmd9IGVycm9yQ29kZSAtIHRoZSBlcnJvciBjb2RlXG4gKiBAcGFyYW0ge29iamVjdH0gZXJyb3JDb250ZXh0IC0gYWRkaXRpb25hbCBlcnJvciBjb250ZXh0XG4gKi9cbmZ1bmN0aW9uIGFib3J0VXBncmFkZShzb2NrZXQsIGVycm9yQ29kZSwgZXJyb3JDb250ZXh0ID0ge30pIHtcbiAgICBzb2NrZXQub24oXCJlcnJvclwiLCAoKSA9PiB7XG4gICAgICAgIGRlYnVnKFwiaWdub3JpbmcgZXJyb3IgZnJvbSBjbG9zZWQgY29ubmVjdGlvblwiKTtcbiAgICB9KTtcbiAgICBpZiAoc29ja2V0LndyaXRhYmxlKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBlcnJvckNvbnRleHQubWVzc2FnZSB8fCBTZXJ2ZXIuZXJyb3JNZXNzYWdlc1tlcnJvckNvZGVdO1xuICAgICAgICBjb25zdCBsZW5ndGggPSBCdWZmZXIuYnl0ZUxlbmd0aChtZXNzYWdlKTtcbiAgICAgICAgc29ja2V0LndyaXRlKFwiSFRUUC8xLjEgNDAwIEJhZCBSZXF1ZXN0XFxyXFxuXCIgK1xuICAgICAgICAgICAgXCJDb25uZWN0aW9uOiBjbG9zZVxcclxcblwiICtcbiAgICAgICAgICAgIFwiQ29udGVudC10eXBlOiB0ZXh0L2h0bWxcXHJcXG5cIiArXG4gICAgICAgICAgICBcIkNvbnRlbnQtTGVuZ3RoOiBcIiArXG4gICAgICAgICAgICBsZW5ndGggK1xuICAgICAgICAgICAgXCJcXHJcXG5cIiArXG4gICAgICAgICAgICBcIlxcclxcblwiICtcbiAgICAgICAgICAgIG1lc3NhZ2UpO1xuICAgIH1cbiAgICBzb2NrZXQuZGVzdHJveSgpO1xufVxuLyogZXNsaW50LWRpc2FibGUgKi9cbi8qKlxuICogRnJvbSBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL25vZGUvYmxvYi92OC40LjAvbGliL19odHRwX2NvbW1vbi5qcyNMMzAzLUwzNTRcbiAqXG4gKiBUcnVlIGlmIHZhbCBjb250YWlucyBhbiBpbnZhbGlkIGZpZWxkLXZjaGFyXG4gKiAgZmllbGQtdmFsdWUgICAgPSAqKCBmaWVsZC1jb250ZW50IC8gb2JzLWZvbGQgKVxuICogIGZpZWxkLWNvbnRlbnQgID0gZmllbGQtdmNoYXIgWyAxKiggU1AgLyBIVEFCICkgZmllbGQtdmNoYXIgXVxuICogIGZpZWxkLXZjaGFyICAgID0gVkNIQVIgLyBvYnMtdGV4dFxuICpcbiAqIGNoZWNrSW52YWxpZEhlYWRlckNoYXIoKSBpcyBjdXJyZW50bHkgZGVzaWduZWQgdG8gYmUgaW5saW5hYmxlIGJ5IHY4LFxuICogc28gdGFrZSBjYXJlIHdoZW4gbWFraW5nIGNoYW5nZXMgdG8gdGhlIGltcGxlbWVudGF0aW9uIHNvIHRoYXQgdGhlIHNvdXJjZVxuICogY29kZSBzaXplIGRvZXMgbm90IGV4Y2VlZCB2OCdzIGRlZmF1bHQgbWF4X2lubGluZWRfc291cmNlX3NpemUgc2V0dGluZy5cbiAqKi9cbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgdmFsaWRIZHJDaGFycyA9IFtcbiAgICAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAxLCAwLCAwLCAwLCAwLCAwLCAwLCAvLyAwIC0gMTVcbiAgICAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAvLyAxNiAtIDMxXG4gICAgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgLy8gMzIgLSA0N1xuICAgIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIC8vIDQ4IC0gNjNcbiAgICAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAvLyA2NCAtIDc5XG4gICAgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgLy8gODAgLSA5NVxuICAgIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIC8vIDk2IC0gMTExXG4gICAgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMCwgLy8gMTEyIC0gMTI3XG4gICAgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgLy8gMTI4IC4uLlxuICAgIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsXG4gICAgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSxcbiAgICAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLFxuICAgIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsXG4gICAgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSxcbiAgICAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLFxuICAgIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEgLy8gLi4uIDI1NVxuXTtcbmZ1bmN0aW9uIGNoZWNrSW52YWxpZEhlYWRlckNoYXIodmFsKSB7XG4gICAgdmFsICs9IFwiXCI7XG4gICAgaWYgKHZhbC5sZW5ndGggPCAxKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgaWYgKCF2YWxpZEhkckNoYXJzW3ZhbC5jaGFyQ29kZUF0KDApXSkge1xuICAgICAgICBkZWJ1ZygnaW52YWxpZCBoZWFkZXIsIGluZGV4IDAsIGNoYXIgXCIlc1wiJywgdmFsLmNoYXJDb2RlQXQoMCkpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKHZhbC5sZW5ndGggPCAyKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgaWYgKCF2YWxpZEhkckNoYXJzW3ZhbC5jaGFyQ29kZUF0KDEpXSkge1xuICAgICAgICBkZWJ1ZygnaW52YWxpZCBoZWFkZXIsIGluZGV4IDEsIGNoYXIgXCIlc1wiJywgdmFsLmNoYXJDb2RlQXQoMSkpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKHZhbC5sZW5ndGggPCAzKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgaWYgKCF2YWxpZEhkckNoYXJzW3ZhbC5jaGFyQ29kZUF0KDIpXSkge1xuICAgICAgICBkZWJ1ZygnaW52YWxpZCBoZWFkZXIsIGluZGV4IDIsIGNoYXIgXCIlc1wiJywgdmFsLmNoYXJDb2RlQXQoMikpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKHZhbC5sZW5ndGggPCA0KVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgaWYgKCF2YWxpZEhkckNoYXJzW3ZhbC5jaGFyQ29kZUF0KDMpXSkge1xuICAgICAgICBkZWJ1ZygnaW52YWxpZCBoZWFkZXIsIGluZGV4IDMsIGNoYXIgXCIlc1wiJywgdmFsLmNoYXJDb2RlQXQoMykpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDQ7IGkgPCB2YWwubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgaWYgKCF2YWxpZEhkckNoYXJzW3ZhbC5jaGFyQ29kZUF0KGkpXSkge1xuICAgICAgICAgICAgZGVidWcoJ2ludmFsaWQgaGVhZGVyLCBpbmRleCBcIiVpXCIsIGNoYXIgXCIlc1wiJywgaSwgdmFsLmNoYXJDb2RlQXQoaSkpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiU2VydmVyIiwiQmFzZVNlcnZlciIsInFzIiwicmVxdWlyZSIsInVybF8xIiwiYmFzZTY0aWQiLCJ0cmFuc3BvcnRzXzEiLCJldmVudHNfMSIsInNvY2tldF8xIiwiZGVidWdfMSIsImNvb2tpZV8xIiwid3NfMSIsIndlYnRyYW5zcG9ydF8xIiwiZW5naW5lX2lvX3BhcnNlcl8xIiwiZGVidWciLCJkZWZhdWx0Iiwia1Jlc3BvbnNlSGVhZGVycyIsIlN5bWJvbCIsInBhcnNlU2Vzc2lvbklkIiwiZGF0YSIsInBhcnNlZCIsIkpTT04iLCJwYXJzZSIsInNpZCIsImUiLCJFdmVudEVtaXR0ZXIiLCJjb25zdHJ1Y3RvciIsIm9wdHMiLCJtaWRkbGV3YXJlcyIsImNsaWVudHMiLCJjbGllbnRzQ291bnQiLCJhc3NpZ24iLCJ3c0VuZ2luZSIsInBpbmdUaW1lb3V0IiwicGluZ0ludGVydmFsIiwidXBncmFkZVRpbWVvdXQiLCJtYXhIdHRwQnVmZmVyU2l6ZSIsInRyYW5zcG9ydHMiLCJhbGxvd1VwZ3JhZGVzIiwiaHR0cENvbXByZXNzaW9uIiwidGhyZXNob2xkIiwiY29ycyIsImFsbG93RUlPMyIsImNvb2tpZSIsIm5hbWUiLCJwYXRoIiwiaHR0cE9ubHkiLCJzYW1lU2l0ZSIsInVzZSIsInBlck1lc3NhZ2VEZWZsYXRlIiwiaW5pdCIsIl9jb21wdXRlUGF0aCIsIm9wdGlvbnMiLCJyZXBsYWNlIiwiYWRkVHJhaWxpbmdTbGFzaCIsInVwZ3JhZGVzIiwidHJhbnNwb3J0IiwidXBncmFkZXNUbyIsInZlcmlmeSIsInJlcSIsInVwZ3JhZGUiLCJmbiIsIl9xdWVyeSIsImluZGV4T2YiLCJlcnJvcnMiLCJVTktOT1dOX1RSQU5TUE9SVCIsImlzT3JpZ2luSW52YWxpZCIsImNoZWNrSW52YWxpZEhlYWRlckNoYXIiLCJoZWFkZXJzIiwib3JpZ2luIiwiQkFEX1JFUVVFU1QiLCJoYXNPd25Qcm9wZXJ0eSIsIlVOS05PV05fU0lEIiwicHJldmlvdXNUcmFuc3BvcnQiLCJtZXRob2QiLCJCQURfSEFORFNIQUtFX01FVEhPRCIsImFsbG93UmVxdWVzdCIsIm1lc3NhZ2UiLCJzdWNjZXNzIiwiRk9SQklEREVOIiwicHVzaCIsIl9hcHBseU1pZGRsZXdhcmVzIiwicmVzIiwiY2FsbGJhY2siLCJsZW5ndGgiLCJhcHBseSIsImkiLCJlcnIiLCJjbG9zZSIsImNsZWFudXAiLCJnZW5lcmF0ZUlkIiwiaGFuZHNoYWtlIiwidHJhbnNwb3J0TmFtZSIsImNsb3NlQ29ubmVjdGlvbiIsInByb3RvY29sIiwiRUlPIiwiZW1pdCIsImNvZGUiLCJVTlNVUFBPUlRFRF9QUk9UT0NPTF9WRVJTSU9OIiwiZXJyb3JNZXNzYWdlcyIsImNvbnRleHQiLCJpZCIsImVycm9yIiwiY3JlYXRlVHJhbnNwb3J0Iiwic29ja2V0IiwiU29ja2V0Iiwib24iLCJpc0luaXRpYWxSZXF1ZXN0Iiwic2VyaWFsaXplIiwib25SZXF1ZXN0Iiwib25jZSIsIm9uV2ViVHJhbnNwb3J0U2Vzc2lvbiIsInNlc3Npb24iLCJ0aW1lb3V0Iiwic2V0VGltZW91dCIsInN0cmVhbVJlYWRlciIsImluY29taW5nQmlkaXJlY3Rpb25hbFN0cmVhbXMiLCJnZXRSZWFkZXIiLCJyZXN1bHQiLCJyZWFkIiwiZG9uZSIsInN0cmVhbSIsInRyYW5zZm9ybVN0cmVhbSIsImNyZWF0ZVBhY2tldERlY29kZXJTdHJlYW0iLCJyZWFkZXIiLCJyZWFkYWJsZSIsInBpcGVUaHJvdWdoIiwiY2xlYXJUaW1lb3V0IiwidHlwZSIsInVuZGVmaW5lZCIsIldlYlRyYW5zcG9ydCIsImNsaWVudCIsInVwZ3JhZGluZyIsInVwZ3JhZGVkIiwiX21heWJlVXBncmFkZSIsIldlYlNvY2tldFJlc3BvbnNlIiwic2V0SGVhZGVyIiwiZ2V0SGVhZGVyIiwicmVtb3ZlSGVhZGVyIiwid3JpdGUiLCJ3cml0ZUhlYWQiLCJlbmQiLCJkZXN0cm95Iiwid3MiLCJub1NlcnZlciIsImNsaWVudFRyYWNraW5nIiwibWF4UGF5bG9hZCIsImhlYWRlcnNBcnJheSIsImFkZGl0aW9uYWxIZWFkZXJzIiwia2V5cyIsImZvckVhY2giLCJrZXkiLCJwcmVwYXJlIiwidXJsIiwicXVlcnkiLCJoYW5kbGVSZXF1ZXN0IiwiZXJyb3JDb2RlIiwiZXJyb3JDb250ZXh0IiwiYWJvcnRSZXF1ZXN0IiwiaGFuZGxlVXBncmFkZSIsInVwZ3JhZGVIZWFkIiwiYWJvcnRVcGdyYWRlIiwiaGVhZCIsIkJ1ZmZlciIsImZyb20iLCJ3ZWJzb2NrZXQiLCJvbldlYlNvY2tldCIsIm9uVXBncmFkZUVycm9yIiwicHJvdG90eXBlIiwiaGFuZGxlc1VwZ3JhZGVzIiwicmVtb3ZlTGlzdGVuZXIiLCJhdHRhY2giLCJzZXJ2ZXIiLCJkZXN0cm95VXBncmFkZVRpbWVvdXQiLCJjaGVjayIsInNsaWNlIiwibGlzdGVuZXJzIiwicmVtb3ZlQWxsTGlzdGVuZXJzIiwiYmluZCIsImwiLCJjYWxsIiwiZGVzdHJveVVwZ3JhZGUiLCJ3cml0YWJsZSIsImJ5dGVzV3JpdHRlbiIsInN0YXR1c0NvZGUiLCJzdHJpbmdpZnkiLCJieXRlTGVuZ3RoIiwidmFsaWRIZHJDaGFycyIsInZhbCIsImNoYXJDb2RlQXQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/engine.io/build/server.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/engine.io/build/socket.js":
/*!************************************************!*\
  !*** ./node_modules/engine.io/build/socket.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.Socket = void 0;\nconst events_1 = __webpack_require__(/*! events */ \"events\");\nconst debug_1 = __webpack_require__(/*! debug */ \"(rsc)/./node_modules/engine.io/node_modules/debug/src/index.js\");\nconst timers_1 = __webpack_require__(/*! timers */ \"timers\");\nconst debug = (0, debug_1.default)(\"engine:socket\");\nclass Socket extends events_1.EventEmitter {\n    get readyState() {\n        return this._readyState;\n    }\n    set readyState(state) {\n        debug(\"readyState updated from %s to %s\", this._readyState, state);\n        this._readyState = state;\n    }\n    constructor(id, server, transport, req, protocol){\n        super();\n        /**\n         * The current state of the socket.\n         */ this._readyState = \"opening\";\n        /* private */ this.upgrading = false;\n        /* private */ this.upgraded = false;\n        this.writeBuffer = [];\n        this.packetsFn = [];\n        this.sentCallbackFn = [];\n        this.cleanupFn = [];\n        this.id = id;\n        this.server = server;\n        this.request = req;\n        this.protocol = protocol;\n        // Cache IP since it might not be in the req later\n        if (req) {\n            if (req.websocket && req.websocket._socket) {\n                this.remoteAddress = req.websocket._socket.remoteAddress;\n            } else {\n                this.remoteAddress = req.connection.remoteAddress;\n            }\n        } else {\n        // TODO there is currently no way to get the IP address of the client when it connects with WebTransport\n        //  see https://github.com/fails-components/webtransport/issues/114\n        }\n        this.pingTimeoutTimer = null;\n        this.pingIntervalTimer = null;\n        this.setTransport(transport);\n        this.onOpen();\n    }\n    /**\n     * Called upon transport considered open.\n     *\n     * @private\n     */ onOpen() {\n        this.readyState = \"open\";\n        // sends an `open` packet\n        this.transport.sid = this.id;\n        this.sendPacket(\"open\", JSON.stringify({\n            sid: this.id,\n            upgrades: this.getAvailableUpgrades(),\n            pingInterval: this.server.opts.pingInterval,\n            pingTimeout: this.server.opts.pingTimeout,\n            maxPayload: this.server.opts.maxHttpBufferSize\n        }));\n        if (this.server.opts.initialPacket) {\n            this.sendPacket(\"message\", this.server.opts.initialPacket);\n        }\n        this.emit(\"open\");\n        if (this.protocol === 3) {\n            // in protocol v3, the client sends a ping, and the server answers with a pong\n            this.resetPingTimeout();\n        } else {\n            // in protocol v4, the server sends a ping, and the client answers with a pong\n            this.schedulePing();\n        }\n    }\n    /**\n     * Called upon transport packet.\n     *\n     * @param {Object} packet\n     * @private\n     */ onPacket(packet) {\n        if (\"open\" !== this.readyState) {\n            return debug(\"packet received with closed socket\");\n        }\n        // export packet event\n        debug(`received packet ${packet.type}`);\n        this.emit(\"packet\", packet);\n        switch(packet.type){\n            case \"ping\":\n                if (this.transport.protocol !== 3) {\n                    this.onError(new Error(\"invalid heartbeat direction\"));\n                    return;\n                }\n                debug(\"got ping\");\n                this.pingTimeoutTimer.refresh();\n                this.sendPacket(\"pong\");\n                this.emit(\"heartbeat\");\n                break;\n            case \"pong\":\n                if (this.transport.protocol === 3) {\n                    this.onError(new Error(\"invalid heartbeat direction\"));\n                    return;\n                }\n                debug(\"got pong\");\n                (0, timers_1.clearTimeout)(this.pingTimeoutTimer);\n                this.pingIntervalTimer.refresh();\n                this.emit(\"heartbeat\");\n                break;\n            case \"error\":\n                this.onClose(\"parse error\");\n                break;\n            case \"message\":\n                this.emit(\"data\", packet.data);\n                this.emit(\"message\", packet.data);\n                break;\n        }\n    }\n    /**\n     * Called upon transport error.\n     *\n     * @param {Error} err - error object\n     * @private\n     */ onError(err) {\n        debug(\"transport error\");\n        this.onClose(\"transport error\", err);\n    }\n    /**\n     * Pings client every `this.pingInterval` and expects response\n     * within `this.pingTimeout` or closes connection.\n     *\n     * @private\n     */ schedulePing() {\n        this.pingIntervalTimer = (0, timers_1.setTimeout)(()=>{\n            debug(\"writing ping packet - expecting pong within %sms\", this.server.opts.pingTimeout);\n            this.sendPacket(\"ping\");\n            this.resetPingTimeout();\n        }, this.server.opts.pingInterval);\n    }\n    /**\n     * Resets ping timeout.\n     *\n     * @private\n     */ resetPingTimeout() {\n        (0, timers_1.clearTimeout)(this.pingTimeoutTimer);\n        this.pingTimeoutTimer = (0, timers_1.setTimeout)(()=>{\n            if (this.readyState === \"closed\") return;\n            this.onClose(\"ping timeout\");\n        }, this.protocol === 3 ? this.server.opts.pingInterval + this.server.opts.pingTimeout : this.server.opts.pingTimeout);\n    }\n    /**\n     * Attaches handlers for the given transport.\n     *\n     * @param {Transport} transport\n     * @private\n     */ setTransport(transport) {\n        const onError = this.onError.bind(this);\n        const onReady = ()=>this.flush();\n        const onPacket = this.onPacket.bind(this);\n        const onDrain = this.onDrain.bind(this);\n        const onClose = this.onClose.bind(this, \"transport close\");\n        this.transport = transport;\n        this.transport.once(\"error\", onError);\n        this.transport.on(\"ready\", onReady);\n        this.transport.on(\"packet\", onPacket);\n        this.transport.on(\"drain\", onDrain);\n        this.transport.once(\"close\", onClose);\n        this.cleanupFn.push(function() {\n            transport.removeListener(\"error\", onError);\n            transport.removeListener(\"ready\", onReady);\n            transport.removeListener(\"packet\", onPacket);\n            transport.removeListener(\"drain\", onDrain);\n            transport.removeListener(\"close\", onClose);\n        });\n    }\n    /**\n     * Upon transport \"drain\" event\n     *\n     * @private\n     */ onDrain() {\n        if (this.sentCallbackFn.length > 0) {\n            debug(\"executing batch send callback\");\n            const seqFn = this.sentCallbackFn.shift();\n            if (seqFn) {\n                for(let i = 0; i < seqFn.length; i++){\n                    seqFn[i](this.transport);\n                }\n            }\n        }\n    }\n    /**\n     * Upgrades socket to the given transport\n     *\n     * @param {Transport} transport\n     * @private\n     */ /* private */ _maybeUpgrade(transport) {\n        debug('might upgrade socket transport from \"%s\" to \"%s\"', this.transport.name, transport.name);\n        this.upgrading = true;\n        // set transport upgrade timer\n        const upgradeTimeoutTimer = (0, timers_1.setTimeout)(()=>{\n            debug(\"client did not complete upgrade - closing transport\");\n            cleanup();\n            if (\"open\" === transport.readyState) {\n                transport.close();\n            }\n        }, this.server.opts.upgradeTimeout);\n        let checkIntervalTimer;\n        const onPacket = (packet)=>{\n            if (\"ping\" === packet.type && \"probe\" === packet.data) {\n                debug(\"got probe ping packet, sending pong\");\n                transport.send([\n                    {\n                        type: \"pong\",\n                        data: \"probe\"\n                    }\n                ]);\n                this.emit(\"upgrading\", transport);\n                clearInterval(checkIntervalTimer);\n                checkIntervalTimer = setInterval(check, 100);\n            } else if (\"upgrade\" === packet.type && this.readyState !== \"closed\") {\n                debug(\"got upgrade packet - upgrading\");\n                cleanup();\n                this.transport.discard();\n                this.upgraded = true;\n                this.clearTransport();\n                this.setTransport(transport);\n                this.emit(\"upgrade\", transport);\n                this.flush();\n                if (this.readyState === \"closing\") {\n                    transport.close(()=>{\n                        this.onClose(\"forced close\");\n                    });\n                }\n            } else {\n                cleanup();\n                transport.close();\n            }\n        };\n        // we force a polling cycle to ensure a fast upgrade\n        const check = ()=>{\n            if (\"polling\" === this.transport.name && this.transport.writable) {\n                debug(\"writing a noop packet to polling for fast upgrade\");\n                this.transport.send([\n                    {\n                        type: \"noop\"\n                    }\n                ]);\n            }\n        };\n        const cleanup = ()=>{\n            this.upgrading = false;\n            clearInterval(checkIntervalTimer);\n            (0, timers_1.clearTimeout)(upgradeTimeoutTimer);\n            transport.removeListener(\"packet\", onPacket);\n            transport.removeListener(\"close\", onTransportClose);\n            transport.removeListener(\"error\", onError);\n            this.removeListener(\"close\", onClose);\n        };\n        const onError = (err)=>{\n            debug(\"client did not complete upgrade - %s\", err);\n            cleanup();\n            transport.close();\n            transport = null;\n        };\n        const onTransportClose = ()=>{\n            onError(\"transport closed\");\n        };\n        const onClose = ()=>{\n            onError(\"socket closed\");\n        };\n        transport.on(\"packet\", onPacket);\n        transport.once(\"close\", onTransportClose);\n        transport.once(\"error\", onError);\n        this.once(\"close\", onClose);\n    }\n    /**\n     * Clears listeners and timers associated with current transport.\n     *\n     * @private\n     */ clearTransport() {\n        let cleanup;\n        const toCleanUp = this.cleanupFn.length;\n        for(let i = 0; i < toCleanUp; i++){\n            cleanup = this.cleanupFn.shift();\n            cleanup();\n        }\n        // silence further transport errors and prevent uncaught exceptions\n        this.transport.on(\"error\", function() {\n            debug(\"error triggered by discarded transport\");\n        });\n        // ensure transport won't stay open\n        this.transport.close();\n        (0, timers_1.clearTimeout)(this.pingTimeoutTimer);\n    }\n    /**\n     * Called upon transport considered closed.\n     * Possible reasons: `ping timeout`, `client error`, `parse error`,\n     * `transport error`, `server close`, `transport close`\n     */ onClose(reason, description) {\n        if (\"closed\" !== this.readyState) {\n            this.readyState = \"closed\";\n            // clear timers\n            (0, timers_1.clearTimeout)(this.pingIntervalTimer);\n            (0, timers_1.clearTimeout)(this.pingTimeoutTimer);\n            // clean writeBuffer in next tick, so developers can still\n            // grab the writeBuffer on 'close' event\n            process.nextTick(()=>{\n                this.writeBuffer = [];\n            });\n            this.packetsFn = [];\n            this.sentCallbackFn = [];\n            this.clearTransport();\n            this.emit(\"close\", reason, description);\n        }\n    }\n    /**\n     * Sends a message packet.\n     *\n     * @param {Object} data\n     * @param {Object} options\n     * @param {Function} callback\n     * @return {Socket} for chaining\n     */ send(data, options, callback) {\n        this.sendPacket(\"message\", data, options, callback);\n        return this;\n    }\n    /**\n     * Alias of {@link send}.\n     *\n     * @param data\n     * @param options\n     * @param callback\n     */ write(data, options, callback) {\n        this.sendPacket(\"message\", data, options, callback);\n        return this;\n    }\n    /**\n     * Sends a packet.\n     *\n     * @param {String} type - packet type\n     * @param {String} data\n     * @param {Object} options\n     * @param {Function} callback\n     *\n     * @private\n     */ sendPacket(type, data, options = {}, callback) {\n        if (\"function\" === typeof options) {\n            callback = options;\n            options = {};\n        }\n        if (\"closing\" !== this.readyState && \"closed\" !== this.readyState) {\n            debug('sending packet \"%s\" (%s)', type, data);\n            // compression is enabled by default\n            options.compress = options.compress !== false;\n            const packet = {\n                type,\n                options: options\n            };\n            if (data) packet.data = data;\n            // exports packetCreate event\n            this.emit(\"packetCreate\", packet);\n            this.writeBuffer.push(packet);\n            // add send callback to object, if defined\n            if (\"function\" === typeof callback) this.packetsFn.push(callback);\n            this.flush();\n        }\n    }\n    /**\n     * Attempts to flush the packets buffer.\n     *\n     * @private\n     */ flush() {\n        if (\"closed\" !== this.readyState && this.transport.writable && this.writeBuffer.length) {\n            debug(\"flushing buffer to transport\");\n            this.emit(\"flush\", this.writeBuffer);\n            this.server.emit(\"flush\", this, this.writeBuffer);\n            const wbuf = this.writeBuffer;\n            this.writeBuffer = [];\n            if (this.packetsFn.length) {\n                this.sentCallbackFn.push(this.packetsFn);\n                this.packetsFn = [];\n            } else {\n                this.sentCallbackFn.push(null);\n            }\n            this.transport.send(wbuf);\n            this.emit(\"drain\");\n            this.server.emit(\"drain\", this);\n        }\n    }\n    /**\n     * Get available upgrades for this socket.\n     *\n     * @private\n     */ getAvailableUpgrades() {\n        const availableUpgrades = [];\n        const allUpgrades = this.server.upgrades(this.transport.name);\n        for(let i = 0; i < allUpgrades.length; ++i){\n            const upg = allUpgrades[i];\n            if (this.server.opts.transports.indexOf(upg) !== -1) {\n                availableUpgrades.push(upg);\n            }\n        }\n        return availableUpgrades;\n    }\n    /**\n     * Closes the socket and underlying transport.\n     *\n     * @param {Boolean} discard - optional, discard the transport\n     * @return {Socket} for chaining\n     */ close(discard) {\n        if (discard && (this.readyState === \"open\" || this.readyState === \"closing\")) {\n            return this.closeTransport(discard);\n        }\n        if (\"open\" !== this.readyState) return;\n        this.readyState = \"closing\";\n        if (this.writeBuffer.length) {\n            debug(\"there are %d remaining packets in the buffer, waiting for the 'drain' event\", this.writeBuffer.length);\n            this.once(\"drain\", ()=>{\n                debug(\"all packets have been sent, closing the transport\");\n                this.closeTransport(discard);\n            });\n            return;\n        }\n        debug(\"the buffer is empty, closing the transport right away\");\n        this.closeTransport(discard);\n    }\n    /**\n     * Closes the underlying transport.\n     *\n     * @param {Boolean} discard\n     * @private\n     */ closeTransport(discard) {\n        debug(\"closing the transport (discard? %s)\", !!discard);\n        if (discard) this.transport.discard();\n        this.transport.close(this.onClose.bind(this, \"forced close\"));\n    }\n}\nexports.Socket = Socket;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZW5naW5lLmlvL2J1aWxkL3NvY2tldC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsY0FBYyxHQUFHLEtBQUs7QUFDdEIsTUFBTUcsV0FBV0MsbUJBQU9BLENBQUMsc0JBQVE7QUFDakMsTUFBTUMsVUFBVUQsbUJBQU9BLENBQUMsNkVBQU87QUFDL0IsTUFBTUUsV0FBV0YsbUJBQU9BLENBQUMsc0JBQVE7QUFDakMsTUFBTUcsUUFBUSxDQUFDLEdBQUdGLFFBQVFHLE9BQU8sRUFBRTtBQUNuQyxNQUFNTixlQUFlQyxTQUFTTSxZQUFZO0lBQ3RDLElBQUlDLGFBQWE7UUFDYixPQUFPLElBQUksQ0FBQ0MsV0FBVztJQUMzQjtJQUNBLElBQUlELFdBQVdFLEtBQUssRUFBRTtRQUNsQkwsTUFBTSxvQ0FBb0MsSUFBSSxDQUFDSSxXQUFXLEVBQUVDO1FBQzVELElBQUksQ0FBQ0QsV0FBVyxHQUFHQztJQUN2QjtJQUNBQyxZQUFZQyxFQUFFLEVBQUVDLE1BQU0sRUFBRUMsU0FBUyxFQUFFQyxHQUFHLEVBQUVDLFFBQVEsQ0FBRTtRQUM5QyxLQUFLO1FBQ0w7O1NBRUMsR0FDRCxJQUFJLENBQUNQLFdBQVcsR0FBRztRQUNuQixXQUFXLEdBQUcsSUFBSSxDQUFDUSxTQUFTLEdBQUc7UUFDL0IsV0FBVyxHQUFHLElBQUksQ0FBQ0MsUUFBUSxHQUFHO1FBQzlCLElBQUksQ0FBQ0MsV0FBVyxHQUFHLEVBQUU7UUFDckIsSUFBSSxDQUFDQyxTQUFTLEdBQUcsRUFBRTtRQUNuQixJQUFJLENBQUNDLGNBQWMsR0FBRyxFQUFFO1FBQ3hCLElBQUksQ0FBQ0MsU0FBUyxHQUFHLEVBQUU7UUFDbkIsSUFBSSxDQUFDVixFQUFFLEdBQUdBO1FBQ1YsSUFBSSxDQUFDQyxNQUFNLEdBQUdBO1FBQ2QsSUFBSSxDQUFDVSxPQUFPLEdBQUdSO1FBQ2YsSUFBSSxDQUFDQyxRQUFRLEdBQUdBO1FBQ2hCLGtEQUFrRDtRQUNsRCxJQUFJRCxLQUFLO1lBQ0wsSUFBSUEsSUFBSVMsU0FBUyxJQUFJVCxJQUFJUyxTQUFTLENBQUNDLE9BQU8sRUFBRTtnQkFDeEMsSUFBSSxDQUFDQyxhQUFhLEdBQUdYLElBQUlTLFNBQVMsQ0FBQ0MsT0FBTyxDQUFDQyxhQUFhO1lBQzVELE9BQ0s7Z0JBQ0QsSUFBSSxDQUFDQSxhQUFhLEdBQUdYLElBQUlZLFVBQVUsQ0FBQ0QsYUFBYTtZQUNyRDtRQUNKLE9BQ0s7UUFDRCx3R0FBd0c7UUFDeEcsbUVBQW1FO1FBQ3ZFO1FBQ0EsSUFBSSxDQUFDRSxnQkFBZ0IsR0FBRztRQUN4QixJQUFJLENBQUNDLGlCQUFpQixHQUFHO1FBQ3pCLElBQUksQ0FBQ0MsWUFBWSxDQUFDaEI7UUFDbEIsSUFBSSxDQUFDaUIsTUFBTTtJQUNmO0lBQ0E7Ozs7S0FJQyxHQUNEQSxTQUFTO1FBQ0wsSUFBSSxDQUFDdkIsVUFBVSxHQUFHO1FBQ2xCLHlCQUF5QjtRQUN6QixJQUFJLENBQUNNLFNBQVMsQ0FBQ2tCLEdBQUcsR0FBRyxJQUFJLENBQUNwQixFQUFFO1FBQzVCLElBQUksQ0FBQ3FCLFVBQVUsQ0FBQyxRQUFRQyxLQUFLQyxTQUFTLENBQUM7WUFDbkNILEtBQUssSUFBSSxDQUFDcEIsRUFBRTtZQUNad0IsVUFBVSxJQUFJLENBQUNDLG9CQUFvQjtZQUNuQ0MsY0FBYyxJQUFJLENBQUN6QixNQUFNLENBQUMwQixJQUFJLENBQUNELFlBQVk7WUFDM0NFLGFBQWEsSUFBSSxDQUFDM0IsTUFBTSxDQUFDMEIsSUFBSSxDQUFDQyxXQUFXO1lBQ3pDQyxZQUFZLElBQUksQ0FBQzVCLE1BQU0sQ0FBQzBCLElBQUksQ0FBQ0csaUJBQWlCO1FBQ2xEO1FBQ0EsSUFBSSxJQUFJLENBQUM3QixNQUFNLENBQUMwQixJQUFJLENBQUNJLGFBQWEsRUFBRTtZQUNoQyxJQUFJLENBQUNWLFVBQVUsQ0FBQyxXQUFXLElBQUksQ0FBQ3BCLE1BQU0sQ0FBQzBCLElBQUksQ0FBQ0ksYUFBYTtRQUM3RDtRQUNBLElBQUksQ0FBQ0MsSUFBSSxDQUFDO1FBQ1YsSUFBSSxJQUFJLENBQUM1QixRQUFRLEtBQUssR0FBRztZQUNyQiw4RUFBOEU7WUFDOUUsSUFBSSxDQUFDNkIsZ0JBQWdCO1FBQ3pCLE9BQ0s7WUFDRCw4RUFBOEU7WUFDOUUsSUFBSSxDQUFDQyxZQUFZO1FBQ3JCO0lBQ0o7SUFDQTs7Ozs7S0FLQyxHQUNEQyxTQUFTQyxNQUFNLEVBQUU7UUFDYixJQUFJLFdBQVcsSUFBSSxDQUFDeEMsVUFBVSxFQUFFO1lBQzVCLE9BQU9ILE1BQU07UUFDakI7UUFDQSxzQkFBc0I7UUFDdEJBLE1BQU0sQ0FBQyxnQkFBZ0IsRUFBRTJDLE9BQU9DLElBQUksQ0FBQyxDQUFDO1FBQ3RDLElBQUksQ0FBQ0wsSUFBSSxDQUFDLFVBQVVJO1FBQ3BCLE9BQVFBLE9BQU9DLElBQUk7WUFDZixLQUFLO2dCQUNELElBQUksSUFBSSxDQUFDbkMsU0FBUyxDQUFDRSxRQUFRLEtBQUssR0FBRztvQkFDL0IsSUFBSSxDQUFDa0MsT0FBTyxDQUFDLElBQUlDLE1BQU07b0JBQ3ZCO2dCQUNKO2dCQUNBOUMsTUFBTTtnQkFDTixJQUFJLENBQUN1QixnQkFBZ0IsQ0FBQ3dCLE9BQU87Z0JBQzdCLElBQUksQ0FBQ25CLFVBQVUsQ0FBQztnQkFDaEIsSUFBSSxDQUFDVyxJQUFJLENBQUM7Z0JBQ1Y7WUFDSixLQUFLO2dCQUNELElBQUksSUFBSSxDQUFDOUIsU0FBUyxDQUFDRSxRQUFRLEtBQUssR0FBRztvQkFDL0IsSUFBSSxDQUFDa0MsT0FBTyxDQUFDLElBQUlDLE1BQU07b0JBQ3ZCO2dCQUNKO2dCQUNBOUMsTUFBTTtnQkFDTCxJQUFHRCxTQUFTaUQsWUFBWSxFQUFFLElBQUksQ0FBQ3pCLGdCQUFnQjtnQkFDaEQsSUFBSSxDQUFDQyxpQkFBaUIsQ0FBQ3VCLE9BQU87Z0JBQzlCLElBQUksQ0FBQ1IsSUFBSSxDQUFDO2dCQUNWO1lBQ0osS0FBSztnQkFDRCxJQUFJLENBQUNVLE9BQU8sQ0FBQztnQkFDYjtZQUNKLEtBQUs7Z0JBQ0QsSUFBSSxDQUFDVixJQUFJLENBQUMsUUFBUUksT0FBT08sSUFBSTtnQkFDN0IsSUFBSSxDQUFDWCxJQUFJLENBQUMsV0FBV0ksT0FBT08sSUFBSTtnQkFDaEM7UUFDUjtJQUNKO0lBQ0E7Ozs7O0tBS0MsR0FDREwsUUFBUU0sR0FBRyxFQUFFO1FBQ1RuRCxNQUFNO1FBQ04sSUFBSSxDQUFDaUQsT0FBTyxDQUFDLG1CQUFtQkU7SUFDcEM7SUFDQTs7Ozs7S0FLQyxHQUNEVixlQUFlO1FBQ1gsSUFBSSxDQUFDakIsaUJBQWlCLEdBQUcsQ0FBQyxHQUFHekIsU0FBU3FELFVBQVUsRUFBRTtZQUM5Q3BELE1BQU0sb0RBQW9ELElBQUksQ0FBQ1EsTUFBTSxDQUFDMEIsSUFBSSxDQUFDQyxXQUFXO1lBQ3RGLElBQUksQ0FBQ1AsVUFBVSxDQUFDO1lBQ2hCLElBQUksQ0FBQ1ksZ0JBQWdCO1FBQ3pCLEdBQUcsSUFBSSxDQUFDaEMsTUFBTSxDQUFDMEIsSUFBSSxDQUFDRCxZQUFZO0lBQ3BDO0lBQ0E7Ozs7S0FJQyxHQUNETyxtQkFBbUI7UUFDZCxJQUFHekMsU0FBU2lELFlBQVksRUFBRSxJQUFJLENBQUN6QixnQkFBZ0I7UUFDaEQsSUFBSSxDQUFDQSxnQkFBZ0IsR0FBRyxDQUFDLEdBQUd4QixTQUFTcUQsVUFBVSxFQUFFO1lBQzdDLElBQUksSUFBSSxDQUFDakQsVUFBVSxLQUFLLFVBQ3BCO1lBQ0osSUFBSSxDQUFDOEMsT0FBTyxDQUFDO1FBQ2pCLEdBQUcsSUFBSSxDQUFDdEMsUUFBUSxLQUFLLElBQ2YsSUFBSSxDQUFDSCxNQUFNLENBQUMwQixJQUFJLENBQUNELFlBQVksR0FBRyxJQUFJLENBQUN6QixNQUFNLENBQUMwQixJQUFJLENBQUNDLFdBQVcsR0FDNUQsSUFBSSxDQUFDM0IsTUFBTSxDQUFDMEIsSUFBSSxDQUFDQyxXQUFXO0lBQ3RDO0lBQ0E7Ozs7O0tBS0MsR0FDRFYsYUFBYWhCLFNBQVMsRUFBRTtRQUNwQixNQUFNb0MsVUFBVSxJQUFJLENBQUNBLE9BQU8sQ0FBQ1EsSUFBSSxDQUFDLElBQUk7UUFDdEMsTUFBTUMsVUFBVSxJQUFNLElBQUksQ0FBQ0MsS0FBSztRQUNoQyxNQUFNYixXQUFXLElBQUksQ0FBQ0EsUUFBUSxDQUFDVyxJQUFJLENBQUMsSUFBSTtRQUN4QyxNQUFNRyxVQUFVLElBQUksQ0FBQ0EsT0FBTyxDQUFDSCxJQUFJLENBQUMsSUFBSTtRQUN0QyxNQUFNSixVQUFVLElBQUksQ0FBQ0EsT0FBTyxDQUFDSSxJQUFJLENBQUMsSUFBSSxFQUFFO1FBQ3hDLElBQUksQ0FBQzVDLFNBQVMsR0FBR0E7UUFDakIsSUFBSSxDQUFDQSxTQUFTLENBQUNnRCxJQUFJLENBQUMsU0FBU1o7UUFDN0IsSUFBSSxDQUFDcEMsU0FBUyxDQUFDaUQsRUFBRSxDQUFDLFNBQVNKO1FBQzNCLElBQUksQ0FBQzdDLFNBQVMsQ0FBQ2lELEVBQUUsQ0FBQyxVQUFVaEI7UUFDNUIsSUFBSSxDQUFDakMsU0FBUyxDQUFDaUQsRUFBRSxDQUFDLFNBQVNGO1FBQzNCLElBQUksQ0FBQy9DLFNBQVMsQ0FBQ2dELElBQUksQ0FBQyxTQUFTUjtRQUM3QixJQUFJLENBQUNoQyxTQUFTLENBQUMwQyxJQUFJLENBQUM7WUFDaEJsRCxVQUFVbUQsY0FBYyxDQUFDLFNBQVNmO1lBQ2xDcEMsVUFBVW1ELGNBQWMsQ0FBQyxTQUFTTjtZQUNsQzdDLFVBQVVtRCxjQUFjLENBQUMsVUFBVWxCO1lBQ25DakMsVUFBVW1ELGNBQWMsQ0FBQyxTQUFTSjtZQUNsQy9DLFVBQVVtRCxjQUFjLENBQUMsU0FBU1g7UUFDdEM7SUFDSjtJQUNBOzs7O0tBSUMsR0FDRE8sVUFBVTtRQUNOLElBQUksSUFBSSxDQUFDeEMsY0FBYyxDQUFDNkMsTUFBTSxHQUFHLEdBQUc7WUFDaEM3RCxNQUFNO1lBQ04sTUFBTThELFFBQVEsSUFBSSxDQUFDOUMsY0FBYyxDQUFDK0MsS0FBSztZQUN2QyxJQUFJRCxPQUFPO2dCQUNQLElBQUssSUFBSUUsSUFBSSxHQUFHQSxJQUFJRixNQUFNRCxNQUFNLEVBQUVHLElBQUs7b0JBQ25DRixLQUFLLENBQUNFLEVBQUUsQ0FBQyxJQUFJLENBQUN2RCxTQUFTO2dCQUMzQjtZQUNKO1FBQ0o7SUFDSjtJQUNBOzs7OztLQUtDLEdBQ0QsV0FBVyxHQUFHd0QsY0FBY3hELFNBQVMsRUFBRTtRQUNuQ1QsTUFBTSxvREFBb0QsSUFBSSxDQUFDUyxTQUFTLENBQUN5RCxJQUFJLEVBQUV6RCxVQUFVeUQsSUFBSTtRQUM3RixJQUFJLENBQUN0RCxTQUFTLEdBQUc7UUFDakIsOEJBQThCO1FBQzlCLE1BQU11RCxzQkFBc0IsQ0FBQyxHQUFHcEUsU0FBU3FELFVBQVUsRUFBRTtZQUNqRHBELE1BQU07WUFDTm9FO1lBQ0EsSUFBSSxXQUFXM0QsVUFBVU4sVUFBVSxFQUFFO2dCQUNqQ00sVUFBVTRELEtBQUs7WUFDbkI7UUFDSixHQUFHLElBQUksQ0FBQzdELE1BQU0sQ0FBQzBCLElBQUksQ0FBQ29DLGNBQWM7UUFDbEMsSUFBSUM7UUFDSixNQUFNN0IsV0FBVyxDQUFDQztZQUNkLElBQUksV0FBV0EsT0FBT0MsSUFBSSxJQUFJLFlBQVlELE9BQU9PLElBQUksRUFBRTtnQkFDbkRsRCxNQUFNO2dCQUNOUyxVQUFVK0QsSUFBSSxDQUFDO29CQUFDO3dCQUFFNUIsTUFBTTt3QkFBUU0sTUFBTTtvQkFBUTtpQkFBRTtnQkFDaEQsSUFBSSxDQUFDWCxJQUFJLENBQUMsYUFBYTlCO2dCQUN2QmdFLGNBQWNGO2dCQUNkQSxxQkFBcUJHLFlBQVlDLE9BQU87WUFDNUMsT0FDSyxJQUFJLGNBQWNoQyxPQUFPQyxJQUFJLElBQUksSUFBSSxDQUFDekMsVUFBVSxLQUFLLFVBQVU7Z0JBQ2hFSCxNQUFNO2dCQUNOb0U7Z0JBQ0EsSUFBSSxDQUFDM0QsU0FBUyxDQUFDbUUsT0FBTztnQkFDdEIsSUFBSSxDQUFDL0QsUUFBUSxHQUFHO2dCQUNoQixJQUFJLENBQUNnRSxjQUFjO2dCQUNuQixJQUFJLENBQUNwRCxZQUFZLENBQUNoQjtnQkFDbEIsSUFBSSxDQUFDOEIsSUFBSSxDQUFDLFdBQVc5QjtnQkFDckIsSUFBSSxDQUFDOEMsS0FBSztnQkFDVixJQUFJLElBQUksQ0FBQ3BELFVBQVUsS0FBSyxXQUFXO29CQUMvQk0sVUFBVTRELEtBQUssQ0FBQzt3QkFDWixJQUFJLENBQUNwQixPQUFPLENBQUM7b0JBQ2pCO2dCQUNKO1lBQ0osT0FDSztnQkFDRG1CO2dCQUNBM0QsVUFBVTRELEtBQUs7WUFDbkI7UUFDSjtRQUNBLG9EQUFvRDtRQUNwRCxNQUFNTSxRQUFRO1lBQ1YsSUFBSSxjQUFjLElBQUksQ0FBQ2xFLFNBQVMsQ0FBQ3lELElBQUksSUFBSSxJQUFJLENBQUN6RCxTQUFTLENBQUNxRSxRQUFRLEVBQUU7Z0JBQzlEOUUsTUFBTTtnQkFDTixJQUFJLENBQUNTLFNBQVMsQ0FBQytELElBQUksQ0FBQztvQkFBQzt3QkFBRTVCLE1BQU07b0JBQU87aUJBQUU7WUFDMUM7UUFDSjtRQUNBLE1BQU13QixVQUFVO1lBQ1osSUFBSSxDQUFDeEQsU0FBUyxHQUFHO1lBQ2pCNkQsY0FBY0Y7WUFDYixJQUFHeEUsU0FBU2lELFlBQVksRUFBRW1CO1lBQzNCMUQsVUFBVW1ELGNBQWMsQ0FBQyxVQUFVbEI7WUFDbkNqQyxVQUFVbUQsY0FBYyxDQUFDLFNBQVNtQjtZQUNsQ3RFLFVBQVVtRCxjQUFjLENBQUMsU0FBU2Y7WUFDbEMsSUFBSSxDQUFDZSxjQUFjLENBQUMsU0FBU1g7UUFDakM7UUFDQSxNQUFNSixVQUFVLENBQUNNO1lBQ2JuRCxNQUFNLHdDQUF3Q21EO1lBQzlDaUI7WUFDQTNELFVBQVU0RCxLQUFLO1lBQ2Y1RCxZQUFZO1FBQ2hCO1FBQ0EsTUFBTXNFLG1CQUFtQjtZQUNyQmxDLFFBQVE7UUFDWjtRQUNBLE1BQU1JLFVBQVU7WUFDWkosUUFBUTtRQUNaO1FBQ0FwQyxVQUFVaUQsRUFBRSxDQUFDLFVBQVVoQjtRQUN2QmpDLFVBQVVnRCxJQUFJLENBQUMsU0FBU3NCO1FBQ3hCdEUsVUFBVWdELElBQUksQ0FBQyxTQUFTWjtRQUN4QixJQUFJLENBQUNZLElBQUksQ0FBQyxTQUFTUjtJQUN2QjtJQUNBOzs7O0tBSUMsR0FDRDRCLGlCQUFpQjtRQUNiLElBQUlUO1FBQ0osTUFBTVksWUFBWSxJQUFJLENBQUMvRCxTQUFTLENBQUM0QyxNQUFNO1FBQ3ZDLElBQUssSUFBSUcsSUFBSSxHQUFHQSxJQUFJZ0IsV0FBV2hCLElBQUs7WUFDaENJLFVBQVUsSUFBSSxDQUFDbkQsU0FBUyxDQUFDOEMsS0FBSztZQUM5Qks7UUFDSjtRQUNBLG1FQUFtRTtRQUNuRSxJQUFJLENBQUMzRCxTQUFTLENBQUNpRCxFQUFFLENBQUMsU0FBUztZQUN2QjFELE1BQU07UUFDVjtRQUNBLG1DQUFtQztRQUNuQyxJQUFJLENBQUNTLFNBQVMsQ0FBQzRELEtBQUs7UUFDbkIsSUFBR3RFLFNBQVNpRCxZQUFZLEVBQUUsSUFBSSxDQUFDekIsZ0JBQWdCO0lBQ3BEO0lBQ0E7Ozs7S0FJQyxHQUNEMEIsUUFBUWdDLE1BQU0sRUFBRUMsV0FBVyxFQUFFO1FBQ3pCLElBQUksYUFBYSxJQUFJLENBQUMvRSxVQUFVLEVBQUU7WUFDOUIsSUFBSSxDQUFDQSxVQUFVLEdBQUc7WUFDbEIsZUFBZTtZQUNkLElBQUdKLFNBQVNpRCxZQUFZLEVBQUUsSUFBSSxDQUFDeEIsaUJBQWlCO1lBQ2hELElBQUd6QixTQUFTaUQsWUFBWSxFQUFFLElBQUksQ0FBQ3pCLGdCQUFnQjtZQUNoRCwwREFBMEQ7WUFDMUQsd0NBQXdDO1lBQ3hDNEQsUUFBUUMsUUFBUSxDQUFDO2dCQUNiLElBQUksQ0FBQ3RFLFdBQVcsR0FBRyxFQUFFO1lBQ3pCO1lBQ0EsSUFBSSxDQUFDQyxTQUFTLEdBQUcsRUFBRTtZQUNuQixJQUFJLENBQUNDLGNBQWMsR0FBRyxFQUFFO1lBQ3hCLElBQUksQ0FBQzZELGNBQWM7WUFDbkIsSUFBSSxDQUFDdEMsSUFBSSxDQUFDLFNBQVMwQyxRQUFRQztRQUMvQjtJQUNKO0lBQ0E7Ozs7Ozs7S0FPQyxHQUNEVixLQUFLdEIsSUFBSSxFQUFFbUMsT0FBTyxFQUFFQyxRQUFRLEVBQUU7UUFDMUIsSUFBSSxDQUFDMUQsVUFBVSxDQUFDLFdBQVdzQixNQUFNbUMsU0FBU0M7UUFDMUMsT0FBTyxJQUFJO0lBQ2Y7SUFDQTs7Ozs7O0tBTUMsR0FDREMsTUFBTXJDLElBQUksRUFBRW1DLE9BQU8sRUFBRUMsUUFBUSxFQUFFO1FBQzNCLElBQUksQ0FBQzFELFVBQVUsQ0FBQyxXQUFXc0IsTUFBTW1DLFNBQVNDO1FBQzFDLE9BQU8sSUFBSTtJQUNmO0lBQ0E7Ozs7Ozs7OztLQVNDLEdBQ0QxRCxXQUFXZ0IsSUFBSSxFQUFFTSxJQUFJLEVBQUVtQyxVQUFVLENBQUMsQ0FBQyxFQUFFQyxRQUFRLEVBQUU7UUFDM0MsSUFBSSxlQUFlLE9BQU9ELFNBQVM7WUFDL0JDLFdBQVdEO1lBQ1hBLFVBQVUsQ0FBQztRQUNmO1FBQ0EsSUFBSSxjQUFjLElBQUksQ0FBQ2xGLFVBQVUsSUFBSSxhQUFhLElBQUksQ0FBQ0EsVUFBVSxFQUFFO1lBQy9ESCxNQUFNLDRCQUE0QjRDLE1BQU1NO1lBQ3hDLG9DQUFvQztZQUNwQ21DLFFBQVFHLFFBQVEsR0FBR0gsUUFBUUcsUUFBUSxLQUFLO1lBQ3hDLE1BQU03QyxTQUFTO2dCQUNYQztnQkFDQXlDLFNBQVNBO1lBQ2I7WUFDQSxJQUFJbkMsTUFDQVAsT0FBT08sSUFBSSxHQUFHQTtZQUNsQiw2QkFBNkI7WUFDN0IsSUFBSSxDQUFDWCxJQUFJLENBQUMsZ0JBQWdCSTtZQUMxQixJQUFJLENBQUM3QixXQUFXLENBQUM2QyxJQUFJLENBQUNoQjtZQUN0QiwwQ0FBMEM7WUFDMUMsSUFBSSxlQUFlLE9BQU8yQyxVQUN0QixJQUFJLENBQUN2RSxTQUFTLENBQUM0QyxJQUFJLENBQUMyQjtZQUN4QixJQUFJLENBQUMvQixLQUFLO1FBQ2Q7SUFDSjtJQUNBOzs7O0tBSUMsR0FDREEsUUFBUTtRQUNKLElBQUksYUFBYSxJQUFJLENBQUNwRCxVQUFVLElBQzVCLElBQUksQ0FBQ00sU0FBUyxDQUFDcUUsUUFBUSxJQUN2QixJQUFJLENBQUNoRSxXQUFXLENBQUMrQyxNQUFNLEVBQUU7WUFDekI3RCxNQUFNO1lBQ04sSUFBSSxDQUFDdUMsSUFBSSxDQUFDLFNBQVMsSUFBSSxDQUFDekIsV0FBVztZQUNuQyxJQUFJLENBQUNOLE1BQU0sQ0FBQytCLElBQUksQ0FBQyxTQUFTLElBQUksRUFBRSxJQUFJLENBQUN6QixXQUFXO1lBQ2hELE1BQU0yRSxPQUFPLElBQUksQ0FBQzNFLFdBQVc7WUFDN0IsSUFBSSxDQUFDQSxXQUFXLEdBQUcsRUFBRTtZQUNyQixJQUFJLElBQUksQ0FBQ0MsU0FBUyxDQUFDOEMsTUFBTSxFQUFFO2dCQUN2QixJQUFJLENBQUM3QyxjQUFjLENBQUMyQyxJQUFJLENBQUMsSUFBSSxDQUFDNUMsU0FBUztnQkFDdkMsSUFBSSxDQUFDQSxTQUFTLEdBQUcsRUFBRTtZQUN2QixPQUNLO2dCQUNELElBQUksQ0FBQ0MsY0FBYyxDQUFDMkMsSUFBSSxDQUFDO1lBQzdCO1lBQ0EsSUFBSSxDQUFDbEQsU0FBUyxDQUFDK0QsSUFBSSxDQUFDaUI7WUFDcEIsSUFBSSxDQUFDbEQsSUFBSSxDQUFDO1lBQ1YsSUFBSSxDQUFDL0IsTUFBTSxDQUFDK0IsSUFBSSxDQUFDLFNBQVMsSUFBSTtRQUNsQztJQUNKO0lBQ0E7Ozs7S0FJQyxHQUNEUCx1QkFBdUI7UUFDbkIsTUFBTTBELG9CQUFvQixFQUFFO1FBQzVCLE1BQU1DLGNBQWMsSUFBSSxDQUFDbkYsTUFBTSxDQUFDdUIsUUFBUSxDQUFDLElBQUksQ0FBQ3RCLFNBQVMsQ0FBQ3lELElBQUk7UUFDNUQsSUFBSyxJQUFJRixJQUFJLEdBQUdBLElBQUkyQixZQUFZOUIsTUFBTSxFQUFFLEVBQUVHLEVBQUc7WUFDekMsTUFBTTRCLE1BQU1ELFdBQVcsQ0FBQzNCLEVBQUU7WUFDMUIsSUFBSSxJQUFJLENBQUN4RCxNQUFNLENBQUMwQixJQUFJLENBQUMyRCxVQUFVLENBQUNDLE9BQU8sQ0FBQ0YsU0FBUyxDQUFDLEdBQUc7Z0JBQ2pERixrQkFBa0IvQixJQUFJLENBQUNpQztZQUMzQjtRQUNKO1FBQ0EsT0FBT0Y7SUFDWDtJQUNBOzs7OztLQUtDLEdBQ0RyQixNQUFNTyxPQUFPLEVBQUU7UUFDWCxJQUFJQSxXQUNDLEtBQUksQ0FBQ3pFLFVBQVUsS0FBSyxVQUFVLElBQUksQ0FBQ0EsVUFBVSxLQUFLLFNBQVEsR0FBSTtZQUMvRCxPQUFPLElBQUksQ0FBQzRGLGNBQWMsQ0FBQ25CO1FBQy9CO1FBQ0EsSUFBSSxXQUFXLElBQUksQ0FBQ3pFLFVBQVUsRUFDMUI7UUFDSixJQUFJLENBQUNBLFVBQVUsR0FBRztRQUNsQixJQUFJLElBQUksQ0FBQ1csV0FBVyxDQUFDK0MsTUFBTSxFQUFFO1lBQ3pCN0QsTUFBTSwrRUFBK0UsSUFBSSxDQUFDYyxXQUFXLENBQUMrQyxNQUFNO1lBQzVHLElBQUksQ0FBQ0osSUFBSSxDQUFDLFNBQVM7Z0JBQ2Z6RCxNQUFNO2dCQUNOLElBQUksQ0FBQytGLGNBQWMsQ0FBQ25CO1lBQ3hCO1lBQ0E7UUFDSjtRQUNBNUUsTUFBTTtRQUNOLElBQUksQ0FBQytGLGNBQWMsQ0FBQ25CO0lBQ3hCO0lBQ0E7Ozs7O0tBS0MsR0FDRG1CLGVBQWVuQixPQUFPLEVBQUU7UUFDcEI1RSxNQUFNLHVDQUF1QyxDQUFDLENBQUM0RTtRQUMvQyxJQUFJQSxTQUNBLElBQUksQ0FBQ25FLFNBQVMsQ0FBQ21FLE9BQU87UUFDMUIsSUFBSSxDQUFDbkUsU0FBUyxDQUFDNEQsS0FBSyxDQUFDLElBQUksQ0FBQ3BCLE9BQU8sQ0FBQ0ksSUFBSSxDQUFDLElBQUksRUFBRTtJQUNqRDtBQUNKO0FBQ0E1RCxjQUFjLEdBQUdFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZXhhbXJvc2gvLi9ub2RlX21vZHVsZXMvZW5naW5lLmlvL2J1aWxkL3NvY2tldC5qcz9jNDY0Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Tb2NrZXQgPSB2b2lkIDA7XG5jb25zdCBldmVudHNfMSA9IHJlcXVpcmUoXCJldmVudHNcIik7XG5jb25zdCBkZWJ1Z18xID0gcmVxdWlyZShcImRlYnVnXCIpO1xuY29uc3QgdGltZXJzXzEgPSByZXF1aXJlKFwidGltZXJzXCIpO1xuY29uc3QgZGVidWcgPSAoMCwgZGVidWdfMS5kZWZhdWx0KShcImVuZ2luZTpzb2NrZXRcIik7XG5jbGFzcyBTb2NrZXQgZXh0ZW5kcyBldmVudHNfMS5FdmVudEVtaXR0ZXIge1xuICAgIGdldCByZWFkeVN0YXRlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcmVhZHlTdGF0ZTtcbiAgICB9XG4gICAgc2V0IHJlYWR5U3RhdGUoc3RhdGUpIHtcbiAgICAgICAgZGVidWcoXCJyZWFkeVN0YXRlIHVwZGF0ZWQgZnJvbSAlcyB0byAlc1wiLCB0aGlzLl9yZWFkeVN0YXRlLCBzdGF0ZSk7XG4gICAgICAgIHRoaXMuX3JlYWR5U3RhdGUgPSBzdGF0ZTtcbiAgICB9XG4gICAgY29uc3RydWN0b3IoaWQsIHNlcnZlciwgdHJhbnNwb3J0LCByZXEsIHByb3RvY29sKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgY3VycmVudCBzdGF0ZSBvZiB0aGUgc29ja2V0LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fcmVhZHlTdGF0ZSA9IFwib3BlbmluZ1wiO1xuICAgICAgICAvKiBwcml2YXRlICovIHRoaXMudXBncmFkaW5nID0gZmFsc2U7XG4gICAgICAgIC8qIHByaXZhdGUgKi8gdGhpcy51cGdyYWRlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLndyaXRlQnVmZmVyID0gW107XG4gICAgICAgIHRoaXMucGFja2V0c0ZuID0gW107XG4gICAgICAgIHRoaXMuc2VudENhbGxiYWNrRm4gPSBbXTtcbiAgICAgICAgdGhpcy5jbGVhbnVwRm4gPSBbXTtcbiAgICAgICAgdGhpcy5pZCA9IGlkO1xuICAgICAgICB0aGlzLnNlcnZlciA9IHNlcnZlcjtcbiAgICAgICAgdGhpcy5yZXF1ZXN0ID0gcmVxO1xuICAgICAgICB0aGlzLnByb3RvY29sID0gcHJvdG9jb2w7XG4gICAgICAgIC8vIENhY2hlIElQIHNpbmNlIGl0IG1pZ2h0IG5vdCBiZSBpbiB0aGUgcmVxIGxhdGVyXG4gICAgICAgIGlmIChyZXEpIHtcbiAgICAgICAgICAgIGlmIChyZXEud2Vic29ja2V0ICYmIHJlcS53ZWJzb2NrZXQuX3NvY2tldCkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVtb3RlQWRkcmVzcyA9IHJlcS53ZWJzb2NrZXQuX3NvY2tldC5yZW1vdGVBZGRyZXNzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW1vdGVBZGRyZXNzID0gcmVxLmNvbm5lY3Rpb24ucmVtb3RlQWRkcmVzcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIFRPRE8gdGhlcmUgaXMgY3VycmVudGx5IG5vIHdheSB0byBnZXQgdGhlIElQIGFkZHJlc3Mgb2YgdGhlIGNsaWVudCB3aGVuIGl0IGNvbm5lY3RzIHdpdGggV2ViVHJhbnNwb3J0XG4gICAgICAgICAgICAvLyAgc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWlscy1jb21wb25lbnRzL3dlYnRyYW5zcG9ydC9pc3N1ZXMvMTE0XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5waW5nVGltZW91dFRpbWVyID0gbnVsbDtcbiAgICAgICAgdGhpcy5waW5nSW50ZXJ2YWxUaW1lciA9IG51bGw7XG4gICAgICAgIHRoaXMuc2V0VHJhbnNwb3J0KHRyYW5zcG9ydCk7XG4gICAgICAgIHRoaXMub25PcGVuKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGxlZCB1cG9uIHRyYW5zcG9ydCBjb25zaWRlcmVkIG9wZW4uXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIG9uT3BlbigpIHtcbiAgICAgICAgdGhpcy5yZWFkeVN0YXRlID0gXCJvcGVuXCI7XG4gICAgICAgIC8vIHNlbmRzIGFuIGBvcGVuYCBwYWNrZXRcbiAgICAgICAgdGhpcy50cmFuc3BvcnQuc2lkID0gdGhpcy5pZDtcbiAgICAgICAgdGhpcy5zZW5kUGFja2V0KFwib3BlblwiLCBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICBzaWQ6IHRoaXMuaWQsXG4gICAgICAgICAgICB1cGdyYWRlczogdGhpcy5nZXRBdmFpbGFibGVVcGdyYWRlcygpLFxuICAgICAgICAgICAgcGluZ0ludGVydmFsOiB0aGlzLnNlcnZlci5vcHRzLnBpbmdJbnRlcnZhbCxcbiAgICAgICAgICAgIHBpbmdUaW1lb3V0OiB0aGlzLnNlcnZlci5vcHRzLnBpbmdUaW1lb3V0LFxuICAgICAgICAgICAgbWF4UGF5bG9hZDogdGhpcy5zZXJ2ZXIub3B0cy5tYXhIdHRwQnVmZmVyU2l6ZSxcbiAgICAgICAgfSkpO1xuICAgICAgICBpZiAodGhpcy5zZXJ2ZXIub3B0cy5pbml0aWFsUGFja2V0KSB7XG4gICAgICAgICAgICB0aGlzLnNlbmRQYWNrZXQoXCJtZXNzYWdlXCIsIHRoaXMuc2VydmVyLm9wdHMuaW5pdGlhbFBhY2tldCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lbWl0KFwib3BlblwiKTtcbiAgICAgICAgaWYgKHRoaXMucHJvdG9jb2wgPT09IDMpIHtcbiAgICAgICAgICAgIC8vIGluIHByb3RvY29sIHYzLCB0aGUgY2xpZW50IHNlbmRzIGEgcGluZywgYW5kIHRoZSBzZXJ2ZXIgYW5zd2VycyB3aXRoIGEgcG9uZ1xuICAgICAgICAgICAgdGhpcy5yZXNldFBpbmdUaW1lb3V0KCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBpbiBwcm90b2NvbCB2NCwgdGhlIHNlcnZlciBzZW5kcyBhIHBpbmcsIGFuZCB0aGUgY2xpZW50IGFuc3dlcnMgd2l0aCBhIHBvbmdcbiAgICAgICAgICAgIHRoaXMuc2NoZWR1bGVQaW5nKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHVwb24gdHJhbnNwb3J0IHBhY2tldC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwYWNrZXRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIG9uUGFja2V0KHBhY2tldCkge1xuICAgICAgICBpZiAoXCJvcGVuXCIgIT09IHRoaXMucmVhZHlTdGF0ZSkge1xuICAgICAgICAgICAgcmV0dXJuIGRlYnVnKFwicGFja2V0IHJlY2VpdmVkIHdpdGggY2xvc2VkIHNvY2tldFwiKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBleHBvcnQgcGFja2V0IGV2ZW50XG4gICAgICAgIGRlYnVnKGByZWNlaXZlZCBwYWNrZXQgJHtwYWNrZXQudHlwZX1gKTtcbiAgICAgICAgdGhpcy5lbWl0KFwicGFja2V0XCIsIHBhY2tldCk7XG4gICAgICAgIHN3aXRjaCAocGFja2V0LnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgXCJwaW5nXCI6XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMudHJhbnNwb3J0LnByb3RvY29sICE9PSAzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub25FcnJvcihuZXcgRXJyb3IoXCJpbnZhbGlkIGhlYXJ0YmVhdCBkaXJlY3Rpb25cIikpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRlYnVnKFwiZ290IHBpbmdcIik7XG4gICAgICAgICAgICAgICAgdGhpcy5waW5nVGltZW91dFRpbWVyLnJlZnJlc2goKTtcbiAgICAgICAgICAgICAgICB0aGlzLnNlbmRQYWNrZXQoXCJwb25nXCIpO1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcImhlYXJ0YmVhdFwiKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJwb25nXCI6XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMudHJhbnNwb3J0LnByb3RvY29sID09PSAzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub25FcnJvcihuZXcgRXJyb3IoXCJpbnZhbGlkIGhlYXJ0YmVhdCBkaXJlY3Rpb25cIikpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRlYnVnKFwiZ290IHBvbmdcIik7XG4gICAgICAgICAgICAgICAgKDAsIHRpbWVyc18xLmNsZWFyVGltZW91dCkodGhpcy5waW5nVGltZW91dFRpbWVyKTtcbiAgICAgICAgICAgICAgICB0aGlzLnBpbmdJbnRlcnZhbFRpbWVyLnJlZnJlc2goKTtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJoZWFydGJlYXRcIik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiZXJyb3JcIjpcbiAgICAgICAgICAgICAgICB0aGlzLm9uQ2xvc2UoXCJwYXJzZSBlcnJvclwiKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJtZXNzYWdlXCI6XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwiZGF0YVwiLCBwYWNrZXQuZGF0YSk7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwibWVzc2FnZVwiLCBwYWNrZXQuZGF0YSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHVwb24gdHJhbnNwb3J0IGVycm9yLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtFcnJvcn0gZXJyIC0gZXJyb3Igb2JqZWN0XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBvbkVycm9yKGVycikge1xuICAgICAgICBkZWJ1ZyhcInRyYW5zcG9ydCBlcnJvclwiKTtcbiAgICAgICAgdGhpcy5vbkNsb3NlKFwidHJhbnNwb3J0IGVycm9yXCIsIGVycik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBpbmdzIGNsaWVudCBldmVyeSBgdGhpcy5waW5nSW50ZXJ2YWxgIGFuZCBleHBlY3RzIHJlc3BvbnNlXG4gICAgICogd2l0aGluIGB0aGlzLnBpbmdUaW1lb3V0YCBvciBjbG9zZXMgY29ubmVjdGlvbi5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgc2NoZWR1bGVQaW5nKCkge1xuICAgICAgICB0aGlzLnBpbmdJbnRlcnZhbFRpbWVyID0gKDAsIHRpbWVyc18xLnNldFRpbWVvdXQpKCgpID0+IHtcbiAgICAgICAgICAgIGRlYnVnKFwid3JpdGluZyBwaW5nIHBhY2tldCAtIGV4cGVjdGluZyBwb25nIHdpdGhpbiAlc21zXCIsIHRoaXMuc2VydmVyLm9wdHMucGluZ1RpbWVvdXQpO1xuICAgICAgICAgICAgdGhpcy5zZW5kUGFja2V0KFwicGluZ1wiKTtcbiAgICAgICAgICAgIHRoaXMucmVzZXRQaW5nVGltZW91dCgpO1xuICAgICAgICB9LCB0aGlzLnNlcnZlci5vcHRzLnBpbmdJbnRlcnZhbCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlc2V0cyBwaW5nIHRpbWVvdXQuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHJlc2V0UGluZ1RpbWVvdXQoKSB7XG4gICAgICAgICgwLCB0aW1lcnNfMS5jbGVhclRpbWVvdXQpKHRoaXMucGluZ1RpbWVvdXRUaW1lcik7XG4gICAgICAgIHRoaXMucGluZ1RpbWVvdXRUaW1lciA9ICgwLCB0aW1lcnNfMS5zZXRUaW1lb3V0KSgoKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5yZWFkeVN0YXRlID09PSBcImNsb3NlZFwiKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHRoaXMub25DbG9zZShcInBpbmcgdGltZW91dFwiKTtcbiAgICAgICAgfSwgdGhpcy5wcm90b2NvbCA9PT0gM1xuICAgICAgICAgICAgPyB0aGlzLnNlcnZlci5vcHRzLnBpbmdJbnRlcnZhbCArIHRoaXMuc2VydmVyLm9wdHMucGluZ1RpbWVvdXRcbiAgICAgICAgICAgIDogdGhpcy5zZXJ2ZXIub3B0cy5waW5nVGltZW91dCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEF0dGFjaGVzIGhhbmRsZXJzIGZvciB0aGUgZ2l2ZW4gdHJhbnNwb3J0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtUcmFuc3BvcnR9IHRyYW5zcG9ydFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgc2V0VHJhbnNwb3J0KHRyYW5zcG9ydCkge1xuICAgICAgICBjb25zdCBvbkVycm9yID0gdGhpcy5vbkVycm9yLmJpbmQodGhpcyk7XG4gICAgICAgIGNvbnN0IG9uUmVhZHkgPSAoKSA9PiB0aGlzLmZsdXNoKCk7XG4gICAgICAgIGNvbnN0IG9uUGFja2V0ID0gdGhpcy5vblBhY2tldC5iaW5kKHRoaXMpO1xuICAgICAgICBjb25zdCBvbkRyYWluID0gdGhpcy5vbkRyYWluLmJpbmQodGhpcyk7XG4gICAgICAgIGNvbnN0IG9uQ2xvc2UgPSB0aGlzLm9uQ2xvc2UuYmluZCh0aGlzLCBcInRyYW5zcG9ydCBjbG9zZVwiKTtcbiAgICAgICAgdGhpcy50cmFuc3BvcnQgPSB0cmFuc3BvcnQ7XG4gICAgICAgIHRoaXMudHJhbnNwb3J0Lm9uY2UoXCJlcnJvclwiLCBvbkVycm9yKTtcbiAgICAgICAgdGhpcy50cmFuc3BvcnQub24oXCJyZWFkeVwiLCBvblJlYWR5KTtcbiAgICAgICAgdGhpcy50cmFuc3BvcnQub24oXCJwYWNrZXRcIiwgb25QYWNrZXQpO1xuICAgICAgICB0aGlzLnRyYW5zcG9ydC5vbihcImRyYWluXCIsIG9uRHJhaW4pO1xuICAgICAgICB0aGlzLnRyYW5zcG9ydC5vbmNlKFwiY2xvc2VcIiwgb25DbG9zZSk7XG4gICAgICAgIHRoaXMuY2xlYW51cEZuLnB1c2goZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdHJhbnNwb3J0LnJlbW92ZUxpc3RlbmVyKFwiZXJyb3JcIiwgb25FcnJvcik7XG4gICAgICAgICAgICB0cmFuc3BvcnQucmVtb3ZlTGlzdGVuZXIoXCJyZWFkeVwiLCBvblJlYWR5KTtcbiAgICAgICAgICAgIHRyYW5zcG9ydC5yZW1vdmVMaXN0ZW5lcihcInBhY2tldFwiLCBvblBhY2tldCk7XG4gICAgICAgICAgICB0cmFuc3BvcnQucmVtb3ZlTGlzdGVuZXIoXCJkcmFpblwiLCBvbkRyYWluKTtcbiAgICAgICAgICAgIHRyYW5zcG9ydC5yZW1vdmVMaXN0ZW5lcihcImNsb3NlXCIsIG9uQ2xvc2UpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBvbiB0cmFuc3BvcnQgXCJkcmFpblwiIGV2ZW50XG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIG9uRHJhaW4oKSB7XG4gICAgICAgIGlmICh0aGlzLnNlbnRDYWxsYmFja0ZuLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGRlYnVnKFwiZXhlY3V0aW5nIGJhdGNoIHNlbmQgY2FsbGJhY2tcIik7XG4gICAgICAgICAgICBjb25zdCBzZXFGbiA9IHRoaXMuc2VudENhbGxiYWNrRm4uc2hpZnQoKTtcbiAgICAgICAgICAgIGlmIChzZXFGbikge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2VxRm4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgc2VxRm5baV0odGhpcy50cmFuc3BvcnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGdyYWRlcyBzb2NrZXQgdG8gdGhlIGdpdmVuIHRyYW5zcG9ydFxuICAgICAqXG4gICAgICogQHBhcmFtIHtUcmFuc3BvcnR9IHRyYW5zcG9ydFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgLyogcHJpdmF0ZSAqLyBfbWF5YmVVcGdyYWRlKHRyYW5zcG9ydCkge1xuICAgICAgICBkZWJ1ZygnbWlnaHQgdXBncmFkZSBzb2NrZXQgdHJhbnNwb3J0IGZyb20gXCIlc1wiIHRvIFwiJXNcIicsIHRoaXMudHJhbnNwb3J0Lm5hbWUsIHRyYW5zcG9ydC5uYW1lKTtcbiAgICAgICAgdGhpcy51cGdyYWRpbmcgPSB0cnVlO1xuICAgICAgICAvLyBzZXQgdHJhbnNwb3J0IHVwZ3JhZGUgdGltZXJcbiAgICAgICAgY29uc3QgdXBncmFkZVRpbWVvdXRUaW1lciA9ICgwLCB0aW1lcnNfMS5zZXRUaW1lb3V0KSgoKSA9PiB7XG4gICAgICAgICAgICBkZWJ1ZyhcImNsaWVudCBkaWQgbm90IGNvbXBsZXRlIHVwZ3JhZGUgLSBjbG9zaW5nIHRyYW5zcG9ydFwiKTtcbiAgICAgICAgICAgIGNsZWFudXAoKTtcbiAgICAgICAgICAgIGlmIChcIm9wZW5cIiA9PT0gdHJhbnNwb3J0LnJlYWR5U3RhdGUpIHtcbiAgICAgICAgICAgICAgICB0cmFuc3BvcnQuY2xvc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgdGhpcy5zZXJ2ZXIub3B0cy51cGdyYWRlVGltZW91dCk7XG4gICAgICAgIGxldCBjaGVja0ludGVydmFsVGltZXI7XG4gICAgICAgIGNvbnN0IG9uUGFja2V0ID0gKHBhY2tldCkgPT4ge1xuICAgICAgICAgICAgaWYgKFwicGluZ1wiID09PSBwYWNrZXQudHlwZSAmJiBcInByb2JlXCIgPT09IHBhY2tldC5kYXRhKSB7XG4gICAgICAgICAgICAgICAgZGVidWcoXCJnb3QgcHJvYmUgcGluZyBwYWNrZXQsIHNlbmRpbmcgcG9uZ1wiKTtcbiAgICAgICAgICAgICAgICB0cmFuc3BvcnQuc2VuZChbeyB0eXBlOiBcInBvbmdcIiwgZGF0YTogXCJwcm9iZVwiIH1dKTtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJ1cGdyYWRpbmdcIiwgdHJhbnNwb3J0KTtcbiAgICAgICAgICAgICAgICBjbGVhckludGVydmFsKGNoZWNrSW50ZXJ2YWxUaW1lcik7XG4gICAgICAgICAgICAgICAgY2hlY2tJbnRlcnZhbFRpbWVyID0gc2V0SW50ZXJ2YWwoY2hlY2ssIDEwMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChcInVwZ3JhZGVcIiA9PT0gcGFja2V0LnR5cGUgJiYgdGhpcy5yZWFkeVN0YXRlICE9PSBcImNsb3NlZFwiKSB7XG4gICAgICAgICAgICAgICAgZGVidWcoXCJnb3QgdXBncmFkZSBwYWNrZXQgLSB1cGdyYWRpbmdcIik7XG4gICAgICAgICAgICAgICAgY2xlYW51cCgpO1xuICAgICAgICAgICAgICAgIHRoaXMudHJhbnNwb3J0LmRpc2NhcmQoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZ3JhZGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLmNsZWFyVHJhbnNwb3J0KCk7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRUcmFuc3BvcnQodHJhbnNwb3J0KTtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJ1cGdyYWRlXCIsIHRyYW5zcG9ydCk7XG4gICAgICAgICAgICAgICAgdGhpcy5mbHVzaCgpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgPT09IFwiY2xvc2luZ1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyYW5zcG9ydC5jbG9zZSgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm9uQ2xvc2UoXCJmb3JjZWQgY2xvc2VcIik7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNsZWFudXAoKTtcbiAgICAgICAgICAgICAgICB0cmFuc3BvcnQuY2xvc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLy8gd2UgZm9yY2UgYSBwb2xsaW5nIGN5Y2xlIHRvIGVuc3VyZSBhIGZhc3QgdXBncmFkZVxuICAgICAgICBjb25zdCBjaGVjayA9ICgpID0+IHtcbiAgICAgICAgICAgIGlmIChcInBvbGxpbmdcIiA9PT0gdGhpcy50cmFuc3BvcnQubmFtZSAmJiB0aGlzLnRyYW5zcG9ydC53cml0YWJsZSkge1xuICAgICAgICAgICAgICAgIGRlYnVnKFwid3JpdGluZyBhIG5vb3AgcGFja2V0IHRvIHBvbGxpbmcgZm9yIGZhc3QgdXBncmFkZVwiKTtcbiAgICAgICAgICAgICAgICB0aGlzLnRyYW5zcG9ydC5zZW5kKFt7IHR5cGU6IFwibm9vcFwiIH1dKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgY2xlYW51cCA9ICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMudXBncmFkaW5nID0gZmFsc2U7XG4gICAgICAgICAgICBjbGVhckludGVydmFsKGNoZWNrSW50ZXJ2YWxUaW1lcik7XG4gICAgICAgICAgICAoMCwgdGltZXJzXzEuY2xlYXJUaW1lb3V0KSh1cGdyYWRlVGltZW91dFRpbWVyKTtcbiAgICAgICAgICAgIHRyYW5zcG9ydC5yZW1vdmVMaXN0ZW5lcihcInBhY2tldFwiLCBvblBhY2tldCk7XG4gICAgICAgICAgICB0cmFuc3BvcnQucmVtb3ZlTGlzdGVuZXIoXCJjbG9zZVwiLCBvblRyYW5zcG9ydENsb3NlKTtcbiAgICAgICAgICAgIHRyYW5zcG9ydC5yZW1vdmVMaXN0ZW5lcihcImVycm9yXCIsIG9uRXJyb3IpO1xuICAgICAgICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcihcImNsb3NlXCIsIG9uQ2xvc2UpO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBvbkVycm9yID0gKGVycikgPT4ge1xuICAgICAgICAgICAgZGVidWcoXCJjbGllbnQgZGlkIG5vdCBjb21wbGV0ZSB1cGdyYWRlIC0gJXNcIiwgZXJyKTtcbiAgICAgICAgICAgIGNsZWFudXAoKTtcbiAgICAgICAgICAgIHRyYW5zcG9ydC5jbG9zZSgpO1xuICAgICAgICAgICAgdHJhbnNwb3J0ID0gbnVsbDtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3Qgb25UcmFuc3BvcnRDbG9zZSA9ICgpID0+IHtcbiAgICAgICAgICAgIG9uRXJyb3IoXCJ0cmFuc3BvcnQgY2xvc2VkXCIpO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBvbkNsb3NlID0gKCkgPT4ge1xuICAgICAgICAgICAgb25FcnJvcihcInNvY2tldCBjbG9zZWRcIik7XG4gICAgICAgIH07XG4gICAgICAgIHRyYW5zcG9ydC5vbihcInBhY2tldFwiLCBvblBhY2tldCk7XG4gICAgICAgIHRyYW5zcG9ydC5vbmNlKFwiY2xvc2VcIiwgb25UcmFuc3BvcnRDbG9zZSk7XG4gICAgICAgIHRyYW5zcG9ydC5vbmNlKFwiZXJyb3JcIiwgb25FcnJvcik7XG4gICAgICAgIHRoaXMub25jZShcImNsb3NlXCIsIG9uQ2xvc2UpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDbGVhcnMgbGlzdGVuZXJzIGFuZCB0aW1lcnMgYXNzb2NpYXRlZCB3aXRoIGN1cnJlbnQgdHJhbnNwb3J0LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBjbGVhclRyYW5zcG9ydCgpIHtcbiAgICAgICAgbGV0IGNsZWFudXA7XG4gICAgICAgIGNvbnN0IHRvQ2xlYW5VcCA9IHRoaXMuY2xlYW51cEZuLmxlbmd0aDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0b0NsZWFuVXA7IGkrKykge1xuICAgICAgICAgICAgY2xlYW51cCA9IHRoaXMuY2xlYW51cEZuLnNoaWZ0KCk7XG4gICAgICAgICAgICBjbGVhbnVwKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gc2lsZW5jZSBmdXJ0aGVyIHRyYW5zcG9ydCBlcnJvcnMgYW5kIHByZXZlbnQgdW5jYXVnaHQgZXhjZXB0aW9uc1xuICAgICAgICB0aGlzLnRyYW5zcG9ydC5vbihcImVycm9yXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGRlYnVnKFwiZXJyb3IgdHJpZ2dlcmVkIGJ5IGRpc2NhcmRlZCB0cmFuc3BvcnRcIik7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBlbnN1cmUgdHJhbnNwb3J0IHdvbid0IHN0YXkgb3BlblxuICAgICAgICB0aGlzLnRyYW5zcG9ydC5jbG9zZSgpO1xuICAgICAgICAoMCwgdGltZXJzXzEuY2xlYXJUaW1lb3V0KSh0aGlzLnBpbmdUaW1lb3V0VGltZXIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgdXBvbiB0cmFuc3BvcnQgY29uc2lkZXJlZCBjbG9zZWQuXG4gICAgICogUG9zc2libGUgcmVhc29uczogYHBpbmcgdGltZW91dGAsIGBjbGllbnQgZXJyb3JgLCBgcGFyc2UgZXJyb3JgLFxuICAgICAqIGB0cmFuc3BvcnQgZXJyb3JgLCBgc2VydmVyIGNsb3NlYCwgYHRyYW5zcG9ydCBjbG9zZWBcbiAgICAgKi9cbiAgICBvbkNsb3NlKHJlYXNvbiwgZGVzY3JpcHRpb24pIHtcbiAgICAgICAgaWYgKFwiY2xvc2VkXCIgIT09IHRoaXMucmVhZHlTdGF0ZSkge1xuICAgICAgICAgICAgdGhpcy5yZWFkeVN0YXRlID0gXCJjbG9zZWRcIjtcbiAgICAgICAgICAgIC8vIGNsZWFyIHRpbWVyc1xuICAgICAgICAgICAgKDAsIHRpbWVyc18xLmNsZWFyVGltZW91dCkodGhpcy5waW5nSW50ZXJ2YWxUaW1lcik7XG4gICAgICAgICAgICAoMCwgdGltZXJzXzEuY2xlYXJUaW1lb3V0KSh0aGlzLnBpbmdUaW1lb3V0VGltZXIpO1xuICAgICAgICAgICAgLy8gY2xlYW4gd3JpdGVCdWZmZXIgaW4gbmV4dCB0aWNrLCBzbyBkZXZlbG9wZXJzIGNhbiBzdGlsbFxuICAgICAgICAgICAgLy8gZ3JhYiB0aGUgd3JpdGVCdWZmZXIgb24gJ2Nsb3NlJyBldmVudFxuICAgICAgICAgICAgcHJvY2Vzcy5uZXh0VGljaygoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy53cml0ZUJ1ZmZlciA9IFtdO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLnBhY2tldHNGbiA9IFtdO1xuICAgICAgICAgICAgdGhpcy5zZW50Q2FsbGJhY2tGbiA9IFtdO1xuICAgICAgICAgICAgdGhpcy5jbGVhclRyYW5zcG9ydCgpO1xuICAgICAgICAgICAgdGhpcy5lbWl0KFwiY2xvc2VcIiwgcmVhc29uLCBkZXNjcmlwdGlvbik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VuZHMgYSBtZXNzYWdlIHBhY2tldC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgICAqIEByZXR1cm4ge1NvY2tldH0gZm9yIGNoYWluaW5nXG4gICAgICovXG4gICAgc2VuZChkYXRhLCBvcHRpb25zLCBjYWxsYmFjaykge1xuICAgICAgICB0aGlzLnNlbmRQYWNrZXQoXCJtZXNzYWdlXCIsIGRhdGEsIG9wdGlvbnMsIGNhbGxiYWNrKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFsaWFzIG9mIHtAbGluayBzZW5kfS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBkYXRhXG4gICAgICogQHBhcmFtIG9wdGlvbnNcbiAgICAgKiBAcGFyYW0gY2FsbGJhY2tcbiAgICAgKi9cbiAgICB3cml0ZShkYXRhLCBvcHRpb25zLCBjYWxsYmFjaykge1xuICAgICAgICB0aGlzLnNlbmRQYWNrZXQoXCJtZXNzYWdlXCIsIGRhdGEsIG9wdGlvbnMsIGNhbGxiYWNrKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlbmRzIGEgcGFja2V0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgLSBwYWNrZXQgdHlwZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBzZW5kUGFja2V0KHR5cGUsIGRhdGEsIG9wdGlvbnMgPSB7fSwgY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrID0gb3B0aW9ucztcbiAgICAgICAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoXCJjbG9zaW5nXCIgIT09IHRoaXMucmVhZHlTdGF0ZSAmJiBcImNsb3NlZFwiICE9PSB0aGlzLnJlYWR5U3RhdGUpIHtcbiAgICAgICAgICAgIGRlYnVnKCdzZW5kaW5nIHBhY2tldCBcIiVzXCIgKCVzKScsIHR5cGUsIGRhdGEpO1xuICAgICAgICAgICAgLy8gY29tcHJlc3Npb24gaXMgZW5hYmxlZCBieSBkZWZhdWx0XG4gICAgICAgICAgICBvcHRpb25zLmNvbXByZXNzID0gb3B0aW9ucy5jb21wcmVzcyAhPT0gZmFsc2U7XG4gICAgICAgICAgICBjb25zdCBwYWNrZXQgPSB7XG4gICAgICAgICAgICAgICAgdHlwZSxcbiAgICAgICAgICAgICAgICBvcHRpb25zOiBvcHRpb25zLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChkYXRhKVxuICAgICAgICAgICAgICAgIHBhY2tldC5kYXRhID0gZGF0YTtcbiAgICAgICAgICAgIC8vIGV4cG9ydHMgcGFja2V0Q3JlYXRlIGV2ZW50XG4gICAgICAgICAgICB0aGlzLmVtaXQoXCJwYWNrZXRDcmVhdGVcIiwgcGFja2V0KTtcbiAgICAgICAgICAgIHRoaXMud3JpdGVCdWZmZXIucHVzaChwYWNrZXQpO1xuICAgICAgICAgICAgLy8gYWRkIHNlbmQgY2FsbGJhY2sgdG8gb2JqZWN0LCBpZiBkZWZpbmVkXG4gICAgICAgICAgICBpZiAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgY2FsbGJhY2spXG4gICAgICAgICAgICAgICAgdGhpcy5wYWNrZXRzRm4ucHVzaChjYWxsYmFjayk7XG4gICAgICAgICAgICB0aGlzLmZsdXNoKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQXR0ZW1wdHMgdG8gZmx1c2ggdGhlIHBhY2tldHMgYnVmZmVyLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBmbHVzaCgpIHtcbiAgICAgICAgaWYgKFwiY2xvc2VkXCIgIT09IHRoaXMucmVhZHlTdGF0ZSAmJlxuICAgICAgICAgICAgdGhpcy50cmFuc3BvcnQud3JpdGFibGUgJiZcbiAgICAgICAgICAgIHRoaXMud3JpdGVCdWZmZXIubGVuZ3RoKSB7XG4gICAgICAgICAgICBkZWJ1ZyhcImZsdXNoaW5nIGJ1ZmZlciB0byB0cmFuc3BvcnRcIik7XG4gICAgICAgICAgICB0aGlzLmVtaXQoXCJmbHVzaFwiLCB0aGlzLndyaXRlQnVmZmVyKTtcbiAgICAgICAgICAgIHRoaXMuc2VydmVyLmVtaXQoXCJmbHVzaFwiLCB0aGlzLCB0aGlzLndyaXRlQnVmZmVyKTtcbiAgICAgICAgICAgIGNvbnN0IHdidWYgPSB0aGlzLndyaXRlQnVmZmVyO1xuICAgICAgICAgICAgdGhpcy53cml0ZUJ1ZmZlciA9IFtdO1xuICAgICAgICAgICAgaWYgKHRoaXMucGFja2V0c0ZuLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2VudENhbGxiYWNrRm4ucHVzaCh0aGlzLnBhY2tldHNGbik7XG4gICAgICAgICAgICAgICAgdGhpcy5wYWNrZXRzRm4gPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuc2VudENhbGxiYWNrRm4ucHVzaChudWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMudHJhbnNwb3J0LnNlbmQod2J1Zik7XG4gICAgICAgICAgICB0aGlzLmVtaXQoXCJkcmFpblwiKTtcbiAgICAgICAgICAgIHRoaXMuc2VydmVyLmVtaXQoXCJkcmFpblwiLCB0aGlzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgYXZhaWxhYmxlIHVwZ3JhZGVzIGZvciB0aGlzIHNvY2tldC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgZ2V0QXZhaWxhYmxlVXBncmFkZXMoKSB7XG4gICAgICAgIGNvbnN0IGF2YWlsYWJsZVVwZ3JhZGVzID0gW107XG4gICAgICAgIGNvbnN0IGFsbFVwZ3JhZGVzID0gdGhpcy5zZXJ2ZXIudXBncmFkZXModGhpcy50cmFuc3BvcnQubmFtZSk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYWxsVXBncmFkZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGNvbnN0IHVwZyA9IGFsbFVwZ3JhZGVzW2ldO1xuICAgICAgICAgICAgaWYgKHRoaXMuc2VydmVyLm9wdHMudHJhbnNwb3J0cy5pbmRleE9mKHVwZykgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgYXZhaWxhYmxlVXBncmFkZXMucHVzaCh1cGcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhdmFpbGFibGVVcGdyYWRlcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2xvc2VzIHRoZSBzb2NrZXQgYW5kIHVuZGVybHlpbmcgdHJhbnNwb3J0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBkaXNjYXJkIC0gb3B0aW9uYWwsIGRpc2NhcmQgdGhlIHRyYW5zcG9ydFxuICAgICAqIEByZXR1cm4ge1NvY2tldH0gZm9yIGNoYWluaW5nXG4gICAgICovXG4gICAgY2xvc2UoZGlzY2FyZCkge1xuICAgICAgICBpZiAoZGlzY2FyZCAmJlxuICAgICAgICAgICAgKHRoaXMucmVhZHlTdGF0ZSA9PT0gXCJvcGVuXCIgfHwgdGhpcy5yZWFkeVN0YXRlID09PSBcImNsb3NpbmdcIikpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNsb3NlVHJhbnNwb3J0KGRpc2NhcmQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChcIm9wZW5cIiAhPT0gdGhpcy5yZWFkeVN0YXRlKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLnJlYWR5U3RhdGUgPSBcImNsb3NpbmdcIjtcbiAgICAgICAgaWYgKHRoaXMud3JpdGVCdWZmZXIubGVuZ3RoKSB7XG4gICAgICAgICAgICBkZWJ1ZyhcInRoZXJlIGFyZSAlZCByZW1haW5pbmcgcGFja2V0cyBpbiB0aGUgYnVmZmVyLCB3YWl0aW5nIGZvciB0aGUgJ2RyYWluJyBldmVudFwiLCB0aGlzLndyaXRlQnVmZmVyLmxlbmd0aCk7XG4gICAgICAgICAgICB0aGlzLm9uY2UoXCJkcmFpblwiLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgZGVidWcoXCJhbGwgcGFja2V0cyBoYXZlIGJlZW4gc2VudCwgY2xvc2luZyB0aGUgdHJhbnNwb3J0XCIpO1xuICAgICAgICAgICAgICAgIHRoaXMuY2xvc2VUcmFuc3BvcnQoZGlzY2FyZCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBkZWJ1ZyhcInRoZSBidWZmZXIgaXMgZW1wdHksIGNsb3NpbmcgdGhlIHRyYW5zcG9ydCByaWdodCBhd2F5XCIpO1xuICAgICAgICB0aGlzLmNsb3NlVHJhbnNwb3J0KGRpc2NhcmQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDbG9zZXMgdGhlIHVuZGVybHlpbmcgdHJhbnNwb3J0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBkaXNjYXJkXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBjbG9zZVRyYW5zcG9ydChkaXNjYXJkKSB7XG4gICAgICAgIGRlYnVnKFwiY2xvc2luZyB0aGUgdHJhbnNwb3J0IChkaXNjYXJkPyAlcylcIiwgISFkaXNjYXJkKTtcbiAgICAgICAgaWYgKGRpc2NhcmQpXG4gICAgICAgICAgICB0aGlzLnRyYW5zcG9ydC5kaXNjYXJkKCk7XG4gICAgICAgIHRoaXMudHJhbnNwb3J0LmNsb3NlKHRoaXMub25DbG9zZS5iaW5kKHRoaXMsIFwiZm9yY2VkIGNsb3NlXCIpKTtcbiAgICB9XG59XG5leHBvcnRzLlNvY2tldCA9IFNvY2tldDtcbiJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIlNvY2tldCIsImV2ZW50c18xIiwicmVxdWlyZSIsImRlYnVnXzEiLCJ0aW1lcnNfMSIsImRlYnVnIiwiZGVmYXVsdCIsIkV2ZW50RW1pdHRlciIsInJlYWR5U3RhdGUiLCJfcmVhZHlTdGF0ZSIsInN0YXRlIiwiY29uc3RydWN0b3IiLCJpZCIsInNlcnZlciIsInRyYW5zcG9ydCIsInJlcSIsInByb3RvY29sIiwidXBncmFkaW5nIiwidXBncmFkZWQiLCJ3cml0ZUJ1ZmZlciIsInBhY2tldHNGbiIsInNlbnRDYWxsYmFja0ZuIiwiY2xlYW51cEZuIiwicmVxdWVzdCIsIndlYnNvY2tldCIsIl9zb2NrZXQiLCJyZW1vdGVBZGRyZXNzIiwiY29ubmVjdGlvbiIsInBpbmdUaW1lb3V0VGltZXIiLCJwaW5nSW50ZXJ2YWxUaW1lciIsInNldFRyYW5zcG9ydCIsIm9uT3BlbiIsInNpZCIsInNlbmRQYWNrZXQiLCJKU09OIiwic3RyaW5naWZ5IiwidXBncmFkZXMiLCJnZXRBdmFpbGFibGVVcGdyYWRlcyIsInBpbmdJbnRlcnZhbCIsIm9wdHMiLCJwaW5nVGltZW91dCIsIm1heFBheWxvYWQiLCJtYXhIdHRwQnVmZmVyU2l6ZSIsImluaXRpYWxQYWNrZXQiLCJlbWl0IiwicmVzZXRQaW5nVGltZW91dCIsInNjaGVkdWxlUGluZyIsIm9uUGFja2V0IiwicGFja2V0IiwidHlwZSIsIm9uRXJyb3IiLCJFcnJvciIsInJlZnJlc2giLCJjbGVhclRpbWVvdXQiLCJvbkNsb3NlIiwiZGF0YSIsImVyciIsInNldFRpbWVvdXQiLCJiaW5kIiwib25SZWFkeSIsImZsdXNoIiwib25EcmFpbiIsIm9uY2UiLCJvbiIsInB1c2giLCJyZW1vdmVMaXN0ZW5lciIsImxlbmd0aCIsInNlcUZuIiwic2hpZnQiLCJpIiwiX21heWJlVXBncmFkZSIsIm5hbWUiLCJ1cGdyYWRlVGltZW91dFRpbWVyIiwiY2xlYW51cCIsImNsb3NlIiwidXBncmFkZVRpbWVvdXQiLCJjaGVja0ludGVydmFsVGltZXIiLCJzZW5kIiwiY2xlYXJJbnRlcnZhbCIsInNldEludGVydmFsIiwiY2hlY2siLCJkaXNjYXJkIiwiY2xlYXJUcmFuc3BvcnQiLCJ3cml0YWJsZSIsIm9uVHJhbnNwb3J0Q2xvc2UiLCJ0b0NsZWFuVXAiLCJyZWFzb24iLCJkZXNjcmlwdGlvbiIsInByb2Nlc3MiLCJuZXh0VGljayIsIm9wdGlvbnMiLCJjYWxsYmFjayIsIndyaXRlIiwiY29tcHJlc3MiLCJ3YnVmIiwiYXZhaWxhYmxlVXBncmFkZXMiLCJhbGxVcGdyYWRlcyIsInVwZyIsInRyYW5zcG9ydHMiLCJpbmRleE9mIiwiY2xvc2VUcmFuc3BvcnQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/engine.io/build/socket.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/engine.io/build/transport.js":
/*!***************************************************!*\
  !*** ./node_modules/engine.io/build/transport.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.Transport = void 0;\nconst events_1 = __webpack_require__(/*! events */ \"events\");\nconst parser_v4 = __webpack_require__(/*! engine.io-parser */ \"(rsc)/./node_modules/engine.io-parser/build/cjs/index.js\");\nconst parser_v3 = __webpack_require__(/*! ./parser-v3/index */ \"(rsc)/./node_modules/engine.io/build/parser-v3/index.js\");\nconst debug_1 = __webpack_require__(/*! debug */ \"(rsc)/./node_modules/engine.io/node_modules/debug/src/index.js\");\nconst debug = (0, debug_1.default)(\"engine:transport\");\nfunction noop() {}\nclass Transport extends events_1.EventEmitter {\n    get readyState() {\n        return this._readyState;\n    }\n    set readyState(state) {\n        debug(\"readyState updated from %s to %s (%s)\", this._readyState, state, this.name);\n        this._readyState = state;\n    }\n    /**\n     * Transport constructor.\n     *\n     * @param {EngineRequest} req\n     */ constructor(req){\n        super();\n        /**\n         * Whether the transport is currently ready to send packets.\n         */ this.writable = false;\n        /**\n         * The current state of the transport.\n         * @protected\n         */ this._readyState = \"open\";\n        /**\n         * Whether the transport is discarded and can be safely closed (used during upgrade).\n         * @protected\n         */ this.discarded = false;\n        this.protocol = req._query.EIO === \"4\" ? 4 : 3; // 3rd revision by default\n        this.parser = this.protocol === 4 ? parser_v4 : parser_v3;\n        this.supportsBinary = !(req._query && req._query.b64);\n    }\n    /**\n     * Flags the transport as discarded.\n     *\n     * @package\n     */ discard() {\n        this.discarded = true;\n    }\n    /**\n     * Called with an incoming HTTP request.\n     *\n     * @param req\n     * @package\n     */ onRequest(req) {}\n    /**\n     * Closes the transport.\n     *\n     * @package\n     */ close(fn) {\n        if (\"closed\" === this.readyState || \"closing\" === this.readyState) return;\n        this.readyState = \"closing\";\n        this.doClose(fn || noop);\n    }\n    /**\n     * Called with a transport error.\n     *\n     * @param {String} msg - message error\n     * @param {Object} desc - error description\n     * @protected\n     */ onError(msg, desc) {\n        if (this.listeners(\"error\").length) {\n            const err = new Error(msg);\n            // @ts-ignore\n            err.type = \"TransportError\";\n            // @ts-ignore\n            err.description = desc;\n            this.emit(\"error\", err);\n        } else {\n            debug(\"ignored transport error %s (%s)\", msg, desc);\n        }\n    }\n    /**\n     * Called with parsed out a packets from the data stream.\n     *\n     * @param {Object} packet\n     * @protected\n     */ onPacket(packet) {\n        this.emit(\"packet\", packet);\n    }\n    /**\n     * Called with the encoded packet data.\n     *\n     * @param {String} data\n     * @protected\n     */ onData(data) {\n        this.onPacket(this.parser.decodePacket(data));\n    }\n    /**\n     * Called upon transport close.\n     *\n     * @protected\n     */ onClose() {\n        this.readyState = \"closed\";\n        this.emit(\"close\");\n    }\n}\nexports.Transport = Transport;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZW5naW5lLmlvL2J1aWxkL3RyYW5zcG9ydC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsaUJBQWlCLEdBQUcsS0FBSztBQUN6QixNQUFNRyxXQUFXQyxtQkFBT0EsQ0FBQyxzQkFBUTtBQUNqQyxNQUFNQyxZQUFZRCxtQkFBT0EsQ0FBQyxrRkFBa0I7QUFDNUMsTUFBTUUsWUFBWUYsbUJBQU9BLENBQUMsa0ZBQW1CO0FBQzdDLE1BQU1HLFVBQVVILG1CQUFPQSxDQUFDLDZFQUFPO0FBQy9CLE1BQU1JLFFBQVEsQ0FBQyxHQUFHRCxRQUFRRSxPQUFPLEVBQUU7QUFDbkMsU0FBU0MsUUFBUztBQUNsQixNQUFNUixrQkFBa0JDLFNBQVNRLFlBQVk7SUFDekMsSUFBSUMsYUFBYTtRQUNiLE9BQU8sSUFBSSxDQUFDQyxXQUFXO0lBQzNCO0lBQ0EsSUFBSUQsV0FBV0UsS0FBSyxFQUFFO1FBQ2xCTixNQUFNLHlDQUF5QyxJQUFJLENBQUNLLFdBQVcsRUFBRUMsT0FBTyxJQUFJLENBQUNDLElBQUk7UUFDakYsSUFBSSxDQUFDRixXQUFXLEdBQUdDO0lBQ3ZCO0lBQ0E7Ozs7S0FJQyxHQUNERSxZQUFZQyxHQUFHLENBQUU7UUFDYixLQUFLO1FBQ0w7O1NBRUMsR0FDRCxJQUFJLENBQUNDLFFBQVEsR0FBRztRQUNoQjs7O1NBR0MsR0FDRCxJQUFJLENBQUNMLFdBQVcsR0FBRztRQUNuQjs7O1NBR0MsR0FDRCxJQUFJLENBQUNNLFNBQVMsR0FBRztRQUNqQixJQUFJLENBQUNDLFFBQVEsR0FBR0gsSUFBSUksTUFBTSxDQUFDQyxHQUFHLEtBQUssTUFBTSxJQUFJLEdBQUcsMEJBQTBCO1FBQzFFLElBQUksQ0FBQ0MsTUFBTSxHQUFHLElBQUksQ0FBQ0gsUUFBUSxLQUFLLElBQUlmLFlBQVlDO1FBQ2hELElBQUksQ0FBQ2tCLGNBQWMsR0FBRyxDQUFFUCxDQUFBQSxJQUFJSSxNQUFNLElBQUlKLElBQUlJLE1BQU0sQ0FBQ0ksR0FBRztJQUN4RDtJQUNBOzs7O0tBSUMsR0FDREMsVUFBVTtRQUNOLElBQUksQ0FBQ1AsU0FBUyxHQUFHO0lBQ3JCO0lBQ0E7Ozs7O0tBS0MsR0FDRFEsVUFBVVYsR0FBRyxFQUFFLENBQUU7SUFDakI7Ozs7S0FJQyxHQUNEVyxNQUFNQyxFQUFFLEVBQUU7UUFDTixJQUFJLGFBQWEsSUFBSSxDQUFDakIsVUFBVSxJQUFJLGNBQWMsSUFBSSxDQUFDQSxVQUFVLEVBQzdEO1FBQ0osSUFBSSxDQUFDQSxVQUFVLEdBQUc7UUFDbEIsSUFBSSxDQUFDa0IsT0FBTyxDQUFDRCxNQUFNbkI7SUFDdkI7SUFDQTs7Ozs7O0tBTUMsR0FDRHFCLFFBQVFDLEdBQUcsRUFBRUMsSUFBSSxFQUFFO1FBQ2YsSUFBSSxJQUFJLENBQUNDLFNBQVMsQ0FBQyxTQUFTQyxNQUFNLEVBQUU7WUFDaEMsTUFBTUMsTUFBTSxJQUFJQyxNQUFNTDtZQUN0QixhQUFhO1lBQ2JJLElBQUlFLElBQUksR0FBRztZQUNYLGFBQWE7WUFDYkYsSUFBSUcsV0FBVyxHQUFHTjtZQUNsQixJQUFJLENBQUNPLElBQUksQ0FBQyxTQUFTSjtRQUN2QixPQUNLO1lBQ0Q1QixNQUFNLG1DQUFtQ3dCLEtBQUtDO1FBQ2xEO0lBQ0o7SUFDQTs7Ozs7S0FLQyxHQUNEUSxTQUFTQyxNQUFNLEVBQUU7UUFDYixJQUFJLENBQUNGLElBQUksQ0FBQyxVQUFVRTtJQUN4QjtJQUNBOzs7OztLQUtDLEdBQ0RDLE9BQU9DLElBQUksRUFBRTtRQUNULElBQUksQ0FBQ0gsUUFBUSxDQUFDLElBQUksQ0FBQ2xCLE1BQU0sQ0FBQ3NCLFlBQVksQ0FBQ0Q7SUFDM0M7SUFDQTs7OztLQUlDLEdBQ0RFLFVBQVU7UUFDTixJQUFJLENBQUNsQyxVQUFVLEdBQUc7UUFDbEIsSUFBSSxDQUFDNEIsSUFBSSxDQUFDO0lBQ2Q7QUFDSjtBQUNBeEMsaUJBQWlCLEdBQUdFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZXhhbXJvc2gvLi9ub2RlX21vZHVsZXMvZW5naW5lLmlvL2J1aWxkL3RyYW5zcG9ydC5qcz8zNzk5Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5UcmFuc3BvcnQgPSB2b2lkIDA7XG5jb25zdCBldmVudHNfMSA9IHJlcXVpcmUoXCJldmVudHNcIik7XG5jb25zdCBwYXJzZXJfdjQgPSByZXF1aXJlKFwiZW5naW5lLmlvLXBhcnNlclwiKTtcbmNvbnN0IHBhcnNlcl92MyA9IHJlcXVpcmUoXCIuL3BhcnNlci12My9pbmRleFwiKTtcbmNvbnN0IGRlYnVnXzEgPSByZXF1aXJlKFwiZGVidWdcIik7XG5jb25zdCBkZWJ1ZyA9ICgwLCBkZWJ1Z18xLmRlZmF1bHQpKFwiZW5naW5lOnRyYW5zcG9ydFwiKTtcbmZ1bmN0aW9uIG5vb3AoKSB7IH1cbmNsYXNzIFRyYW5zcG9ydCBleHRlbmRzIGV2ZW50c18xLkV2ZW50RW1pdHRlciB7XG4gICAgZ2V0IHJlYWR5U3RhdGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZWFkeVN0YXRlO1xuICAgIH1cbiAgICBzZXQgcmVhZHlTdGF0ZShzdGF0ZSkge1xuICAgICAgICBkZWJ1ZyhcInJlYWR5U3RhdGUgdXBkYXRlZCBmcm9tICVzIHRvICVzICglcylcIiwgdGhpcy5fcmVhZHlTdGF0ZSwgc3RhdGUsIHRoaXMubmFtZSk7XG4gICAgICAgIHRoaXMuX3JlYWR5U3RhdGUgPSBzdGF0ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVHJhbnNwb3J0IGNvbnN0cnVjdG9yLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtFbmdpbmVSZXF1ZXN0fSByZXFcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihyZXEpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZXRoZXIgdGhlIHRyYW5zcG9ydCBpcyBjdXJyZW50bHkgcmVhZHkgdG8gc2VuZCBwYWNrZXRzLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy53cml0YWJsZSA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGN1cnJlbnQgc3RhdGUgb2YgdGhlIHRyYW5zcG9ydC5cbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fcmVhZHlTdGF0ZSA9IFwib3BlblwiO1xuICAgICAgICAvKipcbiAgICAgICAgICogV2hldGhlciB0aGUgdHJhbnNwb3J0IGlzIGRpc2NhcmRlZCBhbmQgY2FuIGJlIHNhZmVseSBjbG9zZWQgKHVzZWQgZHVyaW5nIHVwZ3JhZGUpLlxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmRpc2NhcmRlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLnByb3RvY29sID0gcmVxLl9xdWVyeS5FSU8gPT09IFwiNFwiID8gNCA6IDM7IC8vIDNyZCByZXZpc2lvbiBieSBkZWZhdWx0XG4gICAgICAgIHRoaXMucGFyc2VyID0gdGhpcy5wcm90b2NvbCA9PT0gNCA/IHBhcnNlcl92NCA6IHBhcnNlcl92MztcbiAgICAgICAgdGhpcy5zdXBwb3J0c0JpbmFyeSA9ICEocmVxLl9xdWVyeSAmJiByZXEuX3F1ZXJ5LmI2NCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZsYWdzIHRoZSB0cmFuc3BvcnQgYXMgZGlzY2FyZGVkLlxuICAgICAqXG4gICAgICogQHBhY2thZ2VcbiAgICAgKi9cbiAgICBkaXNjYXJkKCkge1xuICAgICAgICB0aGlzLmRpc2NhcmRlZCA9IHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGxlZCB3aXRoIGFuIGluY29taW5nIEhUVFAgcmVxdWVzdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSByZXFcbiAgICAgKiBAcGFja2FnZVxuICAgICAqL1xuICAgIG9uUmVxdWVzdChyZXEpIHsgfVxuICAgIC8qKlxuICAgICAqIENsb3NlcyB0aGUgdHJhbnNwb3J0LlxuICAgICAqXG4gICAgICogQHBhY2thZ2VcbiAgICAgKi9cbiAgICBjbG9zZShmbikge1xuICAgICAgICBpZiAoXCJjbG9zZWRcIiA9PT0gdGhpcy5yZWFkeVN0YXRlIHx8IFwiY2xvc2luZ1wiID09PSB0aGlzLnJlYWR5U3RhdGUpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMucmVhZHlTdGF0ZSA9IFwiY2xvc2luZ1wiO1xuICAgICAgICB0aGlzLmRvQ2xvc2UoZm4gfHwgbm9vcCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGxlZCB3aXRoIGEgdHJhbnNwb3J0IGVycm9yLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG1zZyAtIG1lc3NhZ2UgZXJyb3JcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGVzYyAtIGVycm9yIGRlc2NyaXB0aW9uXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIG9uRXJyb3IobXNnLCBkZXNjKSB7XG4gICAgICAgIGlmICh0aGlzLmxpc3RlbmVycyhcImVycm9yXCIpLmxlbmd0aCkge1xuICAgICAgICAgICAgY29uc3QgZXJyID0gbmV3IEVycm9yKG1zZyk7XG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICBlcnIudHlwZSA9IFwiVHJhbnNwb3J0RXJyb3JcIjtcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgIGVyci5kZXNjcmlwdGlvbiA9IGRlc2M7XG4gICAgICAgICAgICB0aGlzLmVtaXQoXCJlcnJvclwiLCBlcnIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZGVidWcoXCJpZ25vcmVkIHRyYW5zcG9ydCBlcnJvciAlcyAoJXMpXCIsIG1zZywgZGVzYyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHdpdGggcGFyc2VkIG91dCBhIHBhY2tldHMgZnJvbSB0aGUgZGF0YSBzdHJlYW0uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcGFja2V0XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIG9uUGFja2V0KHBhY2tldCkge1xuICAgICAgICB0aGlzLmVtaXQoXCJwYWNrZXRcIiwgcGFja2V0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHdpdGggdGhlIGVuY29kZWQgcGFja2V0IGRhdGEuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZGF0YVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBvbkRhdGEoZGF0YSkge1xuICAgICAgICB0aGlzLm9uUGFja2V0KHRoaXMucGFyc2VyLmRlY29kZVBhY2tldChkYXRhKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGxlZCB1cG9uIHRyYW5zcG9ydCBjbG9zZS5cbiAgICAgKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBvbkNsb3NlKCkge1xuICAgICAgICB0aGlzLnJlYWR5U3RhdGUgPSBcImNsb3NlZFwiO1xuICAgICAgICB0aGlzLmVtaXQoXCJjbG9zZVwiKTtcbiAgICB9XG59XG5leHBvcnRzLlRyYW5zcG9ydCA9IFRyYW5zcG9ydDtcbiJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIlRyYW5zcG9ydCIsImV2ZW50c18xIiwicmVxdWlyZSIsInBhcnNlcl92NCIsInBhcnNlcl92MyIsImRlYnVnXzEiLCJkZWJ1ZyIsImRlZmF1bHQiLCJub29wIiwiRXZlbnRFbWl0dGVyIiwicmVhZHlTdGF0ZSIsIl9yZWFkeVN0YXRlIiwic3RhdGUiLCJuYW1lIiwiY29uc3RydWN0b3IiLCJyZXEiLCJ3cml0YWJsZSIsImRpc2NhcmRlZCIsInByb3RvY29sIiwiX3F1ZXJ5IiwiRUlPIiwicGFyc2VyIiwic3VwcG9ydHNCaW5hcnkiLCJiNjQiLCJkaXNjYXJkIiwib25SZXF1ZXN0IiwiY2xvc2UiLCJmbiIsImRvQ2xvc2UiLCJvbkVycm9yIiwibXNnIiwiZGVzYyIsImxpc3RlbmVycyIsImxlbmd0aCIsImVyciIsIkVycm9yIiwidHlwZSIsImRlc2NyaXB0aW9uIiwiZW1pdCIsIm9uUGFja2V0IiwicGFja2V0Iiwib25EYXRhIiwiZGF0YSIsImRlY29kZVBhY2tldCIsIm9uQ2xvc2UiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/engine.io/build/transport.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/engine.io/build/transports-uws/index.js":
/*!**************************************************************!*\
  !*** ./node_modules/engine.io/build/transports-uws/index.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nconst polling_1 = __webpack_require__(/*! ./polling */ \"(rsc)/./node_modules/engine.io/build/transports-uws/polling.js\");\nconst websocket_1 = __webpack_require__(/*! ./websocket */ \"(rsc)/./node_modules/engine.io/build/transports-uws/websocket.js\");\nexports[\"default\"] = {\n    polling: polling_1.Polling,\n    websocket: websocket_1.WebSocket\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZW5naW5lLmlvL2J1aWxkL3RyYW5zcG9ydHMtdXdzL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdELE1BQU1DLFlBQVlDLG1CQUFPQSxDQUFDLGlGQUFXO0FBQ3JDLE1BQU1DLGNBQWNELG1CQUFPQSxDQUFDLHFGQUFhO0FBQ3pDSCxrQkFBZSxHQUFHO0lBQ2RNLFNBQVNKLFVBQVVLLE9BQU87SUFDMUJDLFdBQVdKLFlBQVlLLFNBQVM7QUFDcEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9leGFtcm9zaC8uL25vZGVfbW9kdWxlcy9lbmdpbmUuaW8vYnVpbGQvdHJhbnNwb3J0cy11d3MvaW5kZXguanM/MTZhNiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IHBvbGxpbmdfMSA9IHJlcXVpcmUoXCIuL3BvbGxpbmdcIik7XG5jb25zdCB3ZWJzb2NrZXRfMSA9IHJlcXVpcmUoXCIuL3dlYnNvY2tldFwiKTtcbmV4cG9ydHMuZGVmYXVsdCA9IHtcbiAgICBwb2xsaW5nOiBwb2xsaW5nXzEuUG9sbGluZyxcbiAgICB3ZWJzb2NrZXQ6IHdlYnNvY2tldF8xLldlYlNvY2tldCxcbn07XG4iXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJwb2xsaW5nXzEiLCJyZXF1aXJlIiwid2Vic29ja2V0XzEiLCJkZWZhdWx0IiwicG9sbGluZyIsIlBvbGxpbmciLCJ3ZWJzb2NrZXQiLCJXZWJTb2NrZXQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/engine.io/build/transports-uws/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/engine.io/build/transports-uws/polling.js":
/*!****************************************************************!*\
  !*** ./node_modules/engine.io/build/transports-uws/polling.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.Polling = void 0;\nconst transport_1 = __webpack_require__(/*! ../transport */ \"(rsc)/./node_modules/engine.io/build/transport.js\");\nconst zlib_1 = __webpack_require__(/*! zlib */ \"zlib\");\nconst accepts = __webpack_require__(/*! accepts */ \"(rsc)/./node_modules/accepts/index.js\");\nconst debug_1 = __webpack_require__(/*! debug */ \"(rsc)/./node_modules/engine.io/node_modules/debug/src/index.js\");\nconst debug = (0, debug_1.default)(\"engine:polling\");\nconst compressionMethods = {\n    gzip: zlib_1.createGzip,\n    deflate: zlib_1.createDeflate\n};\nclass Polling extends transport_1.Transport {\n    /**\n     * HTTP polling constructor.\n     */ constructor(req){\n        super(req);\n        this.closeTimeout = 30 * 1000;\n    }\n    /**\n     * Transport name\n     */ get name() {\n        return \"polling\";\n    }\n    /**\n     * Overrides onRequest.\n     *\n     * @param req\n     *\n     * @private\n     */ onRequest(req) {\n        const res = req.res;\n        // remove the reference to the ServerResponse object (as the first request of the session is kept in memory by default)\n        req.res = null;\n        if (req.getMethod() === \"get\") {\n            this.onPollRequest(req, res);\n        } else if (req.getMethod() === \"post\") {\n            this.onDataRequest(req, res);\n        } else {\n            res.writeStatus(\"500 Internal Server Error\");\n            res.end();\n        }\n    }\n    /**\n     * The client sends a request awaiting for us to send data.\n     *\n     * @private\n     */ onPollRequest(req, res) {\n        if (this.req) {\n            debug(\"request overlap\");\n            // assert: this.res, '.req and .res should be (un)set together'\n            this.onError(\"overlap from client\");\n            res.writeStatus(\"500 Internal Server Error\");\n            res.end();\n            return;\n        }\n        debug(\"setting request\");\n        this.req = req;\n        this.res = res;\n        const onClose = ()=>{\n            this.writable = false;\n            this.onError(\"poll connection closed prematurely\");\n        };\n        const cleanup = ()=>{\n            this.req = this.res = null;\n        };\n        req.cleanup = cleanup;\n        res.onAborted(onClose);\n        this.writable = true;\n        this.emit(\"ready\");\n        // if we're still writable but had a pending close, trigger an empty send\n        if (this.writable && this.shouldClose) {\n            debug(\"triggering empty send to append close packet\");\n            this.send([\n                {\n                    type: \"noop\"\n                }\n            ]);\n        }\n    }\n    /**\n     * The client sends a request with data.\n     *\n     * @private\n     */ onDataRequest(req, res) {\n        if (this.dataReq) {\n            // assert: this.dataRes, '.dataReq and .dataRes should be (un)set together'\n            this.onError(\"data request overlap from client\");\n            res.writeStatus(\"500 Internal Server Error\");\n            res.end();\n            return;\n        }\n        const expectedContentLength = Number(req.headers[\"content-length\"]);\n        if (!expectedContentLength) {\n            this.onError(\"content-length header required\");\n            res.writeStatus(\"411 Length Required\").end();\n            return;\n        }\n        if (expectedContentLength > this.maxHttpBufferSize) {\n            this.onError(\"payload too large\");\n            res.writeStatus(\"413 Payload Too Large\").end();\n            return;\n        }\n        const isBinary = \"application/octet-stream\" === req.headers[\"content-type\"];\n        if (isBinary && this.protocol === 4) {\n            return this.onError(\"invalid content\");\n        }\n        this.dataReq = req;\n        this.dataRes = res;\n        let buffer;\n        let offset = 0;\n        const headers = {\n            // text/html is required instead of text/plain to avoid an\n            // unwanted download dialog on certain user-agents (GH-43)\n            \"Content-Type\": \"text/html\"\n        };\n        this.headers(req, headers);\n        for(let key in headers){\n            res.writeHeader(key, String(headers[key]));\n        }\n        const onEnd = (buffer)=>{\n            this.onData(buffer.toString());\n            this.onDataRequestCleanup();\n            res.cork(()=>{\n                res.end(\"ok\");\n            });\n        };\n        res.onAborted(()=>{\n            this.onDataRequestCleanup();\n            this.onError(\"data request connection closed prematurely\");\n        });\n        res.onData((arrayBuffer, isLast)=>{\n            const totalLength = offset + arrayBuffer.byteLength;\n            if (totalLength > expectedContentLength) {\n                this.onError(\"content-length mismatch\");\n                res.close(); // calls onAborted\n                return;\n            }\n            if (!buffer) {\n                if (isLast) {\n                    onEnd(Buffer.from(arrayBuffer));\n                    return;\n                }\n                buffer = Buffer.allocUnsafe(expectedContentLength);\n            }\n            Buffer.from(arrayBuffer).copy(buffer, offset);\n            if (isLast) {\n                if (totalLength != expectedContentLength) {\n                    this.onError(\"content-length mismatch\");\n                    res.writeStatus(\"400 Content-Length Mismatch\").end();\n                    this.onDataRequestCleanup();\n                    return;\n                }\n                onEnd(buffer);\n                return;\n            }\n            offset = totalLength;\n        });\n    }\n    /**\n     * Cleanup request.\n     *\n     * @private\n     */ onDataRequestCleanup() {\n        this.dataReq = this.dataRes = null;\n    }\n    /**\n     * Processes the incoming data payload.\n     *\n     * @param {String} encoded payload\n     * @private\n     */ onData(data) {\n        debug('received \"%s\"', data);\n        const callback = (packet)=>{\n            if (\"close\" === packet.type) {\n                debug(\"got xhr close packet\");\n                this.onClose();\n                return false;\n            }\n            this.onPacket(packet);\n        };\n        if (this.protocol === 3) {\n            this.parser.decodePayload(data, callback);\n        } else {\n            this.parser.decodePayload(data).forEach(callback);\n        }\n    }\n    /**\n     * Overrides onClose.\n     *\n     * @private\n     */ onClose() {\n        if (this.writable) {\n            // close pending poll request\n            this.send([\n                {\n                    type: \"noop\"\n                }\n            ]);\n        }\n        super.onClose();\n    }\n    /**\n     * Writes a packet payload.\n     *\n     * @param {Object} packet\n     * @private\n     */ send(packets) {\n        this.writable = false;\n        if (this.shouldClose) {\n            debug(\"appending close packet to payload\");\n            packets.push({\n                type: \"close\"\n            });\n            this.shouldClose();\n            this.shouldClose = null;\n        }\n        const doWrite = (data)=>{\n            const compress = packets.some((packet)=>{\n                return packet.options && packet.options.compress;\n            });\n            this.write(data, {\n                compress\n            });\n        };\n        if (this.protocol === 3) {\n            this.parser.encodePayload(packets, this.supportsBinary, doWrite);\n        } else {\n            this.parser.encodePayload(packets, doWrite);\n        }\n    }\n    /**\n     * Writes data as response to poll request.\n     *\n     * @param {String} data\n     * @param {Object} options\n     * @private\n     */ write(data, options) {\n        debug('writing \"%s\"', data);\n        this.doWrite(data, options, ()=>{\n            this.req.cleanup();\n            this.emit(\"drain\");\n        });\n    }\n    /**\n     * Performs the write.\n     *\n     * @private\n     */ doWrite(data, options, callback) {\n        // explicit UTF-8 is required for pages not served under utf\n        const isString = typeof data === \"string\";\n        const contentType = isString ? \"text/plain; charset=UTF-8\" : \"application/octet-stream\";\n        const headers = {\n            \"Content-Type\": contentType\n        };\n        const respond = (data)=>{\n            this.headers(this.req, headers);\n            this.res.cork(()=>{\n                Object.keys(headers).forEach((key)=>{\n                    this.res.writeHeader(key, String(headers[key]));\n                });\n                this.res.end(data);\n            });\n            callback();\n        };\n        if (!this.httpCompression || !options.compress) {\n            respond(data);\n            return;\n        }\n        const len = isString ? Buffer.byteLength(data) : data.length;\n        if (len < this.httpCompression.threshold) {\n            respond(data);\n            return;\n        }\n        const encoding = accepts(this.req).encodings([\n            \"gzip\",\n            \"deflate\"\n        ]);\n        if (!encoding) {\n            respond(data);\n            return;\n        }\n        this.compress(data, encoding, (err, data)=>{\n            if (err) {\n                this.res.writeStatus(\"500 Internal Server Error\");\n                this.res.end();\n                callback(err);\n                return;\n            }\n            headers[\"Content-Encoding\"] = encoding;\n            respond(data);\n        });\n    }\n    /**\n     * Compresses data.\n     *\n     * @private\n     */ compress(data, encoding, callback) {\n        debug(\"compressing\");\n        const buffers = [];\n        let nread = 0;\n        compressionMethods[encoding](this.httpCompression).on(\"error\", callback).on(\"data\", function(chunk) {\n            buffers.push(chunk);\n            nread += chunk.length;\n        }).on(\"end\", function() {\n            callback(null, Buffer.concat(buffers, nread));\n        }).end(data);\n    }\n    /**\n     * Closes the transport.\n     *\n     * @private\n     */ doClose(fn) {\n        debug(\"closing\");\n        let closeTimeoutTimer;\n        const onClose = ()=>{\n            clearTimeout(closeTimeoutTimer);\n            fn();\n            this.onClose();\n        };\n        if (this.writable) {\n            debug(\"transport writable - closing right away\");\n            this.send([\n                {\n                    type: \"close\"\n                }\n            ]);\n            onClose();\n        } else if (this.discarded) {\n            debug(\"transport discarded - closing right away\");\n            onClose();\n        } else {\n            debug(\"transport not writable - buffering orderly close\");\n            this.shouldClose = onClose;\n            closeTimeoutTimer = setTimeout(onClose, this.closeTimeout);\n        }\n    }\n    /**\n     * Returns headers for a response.\n     *\n     * @param req - request\n     * @param {Object} extra headers\n     * @private\n     */ headers(req, headers) {\n        headers = headers || {};\n        // prevent XSS warnings on IE\n        // https://github.com/LearnBoost/socket.io/pull/1333\n        const ua = req.headers[\"user-agent\"];\n        if (ua && (~ua.indexOf(\";MSIE\") || ~ua.indexOf(\"Trident/\"))) {\n            headers[\"X-XSS-Protection\"] = \"0\";\n        }\n        headers[\"cache-control\"] = \"no-store\";\n        this.emit(\"headers\", headers, req);\n        return headers;\n    }\n}\nexports.Polling = Polling;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZW5naW5lLmlvL2J1aWxkL3RyYW5zcG9ydHMtdXdzL3BvbGxpbmcuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELGVBQWUsR0FBRyxLQUFLO0FBQ3ZCLE1BQU1HLGNBQWNDLG1CQUFPQSxDQUFDLHVFQUFjO0FBQzFDLE1BQU1DLFNBQVNELG1CQUFPQSxDQUFDLGtCQUFNO0FBQzdCLE1BQU1FLFVBQVVGLG1CQUFPQSxDQUFDLHNEQUFTO0FBQ2pDLE1BQU1HLFVBQVVILG1CQUFPQSxDQUFDLDZFQUFPO0FBQy9CLE1BQU1JLFFBQVEsQ0FBQyxHQUFHRCxRQUFRRSxPQUFPLEVBQUU7QUFDbkMsTUFBTUMscUJBQXFCO0lBQ3ZCQyxNQUFNTixPQUFPTyxVQUFVO0lBQ3ZCQyxTQUFTUixPQUFPUyxhQUFhO0FBQ2pDO0FBQ0EsTUFBTVosZ0JBQWdCQyxZQUFZWSxTQUFTO0lBQ3ZDOztLQUVDLEdBQ0RDLFlBQVlDLEdBQUcsQ0FBRTtRQUNiLEtBQUssQ0FBQ0E7UUFDTixJQUFJLENBQUNDLFlBQVksR0FBRyxLQUFLO0lBQzdCO0lBQ0E7O0tBRUMsR0FDRCxJQUFJQyxPQUFPO1FBQ1AsT0FBTztJQUNYO0lBQ0E7Ozs7OztLQU1DLEdBQ0RDLFVBQVVILEdBQUcsRUFBRTtRQUNYLE1BQU1JLE1BQU1KLElBQUlJLEdBQUc7UUFDbkIsdUhBQXVIO1FBQ3ZISixJQUFJSSxHQUFHLEdBQUc7UUFDVixJQUFJSixJQUFJSyxTQUFTLE9BQU8sT0FBTztZQUMzQixJQUFJLENBQUNDLGFBQWEsQ0FBQ04sS0FBS0k7UUFDNUIsT0FDSyxJQUFJSixJQUFJSyxTQUFTLE9BQU8sUUFBUTtZQUNqQyxJQUFJLENBQUNFLGFBQWEsQ0FBQ1AsS0FBS0k7UUFDNUIsT0FDSztZQUNEQSxJQUFJSSxXQUFXLENBQUM7WUFDaEJKLElBQUlLLEdBQUc7UUFDWDtJQUNKO0lBQ0E7Ozs7S0FJQyxHQUNE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S3BGLElBQUlzQixPQUFPLENBQUMsYUFBYTtRQUNwQyxJQUFJOEQsTUFBTyxFQUFDQSxHQUFHQyxPQUFPLENBQUMsWUFBWSxDQUFDRCxHQUFHQyxPQUFPLENBQUMsV0FBVSxHQUFJO1lBQ3pEL0QsT0FBTyxDQUFDLG1CQUFtQixHQUFHO1FBQ2xDO1FBQ0FBLE9BQU8sQ0FBQyxnQkFBZ0IsR0FBRztRQUMzQixJQUFJLENBQUNQLElBQUksQ0FBQyxXQUFXTyxTQUFTdEI7UUFDOUIsT0FBT3NCO0lBQ1g7QUFDSjtBQUNBdkMsZUFBZSxHQUFHRSIsInNvdXJjZXMiOlsid2VicGFjazovL2V4YW1yb3NoLy4vbm9kZV9tb2R1bGVzL2VuZ2luZS5pby9idWlsZC90cmFuc3BvcnRzLXV3cy9wb2xsaW5nLmpzPzcyYTYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlBvbGxpbmcgPSB2b2lkIDA7XG5jb25zdCB0cmFuc3BvcnRfMSA9IHJlcXVpcmUoXCIuLi90cmFuc3BvcnRcIik7XG5jb25zdCB6bGliXzEgPSByZXF1aXJlKFwiemxpYlwiKTtcbmNvbnN0IGFjY2VwdHMgPSByZXF1aXJlKFwiYWNjZXB0c1wiKTtcbmNvbnN0IGRlYnVnXzEgPSByZXF1aXJlKFwiZGVidWdcIik7XG5jb25zdCBkZWJ1ZyA9ICgwLCBkZWJ1Z18xLmRlZmF1bHQpKFwiZW5naW5lOnBvbGxpbmdcIik7XG5jb25zdCBjb21wcmVzc2lvbk1ldGhvZHMgPSB7XG4gICAgZ3ppcDogemxpYl8xLmNyZWF0ZUd6aXAsXG4gICAgZGVmbGF0ZTogemxpYl8xLmNyZWF0ZURlZmxhdGUsXG59O1xuY2xhc3MgUG9sbGluZyBleHRlbmRzIHRyYW5zcG9ydF8xLlRyYW5zcG9ydCB7XG4gICAgLyoqXG4gICAgICogSFRUUCBwb2xsaW5nIGNvbnN0cnVjdG9yLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHJlcSkge1xuICAgICAgICBzdXBlcihyZXEpO1xuICAgICAgICB0aGlzLmNsb3NlVGltZW91dCA9IDMwICogMTAwMDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVHJhbnNwb3J0IG5hbWVcbiAgICAgKi9cbiAgICBnZXQgbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIFwicG9sbGluZ1wiO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBPdmVycmlkZXMgb25SZXF1ZXN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHJlcVxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBvblJlcXVlc3QocmVxKSB7XG4gICAgICAgIGNvbnN0IHJlcyA9IHJlcS5yZXM7XG4gICAgICAgIC8vIHJlbW92ZSB0aGUgcmVmZXJlbmNlIHRvIHRoZSBTZXJ2ZXJSZXNwb25zZSBvYmplY3QgKGFzIHRoZSBmaXJzdCByZXF1ZXN0IG9mIHRoZSBzZXNzaW9uIGlzIGtlcHQgaW4gbWVtb3J5IGJ5IGRlZmF1bHQpXG4gICAgICAgIHJlcS5yZXMgPSBudWxsO1xuICAgICAgICBpZiAocmVxLmdldE1ldGhvZCgpID09PSBcImdldFwiKSB7XG4gICAgICAgICAgICB0aGlzLm9uUG9sbFJlcXVlc3QocmVxLCByZXMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHJlcS5nZXRNZXRob2QoKSA9PT0gXCJwb3N0XCIpIHtcbiAgICAgICAgICAgIHRoaXMub25EYXRhUmVxdWVzdChyZXEsIHJlcyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXMud3JpdGVTdGF0dXMoXCI1MDAgSW50ZXJuYWwgU2VydmVyIEVycm9yXCIpO1xuICAgICAgICAgICAgcmVzLmVuZCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBjbGllbnQgc2VuZHMgYSByZXF1ZXN0IGF3YWl0aW5nIGZvciB1cyB0byBzZW5kIGRhdGEuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIG9uUG9sbFJlcXVlc3QocmVxLCByZXMpIHtcbiAgICAgICAgaWYgKHRoaXMucmVxKSB7XG4gICAgICAgICAgICBkZWJ1ZyhcInJlcXVlc3Qgb3ZlcmxhcFwiKTtcbiAgICAgICAgICAgIC8vIGFzc2VydDogdGhpcy5yZXMsICcucmVxIGFuZCAucmVzIHNob3VsZCBiZSAodW4pc2V0IHRvZ2V0aGVyJ1xuICAgICAgICAgICAgdGhpcy5vbkVycm9yKFwib3ZlcmxhcCBmcm9tIGNsaWVudFwiKTtcbiAgICAgICAgICAgIHJlcy53cml0ZVN0YXR1cyhcIjUwMCBJbnRlcm5hbCBTZXJ2ZXIgRXJyb3JcIik7XG4gICAgICAgICAgICByZXMuZW5kKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZGVidWcoXCJzZXR0aW5nIHJlcXVlc3RcIik7XG4gICAgICAgIHRoaXMucmVxID0gcmVxO1xuICAgICAgICB0aGlzLnJlcyA9IHJlcztcbiAgICAgICAgY29uc3Qgb25DbG9zZSA9ICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMud3JpdGFibGUgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMub25FcnJvcihcInBvbGwgY29ubmVjdGlvbiBjbG9zZWQgcHJlbWF0dXJlbHlcIik7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGNsZWFudXAgPSAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnJlcSA9IHRoaXMucmVzID0gbnVsbDtcbiAgICAgICAgfTtcbiAgICAgICAgcmVxLmNsZWFudXAgPSBjbGVhbnVwO1xuICAgICAgICByZXMub25BYm9ydGVkKG9uQ2xvc2UpO1xuICAgICAgICB0aGlzLndyaXRhYmxlID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5lbWl0KFwicmVhZHlcIik7XG4gICAgICAgIC8vIGlmIHdlJ3JlIHN0aWxsIHdyaXRhYmxlIGJ1dCBoYWQgYSBwZW5kaW5nIGNsb3NlLCB0cmlnZ2VyIGFuIGVtcHR5IHNlbmRcbiAgICAgICAgaWYgKHRoaXMud3JpdGFibGUgJiYgdGhpcy5zaG91bGRDbG9zZSkge1xuICAgICAgICAgICAgZGVidWcoXCJ0cmlnZ2VyaW5nIGVtcHR5IHNlbmQgdG8gYXBwZW5kIGNsb3NlIHBhY2tldFwiKTtcbiAgICAgICAgICAgIHRoaXMuc2VuZChbeyB0eXBlOiBcIm5vb3BcIiB9XSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIGNsaWVudCBzZW5kcyBhIHJlcXVlc3Qgd2l0aCBkYXRhLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBvbkRhdGFSZXF1ZXN0KHJlcSwgcmVzKSB7XG4gICAgICAgIGlmICh0aGlzLmRhdGFSZXEpIHtcbiAgICAgICAgICAgIC8vIGFzc2VydDogdGhpcy5kYXRhUmVzLCAnLmRhdGFSZXEgYW5kIC5kYXRhUmVzIHNob3VsZCBiZSAodW4pc2V0IHRvZ2V0aGVyJ1xuICAgICAgICAgICAgdGhpcy5vbkVycm9yKFwiZGF0YSByZXF1ZXN0IG92ZXJsYXAgZnJvbSBjbGllbnRcIik7XG4gICAgICAgICAgICByZXMud3JpdGVTdGF0dXMoXCI1MDAgSW50ZXJuYWwgU2VydmVyIEVycm9yXCIpO1xuICAgICAgICAgICAgcmVzLmVuZCgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGV4cGVjdGVkQ29udGVudExlbmd0aCA9IE51bWJlcihyZXEuaGVhZGVyc1tcImNvbnRlbnQtbGVuZ3RoXCJdKTtcbiAgICAgICAgaWYgKCFleHBlY3RlZENvbnRlbnRMZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMub25FcnJvcihcImNvbnRlbnQtbGVuZ3RoIGhlYWRlciByZXF1aXJlZFwiKTtcbiAgICAgICAgICAgIHJlcy53cml0ZVN0YXR1cyhcIjQxMSBMZW5ndGggUmVxdWlyZWRcIikuZW5kKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGV4cGVjdGVkQ29udGVudExlbmd0aCA+IHRoaXMubWF4SHR0cEJ1ZmZlclNpemUpIHtcbiAgICAgICAgICAgIHRoaXMub25FcnJvcihcInBheWxvYWQgdG9vIGxhcmdlXCIpO1xuICAgICAgICAgICAgcmVzLndyaXRlU3RhdHVzKFwiNDEzIFBheWxvYWQgVG9vIExhcmdlXCIpLmVuZCgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGlzQmluYXJ5ID0gXCJhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW1cIiA9PT0gcmVxLmhlYWRlcnNbXCJjb250ZW50LXR5cGVcIl07XG4gICAgICAgIGlmIChpc0JpbmFyeSAmJiB0aGlzLnByb3RvY29sID09PSA0KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5vbkVycm9yKFwiaW52YWxpZCBjb250ZW50XCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGF0YVJlcSA9IHJlcTtcbiAgICAgICAgdGhpcy5kYXRhUmVzID0gcmVzO1xuICAgICAgICBsZXQgYnVmZmVyO1xuICAgICAgICBsZXQgb2Zmc2V0ID0gMDtcbiAgICAgICAgY29uc3QgaGVhZGVycyA9IHtcbiAgICAgICAgICAgIC8vIHRleHQvaHRtbCBpcyByZXF1aXJlZCBpbnN0ZWFkIG9mIHRleHQvcGxhaW4gdG8gYXZvaWQgYW5cbiAgICAgICAgICAgIC8vIHVud2FudGVkIGRvd25sb2FkIGRpYWxvZyBvbiBjZXJ0YWluIHVzZXItYWdlbnRzIChHSC00MylcbiAgICAgICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwidGV4dC9odG1sXCIsXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaGVhZGVycyhyZXEsIGhlYWRlcnMpO1xuICAgICAgICBmb3IgKGxldCBrZXkgaW4gaGVhZGVycykge1xuICAgICAgICAgICAgcmVzLndyaXRlSGVhZGVyKGtleSwgU3RyaW5nKGhlYWRlcnNba2V5XSkpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG9uRW5kID0gKGJ1ZmZlcikgPT4ge1xuICAgICAgICAgICAgdGhpcy5vbkRhdGEoYnVmZmVyLnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgdGhpcy5vbkRhdGFSZXF1ZXN0Q2xlYW51cCgpO1xuICAgICAgICAgICAgcmVzLmNvcmsoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHJlcy5lbmQoXCJva1wiKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICByZXMub25BYm9ydGVkKCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMub25EYXRhUmVxdWVzdENsZWFudXAoKTtcbiAgICAgICAgICAgIHRoaXMub25FcnJvcihcImRhdGEgcmVxdWVzdCBjb25uZWN0aW9uIGNsb3NlZCBwcmVtYXR1cmVseVwiKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJlcy5vbkRhdGEoKGFycmF5QnVmZmVyLCBpc0xhc3QpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHRvdGFsTGVuZ3RoID0gb2Zmc2V0ICsgYXJyYXlCdWZmZXIuYnl0ZUxlbmd0aDtcbiAgICAgICAgICAgIGlmICh0b3RhbExlbmd0aCA+IGV4cGVjdGVkQ29udGVudExlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRoaXMub25FcnJvcihcImNvbnRlbnQtbGVuZ3RoIG1pc21hdGNoXCIpO1xuICAgICAgICAgICAgICAgIHJlcy5jbG9zZSgpOyAvLyBjYWxscyBvbkFib3J0ZWRcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWJ1ZmZlcikge1xuICAgICAgICAgICAgICAgIGlmIChpc0xhc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgb25FbmQoQnVmZmVyLmZyb20oYXJyYXlCdWZmZXIpKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBidWZmZXIgPSBCdWZmZXIuYWxsb2NVbnNhZmUoZXhwZWN0ZWRDb250ZW50TGVuZ3RoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIEJ1ZmZlci5mcm9tKGFycmF5QnVmZmVyKS5jb3B5KGJ1ZmZlciwgb2Zmc2V0KTtcbiAgICAgICAgICAgIGlmIChpc0xhc3QpIHtcbiAgICAgICAgICAgICAgICBpZiAodG90YWxMZW5ndGggIT0gZXhwZWN0ZWRDb250ZW50TGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub25FcnJvcihcImNvbnRlbnQtbGVuZ3RoIG1pc21hdGNoXCIpO1xuICAgICAgICAgICAgICAgICAgICByZXMud3JpdGVTdGF0dXMoXCI0MDAgQ29udGVudC1MZW5ndGggTWlzbWF0Y2hcIikuZW5kKCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub25EYXRhUmVxdWVzdENsZWFudXAoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvbkVuZChidWZmZXIpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9mZnNldCA9IHRvdGFsTGVuZ3RoO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2xlYW51cCByZXF1ZXN0LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBvbkRhdGFSZXF1ZXN0Q2xlYW51cCgpIHtcbiAgICAgICAgdGhpcy5kYXRhUmVxID0gdGhpcy5kYXRhUmVzID0gbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUHJvY2Vzc2VzIHRoZSBpbmNvbWluZyBkYXRhIHBheWxvYWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZW5jb2RlZCBwYXlsb2FkXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBvbkRhdGEoZGF0YSkge1xuICAgICAgICBkZWJ1ZygncmVjZWl2ZWQgXCIlc1wiJywgZGF0YSk7XG4gICAgICAgIGNvbnN0IGNhbGxiYWNrID0gKHBhY2tldCkgPT4ge1xuICAgICAgICAgICAgaWYgKFwiY2xvc2VcIiA9PT0gcGFja2V0LnR5cGUpIHtcbiAgICAgICAgICAgICAgICBkZWJ1ZyhcImdvdCB4aHIgY2xvc2UgcGFja2V0XCIpO1xuICAgICAgICAgICAgICAgIHRoaXMub25DbG9zZSgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMub25QYWNrZXQocGFja2V0KTtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHRoaXMucHJvdG9jb2wgPT09IDMpIHtcbiAgICAgICAgICAgIHRoaXMucGFyc2VyLmRlY29kZVBheWxvYWQoZGF0YSwgY2FsbGJhY2spO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5wYXJzZXIuZGVjb2RlUGF5bG9hZChkYXRhKS5mb3JFYWNoKGNhbGxiYWNrKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBPdmVycmlkZXMgb25DbG9zZS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgb25DbG9zZSgpIHtcbiAgICAgICAgaWYgKHRoaXMud3JpdGFibGUpIHtcbiAgICAgICAgICAgIC8vIGNsb3NlIHBlbmRpbmcgcG9sbCByZXF1ZXN0XG4gICAgICAgICAgICB0aGlzLnNlbmQoW3sgdHlwZTogXCJub29wXCIgfV0pO1xuICAgICAgICB9XG4gICAgICAgIHN1cGVyLm9uQ2xvc2UoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogV3JpdGVzIGEgcGFja2V0IHBheWxvYWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcGFja2V0XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBzZW5kKHBhY2tldHMpIHtcbiAgICAgICAgdGhpcy53cml0YWJsZSA9IGZhbHNlO1xuICAgICAgICBpZiAodGhpcy5zaG91bGRDbG9zZSkge1xuICAgICAgICAgICAgZGVidWcoXCJhcHBlbmRpbmcgY2xvc2UgcGFja2V0IHRvIHBheWxvYWRcIik7XG4gICAgICAgICAgICBwYWNrZXRzLnB1c2goeyB0eXBlOiBcImNsb3NlXCIgfSk7XG4gICAgICAgICAgICB0aGlzLnNob3VsZENsb3NlKCk7XG4gICAgICAgICAgICB0aGlzLnNob3VsZENsb3NlID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkb1dyaXRlID0gKGRhdGEpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGNvbXByZXNzID0gcGFja2V0cy5zb21lKChwYWNrZXQpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFja2V0Lm9wdGlvbnMgJiYgcGFja2V0Lm9wdGlvbnMuY29tcHJlc3M7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMud3JpdGUoZGF0YSwgeyBjb21wcmVzcyB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHRoaXMucHJvdG9jb2wgPT09IDMpIHtcbiAgICAgICAgICAgIHRoaXMucGFyc2VyLmVuY29kZVBheWxvYWQocGFja2V0cywgdGhpcy5zdXBwb3J0c0JpbmFyeSwgZG9Xcml0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnBhcnNlci5lbmNvZGVQYXlsb2FkKHBhY2tldHMsIGRvV3JpdGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdyaXRlcyBkYXRhIGFzIHJlc3BvbnNlIHRvIHBvbGwgcmVxdWVzdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHdyaXRlKGRhdGEsIG9wdGlvbnMpIHtcbiAgICAgICAgZGVidWcoJ3dyaXRpbmcgXCIlc1wiJywgZGF0YSk7XG4gICAgICAgIHRoaXMuZG9Xcml0ZShkYXRhLCBvcHRpb25zLCAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnJlcS5jbGVhbnVwKCk7XG4gICAgICAgICAgICB0aGlzLmVtaXQoXCJkcmFpblwiKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBlcmZvcm1zIHRoZSB3cml0ZS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgZG9Xcml0ZShkYXRhLCBvcHRpb25zLCBjYWxsYmFjaykge1xuICAgICAgICAvLyBleHBsaWNpdCBVVEYtOCBpcyByZXF1aXJlZCBmb3IgcGFnZXMgbm90IHNlcnZlZCB1bmRlciB1dGZcbiAgICAgICAgY29uc3QgaXNTdHJpbmcgPSB0eXBlb2YgZGF0YSA9PT0gXCJzdHJpbmdcIjtcbiAgICAgICAgY29uc3QgY29udGVudFR5cGUgPSBpc1N0cmluZ1xuICAgICAgICAgICAgPyBcInRleHQvcGxhaW47IGNoYXJzZXQ9VVRGLThcIlxuICAgICAgICAgICAgOiBcImFwcGxpY2F0aW9uL29jdGV0LXN0cmVhbVwiO1xuICAgICAgICBjb25zdCBoZWFkZXJzID0ge1xuICAgICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogY29udGVudFR5cGUsXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHJlc3BvbmQgPSAoZGF0YSkgPT4ge1xuICAgICAgICAgICAgdGhpcy5oZWFkZXJzKHRoaXMucmVxLCBoZWFkZXJzKTtcbiAgICAgICAgICAgIHRoaXMucmVzLmNvcmsoKCkgPT4ge1xuICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKGhlYWRlcnMpLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlcy53cml0ZUhlYWRlcihrZXksIFN0cmluZyhoZWFkZXJzW2tleV0pKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlcy5lbmQoZGF0YSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgIH07XG4gICAgICAgIGlmICghdGhpcy5odHRwQ29tcHJlc3Npb24gfHwgIW9wdGlvbnMuY29tcHJlc3MpIHtcbiAgICAgICAgICAgIHJlc3BvbmQoZGF0YSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbGVuID0gaXNTdHJpbmcgPyBCdWZmZXIuYnl0ZUxlbmd0aChkYXRhKSA6IGRhdGEubGVuZ3RoO1xuICAgICAgICBpZiAobGVuIDwgdGhpcy5odHRwQ29tcHJlc3Npb24udGhyZXNob2xkKSB7XG4gICAgICAgICAgICByZXNwb25kKGRhdGEpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGVuY29kaW5nID0gYWNjZXB0cyh0aGlzLnJlcSkuZW5jb2RpbmdzKFtcImd6aXBcIiwgXCJkZWZsYXRlXCJdKTtcbiAgICAgICAgaWYgKCFlbmNvZGluZykge1xuICAgICAgICAgICAgcmVzcG9uZChkYXRhKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNvbXByZXNzKGRhdGEsIGVuY29kaW5nLCAoZXJyLCBkYXRhKSA9PiB7XG4gICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXMud3JpdGVTdGF0dXMoXCI1MDAgSW50ZXJuYWwgU2VydmVyIEVycm9yXCIpO1xuICAgICAgICAgICAgICAgIHRoaXMucmVzLmVuZCgpO1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaGVhZGVyc1tcIkNvbnRlbnQtRW5jb2RpbmdcIl0gPSBlbmNvZGluZztcbiAgICAgICAgICAgIHJlc3BvbmQoZGF0YSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb21wcmVzc2VzIGRhdGEuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGNvbXByZXNzKGRhdGEsIGVuY29kaW5nLCBjYWxsYmFjaykge1xuICAgICAgICBkZWJ1ZyhcImNvbXByZXNzaW5nXCIpO1xuICAgICAgICBjb25zdCBidWZmZXJzID0gW107XG4gICAgICAgIGxldCBucmVhZCA9IDA7XG4gICAgICAgIGNvbXByZXNzaW9uTWV0aG9kc1tlbmNvZGluZ10odGhpcy5odHRwQ29tcHJlc3Npb24pXG4gICAgICAgICAgICAub24oXCJlcnJvclwiLCBjYWxsYmFjaylcbiAgICAgICAgICAgIC5vbihcImRhdGFcIiwgZnVuY3Rpb24gKGNodW5rKSB7XG4gICAgICAgICAgICBidWZmZXJzLnB1c2goY2h1bmspO1xuICAgICAgICAgICAgbnJlYWQgKz0gY2h1bmsubGVuZ3RoO1xuICAgICAgICB9KVxuICAgICAgICAgICAgLm9uKFwiZW5kXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIEJ1ZmZlci5jb25jYXQoYnVmZmVycywgbnJlYWQpKTtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5lbmQoZGF0YSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENsb3NlcyB0aGUgdHJhbnNwb3J0LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBkb0Nsb3NlKGZuKSB7XG4gICAgICAgIGRlYnVnKFwiY2xvc2luZ1wiKTtcbiAgICAgICAgbGV0IGNsb3NlVGltZW91dFRpbWVyO1xuICAgICAgICBjb25zdCBvbkNsb3NlID0gKCkgPT4ge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KGNsb3NlVGltZW91dFRpbWVyKTtcbiAgICAgICAgICAgIGZuKCk7XG4gICAgICAgICAgICB0aGlzLm9uQ2xvc2UoKTtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHRoaXMud3JpdGFibGUpIHtcbiAgICAgICAgICAgIGRlYnVnKFwidHJhbnNwb3J0IHdyaXRhYmxlIC0gY2xvc2luZyByaWdodCBhd2F5XCIpO1xuICAgICAgICAgICAgdGhpcy5zZW5kKFt7IHR5cGU6IFwiY2xvc2VcIiB9XSk7XG4gICAgICAgICAgICBvbkNsb3NlKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5kaXNjYXJkZWQpIHtcbiAgICAgICAgICAgIGRlYnVnKFwidHJhbnNwb3J0IGRpc2NhcmRlZCAtIGNsb3NpbmcgcmlnaHQgYXdheVwiKTtcbiAgICAgICAgICAgIG9uQ2xvc2UoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRlYnVnKFwidHJhbnNwb3J0IG5vdCB3cml0YWJsZSAtIGJ1ZmZlcmluZyBvcmRlcmx5IGNsb3NlXCIpO1xuICAgICAgICAgICAgdGhpcy5zaG91bGRDbG9zZSA9IG9uQ2xvc2U7XG4gICAgICAgICAgICBjbG9zZVRpbWVvdXRUaW1lciA9IHNldFRpbWVvdXQob25DbG9zZSwgdGhpcy5jbG9zZVRpbWVvdXQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgaGVhZGVycyBmb3IgYSByZXNwb25zZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSByZXEgLSByZXF1ZXN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV4dHJhIGhlYWRlcnNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGhlYWRlcnMocmVxLCBoZWFkZXJzKSB7XG4gICAgICAgIGhlYWRlcnMgPSBoZWFkZXJzIHx8IHt9O1xuICAgICAgICAvLyBwcmV2ZW50IFhTUyB3YXJuaW5ncyBvbiBJRVxuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vTGVhcm5Cb29zdC9zb2NrZXQuaW8vcHVsbC8xMzMzXG4gICAgICAgIGNvbnN0IHVhID0gcmVxLmhlYWRlcnNbXCJ1c2VyLWFnZW50XCJdO1xuICAgICAgICBpZiAodWEgJiYgKH51YS5pbmRleE9mKFwiO01TSUVcIikgfHwgfnVhLmluZGV4T2YoXCJUcmlkZW50L1wiKSkpIHtcbiAgICAgICAgICAgIGhlYWRlcnNbXCJYLVhTUy1Qcm90ZWN0aW9uXCJdID0gXCIwXCI7XG4gICAgICAgIH1cbiAgICAgICAgaGVhZGVyc1tcImNhY2hlLWNvbnRyb2xcIl0gPSBcIm5vLXN0b3JlXCI7XG4gICAgICAgIHRoaXMuZW1pdChcImhlYWRlcnNcIiwgaGVhZGVycywgcmVxKTtcbiAgICAgICAgcmV0dXJuIGhlYWRlcnM7XG4gICAgfVxufVxuZXhwb3J0cy5Qb2xsaW5nID0gUG9sbGluZztcbiJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIlBvbGxpbmciLCJ0cmFuc3BvcnRfMSIsInJlcXVpcmUiLCJ6bGliXzEiLCJhY2NlcHRzIiwiZGVidWdfMSIsImRlYnVnIiwiZGVmYXVsdCIsImNvbXByZXNzaW9uTWV0aG9kcyIsImd6aXAiLCJjcmVhdGVHemlwIiwiZGVmbGF0ZSIsImNyZWF0ZURlZmxhdGUiLCJUcmFuc3BvcnQiLCJjb25zdHJ1Y3RvciIsInJlcSIsImNsb3NlVGltZW91dCIsIm5hbWUiLCJvblJlcXVlc3QiLCJyZXMiLCJnZXRNZXRob2QiLCJvblBvbGxSZXF1ZXN0Iiwib25EYXRhUmVxdWVzdCIsIndyaXRlU3RhdHVzIiwiZW5kIiwib25FcnJvciIsIm9uQ2xvc2UiLCJ3cml0YWJsZSIsImNsZWFudXAiLCJvbkFib3J0ZWQiLCJlbWl0Iiwic2hvdWxkQ2xvc2UiLCJzZW5kIiwidHlwZSIsImRhdGFSZXEiLCJleHBlY3RlZENvbnRlbnRMZW5ndGgiLCJOdW1iZXIiLCJoZWFkZXJzIiwibWF4SHR0cEJ1ZmZlclNpemUiLCJpc0JpbmFyeSIsInByb3RvY29sIiwiZGF0YVJlcyIsImJ1ZmZlciIsIm9mZnNldCIsImtleSIsIndyaXRlSGVhZGVyIiwiU3RyaW5nIiwib25FbmQiLCJvbkRhdGEiLCJ0b1N0cmluZyIsIm9uRGF0YVJlcXVlc3RDbGVhbnVwIiwiY29yayIsImFycmF5QnVmZmVyIiwiaXNMYXN0IiwidG90YWxMZW5ndGgiLCJieXRlTGVuZ3RoIiwiY2xvc2UiLCJCdWZmZXIiLCJmcm9tIiwiYWxsb2NVbnNhZmUiLCJjb3B5IiwiZGF0YSIsImNhbGxiYWNrIiwicGFja2V0Iiwib25QYWNrZXQiLCJwYXJzZXIiLCJkZWNvZGVQYXlsb2FkIiwiZm9yRWFjaCIsInBhY2tldHMiLCJwdXNoIiwiZG9Xcml0ZSIsImNvbXByZXNzIiwic29tZSIsIm9wdGlvbnMiLCJ3cml0ZSIsImVuY29kZVBheWxvYWQiLCJzdXBwb3J0c0JpbmFyeSIsImlzU3RyaW5nIiwiY29udGVudFR5cGUiLCJyZXNwb25kIiwia2V5cyIsImh0dHBDb21wcmVzc2lvbiIsImxlbiIsImxlbmd0aCIsInRocmVzaG9sZCIsImVuY29kaW5nIiwiZW5jb2RpbmdzIiwiZXJyIiwiYnVmZmVycyIsIm5yZWFkIiwib24iLCJjaHVuayIsImNvbmNhdCIsImRvQ2xvc2UiLCJmbiIsImNsb3NlVGltZW91dFRpbWVyIiwiY2xlYXJUaW1lb3V0IiwiZGlzY2FyZGVkIiwic2V0VGltZW91dCIsInVhIiwiaW5kZXhPZiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/engine.io/build/transports-uws/polling.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/engine.io/build/transports-uws/websocket.js":
/*!******************************************************************!*\
  !*** ./node_modules/engine.io/build/transports-uws/websocket.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.WebSocket = void 0;\nconst transport_1 = __webpack_require__(/*! ../transport */ \"(rsc)/./node_modules/engine.io/build/transport.js\");\nconst debug_1 = __webpack_require__(/*! debug */ \"(rsc)/./node_modules/engine.io/node_modules/debug/src/index.js\");\nconst debug = (0, debug_1.default)(\"engine:ws\");\nclass WebSocket extends transport_1.Transport {\n    /**\n     * WebSocket transport\n     *\n     * @param req\n     */ constructor(req){\n        super(req);\n        this.writable = false;\n        this.perMessageDeflate = null;\n    }\n    /**\n     * Transport name\n     */ get name() {\n        return \"websocket\";\n    }\n    /**\n     * Advertise upgrade support.\n     */ get handlesUpgrades() {\n        return true;\n    }\n    /**\n     * Writes a packet payload.\n     *\n     * @param {Array} packets\n     * @private\n     */ send(packets) {\n        this.writable = false;\n        for(let i = 0; i < packets.length; i++){\n            const packet = packets[i];\n            const isLast = i + 1 === packets.length;\n            const send = (data)=>{\n                const isBinary = typeof data !== \"string\";\n                const compress = this.perMessageDeflate && Buffer.byteLength(data) > this.perMessageDeflate.threshold;\n                debug('writing \"%s\"', data);\n                this.socket.send(data, isBinary, compress);\n                if (isLast) {\n                    this.emit(\"drain\");\n                    this.writable = true;\n                    this.emit(\"ready\");\n                }\n            };\n            if (packet.options && typeof packet.options.wsPreEncoded === \"string\") {\n                send(packet.options.wsPreEncoded);\n            } else {\n                this.parser.encodePacket(packet, this.supportsBinary, send);\n            }\n        }\n    }\n    /**\n     * Closes the transport.\n     *\n     * @private\n     */ doClose(fn) {\n        debug(\"closing\");\n        fn && fn();\n        // call fn first since socket.end() immediately emits a \"close\" event\n        this.socket.end();\n    }\n}\nexports.WebSocket = WebSocket;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZW5naW5lLmlvL2J1aWxkL3RyYW5zcG9ydHMtdXdzL3dlYnNvY2tldC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsaUJBQWlCLEdBQUcsS0FBSztBQUN6QixNQUFNRyxjQUFjQyxtQkFBT0EsQ0FBQyx1RUFBYztBQUMxQyxNQUFNQyxVQUFVRCxtQkFBT0EsQ0FBQyw2RUFBTztBQUMvQixNQUFNRSxRQUFRLENBQUMsR0FBR0QsUUFBUUUsT0FBTyxFQUFFO0FBQ25DLE1BQU1MLGtCQUFrQkMsWUFBWUssU0FBUztJQUN6Qzs7OztLQUlDLEdBQ0RDLFlBQVlDLEdBQUcsQ0FBRTtRQUNiLEtBQUssQ0FBQ0E7UUFDTixJQUFJLENBQUNDLFFBQVEsR0FBRztRQUNoQixJQUFJLENBQUNDLGlCQUFpQixHQUFHO0lBQzdCO0lBQ0E7O0tBRUMsR0FDRCxJQUFJQyxPQUFPO1FBQ1AsT0FBTztJQUNYO0lBQ0E7O0tBRUMsR0FDRCxJQUFJQyxrQkFBa0I7UUFDbEIsT0FBTztJQUNYO0lBQ0E7Ozs7O0tBS0MsR0FDREMsS0FBS0MsT0FBTyxFQUFFO1FBQ1YsSUFBSSxDQUFDTCxRQUFRLEdBQUc7UUFDaEIsSUFBSyxJQUFJTSxJQUFJLEdBQUdBLElBQUlELFFBQVFFLE1BQU0sRUFBRUQsSUFBSztZQUNyQyxNQUFNRSxTQUFTSCxPQUFPLENBQUNDLEVBQUU7WUFDekIsTUFBTUcsU0FBU0gsSUFBSSxNQUFNRCxRQUFRRSxNQUFNO1lBQ3ZDLE1BQU1ILE9BQU8sQ0FBQ007Z0JBQ1YsTUFBTUMsV0FBVyxPQUFPRCxTQUFTO2dCQUNqQyxNQUFNRSxXQUFXLElBQUksQ0FBQ1gsaUJBQWlCLElBQ25DWSxPQUFPQyxVQUFVLENBQUNKLFFBQVEsSUFBSSxDQUFDVCxpQkFBaUIsQ0FBQ2MsU0FBUztnQkFDOURwQixNQUFNLGdCQUFnQmU7Z0JBQ3RCLElBQUksQ0FBQ00sTUFBTSxDQUFDWixJQUFJLENBQUNNLE1BQU1DLFVBQVVDO2dCQUNqQyxJQUFJSCxRQUFRO29CQUNSLElBQUksQ0FBQ1EsSUFBSSxDQUFDO29CQUNWLElBQUksQ0FBQ2pCLFFBQVEsR0FBRztvQkFDaEIsSUFBSSxDQUFDaUIsSUFBSSxDQUFDO2dCQUNkO1lBQ0o7WUFDQSxJQUFJVCxPQUFPVSxPQUFPLElBQUksT0FBT1YsT0FBT1UsT0FBTyxDQUFDQyxZQUFZLEtBQUssVUFBVTtnQkFDbkVmLEtBQUtJLE9BQU9VLE9BQU8sQ0FBQ0MsWUFBWTtZQUNwQyxPQUNLO2dCQUNELElBQUksQ0FBQ0MsTUFBTSxDQUFDQyxZQUFZLENBQUNiLFFBQVEsSUFBSSxDQUFDYyxjQUFjLEVBQUVsQjtZQUMxRDtRQUNKO0lBQ0o7SUFDQTs7OztLQUlDLEdBQ0RtQixRQUFRQyxFQUFFLEVBQUU7UUFDUjdCLE1BQU07UUFDTjZCLE1BQU1BO1FBQ04scUVBQXFFO1FBQ3JFLElBQUksQ0FBQ1IsTUFBTSxDQUFDUyxHQUFHO0lBQ25CO0FBQ0o7QUFDQXBDLGlCQUFpQixHQUFHRSIsInNvdXJjZXMiOlsid2VicGFjazovL2V4YW1yb3NoLy4vbm9kZV9tb2R1bGVzL2VuZ2luZS5pby9idWlsZC90cmFuc3BvcnRzLXV3cy93ZWJzb2NrZXQuanM/YTM4NSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuV2ViU29ja2V0ID0gdm9pZCAwO1xuY29uc3QgdHJhbnNwb3J0XzEgPSByZXF1aXJlKFwiLi4vdHJhbnNwb3J0XCIpO1xuY29uc3QgZGVidWdfMSA9IHJlcXVpcmUoXCJkZWJ1Z1wiKTtcbmNvbnN0IGRlYnVnID0gKDAsIGRlYnVnXzEuZGVmYXVsdCkoXCJlbmdpbmU6d3NcIik7XG5jbGFzcyBXZWJTb2NrZXQgZXh0ZW5kcyB0cmFuc3BvcnRfMS5UcmFuc3BvcnQge1xuICAgIC8qKlxuICAgICAqIFdlYlNvY2tldCB0cmFuc3BvcnRcbiAgICAgKlxuICAgICAqIEBwYXJhbSByZXFcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihyZXEpIHtcbiAgICAgICAgc3VwZXIocmVxKTtcbiAgICAgICAgdGhpcy53cml0YWJsZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLnBlck1lc3NhZ2VEZWZsYXRlID0gbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVHJhbnNwb3J0IG5hbWVcbiAgICAgKi9cbiAgICBnZXQgbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIFwid2Vic29ja2V0XCI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkdmVydGlzZSB1cGdyYWRlIHN1cHBvcnQuXG4gICAgICovXG4gICAgZ2V0IGhhbmRsZXNVcGdyYWRlcygpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdyaXRlcyBhIHBhY2tldCBwYXlsb2FkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtBcnJheX0gcGFja2V0c1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgc2VuZChwYWNrZXRzKSB7XG4gICAgICAgIHRoaXMud3JpdGFibGUgPSBmYWxzZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYWNrZXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBwYWNrZXQgPSBwYWNrZXRzW2ldO1xuICAgICAgICAgICAgY29uc3QgaXNMYXN0ID0gaSArIDEgPT09IHBhY2tldHMubGVuZ3RoO1xuICAgICAgICAgICAgY29uc3Qgc2VuZCA9IChkYXRhKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgaXNCaW5hcnkgPSB0eXBlb2YgZGF0YSAhPT0gXCJzdHJpbmdcIjtcbiAgICAgICAgICAgICAgICBjb25zdCBjb21wcmVzcyA9IHRoaXMucGVyTWVzc2FnZURlZmxhdGUgJiZcbiAgICAgICAgICAgICAgICAgICAgQnVmZmVyLmJ5dGVMZW5ndGgoZGF0YSkgPiB0aGlzLnBlck1lc3NhZ2VEZWZsYXRlLnRocmVzaG9sZDtcbiAgICAgICAgICAgICAgICBkZWJ1Zygnd3JpdGluZyBcIiVzXCInLCBkYXRhKTtcbiAgICAgICAgICAgICAgICB0aGlzLnNvY2tldC5zZW5kKGRhdGEsIGlzQmluYXJ5LCBjb21wcmVzcyk7XG4gICAgICAgICAgICAgICAgaWYgKGlzTGFzdCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJkcmFpblwiKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy53cml0YWJsZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcInJlYWR5XCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAocGFja2V0Lm9wdGlvbnMgJiYgdHlwZW9mIHBhY2tldC5vcHRpb25zLndzUHJlRW5jb2RlZCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgIHNlbmQocGFja2V0Lm9wdGlvbnMud3NQcmVFbmNvZGVkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMucGFyc2VyLmVuY29kZVBhY2tldChwYWNrZXQsIHRoaXMuc3VwcG9ydHNCaW5hcnksIHNlbmQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENsb3NlcyB0aGUgdHJhbnNwb3J0LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBkb0Nsb3NlKGZuKSB7XG4gICAgICAgIGRlYnVnKFwiY2xvc2luZ1wiKTtcbiAgICAgICAgZm4gJiYgZm4oKTtcbiAgICAgICAgLy8gY2FsbCBmbiBmaXJzdCBzaW5jZSBzb2NrZXQuZW5kKCkgaW1tZWRpYXRlbHkgZW1pdHMgYSBcImNsb3NlXCIgZXZlbnRcbiAgICAgICAgdGhpcy5zb2NrZXQuZW5kKCk7XG4gICAgfVxufVxuZXhwb3J0cy5XZWJTb2NrZXQgPSBXZWJTb2NrZXQ7XG4iXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJXZWJTb2NrZXQiLCJ0cmFuc3BvcnRfMSIsInJlcXVpcmUiLCJkZWJ1Z18xIiwiZGVidWciLCJkZWZhdWx0IiwiVHJhbnNwb3J0IiwiY29uc3RydWN0b3IiLCJyZXEiLCJ3cml0YWJsZSIsInBlck1lc3NhZ2VEZWZsYXRlIiwibmFtZSIsImhhbmRsZXNVcGdyYWRlcyIsInNlbmQiLCJwYWNrZXRzIiwiaSIsImxlbmd0aCIsInBhY2tldCIsImlzTGFzdCIsImRhdGEiLCJpc0JpbmFyeSIsImNvbXByZXNzIiwiQnVmZmVyIiwiYnl0ZUxlbmd0aCIsInRocmVzaG9sZCIsInNvY2tldCIsImVtaXQiLCJvcHRpb25zIiwid3NQcmVFbmNvZGVkIiwicGFyc2VyIiwiZW5jb2RlUGFja2V0Iiwic3VwcG9ydHNCaW5hcnkiLCJkb0Nsb3NlIiwiZm4iLCJlbmQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/engine.io/build/transports-uws/websocket.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/engine.io/build/transports/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/engine.io/build/transports/index.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nconst polling_1 = __webpack_require__(/*! ./polling */ \"(rsc)/./node_modules/engine.io/build/transports/polling.js\");\nconst polling_jsonp_1 = __webpack_require__(/*! ./polling-jsonp */ \"(rsc)/./node_modules/engine.io/build/transports/polling-jsonp.js\");\nconst websocket_1 = __webpack_require__(/*! ./websocket */ \"(rsc)/./node_modules/engine.io/build/transports/websocket.js\");\nconst webtransport_1 = __webpack_require__(/*! ./webtransport */ \"(rsc)/./node_modules/engine.io/build/transports/webtransport.js\");\nexports[\"default\"] = {\n    polling: polling,\n    websocket: websocket_1.WebSocket,\n    webtransport: webtransport_1.WebTransport\n};\n/**\n * Polling polymorphic constructor.\n */ function polling(req) {\n    if (\"string\" === typeof req._query.j) {\n        return new polling_jsonp_1.JSONP(req);\n    } else {\n        return new polling_1.Polling(req);\n    }\n}\npolling.upgradesTo = [\n    \"websocket\",\n    \"webtransport\"\n];\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZW5naW5lLmlvL2J1aWxkL3RyYW5zcG9ydHMvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0QsTUFBTUMsWUFBWUMsbUJBQU9BLENBQUMsNkVBQVc7QUFDckMsTUFBTUMsa0JBQWtCRCxtQkFBT0EsQ0FBQyx5RkFBaUI7QUFDakQsTUFBTUUsY0FBY0YsbUJBQU9BLENBQUMsaUZBQWE7QUFDekMsTUFBTUcsaUJBQWlCSCxtQkFBT0EsQ0FBQyx1RkFBZ0I7QUFDL0NILGtCQUFlLEdBQUc7SUFDZFEsU0FBU0E7SUFDVEMsV0FBV0osWUFBWUssU0FBUztJQUNoQ0MsY0FBY0wsZUFBZU0sWUFBWTtBQUM3QztBQUNBOztDQUVDLEdBQ0QsU0FBU0osUUFBUUssR0FBRztJQUNoQixJQUFJLGFBQWEsT0FBT0EsSUFBSUMsTUFBTSxDQUFDQyxDQUFDLEVBQUU7UUFDbEMsT0FBTyxJQUFJWCxnQkFBZ0JZLEtBQUssQ0FBQ0g7SUFDckMsT0FDSztRQUNELE9BQU8sSUFBSVgsVUFBVWUsT0FBTyxDQUFDSjtJQUNqQztBQUNKO0FBQ0FMLFFBQVFVLFVBQVUsR0FBRztJQUFDO0lBQWE7Q0FBZSIsInNvdXJjZXMiOlsid2VicGFjazovL2V4YW1yb3NoLy4vbm9kZV9tb2R1bGVzL2VuZ2luZS5pby9idWlsZC90cmFuc3BvcnRzL2luZGV4LmpzPzA3NWMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBwb2xsaW5nXzEgPSByZXF1aXJlKFwiLi9wb2xsaW5nXCIpO1xuY29uc3QgcG9sbGluZ19qc29ucF8xID0gcmVxdWlyZShcIi4vcG9sbGluZy1qc29ucFwiKTtcbmNvbnN0IHdlYnNvY2tldF8xID0gcmVxdWlyZShcIi4vd2Vic29ja2V0XCIpO1xuY29uc3Qgd2VidHJhbnNwb3J0XzEgPSByZXF1aXJlKFwiLi93ZWJ0cmFuc3BvcnRcIik7XG5leHBvcnRzLmRlZmF1bHQgPSB7XG4gICAgcG9sbGluZzogcG9sbGluZyxcbiAgICB3ZWJzb2NrZXQ6IHdlYnNvY2tldF8xLldlYlNvY2tldCxcbiAgICB3ZWJ0cmFuc3BvcnQ6IHdlYnRyYW5zcG9ydF8xLldlYlRyYW5zcG9ydCxcbn07XG4vKipcbiAqIFBvbGxpbmcgcG9seW1vcnBoaWMgY29uc3RydWN0b3IuXG4gKi9cbmZ1bmN0aW9uIHBvbGxpbmcocmVxKSB7XG4gICAgaWYgKFwic3RyaW5nXCIgPT09IHR5cGVvZiByZXEuX3F1ZXJ5LmopIHtcbiAgICAgICAgcmV0dXJuIG5ldyBwb2xsaW5nX2pzb25wXzEuSlNPTlAocmVxKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBuZXcgcG9sbGluZ18xLlBvbGxpbmcocmVxKTtcbiAgICB9XG59XG5wb2xsaW5nLnVwZ3JhZGVzVG8gPSBbXCJ3ZWJzb2NrZXRcIiwgXCJ3ZWJ0cmFuc3BvcnRcIl07XG4iXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJwb2xsaW5nXzEiLCJyZXF1aXJlIiwicG9sbGluZ19qc29ucF8xIiwid2Vic29ja2V0XzEiLCJ3ZWJ0cmFuc3BvcnRfMSIsImRlZmF1bHQiLCJwb2xsaW5nIiwid2Vic29ja2V0IiwiV2ViU29ja2V0Iiwid2VidHJhbnNwb3J0IiwiV2ViVHJhbnNwb3J0IiwicmVxIiwiX3F1ZXJ5IiwiaiIsIkpTT05QIiwiUG9sbGluZyIsInVwZ3JhZGVzVG8iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/engine.io/build/transports/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/engine.io/build/transports/polling-jsonp.js":
/*!******************************************************************!*\
  !*** ./node_modules/engine.io/build/transports/polling-jsonp.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.JSONP = void 0;\nconst polling_1 = __webpack_require__(/*! ./polling */ \"(rsc)/./node_modules/engine.io/build/transports/polling.js\");\nconst qs = __webpack_require__(/*! querystring */ \"querystring\");\nconst rDoubleSlashes = /\\\\\\\\n/g;\nconst rSlashes = /(\\\\)?\\\\n/g;\nclass JSONP extends polling_1.Polling {\n    /**\n     * JSON-P polling transport.\n     */ constructor(req){\n        super(req);\n        this.head = \"___eio[\" + (req._query.j || \"\").replace(/[^0-9]/g, \"\") + \"](\";\n        this.foot = \");\";\n    }\n    onData(data) {\n        // we leverage the qs module so that we get built-in DoS protection\n        // and the fast alternative to decodeURIComponent\n        data = qs.parse(data).d;\n        if (\"string\" === typeof data) {\n            // client will send already escaped newlines as \\\\\\\\n and newlines as \\\\n\n            // \\\\n must be replaced with \\n and \\\\\\\\n with \\\\n\n            data = data.replace(rSlashes, function(match, slashes) {\n                return slashes ? match : \"\\n\";\n            });\n            super.onData(data.replace(rDoubleSlashes, \"\\\\n\"));\n        }\n    }\n    doWrite(data, options, callback) {\n        // we must output valid javascript, not valid json\n        // see: http://timelessrepo.com/json-isnt-a-javascript-subset\n        const js = JSON.stringify(data).replace(/\\u2028/g, \"\\\\u2028\").replace(/\\u2029/g, \"\\\\u2029\");\n        // prepare response\n        data = this.head + js + this.foot;\n        super.doWrite(data, options, callback);\n    }\n}\nexports.JSONP = JSONP;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZW5naW5lLmlvL2J1aWxkL3RyYW5zcG9ydHMvcG9sbGluZy1qc29ucC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsYUFBYSxHQUFHLEtBQUs7QUFDckIsTUFBTUcsWUFBWUMsbUJBQU9BLENBQUMsNkVBQVc7QUFDckMsTUFBTUMsS0FBS0QsbUJBQU9BLENBQUMsZ0NBQWE7QUFDaEMsTUFBTUUsaUJBQWlCO0FBQ3ZCLE1BQU1DLFdBQVc7QUFDakIsTUFBTUwsY0FBY0MsVUFBVUssT0FBTztJQUNqQzs7S0FFQyxHQUNEQyxZQUFZQyxHQUFHLENBQUU7UUFDYixLQUFLLENBQUNBO1FBQ04sSUFBSSxDQUFDQyxJQUFJLEdBQUcsWUFBWSxDQUFDRCxJQUFJRSxNQUFNLENBQUNDLENBQUMsSUFBSSxFQUFDLEVBQUdDLE9BQU8sQ0FBQyxXQUFXLE1BQU07UUFDdEUsSUFBSSxDQUFDQyxJQUFJLEdBQUc7SUFDaEI7SUFDQUMsT0FBT0MsSUFBSSxFQUFFO1FBQ1QsbUVBQW1FO1FBQ25FLGlEQUFpRDtRQUNqREEsT0FBT1osR0FBR2EsS0FBSyxDQUFDRCxNQUFNRSxDQUFDO1FBQ3ZCLElBQUksYUFBYSxPQUFPRixNQUFNO1lBQzFCLHlFQUF5RTtZQUN6RSxrREFBa0Q7WUFDbERBLE9BQU9BLEtBQUtILE9BQU8sQ0FBQ1AsVUFBVSxTQUFVYSxLQUFLLEVBQUVDLE9BQU87Z0JBQ2xELE9BQU9BLFVBQVVELFFBQVE7WUFDN0I7WUFDQSxLQUFLLENBQUNKLE9BQU9DLEtBQUtILE9BQU8sQ0FBQ1IsZ0JBQWdCO1FBQzlDO0lBQ0o7SUFDQWdCLFFBQVFMLElBQUksRUFBRU0sT0FBTyxFQUFFQyxRQUFRLEVBQUU7UUFDN0Isa0RBQWtEO1FBQ2xELDZEQUE2RDtRQUM3RCxNQUFNQyxLQUFLQyxLQUFLQyxTQUFTLENBQUNWLE1BQ3JCSCxPQUFPLENBQUMsV0FBVyxXQUNuQkEsT0FBTyxDQUFDLFdBQVc7UUFDeEIsbUJBQW1CO1FBQ25CRyxPQUFPLElBQUksQ0FBQ04sSUFBSSxHQUFHYyxLQUFLLElBQUksQ0FBQ1YsSUFBSTtRQUNqQyxLQUFLLENBQUNPLFFBQVFMLE1BQU1NLFNBQVNDO0lBQ2pDO0FBQ0o7QUFDQXhCLGFBQWEsR0FBR0UiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9leGFtcm9zaC8uL25vZGVfbW9kdWxlcy9lbmdpbmUuaW8vYnVpbGQvdHJhbnNwb3J0cy9wb2xsaW5nLWpzb25wLmpzP2Q1NGMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkpTT05QID0gdm9pZCAwO1xuY29uc3QgcG9sbGluZ18xID0gcmVxdWlyZShcIi4vcG9sbGluZ1wiKTtcbmNvbnN0IHFzID0gcmVxdWlyZShcInF1ZXJ5c3RyaW5nXCIpO1xuY29uc3QgckRvdWJsZVNsYXNoZXMgPSAvXFxcXFxcXFxuL2c7XG5jb25zdCByU2xhc2hlcyA9IC8oXFxcXCk/XFxcXG4vZztcbmNsYXNzIEpTT05QIGV4dGVuZHMgcG9sbGluZ18xLlBvbGxpbmcge1xuICAgIC8qKlxuICAgICAqIEpTT04tUCBwb2xsaW5nIHRyYW5zcG9ydC5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihyZXEpIHtcbiAgICAgICAgc3VwZXIocmVxKTtcbiAgICAgICAgdGhpcy5oZWFkID0gXCJfX19laW9bXCIgKyAocmVxLl9xdWVyeS5qIHx8IFwiXCIpLnJlcGxhY2UoL1teMC05XS9nLCBcIlwiKSArIFwiXShcIjtcbiAgICAgICAgdGhpcy5mb290ID0gXCIpO1wiO1xuICAgIH1cbiAgICBvbkRhdGEoZGF0YSkge1xuICAgICAgICAvLyB3ZSBsZXZlcmFnZSB0aGUgcXMgbW9kdWxlIHNvIHRoYXQgd2UgZ2V0IGJ1aWx0LWluIERvUyBwcm90ZWN0aW9uXG4gICAgICAgIC8vIGFuZCB0aGUgZmFzdCBhbHRlcm5hdGl2ZSB0byBkZWNvZGVVUklDb21wb25lbnRcbiAgICAgICAgZGF0YSA9IHFzLnBhcnNlKGRhdGEpLmQ7XG4gICAgICAgIGlmIChcInN0cmluZ1wiID09PSB0eXBlb2YgZGF0YSkge1xuICAgICAgICAgICAgLy8gY2xpZW50IHdpbGwgc2VuZCBhbHJlYWR5IGVzY2FwZWQgbmV3bGluZXMgYXMgXFxcXFxcXFxuIGFuZCBuZXdsaW5lcyBhcyBcXFxcblxuICAgICAgICAgICAgLy8gXFxcXG4gbXVzdCBiZSByZXBsYWNlZCB3aXRoIFxcbiBhbmQgXFxcXFxcXFxuIHdpdGggXFxcXG5cbiAgICAgICAgICAgIGRhdGEgPSBkYXRhLnJlcGxhY2UoclNsYXNoZXMsIGZ1bmN0aW9uIChtYXRjaCwgc2xhc2hlcykge1xuICAgICAgICAgICAgICAgIHJldHVybiBzbGFzaGVzID8gbWF0Y2ggOiBcIlxcblwiO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzdXBlci5vbkRhdGEoZGF0YS5yZXBsYWNlKHJEb3VibGVTbGFzaGVzLCBcIlxcXFxuXCIpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBkb1dyaXRlKGRhdGEsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gICAgICAgIC8vIHdlIG11c3Qgb3V0cHV0IHZhbGlkIGphdmFzY3JpcHQsIG5vdCB2YWxpZCBqc29uXG4gICAgICAgIC8vIHNlZTogaHR0cDovL3RpbWVsZXNzcmVwby5jb20vanNvbi1pc250LWEtamF2YXNjcmlwdC1zdWJzZXRcbiAgICAgICAgY29uc3QganMgPSBKU09OLnN0cmluZ2lmeShkYXRhKVxuICAgICAgICAgICAgLnJlcGxhY2UoL1xcdTIwMjgvZywgXCJcXFxcdTIwMjhcIilcbiAgICAgICAgICAgIC5yZXBsYWNlKC9cXHUyMDI5L2csIFwiXFxcXHUyMDI5XCIpO1xuICAgICAgICAvLyBwcmVwYXJlIHJlc3BvbnNlXG4gICAgICAgIGRhdGEgPSB0aGlzLmhlYWQgKyBqcyArIHRoaXMuZm9vdDtcbiAgICAgICAgc3VwZXIuZG9Xcml0ZShkYXRhLCBvcHRpb25zLCBjYWxsYmFjayk7XG4gICAgfVxufVxuZXhwb3J0cy5KU09OUCA9IEpTT05QO1xuIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiSlNPTlAiLCJwb2xsaW5nXzEiLCJyZXF1aXJlIiwicXMiLCJyRG91YmxlU2xhc2hlcyIsInJTbGFzaGVzIiwiUG9sbGluZyIsImNvbnN0cnVjdG9yIiwicmVxIiwiaGVhZCIsIl9xdWVyeSIsImoiLCJyZXBsYWNlIiwiZm9vdCIsIm9uRGF0YSIsImRhdGEiLCJwYXJzZSIsImQiLCJtYXRjaCIsInNsYXNoZXMiLCJkb1dyaXRlIiwib3B0aW9ucyIsImNhbGxiYWNrIiwianMiLCJKU09OIiwic3RyaW5naWZ5Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/engine.io/build/transports/polling-jsonp.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/engine.io/build/transports/polling.js":
/*!************************************************************!*\
  !*** ./node_modules/engine.io/build/transports/polling.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.Polling = void 0;\nconst transport_1 = __webpack_require__(/*! ../transport */ \"(rsc)/./node_modules/engine.io/build/transport.js\");\nconst zlib_1 = __webpack_require__(/*! zlib */ \"zlib\");\nconst accepts = __webpack_require__(/*! accepts */ \"(rsc)/./node_modules/accepts/index.js\");\nconst debug_1 = __webpack_require__(/*! debug */ \"(rsc)/./node_modules/engine.io/node_modules/debug/src/index.js\");\nconst debug = (0, debug_1.default)(\"engine:polling\");\nconst compressionMethods = {\n    gzip: zlib_1.createGzip,\n    deflate: zlib_1.createDeflate\n};\nclass Polling extends transport_1.Transport {\n    /**\n     * HTTP polling constructor.\n     */ constructor(req){\n        super(req);\n        this.closeTimeout = 30 * 1000;\n    }\n    /**\n     * Transport name\n     */ get name() {\n        return \"polling\";\n    }\n    /**\n     * Overrides onRequest.\n     *\n     * @param {EngineRequest} req\n     * @package\n     */ onRequest(req) {\n        const res = req.res;\n        // remove the reference to the ServerResponse object (as the first request of the session is kept in memory by default)\n        req.res = null;\n        if (\"GET\" === req.method) {\n            this.onPollRequest(req, res);\n        } else if (\"POST\" === req.method) {\n            this.onDataRequest(req, res);\n        } else {\n            res.writeHead(500);\n            res.end();\n        }\n    }\n    /**\n     * The client sends a request awaiting for us to send data.\n     *\n     * @private\n     */ onPollRequest(req, res) {\n        if (this.req) {\n            debug(\"request overlap\");\n            // assert: this.res, '.req and .res should be (un)set together'\n            this.onError(\"overlap from client\");\n            res.writeHead(400);\n            res.end();\n            return;\n        }\n        debug(\"setting request\");\n        this.req = req;\n        this.res = res;\n        const onClose = ()=>{\n            this.onError(\"poll connection closed prematurely\");\n        };\n        const cleanup = ()=>{\n            req.removeListener(\"close\", onClose);\n            this.req = this.res = null;\n        };\n        req.cleanup = cleanup;\n        req.on(\"close\", onClose);\n        this.writable = true;\n        this.emit(\"ready\");\n        // if we're still writable but had a pending close, trigger an empty send\n        if (this.writable && this.shouldClose) {\n            debug(\"triggering empty send to append close packet\");\n            this.send([\n                {\n                    type: \"noop\"\n                }\n            ]);\n        }\n    }\n    /**\n     * The client sends a request with data.\n     *\n     * @private\n     */ onDataRequest(req, res) {\n        if (this.dataReq) {\n            // assert: this.dataRes, '.dataReq and .dataRes should be (un)set together'\n            this.onError(\"data request overlap from client\");\n            res.writeHead(400);\n            res.end();\n            return;\n        }\n        const isBinary = \"application/octet-stream\" === req.headers[\"content-type\"];\n        if (isBinary && this.protocol === 4) {\n            return this.onError(\"invalid content\");\n        }\n        this.dataReq = req;\n        this.dataRes = res;\n        let chunks = isBinary ? Buffer.concat([]) : \"\";\n        const cleanup = ()=>{\n            req.removeListener(\"data\", onData);\n            req.removeListener(\"end\", onEnd);\n            req.removeListener(\"close\", onClose);\n            this.dataReq = this.dataRes = chunks = null;\n        };\n        const onClose = ()=>{\n            cleanup();\n            this.onError(\"data request connection closed prematurely\");\n        };\n        const onData = (data)=>{\n            let contentLength;\n            if (isBinary) {\n                chunks = Buffer.concat([\n                    chunks,\n                    data\n                ]);\n                contentLength = chunks.length;\n            } else {\n                chunks += data;\n                contentLength = Buffer.byteLength(chunks);\n            }\n            if (contentLength > this.maxHttpBufferSize) {\n                res.writeHead(413).end();\n                cleanup();\n            }\n        };\n        const onEnd = ()=>{\n            this.onData(chunks);\n            const headers = {\n                // text/html is required instead of text/plain to avoid an\n                // unwanted download dialog on certain user-agents (GH-43)\n                \"Content-Type\": \"text/html\",\n                \"Content-Length\": \"2\"\n            };\n            res.writeHead(200, this.headers(req, headers));\n            res.end(\"ok\");\n            cleanup();\n        };\n        req.on(\"close\", onClose);\n        if (!isBinary) req.setEncoding(\"utf8\");\n        req.on(\"data\", onData);\n        req.on(\"end\", onEnd);\n    }\n    /**\n     * Processes the incoming data payload.\n     *\n     * @param data - encoded payload\n     * @protected\n     */ onData(data) {\n        debug('received \"%s\"', data);\n        const callback = (packet)=>{\n            if (\"close\" === packet.type) {\n                debug(\"got xhr close packet\");\n                this.onClose();\n                return false;\n            }\n            this.onPacket(packet);\n        };\n        if (this.protocol === 3) {\n            this.parser.decodePayload(data, callback);\n        } else {\n            this.parser.decodePayload(data).forEach(callback);\n        }\n    }\n    /**\n     * Overrides onClose.\n     *\n     * @private\n     */ onClose() {\n        if (this.writable) {\n            // close pending poll request\n            this.send([\n                {\n                    type: \"noop\"\n                }\n            ]);\n        }\n        super.onClose();\n    }\n    send(packets) {\n        this.writable = false;\n        if (this.shouldClose) {\n            debug(\"appending close packet to payload\");\n            packets.push({\n                type: \"close\"\n            });\n            this.shouldClose();\n            this.shouldClose = null;\n        }\n        const doWrite = (data)=>{\n            const compress = packets.some((packet)=>{\n                return packet.options && packet.options.compress;\n            });\n            this.write(data, {\n                compress\n            });\n        };\n        if (this.protocol === 3) {\n            this.parser.encodePayload(packets, this.supportsBinary, doWrite);\n        } else {\n            this.parser.encodePayload(packets, doWrite);\n        }\n    }\n    /**\n     * Writes data as response to poll request.\n     *\n     * @param {String} data\n     * @param {Object} options\n     * @private\n     */ write(data, options) {\n        debug('writing \"%s\"', data);\n        this.doWrite(data, options, ()=>{\n            this.req.cleanup();\n            this.emit(\"drain\");\n        });\n    }\n    /**\n     * Performs the write.\n     *\n     * @protected\n     */ doWrite(data, options, callback) {\n        // explicit UTF-8 is required for pages not served under utf\n        const isString = typeof data === \"string\";\n        const contentType = isString ? \"text/plain; charset=UTF-8\" : \"application/octet-stream\";\n        const headers = {\n            \"Content-Type\": contentType\n        };\n        const respond = (data)=>{\n            headers[\"Content-Length\"] = \"string\" === typeof data ? Buffer.byteLength(data) : data.length;\n            this.res.writeHead(200, this.headers(this.req, headers));\n            this.res.end(data);\n            callback();\n        };\n        if (!this.httpCompression || !options.compress) {\n            respond(data);\n            return;\n        }\n        const len = isString ? Buffer.byteLength(data) : data.length;\n        if (len < this.httpCompression.threshold) {\n            respond(data);\n            return;\n        }\n        const encoding = accepts(this.req).encodings([\n            \"gzip\",\n            \"deflate\"\n        ]);\n        if (!encoding) {\n            respond(data);\n            return;\n        }\n        this.compress(data, encoding, (err, data)=>{\n            if (err) {\n                this.res.writeHead(500);\n                this.res.end();\n                callback(err);\n                return;\n            }\n            headers[\"Content-Encoding\"] = encoding;\n            respond(data);\n        });\n    }\n    /**\n     * Compresses data.\n     *\n     * @private\n     */ compress(data, encoding, callback) {\n        debug(\"compressing\");\n        const buffers = [];\n        let nread = 0;\n        compressionMethods[encoding](this.httpCompression).on(\"error\", callback).on(\"data\", function(chunk) {\n            buffers.push(chunk);\n            nread += chunk.length;\n        }).on(\"end\", function() {\n            callback(null, Buffer.concat(buffers, nread));\n        }).end(data);\n    }\n    /**\n     * Closes the transport.\n     *\n     * @private\n     */ doClose(fn) {\n        debug(\"closing\");\n        let closeTimeoutTimer;\n        if (this.dataReq) {\n            debug(\"aborting ongoing data request\");\n            this.dataReq.destroy();\n        }\n        const onClose = ()=>{\n            clearTimeout(closeTimeoutTimer);\n            fn();\n            this.onClose();\n        };\n        if (this.writable) {\n            debug(\"transport writable - closing right away\");\n            this.send([\n                {\n                    type: \"close\"\n                }\n            ]);\n            onClose();\n        } else if (this.discarded) {\n            debug(\"transport discarded - closing right away\");\n            onClose();\n        } else {\n            debug(\"transport not writable - buffering orderly close\");\n            this.shouldClose = onClose;\n            closeTimeoutTimer = setTimeout(onClose, this.closeTimeout);\n        }\n    }\n    /**\n     * Returns headers for a response.\n     *\n     * @param {http.IncomingMessage} req\n     * @param {Object} headers - extra headers\n     * @private\n     */ headers(req, headers = {}) {\n        // prevent XSS warnings on IE\n        // https://github.com/LearnBoost/socket.io/pull/1333\n        const ua = req.headers[\"user-agent\"];\n        if (ua && (~ua.indexOf(\";MSIE\") || ~ua.indexOf(\"Trident/\"))) {\n            headers[\"X-XSS-Protection\"] = \"0\";\n        }\n        headers[\"cache-control\"] = \"no-store\";\n        this.emit(\"headers\", headers, req);\n        return headers;\n    }\n}\nexports.Polling = Polling;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZW5naW5lLmlvL2J1aWxkL3RyYW5zcG9ydHMvcG9sbGluZy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsZUFBZSxHQUFHLEtBQUs7QUFDdkIsTUFBTUcsY0FBY0MsbUJBQU9BLENBQUMsdUVBQWM7QUFDMUMsTUFBTUMsU0FBU0QsbUJBQU9BLENBQUMsa0JBQU07QUFDN0IsTUFBTUUsVUFBVUYsbUJBQU9BLENBQUMsc0RBQVM7QUFDakMsTUFBTUcsVUFBVUgsbUJBQU9BLENBQUMsNkVBQU87QUFDL0IsTUFBTUksUUFBUSxDQUFDLEdBQUdELFFBQVFFLE9BQU8sRUFBRTtBQUNuQyxNQUFNQyxxQkFBcUI7SUFDdkJDLE1BQU1OLE9BQU9PLFVBQVU7SUFDdkJDLFNBQVNSLE9BQU9TLGFBQWE7QUFDakM7QUFDQSxNQUFNWixnQkFBZ0JDLFlBQVlZLFNBQVM7SUFDdkM7O0tBRUMsR0FDREMsWUFBWUMsR0FBRyxDQUFFO1FBQ2IsS0FBSyxDQUFDQTtRQUNOLElBQUksQ0FBQ0MsWUFBWSxHQUFHLEtBQUs7SUFDN0I7SUFDQTs7S0FFQyxHQUNELElBQUlDLE9BQU87UUFDUCxPQUFPO0lBQ1g7SUFDQTs7Ozs7S0FLQyxHQUNEQyxVQUFVSCxHQUFHLEVBQUU7UUFDWCxNQUFNSSxNQUFNSixJQUFJSSxHQUFHO1FBQ25CLHVIQUF1SDtRQUN2SEosSUFBSUksR0FBRyxHQUFHO1FBQ1YsSUFBSSxVQUFVSixJQUFJSyxNQUFNLEVBQUU7WUFDdEIsSUFBSSxDQUFDQyxhQUFhLENBQUNOLEtBQUtJO1FBQzVCLE9BQ0ssSUFBSSxXQUFXSixJQUFJSyxNQUFNLEVBQUU7WUFDNUIsSUFBSSxDQUFDRSxhQUFhLENBQUNQLEtBQUtJO1FBQzVCLE9BQ0s7WUFDREEsSUFBSUksU0FBUyxDQUFDO1lBQ2RKLElBQUlLLEdBQUc7UUFDWDtJQUNKO0lBQ0E7Ozs7S0FJQyxHQUNESCxjQUFj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LElBQUksQ0FBQzdDLE9BQU8sRUFBRTtZQUNkN0IsTUFBTTtZQUNOLElBQUksQ0FBQzZCLE9BQU8sQ0FBQzhDLE9BQU87UUFDeEI7UUFDQSxNQUFNdkQsVUFBVTtZQUNad0QsYUFBYUY7WUFDYkQ7WUFDQSxJQUFJLENBQUNyRCxPQUFPO1FBQ2hCO1FBQ0EsSUFBSSxJQUFJLENBQUNJLFFBQVEsRUFBRTtZQUNmeEIsTUFBTTtZQUNOLElBQUksQ0FBQzJCLElBQUksQ0FBQztnQkFBQztvQkFBRUMsTUFBTTtnQkFBUTthQUFFO1lBQzdCUjtRQUNKLE9BQ0ssSUFBSSxJQUFJLENBQUN5RCxTQUFTLEVBQUU7WUFDckI3RSxNQUFNO1lBQ05vQjtRQUNKLE9BQ0s7WUFDRHBCLE1BQU07WUFDTixJQUFJLENBQUMwQixXQUFXLEdBQUdOO1lBQ25Cc0Qsb0JBQW9CSSxXQUFXMUQsU0FBUyxJQUFJLENBQUNWLFlBQVk7UUFDN0Q7SUFDSjtJQUNBOzs7Ozs7S0FNQyxHQUNEcUIsUUFBUXRCLEdBQUcsRUFBRXNCLFVBQVUsQ0FBQyxDQUFDLEVBQUU7UUFDdkIsNkJBQTZCO1FBQzdCLG9EQUFvRDtRQUNwRCxNQUFNZ0QsS0FBS3RFLElBQUlzQixPQUFPLENBQUMsYUFBYTtRQUNwQyxJQUFJZ0QsTUFBTyxFQUFDQSxHQUFHQyxPQUFPLENBQUMsWUFBWSxDQUFDRCxHQUFHQyxPQUFPLENBQUMsV0FBVSxHQUFJO1lBQ3pEakQsT0FBTyxDQUFDLG1CQUFtQixHQUFHO1FBQ2xDO1FBQ0FBLE9BQU8sQ0FBQyxnQkFBZ0IsR0FBRztRQUMzQixJQUFJLENBQUNOLElBQUksQ0FBQyxXQUFXTSxTQUFTdEI7UUFDOUIsT0FBT3NCO0lBQ1g7QUFDSjtBQUNBdkMsZUFBZSxHQUFHRSIsInNvdXJjZXMiOlsid2VicGFjazovL2V4YW1yb3NoLy4vbm9kZV9tb2R1bGVzL2VuZ2luZS5pby9idWlsZC90cmFuc3BvcnRzL3BvbGxpbmcuanM/ZDQ3ZSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuUG9sbGluZyA9IHZvaWQgMDtcbmNvbnN0IHRyYW5zcG9ydF8xID0gcmVxdWlyZShcIi4uL3RyYW5zcG9ydFwiKTtcbmNvbnN0IHpsaWJfMSA9IHJlcXVpcmUoXCJ6bGliXCIpO1xuY29uc3QgYWNjZXB0cyA9IHJlcXVpcmUoXCJhY2NlcHRzXCIpO1xuY29uc3QgZGVidWdfMSA9IHJlcXVpcmUoXCJkZWJ1Z1wiKTtcbmNvbnN0IGRlYnVnID0gKDAsIGRlYnVnXzEuZGVmYXVsdCkoXCJlbmdpbmU6cG9sbGluZ1wiKTtcbmNvbnN0IGNvbXByZXNzaW9uTWV0aG9kcyA9IHtcbiAgICBnemlwOiB6bGliXzEuY3JlYXRlR3ppcCxcbiAgICBkZWZsYXRlOiB6bGliXzEuY3JlYXRlRGVmbGF0ZSxcbn07XG5jbGFzcyBQb2xsaW5nIGV4dGVuZHMgdHJhbnNwb3J0XzEuVHJhbnNwb3J0IHtcbiAgICAvKipcbiAgICAgKiBIVFRQIHBvbGxpbmcgY29uc3RydWN0b3IuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IocmVxKSB7XG4gICAgICAgIHN1cGVyKHJlcSk7XG4gICAgICAgIHRoaXMuY2xvc2VUaW1lb3V0ID0gMzAgKiAxMDAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUcmFuc3BvcnQgbmFtZVxuICAgICAqL1xuICAgIGdldCBuYW1lKCkge1xuICAgICAgICByZXR1cm4gXCJwb2xsaW5nXCI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE92ZXJyaWRlcyBvblJlcXVlc3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0VuZ2luZVJlcXVlc3R9IHJlcVxuICAgICAqIEBwYWNrYWdlXG4gICAgICovXG4gICAgb25SZXF1ZXN0KHJlcSkge1xuICAgICAgICBjb25zdCByZXMgPSByZXEucmVzO1xuICAgICAgICAvLyByZW1vdmUgdGhlIHJlZmVyZW5jZSB0byB0aGUgU2VydmVyUmVzcG9uc2Ugb2JqZWN0IChhcyB0aGUgZmlyc3QgcmVxdWVzdCBvZiB0aGUgc2Vzc2lvbiBpcyBrZXB0IGluIG1lbW9yeSBieSBkZWZhdWx0KVxuICAgICAgICByZXEucmVzID0gbnVsbDtcbiAgICAgICAgaWYgKFwiR0VUXCIgPT09IHJlcS5tZXRob2QpIHtcbiAgICAgICAgICAgIHRoaXMub25Qb2xsUmVxdWVzdChyZXEsIHJlcyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoXCJQT1NUXCIgPT09IHJlcS5tZXRob2QpIHtcbiAgICAgICAgICAgIHRoaXMub25EYXRhUmVxdWVzdChyZXEsIHJlcyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXMud3JpdGVIZWFkKDUwMCk7XG4gICAgICAgICAgICByZXMuZW5kKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIGNsaWVudCBzZW5kcyBhIHJlcXVlc3QgYXdhaXRpbmcgZm9yIHVzIHRvIHNlbmQgZGF0YS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgb25Qb2xsUmVxdWVzdChyZXEsIHJlcykge1xuICAgICAgICBpZiAodGhpcy5yZXEpIHtcbiAgICAgICAgICAgIGRlYnVnKFwicmVxdWVzdCBvdmVybGFwXCIpO1xuICAgICAgICAgICAgLy8gYXNzZXJ0OiB0aGlzLnJlcywgJy5yZXEgYW5kIC5yZXMgc2hvdWxkIGJlICh1bilzZXQgdG9nZXRoZXInXG4gICAgICAgICAgICB0aGlzLm9uRXJyb3IoXCJvdmVybGFwIGZyb20gY2xpZW50XCIpO1xuICAgICAgICAgICAgcmVzLndyaXRlSGVhZCg0MDApO1xuICAgICAgICAgICAgcmVzLmVuZCgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGRlYnVnKFwic2V0dGluZyByZXF1ZXN0XCIpO1xuICAgICAgICB0aGlzLnJlcSA9IHJlcTtcbiAgICAgICAgdGhpcy5yZXMgPSByZXM7XG4gICAgICAgIGNvbnN0IG9uQ2xvc2UgPSAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLm9uRXJyb3IoXCJwb2xsIGNvbm5lY3Rpb24gY2xvc2VkIHByZW1hdHVyZWx5XCIpO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBjbGVhbnVwID0gKCkgPT4ge1xuICAgICAgICAgICAgcmVxLnJlbW92ZUxpc3RlbmVyKFwiY2xvc2VcIiwgb25DbG9zZSk7XG4gICAgICAgICAgICB0aGlzLnJlcSA9IHRoaXMucmVzID0gbnVsbDtcbiAgICAgICAgfTtcbiAgICAgICAgcmVxLmNsZWFudXAgPSBjbGVhbnVwO1xuICAgICAgICByZXEub24oXCJjbG9zZVwiLCBvbkNsb3NlKTtcbiAgICAgICAgdGhpcy53cml0YWJsZSA9IHRydWU7XG4gICAgICAgIHRoaXMuZW1pdChcInJlYWR5XCIpO1xuICAgICAgICAvLyBpZiB3ZSdyZSBzdGlsbCB3cml0YWJsZSBidXQgaGFkIGEgcGVuZGluZyBjbG9zZSwgdHJpZ2dlciBhbiBlbXB0eSBzZW5kXG4gICAgICAgIGlmICh0aGlzLndyaXRhYmxlICYmIHRoaXMuc2hvdWxkQ2xvc2UpIHtcbiAgICAgICAgICAgIGRlYnVnKFwidHJpZ2dlcmluZyBlbXB0eSBzZW5kIHRvIGFwcGVuZCBjbG9zZSBwYWNrZXRcIik7XG4gICAgICAgICAgICB0aGlzLnNlbmQoW3sgdHlwZTogXCJub29wXCIgfV0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBjbGllbnQgc2VuZHMgYSByZXF1ZXN0IHdpdGggZGF0YS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgb25EYXRhUmVxdWVzdChyZXEsIHJlcykge1xuICAgICAgICBpZiAodGhpcy5kYXRhUmVxKSB7XG4gICAgICAgICAgICAvLyBhc3NlcnQ6IHRoaXMuZGF0YVJlcywgJy5kYXRhUmVxIGFuZCAuZGF0YVJlcyBzaG91bGQgYmUgKHVuKXNldCB0b2dldGhlcidcbiAgICAgICAgICAgIHRoaXMub25FcnJvcihcImRhdGEgcmVxdWVzdCBvdmVybGFwIGZyb20gY2xpZW50XCIpO1xuICAgICAgICAgICAgcmVzLndyaXRlSGVhZCg0MDApO1xuICAgICAgICAgICAgcmVzLmVuZCgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGlzQmluYXJ5ID0gXCJhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW1cIiA9PT0gcmVxLmhlYWRlcnNbXCJjb250ZW50LXR5cGVcIl07XG4gICAgICAgIGlmIChpc0JpbmFyeSAmJiB0aGlzLnByb3RvY29sID09PSA0KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5vbkVycm9yKFwiaW52YWxpZCBjb250ZW50XCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGF0YVJlcSA9IHJlcTtcbiAgICAgICAgdGhpcy5kYXRhUmVzID0gcmVzO1xuICAgICAgICBsZXQgY2h1bmtzID0gaXNCaW5hcnkgPyBCdWZmZXIuY29uY2F0KFtdKSA6IFwiXCI7XG4gICAgICAgIGNvbnN0IGNsZWFudXAgPSAoKSA9PiB7XG4gICAgICAgICAgICByZXEucmVtb3ZlTGlzdGVuZXIoXCJkYXRhXCIsIG9uRGF0YSk7XG4gICAgICAgICAgICByZXEucmVtb3ZlTGlzdGVuZXIoXCJlbmRcIiwgb25FbmQpO1xuICAgICAgICAgICAgcmVxLnJlbW92ZUxpc3RlbmVyKFwiY2xvc2VcIiwgb25DbG9zZSk7XG4gICAgICAgICAgICB0aGlzLmRhdGFSZXEgPSB0aGlzLmRhdGFSZXMgPSBjaHVua3MgPSBudWxsO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBvbkNsb3NlID0gKCkgPT4ge1xuICAgICAgICAgICAgY2xlYW51cCgpO1xuICAgICAgICAgICAgdGhpcy5vbkVycm9yKFwiZGF0YSByZXF1ZXN0IGNvbm5lY3Rpb24gY2xvc2VkIHByZW1hdHVyZWx5XCIpO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBvbkRhdGEgPSAoZGF0YSkgPT4ge1xuICAgICAgICAgICAgbGV0IGNvbnRlbnRMZW5ndGg7XG4gICAgICAgICAgICBpZiAoaXNCaW5hcnkpIHtcbiAgICAgICAgICAgICAgICBjaHVua3MgPSBCdWZmZXIuY29uY2F0KFtjaHVua3MsIGRhdGFdKTtcbiAgICAgICAgICAgICAgICBjb250ZW50TGVuZ3RoID0gY2h1bmtzLmxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNodW5rcyArPSBkYXRhO1xuICAgICAgICAgICAgICAgIGNvbnRlbnRMZW5ndGggPSBCdWZmZXIuYnl0ZUxlbmd0aChjaHVua3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNvbnRlbnRMZW5ndGggPiB0aGlzLm1heEh0dHBCdWZmZXJTaXplKSB7XG4gICAgICAgICAgICAgICAgcmVzLndyaXRlSGVhZCg0MTMpLmVuZCgpO1xuICAgICAgICAgICAgICAgIGNsZWFudXAoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgY29uc3Qgb25FbmQgPSAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLm9uRGF0YShjaHVua3MpO1xuICAgICAgICAgICAgY29uc3QgaGVhZGVycyA9IHtcbiAgICAgICAgICAgICAgICAvLyB0ZXh0L2h0bWwgaXMgcmVxdWlyZWQgaW5zdGVhZCBvZiB0ZXh0L3BsYWluIHRvIGF2b2lkIGFuXG4gICAgICAgICAgICAgICAgLy8gdW53YW50ZWQgZG93bmxvYWQgZGlhbG9nIG9uIGNlcnRhaW4gdXNlci1hZ2VudHMgKEdILTQzKVxuICAgICAgICAgICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwidGV4dC9odG1sXCIsXG4gICAgICAgICAgICAgICAgXCJDb250ZW50LUxlbmd0aFwiOiBcIjJcIixcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXMud3JpdGVIZWFkKDIwMCwgdGhpcy5oZWFkZXJzKHJlcSwgaGVhZGVycykpO1xuICAgICAgICAgICAgcmVzLmVuZChcIm9rXCIpO1xuICAgICAgICAgICAgY2xlYW51cCgpO1xuICAgICAgICB9O1xuICAgICAgICByZXEub24oXCJjbG9zZVwiLCBvbkNsb3NlKTtcbiAgICAgICAgaWYgKCFpc0JpbmFyeSlcbiAgICAgICAgICAgIHJlcS5zZXRFbmNvZGluZyhcInV0ZjhcIik7XG4gICAgICAgIHJlcS5vbihcImRhdGFcIiwgb25EYXRhKTtcbiAgICAgICAgcmVxLm9uKFwiZW5kXCIsIG9uRW5kKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUHJvY2Vzc2VzIHRoZSBpbmNvbWluZyBkYXRhIHBheWxvYWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZGF0YSAtIGVuY29kZWQgcGF5bG9hZFxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBvbkRhdGEoZGF0YSkge1xuICAgICAgICBkZWJ1ZygncmVjZWl2ZWQgXCIlc1wiJywgZGF0YSk7XG4gICAgICAgIGNvbnN0IGNhbGxiYWNrID0gKHBhY2tldCkgPT4ge1xuICAgICAgICAgICAgaWYgKFwiY2xvc2VcIiA9PT0gcGFja2V0LnR5cGUpIHtcbiAgICAgICAgICAgICAgICBkZWJ1ZyhcImdvdCB4aHIgY2xvc2UgcGFja2V0XCIpO1xuICAgICAgICAgICAgICAgIHRoaXMub25DbG9zZSgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMub25QYWNrZXQocGFja2V0KTtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHRoaXMucHJvdG9jb2wgPT09IDMpIHtcbiAgICAgICAgICAgIHRoaXMucGFyc2VyLmRlY29kZVBheWxvYWQoZGF0YSwgY2FsbGJhY2spO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5wYXJzZXIuZGVjb2RlUGF5bG9hZChkYXRhKS5mb3JFYWNoKGNhbGxiYWNrKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBPdmVycmlkZXMgb25DbG9zZS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgb25DbG9zZSgpIHtcbiAgICAgICAgaWYgKHRoaXMud3JpdGFibGUpIHtcbiAgICAgICAgICAgIC8vIGNsb3NlIHBlbmRpbmcgcG9sbCByZXF1ZXN0XG4gICAgICAgICAgICB0aGlzLnNlbmQoW3sgdHlwZTogXCJub29wXCIgfV0pO1xuICAgICAgICB9XG4gICAgICAgIHN1cGVyLm9uQ2xvc2UoKTtcbiAgICB9XG4gICAgc2VuZChwYWNrZXRzKSB7XG4gICAgICAgIHRoaXMud3JpdGFibGUgPSBmYWxzZTtcbiAgICAgICAgaWYgKHRoaXMuc2hvdWxkQ2xvc2UpIHtcbiAgICAgICAgICAgIGRlYnVnKFwiYXBwZW5kaW5nIGNsb3NlIHBhY2tldCB0byBwYXlsb2FkXCIpO1xuICAgICAgICAgICAgcGFja2V0cy5wdXNoKHsgdHlwZTogXCJjbG9zZVwiIH0pO1xuICAgICAgICAgICAgdGhpcy5zaG91bGRDbG9zZSgpO1xuICAgICAgICAgICAgdGhpcy5zaG91bGRDbG9zZSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZG9Xcml0ZSA9IChkYXRhKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBjb21wcmVzcyA9IHBhY2tldHMuc29tZSgocGFja2V0KSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhY2tldC5vcHRpb25zICYmIHBhY2tldC5vcHRpb25zLmNvbXByZXNzO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLndyaXRlKGRhdGEsIHsgY29tcHJlc3MgfSk7XG4gICAgICAgIH07XG4gICAgICAgIGlmICh0aGlzLnByb3RvY29sID09PSAzKSB7XG4gICAgICAgICAgICB0aGlzLnBhcnNlci5lbmNvZGVQYXlsb2FkKHBhY2tldHMsIHRoaXMuc3VwcG9ydHNCaW5hcnksIGRvV3JpdGUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5wYXJzZXIuZW5jb2RlUGF5bG9hZChwYWNrZXRzLCBkb1dyaXRlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBXcml0ZXMgZGF0YSBhcyByZXNwb25zZSB0byBwb2xsIHJlcXVlc3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZGF0YVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB3cml0ZShkYXRhLCBvcHRpb25zKSB7XG4gICAgICAgIGRlYnVnKCd3cml0aW5nIFwiJXNcIicsIGRhdGEpO1xuICAgICAgICB0aGlzLmRvV3JpdGUoZGF0YSwgb3B0aW9ucywgKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5yZXEuY2xlYW51cCgpO1xuICAgICAgICAgICAgdGhpcy5lbWl0KFwiZHJhaW5cIik7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQZXJmb3JtcyB0aGUgd3JpdGUuXG4gICAgICpcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgZG9Xcml0ZShkYXRhLCBvcHRpb25zLCBjYWxsYmFjaykge1xuICAgICAgICAvLyBleHBsaWNpdCBVVEYtOCBpcyByZXF1aXJlZCBmb3IgcGFnZXMgbm90IHNlcnZlZCB1bmRlciB1dGZcbiAgICAgICAgY29uc3QgaXNTdHJpbmcgPSB0eXBlb2YgZGF0YSA9PT0gXCJzdHJpbmdcIjtcbiAgICAgICAgY29uc3QgY29udGVudFR5cGUgPSBpc1N0cmluZ1xuICAgICAgICAgICAgPyBcInRleHQvcGxhaW47IGNoYXJzZXQ9VVRGLThcIlxuICAgICAgICAgICAgOiBcImFwcGxpY2F0aW9uL29jdGV0LXN0cmVhbVwiO1xuICAgICAgICBjb25zdCBoZWFkZXJzID0ge1xuICAgICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogY29udGVudFR5cGUsXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHJlc3BvbmQgPSAoZGF0YSkgPT4ge1xuICAgICAgICAgICAgaGVhZGVyc1tcIkNvbnRlbnQtTGVuZ3RoXCJdID1cbiAgICAgICAgICAgICAgICBcInN0cmluZ1wiID09PSB0eXBlb2YgZGF0YSA/IEJ1ZmZlci5ieXRlTGVuZ3RoKGRhdGEpIDogZGF0YS5sZW5ndGg7XG4gICAgICAgICAgICB0aGlzLnJlcy53cml0ZUhlYWQoMjAwLCB0aGlzLmhlYWRlcnModGhpcy5yZXEsIGhlYWRlcnMpKTtcbiAgICAgICAgICAgIHRoaXMucmVzLmVuZChkYXRhKTtcbiAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgIH07XG4gICAgICAgIGlmICghdGhpcy5odHRwQ29tcHJlc3Npb24gfHwgIW9wdGlvbnMuY29tcHJlc3MpIHtcbiAgICAgICAgICAgIHJlc3BvbmQoZGF0YSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbGVuID0gaXNTdHJpbmcgPyBCdWZmZXIuYnl0ZUxlbmd0aChkYXRhKSA6IGRhdGEubGVuZ3RoO1xuICAgICAgICBpZiAobGVuIDwgdGhpcy5odHRwQ29tcHJlc3Npb24udGhyZXNob2xkKSB7XG4gICAgICAgICAgICByZXNwb25kKGRhdGEpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGVuY29kaW5nID0gYWNjZXB0cyh0aGlzLnJlcSkuZW5jb2RpbmdzKFtcImd6aXBcIiwgXCJkZWZsYXRlXCJdKTtcbiAgICAgICAgaWYgKCFlbmNvZGluZykge1xuICAgICAgICAgICAgcmVzcG9uZChkYXRhKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNvbXByZXNzKGRhdGEsIGVuY29kaW5nLCAoZXJyLCBkYXRhKSA9PiB7XG4gICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXMud3JpdGVIZWFkKDUwMCk7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXMuZW5kKCk7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBoZWFkZXJzW1wiQ29udGVudC1FbmNvZGluZ1wiXSA9IGVuY29kaW5nO1xuICAgICAgICAgICAgcmVzcG9uZChkYXRhKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbXByZXNzZXMgZGF0YS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgY29tcHJlc3MoZGF0YSwgZW5jb2RpbmcsIGNhbGxiYWNrKSB7XG4gICAgICAgIGRlYnVnKFwiY29tcHJlc3NpbmdcIik7XG4gICAgICAgIGNvbnN0IGJ1ZmZlcnMgPSBbXTtcbiAgICAgICAgbGV0IG5yZWFkID0gMDtcbiAgICAgICAgY29tcHJlc3Npb25NZXRob2RzW2VuY29kaW5nXSh0aGlzLmh0dHBDb21wcmVzc2lvbilcbiAgICAgICAgICAgIC5vbihcImVycm9yXCIsIGNhbGxiYWNrKVxuICAgICAgICAgICAgLm9uKFwiZGF0YVwiLCBmdW5jdGlvbiAoY2h1bmspIHtcbiAgICAgICAgICAgIGJ1ZmZlcnMucHVzaChjaHVuayk7XG4gICAgICAgICAgICBucmVhZCArPSBjaHVuay5sZW5ndGg7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAub24oXCJlbmRcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgQnVmZmVyLmNvbmNhdChidWZmZXJzLCBucmVhZCkpO1xuICAgICAgICB9KVxuICAgICAgICAgICAgLmVuZChkYXRhKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2xvc2VzIHRoZSB0cmFuc3BvcnQuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGRvQ2xvc2UoZm4pIHtcbiAgICAgICAgZGVidWcoXCJjbG9zaW5nXCIpO1xuICAgICAgICBsZXQgY2xvc2VUaW1lb3V0VGltZXI7XG4gICAgICAgIGlmICh0aGlzLmRhdGFSZXEpIHtcbiAgICAgICAgICAgIGRlYnVnKFwiYWJvcnRpbmcgb25nb2luZyBkYXRhIHJlcXVlc3RcIik7XG4gICAgICAgICAgICB0aGlzLmRhdGFSZXEuZGVzdHJveSgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG9uQ2xvc2UgPSAoKSA9PiB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQoY2xvc2VUaW1lb3V0VGltZXIpO1xuICAgICAgICAgICAgZm4oKTtcbiAgICAgICAgICAgIHRoaXMub25DbG9zZSgpO1xuICAgICAgICB9O1xuICAgICAgICBpZiAodGhpcy53cml0YWJsZSkge1xuICAgICAgICAgICAgZGVidWcoXCJ0cmFuc3BvcnQgd3JpdGFibGUgLSBjbG9zaW5nIHJpZ2h0IGF3YXlcIik7XG4gICAgICAgICAgICB0aGlzLnNlbmQoW3sgdHlwZTogXCJjbG9zZVwiIH1dKTtcbiAgICAgICAgICAgIG9uQ2xvc2UoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLmRpc2NhcmRlZCkge1xuICAgICAgICAgICAgZGVidWcoXCJ0cmFuc3BvcnQgZGlzY2FyZGVkIC0gY2xvc2luZyByaWdodCBhd2F5XCIpO1xuICAgICAgICAgICAgb25DbG9zZSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZGVidWcoXCJ0cmFuc3BvcnQgbm90IHdyaXRhYmxlIC0gYnVmZmVyaW5nIG9yZGVybHkgY2xvc2VcIik7XG4gICAgICAgICAgICB0aGlzLnNob3VsZENsb3NlID0gb25DbG9zZTtcbiAgICAgICAgICAgIGNsb3NlVGltZW91dFRpbWVyID0gc2V0VGltZW91dChvbkNsb3NlLCB0aGlzLmNsb3NlVGltZW91dCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBoZWFkZXJzIGZvciBhIHJlc3BvbnNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtodHRwLkluY29taW5nTWVzc2FnZX0gcmVxXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGhlYWRlcnMgLSBleHRyYSBoZWFkZXJzXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBoZWFkZXJzKHJlcSwgaGVhZGVycyA9IHt9KSB7XG4gICAgICAgIC8vIHByZXZlbnQgWFNTIHdhcm5pbmdzIG9uIElFXG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9MZWFybkJvb3N0L3NvY2tldC5pby9wdWxsLzEzMzNcbiAgICAgICAgY29uc3QgdWEgPSByZXEuaGVhZGVyc1tcInVzZXItYWdlbnRcIl07XG4gICAgICAgIGlmICh1YSAmJiAofnVhLmluZGV4T2YoXCI7TVNJRVwiKSB8fCB+dWEuaW5kZXhPZihcIlRyaWRlbnQvXCIpKSkge1xuICAgICAgICAgICAgaGVhZGVyc1tcIlgtWFNTLVByb3RlY3Rpb25cIl0gPSBcIjBcIjtcbiAgICAgICAgfVxuICAgICAgICBoZWFkZXJzW1wiY2FjaGUtY29udHJvbFwiXSA9IFwibm8tc3RvcmVcIjtcbiAgICAgICAgdGhpcy5lbWl0KFwiaGVhZGVyc1wiLCBoZWFkZXJzLCByZXEpO1xuICAgICAgICByZXR1cm4gaGVhZGVycztcbiAgICB9XG59XG5leHBvcnRzLlBvbGxpbmcgPSBQb2xsaW5nO1xuIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiUG9sbGluZyIsInRyYW5zcG9ydF8xIiwicmVxdWlyZSIsInpsaWJfMSIsImFjY2VwdHMiLCJkZWJ1Z18xIiwiZGVidWciLCJkZWZhdWx0IiwiY29tcHJlc3Npb25NZXRob2RzIiwiZ3ppcCIsImNyZWF0ZUd6aXAiLCJkZWZsYXRlIiwiY3JlYXRlRGVmbGF0ZSIsIlRyYW5zcG9ydCIsImNvbnN0cnVjdG9yIiwicmVxIiwiY2xvc2VUaW1lb3V0IiwibmFtZSIsIm9uUmVxdWVzdCIsInJlcyIsIm1ldGhvZCIsIm9uUG9sbFJlcXVlc3QiLCJvbkRhdGFSZXF1ZXN0Iiwid3JpdGVIZWFkIiwiZW5kIiwib25FcnJvciIsIm9uQ2xvc2UiLCJjbGVhbnVwIiwicmVtb3ZlTGlzdGVuZXIiLCJvbiIsIndyaXRhYmxlIiwiZW1pdCIsInNob3VsZENsb3NlIiwic2VuZCIsInR5cGUiLCJkYXRhUmVxIiwiaXNCaW5hcnkiLCJoZWFkZXJzIiwicHJvdG9jb2wiLCJkYXRhUmVzIiwiY2h1bmtzIiwiQnVmZmVyIiwiY29uY2F0Iiwib25EYXRhIiwib25FbmQiLCJkYXRhIiwiY29udGVudExlbmd0aCIsImxlbmd0aCIsImJ5dGVMZW5ndGgiLCJtYXhIdHRwQnVmZmVyU2l6ZSIsInNldEVuY29kaW5nIiwiY2FsbGJhY2siLCJwYWNrZXQiLCJvblBhY2tldCIsInBhcnNlciIsImRlY29kZVBheWxvYWQiLCJmb3JFYWNoIiwicGFja2V0cyIsInB1c2giLCJkb1dyaXRlIiwiY29tcHJlc3MiLCJzb21lIiwib3B0aW9ucyIsIndyaXRlIiwiZW5jb2RlUGF5bG9hZCIsInN1cHBvcnRzQmluYXJ5IiwiaXNTdHJpbmciLCJjb250ZW50VHlwZSIsInJlc3BvbmQiLCJodHRwQ29tcHJlc3Npb24iLCJsZW4iLCJ0aHJlc2hvbGQiLCJlbmNvZGluZyIsImVuY29kaW5ncyIsImVyciIsImJ1ZmZlcnMiLCJucmVhZCIsImNodW5rIiwiZG9DbG9zZSIsImZuIiwiY2xvc2VUaW1lb3V0VGltZXIiLCJkZXN0cm95IiwiY2xlYXJUaW1lb3V0IiwiZGlzY2FyZGVkIiwic2V0VGltZW91dCIsInVhIiwiaW5kZXhPZiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/engine.io/build/transports/polling.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/engine.io/build/transports/websocket.js":
/*!**************************************************************!*\
  !*** ./node_modules/engine.io/build/transports/websocket.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.WebSocket = void 0;\nconst transport_1 = __webpack_require__(/*! ../transport */ \"(rsc)/./node_modules/engine.io/build/transport.js\");\nconst debug_1 = __webpack_require__(/*! debug */ \"(rsc)/./node_modules/engine.io/node_modules/debug/src/index.js\");\nconst debug = (0, debug_1.default)(\"engine:ws\");\nclass WebSocket extends transport_1.Transport {\n    /**\n     * WebSocket transport\n     *\n     * @param {EngineRequest} req\n     */ constructor(req){\n        super(req);\n        this._doSend = (data)=>{\n            this.socket.send(data, this._onSent);\n        };\n        this._doSendLast = (data)=>{\n            this.socket.send(data, this._onSentLast);\n        };\n        this._onSent = (err)=>{\n            if (err) {\n                this.onError(\"write error\", err.stack);\n            }\n        };\n        this._onSentLast = (err)=>{\n            if (err) {\n                this.onError(\"write error\", err.stack);\n            } else {\n                this.emit(\"drain\");\n                this.writable = true;\n                this.emit(\"ready\");\n            }\n        };\n        this.socket = req.websocket;\n        this.socket.on(\"message\", (data, isBinary)=>{\n            const message = isBinary ? data : data.toString();\n            debug('received \"%s\"', message);\n            super.onData(message);\n        });\n        this.socket.once(\"close\", this.onClose.bind(this));\n        this.socket.on(\"error\", this.onError.bind(this));\n        this.writable = true;\n        this.perMessageDeflate = null;\n    }\n    /**\n     * Transport name\n     */ get name() {\n        return \"websocket\";\n    }\n    /**\n     * Advertise upgrade support.\n     */ get handlesUpgrades() {\n        return true;\n    }\n    send(packets) {\n        this.writable = false;\n        for(let i = 0; i < packets.length; i++){\n            const packet = packets[i];\n            const isLast = i + 1 === packets.length;\n            if (this._canSendPreEncodedFrame(packet)) {\n                // the WebSocket frame was computed with WebSocket.Sender.frame()\n                // see https://github.com/websockets/ws/issues/617#issuecomment-283002469\n                this.socket._sender.sendFrame(// @ts-ignore\n                packet.options.wsPreEncodedFrame, isLast ? this._onSentLast : this._onSent);\n            } else {\n                this.parser.encodePacket(packet, this.supportsBinary, isLast ? this._doSendLast : this._doSend);\n            }\n        }\n    }\n    /**\n     * Whether the encoding of the WebSocket frame can be skipped.\n     * @param packet\n     * @private\n     */ _canSendPreEncodedFrame(packet) {\n        var _a, _b, _c;\n        return !this.perMessageDeflate && typeof ((_b = (_a = this.socket) === null || _a === void 0 ? void 0 : _a._sender) === null || _b === void 0 ? void 0 : _b.sendFrame) === \"function\" && // @ts-ignore\n        ((_c = packet.options) === null || _c === void 0 ? void 0 : _c.wsPreEncodedFrame) !== undefined;\n    }\n    doClose(fn) {\n        debug(\"closing\");\n        this.socket.close();\n        fn && fn();\n    }\n}\nexports.WebSocket = WebSocket;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZW5naW5lLmlvL2J1aWxkL3RyYW5zcG9ydHMvd2Vic29ja2V0LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxpQkFBaUIsR0FBRyxLQUFLO0FBQ3pCLE1BQU1HLGNBQWNDLG1CQUFPQSxDQUFDLHVFQUFjO0FBQzFDLE1BQU1DLFVBQVVELG1CQUFPQSxDQUFDLDZFQUFPO0FBQy9CLE1BQU1FLFFBQVEsQ0FBQyxHQUFHRCxRQUFRRSxPQUFPLEVBQUU7QUFDbkMsTUFBTUwsa0JBQWtCQyxZQUFZSyxTQUFTO0lBQ3pDOzs7O0tBSUMsR0FDREMsWUFBWUMsR0FBRyxDQUFFO1FBQ2IsS0FBSyxDQUFDQTtRQUNOLElBQUksQ0FBQ0MsT0FBTyxHQUFHLENBQUNDO1lBQ1osSUFBSSxDQUFDQyxNQUFNLENBQUNDLElBQUksQ0FBQ0YsTUFBTSxJQUFJLENBQUNHLE9BQU87UUFDdkM7UUFDQSxJQUFJLENBQUNDLFdBQVcsR0FBRyxDQUFDSjtZQUNoQixJQUFJLENBQUNDLE1BQU0sQ0FBQ0MsSUFBSSxDQUFDRixNQUFNLElBQUksQ0FBQ0ssV0FBVztRQUMzQztRQUNBLElBQUksQ0FBQ0YsT0FBTyxHQUFHLENBQUNHO1lBQ1osSUFBSUEsS0FBSztnQkFDTCxJQUFJLENBQUNDLE9BQU8sQ0FBQyxlQUFlRCxJQUFJRSxLQUFLO1lBQ3pDO1FBQ0o7UUFDQSxJQUFJLENBQUNILFdBQVcsR0FBRyxDQUFDQztZQUNoQixJQUFJQSxLQUFLO2dCQUNMLElBQUksQ0FBQ0MsT0FBTyxDQUFDLGVBQWVELElBQUlFLEtBQUs7WUFDekMsT0FDSztnQkFDRCxJQUFJLENBQUNDLElBQUksQ0FBQztnQkFDVixJQUFJLENBQUNDLFFBQVEsR0FBRztnQkFDaEIsSUFBSSxDQUFDRCxJQUFJLENBQUM7WUFDZDtRQUNKO1FBQ0EsSUFBSSxDQUFDUixNQUFNLEdBQUdILElBQUlhLFNBQVM7UUFDM0IsSUFBSSxDQUFDVixNQUFNLENBQUNXLEVBQUUsQ0FBQyxXQUFXLENBQUNaLE1BQU1hO1lBQzdCLE1BQU1DLFVBQVVELFdBQVdiLE9BQU9BLEtBQUtlLFFBQVE7WUFDL0NyQixNQUFNLGlCQUFpQm9CO1lBQ3ZCLEtBQUssQ0FBQ0UsT0FBT0Y7UUFDakI7UUFDQSxJQUFJLENBQUNiLE1BQU0sQ0FBQ2dCLElBQUksQ0FBQyxTQUFTLElBQUksQ0FBQ0MsT0FBTyxDQUFDQyxJQUFJLENBQUMsSUFBSTtRQUNoRCxJQUFJLENBQUNsQixNQUFNLENBQUNXLEVBQUUsQ0FBQyxTQUFTLElBQUksQ0FBQ0wsT0FBTyxDQUFDWSxJQUFJLENBQUMsSUFBSTtRQUM5QyxJQUFJLENBQUNULFFBQVEsR0FBRztRQUNoQixJQUFJLENBQUNVLGlCQUFpQixHQUFHO0lBQzdCO0lBQ0E7O0tBRUMsR0FDRCxJQUFJQyxPQUFPO1FBQ1AsT0FBTztJQUNYO0lBQ0E7O0tBRUMsR0FDRCxJQUFJQyxrQkFBa0I7UUFDbEIsT0FBTztJQUNYO0lBQ0FwQixLQUFLcUIsT0FBTyxFQUFFO1FBQ1YsSUFBSSxDQUFDYixRQUFRLEdBQUc7UUFDaEIsSUFBSyxJQUFJYyxJQUFJLEdBQUdBLElBQUlELFFBQVFFLE1BQU0sRUFBRUQsSUFBSztZQUNyQyxNQUFNRSxTQUFTSCxPQUFPLENBQUNDLEVBQUU7WUFDekIsTUFBTUcsU0FBU0gsSUFBSSxNQUFNRCxRQUFRRSxNQUFNO1lBQ3ZDLElBQUksSUFBSSxDQUFDRyx1QkFBdUIsQ0FBQ0YsU0FBUztnQkFDdEMsaUVBQWlFO2dCQUNqRSx5RUFBeUU7Z0JBQ3pFLElBQUksQ0FBQ3pCLE1BQU0sQ0FBQzRCLE9BQU8sQ0FBQ0MsU0FBUyxDQUM3QixhQUFhO2dCQUNiSixPQUFPSyxPQUFPLENBQUNDLGlCQUFpQixFQUFFTCxTQUFTLElBQUksQ0FBQ3RCLFdBQVcsR0FBRyxJQUFJLENBQUNGLE9BQU87WUFDOUUsT0FDSztnQkFDRCxJQUFJLENBQUM4QixNQUFNLENBQUNDLFlBQVksQ0FBQ1IsUUFBUSxJQUFJLENBQUNTLGNBQWMsRUFBRVIsU0FBUyxJQUFJLENBQUN2QixXQUFXLEdBQUcsSUFBSSxDQUFDTCxPQUFPO1lBQ2xHO1FBQ0o7SUFDSjtJQUNBOzs7O0tBSUMsR0FDRDZCLHdCQUF3QkYsTUFBTSxFQUFFO1FBQzVCLElBQUlVLElBQUlDLElBQUlDO1FBQ1osT0FBUSxDQUFDLElBQUksQ0FBQ2xCLGlCQUFpQixJQUMzQixPQUFRLEVBQUNpQixLQUFLLENBQUNELEtBQUssSUFBSSxDQUFDbkMsTUFBTSxNQUFNLFFBQVFtQyxPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUdQLE9BQU8sTUFBTSxRQUFRUSxPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUdQLFNBQVMsTUFBTSxjQUV6SSxhQURhO1FBQ1osRUFBQ1EsS0FBS1osT0FBT0ssT0FBTyxNQUFNLFFBQVFPLE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBR04saUJBQWlCLE1BQU1PO0lBQzlGO0lBQ0FDLFFBQVFDLEVBQUUsRUFBRTtRQUNSL0MsTUFBTTtRQUNOLElBQUksQ0FBQ08sTUFBTSxDQUFDeUMsS0FBSztRQUNqQkQsTUFBTUE7SUFDVjtBQUNKO0FBQ0FyRCxpQkFBaUIsR0FBR0UiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9leGFtcm9zaC8uL25vZGVfbW9kdWxlcy9lbmdpbmUuaW8vYnVpbGQvdHJhbnNwb3J0cy93ZWJzb2NrZXQuanM/NDcxYSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuV2ViU29ja2V0ID0gdm9pZCAwO1xuY29uc3QgdHJhbnNwb3J0XzEgPSByZXF1aXJlKFwiLi4vdHJhbnNwb3J0XCIpO1xuY29uc3QgZGVidWdfMSA9IHJlcXVpcmUoXCJkZWJ1Z1wiKTtcbmNvbnN0IGRlYnVnID0gKDAsIGRlYnVnXzEuZGVmYXVsdCkoXCJlbmdpbmU6d3NcIik7XG5jbGFzcyBXZWJTb2NrZXQgZXh0ZW5kcyB0cmFuc3BvcnRfMS5UcmFuc3BvcnQge1xuICAgIC8qKlxuICAgICAqIFdlYlNvY2tldCB0cmFuc3BvcnRcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RW5naW5lUmVxdWVzdH0gcmVxXG4gICAgICovXG4gICAgY29uc3RydWN0b3IocmVxKSB7XG4gICAgICAgIHN1cGVyKHJlcSk7XG4gICAgICAgIHRoaXMuX2RvU2VuZCA9IChkYXRhKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnNvY2tldC5zZW5kKGRhdGEsIHRoaXMuX29uU2VudCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX2RvU2VuZExhc3QgPSAoZGF0YSkgPT4ge1xuICAgICAgICAgICAgdGhpcy5zb2NrZXQuc2VuZChkYXRhLCB0aGlzLl9vblNlbnRMYXN0KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5fb25TZW50ID0gKGVycikgPT4ge1xuICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgIHRoaXMub25FcnJvcihcIndyaXRlIGVycm9yXCIsIGVyci5zdGFjayk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX29uU2VudExhc3QgPSAoZXJyKSA9PiB7XG4gICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vbkVycm9yKFwid3JpdGUgZXJyb3JcIiwgZXJyLnN0YWNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcImRyYWluXCIpO1xuICAgICAgICAgICAgICAgIHRoaXMud3JpdGFibGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcInJlYWR5XCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLnNvY2tldCA9IHJlcS53ZWJzb2NrZXQ7XG4gICAgICAgIHRoaXMuc29ja2V0Lm9uKFwibWVzc2FnZVwiLCAoZGF0YSwgaXNCaW5hcnkpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBpc0JpbmFyeSA/IGRhdGEgOiBkYXRhLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICBkZWJ1ZygncmVjZWl2ZWQgXCIlc1wiJywgbWVzc2FnZSk7XG4gICAgICAgICAgICBzdXBlci5vbkRhdGEobWVzc2FnZSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnNvY2tldC5vbmNlKFwiY2xvc2VcIiwgdGhpcy5vbkNsb3NlLmJpbmQodGhpcykpO1xuICAgICAgICB0aGlzLnNvY2tldC5vbihcImVycm9yXCIsIHRoaXMub25FcnJvci5iaW5kKHRoaXMpKTtcbiAgICAgICAgdGhpcy53cml0YWJsZSA9IHRydWU7XG4gICAgICAgIHRoaXMucGVyTWVzc2FnZURlZmxhdGUgPSBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUcmFuc3BvcnQgbmFtZVxuICAgICAqL1xuICAgIGdldCBuYW1lKCkge1xuICAgICAgICByZXR1cm4gXCJ3ZWJzb2NrZXRcIjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWR2ZXJ0aXNlIHVwZ3JhZGUgc3VwcG9ydC5cbiAgICAgKi9cbiAgICBnZXQgaGFuZGxlc1VwZ3JhZGVzKCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgc2VuZChwYWNrZXRzKSB7XG4gICAgICAgIHRoaXMud3JpdGFibGUgPSBmYWxzZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYWNrZXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBwYWNrZXQgPSBwYWNrZXRzW2ldO1xuICAgICAgICAgICAgY29uc3QgaXNMYXN0ID0gaSArIDEgPT09IHBhY2tldHMubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKHRoaXMuX2NhblNlbmRQcmVFbmNvZGVkRnJhbWUocGFja2V0KSkge1xuICAgICAgICAgICAgICAgIC8vIHRoZSBXZWJTb2NrZXQgZnJhbWUgd2FzIGNvbXB1dGVkIHdpdGggV2ViU29ja2V0LlNlbmRlci5mcmFtZSgpXG4gICAgICAgICAgICAgICAgLy8gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS93ZWJzb2NrZXRzL3dzL2lzc3Vlcy82MTcjaXNzdWVjb21tZW50LTI4MzAwMjQ2OVxuICAgICAgICAgICAgICAgIHRoaXMuc29ja2V0Ll9zZW5kZXIuc2VuZEZyYW1lKFxuICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgICAgICBwYWNrZXQub3B0aW9ucy53c1ByZUVuY29kZWRGcmFtZSwgaXNMYXN0ID8gdGhpcy5fb25TZW50TGFzdCA6IHRoaXMuX29uU2VudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBhcnNlci5lbmNvZGVQYWNrZXQocGFja2V0LCB0aGlzLnN1cHBvcnRzQmluYXJ5LCBpc0xhc3QgPyB0aGlzLl9kb1NlbmRMYXN0IDogdGhpcy5fZG9TZW5kKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRoZSBlbmNvZGluZyBvZiB0aGUgV2ViU29ja2V0IGZyYW1lIGNhbiBiZSBza2lwcGVkLlxuICAgICAqIEBwYXJhbSBwYWNrZXRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9jYW5TZW5kUHJlRW5jb2RlZEZyYW1lKHBhY2tldCkge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgcmV0dXJuICghdGhpcy5wZXJNZXNzYWdlRGVmbGF0ZSAmJlxuICAgICAgICAgICAgdHlwZW9mICgoX2IgPSAoX2EgPSB0aGlzLnNvY2tldCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLl9zZW5kZXIpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5zZW5kRnJhbWUpID09PSBcImZ1bmN0aW9uXCIgJiZcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgICgoX2MgPSBwYWNrZXQub3B0aW9ucykgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLndzUHJlRW5jb2RlZEZyYW1lKSAhPT0gdW5kZWZpbmVkKTtcbiAgICB9XG4gICAgZG9DbG9zZShmbikge1xuICAgICAgICBkZWJ1ZyhcImNsb3NpbmdcIik7XG4gICAgICAgIHRoaXMuc29ja2V0LmNsb3NlKCk7XG4gICAgICAgIGZuICYmIGZuKCk7XG4gICAgfVxufVxuZXhwb3J0cy5XZWJTb2NrZXQgPSBXZWJTb2NrZXQ7XG4iXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJXZWJTb2NrZXQiLCJ0cmFuc3BvcnRfMSIsInJlcXVpcmUiLCJkZWJ1Z18xIiwiZGVidWciLCJkZWZhdWx0IiwiVHJhbnNwb3J0IiwiY29uc3RydWN0b3IiLCJyZXEiLCJfZG9TZW5kIiwiZGF0YSIsInNvY2tldCIsInNlbmQiLCJfb25TZW50IiwiX2RvU2VuZExhc3QiLCJfb25TZW50TGFzdCIsImVyciIsIm9uRXJyb3IiLCJzdGFjayIsImVtaXQiLCJ3cml0YWJsZSIsIndlYnNvY2tldCIsIm9uIiwiaXNCaW5hcnkiLCJtZXNzYWdlIiwidG9TdHJpbmciLCJvbkRhdGEiLCJvbmNlIiwib25DbG9zZSIsImJpbmQiLCJwZXJNZXNzYWdlRGVmbGF0ZSIsIm5hbWUiLCJoYW5kbGVzVXBncmFkZXMiLCJwYWNrZXRzIiwiaSIsImxlbmd0aCIsInBhY2tldCIsImlzTGFzdCIsIl9jYW5TZW5kUHJlRW5jb2RlZEZyYW1lIiwiX3NlbmRlciIsInNlbmRGcmFtZSIsIm9wdGlvbnMiLCJ3c1ByZUVuY29kZWRGcmFtZSIsInBhcnNlciIsImVuY29kZVBhY2tldCIsInN1cHBvcnRzQmluYXJ5IiwiX2EiLCJfYiIsIl9jIiwidW5kZWZpbmVkIiwiZG9DbG9zZSIsImZuIiwiY2xvc2UiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/engine.io/build/transports/websocket.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/engine.io/build/transports/webtransport.js":
/*!*****************************************************************!*\
  !*** ./node_modules/engine.io/build/transports/webtransport.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.WebTransport = void 0;\nconst transport_1 = __webpack_require__(/*! ../transport */ \"(rsc)/./node_modules/engine.io/build/transport.js\");\nconst debug_1 = __webpack_require__(/*! debug */ \"(rsc)/./node_modules/engine.io/node_modules/debug/src/index.js\");\nconst engine_io_parser_1 = __webpack_require__(/*! engine.io-parser */ \"(rsc)/./node_modules/engine.io-parser/build/cjs/index.js\");\nconst debug = (0, debug_1.default)(\"engine:webtransport\");\n/**\n * Reference: https://developer.mozilla.org/en-US/docs/Web/API/WebTransport_API\n */ class WebTransport extends transport_1.Transport {\n    constructor(session, stream, reader){\n        super({\n            _query: {\n                EIO: \"4\"\n            }\n        });\n        this.session = session;\n        const transformStream = (0, engine_io_parser_1.createPacketEncoderStream)();\n        transformStream.readable.pipeTo(stream.writable).catch(()=>{\n            debug(\"the stream was closed\");\n        });\n        this.writer = transformStream.writable.getWriter();\n        (async ()=>{\n            try {\n                while(true){\n                    const { value, done } = await reader.read();\n                    if (done) {\n                        debug(\"session is closed\");\n                        break;\n                    }\n                    debug(\"received chunk: %o\", value);\n                    this.onPacket(value);\n                }\n            } catch (e) {\n                debug(\"error while reading: %s\", e.message);\n            }\n        })();\n        session.closed.then(()=>this.onClose());\n        this.writable = true;\n    }\n    get name() {\n        return \"webtransport\";\n    }\n    async send(packets) {\n        this.writable = false;\n        try {\n            for(let i = 0; i < packets.length; i++){\n                const packet = packets[i];\n                await this.writer.write(packet);\n            }\n        } catch (e) {\n            debug(\"error while writing: %s\", e.message);\n        }\n        this.emit(\"drain\");\n        this.writable = true;\n        this.emit(\"ready\");\n    }\n    doClose(fn) {\n        debug(\"closing WebTransport session\");\n        this.session.close();\n        fn && fn();\n    }\n}\nexports.WebTransport = WebTransport;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZW5naW5lLmlvL2J1aWxkL3RyYW5zcG9ydHMvd2VidHJhbnNwb3J0LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxvQkFBb0IsR0FBRyxLQUFLO0FBQzVCLE1BQU1HLGNBQWNDLG1CQUFPQSxDQUFDLHVFQUFjO0FBQzFDLE1BQU1DLFVBQVVELG1CQUFPQSxDQUFDLDZFQUFPO0FBQy9CLE1BQU1FLHFCQUFxQkYsbUJBQU9BLENBQUMsa0ZBQWtCO0FBQ3JELE1BQU1HLFFBQVEsQ0FBQyxHQUFHRixRQUFRRyxPQUFPLEVBQUU7QUFDbkM7O0NBRUMsR0FDRCxNQUFNTixxQkFBcUJDLFlBQVlNLFNBQVM7SUFDNUNDLFlBQVlDLE9BQU8sRUFBRUMsTUFBTSxFQUFFQyxNQUFNLENBQUU7UUFDakMsS0FBSyxDQUFDO1lBQUVDLFFBQVE7Z0JBQUVDLEtBQUs7WUFBSTtRQUFFO1FBQzdCLElBQUksQ0FBQ0osT0FBTyxHQUFHQTtRQUNmLE1BQU1LLGtCQUFrQixDQUFDLEdBQUdWLG1CQUFtQlcseUJBQXlCO1FBQ3hFRCxnQkFBZ0JFLFFBQVEsQ0FBQ0MsTUFBTSxDQUFDUCxPQUFPUSxRQUFRLEVBQUVDLEtBQUssQ0FBQztZQUNuRGQsTUFBTTtRQUNWO1FBQ0EsSUFBSSxDQUFDZSxNQUFNLEdBQUdOLGdCQUFnQkksUUFBUSxDQUFDRyxTQUFTO1FBQy9DO1lBQ0csSUFBSTtnQkFDQSxNQUFPLEtBQU07b0JBQ1QsTUFBTSxFQUFFdEIsS0FBSyxFQUFFdUIsSUFBSSxFQUFFLEdBQUcsTUFBTVgsT0FBT1ksSUFBSTtvQkFDekMsSUFBSUQsTUFBTTt3QkFDTmpCLE1BQU07d0JBQ047b0JBQ0o7b0JBQ0FBLE1BQU0sc0JBQXNCTjtvQkFDNUIsSUFBSSxDQUFDeUIsUUFBUSxDQUFDekI7Z0JBQ2xCO1lBQ0osRUFDQSxPQUFPMEIsR0FBRztnQkFDTnBCLE1BQU0sMkJBQTJCb0IsRUFBRUMsT0FBTztZQUM5QztRQUNKO1FBQ0FqQixRQUFRa0IsTUFBTSxDQUFDQyxJQUFJLENBQUMsSUFBTSxJQUFJLENBQUNDLE9BQU87UUFDdEMsSUFBSSxDQUFDWCxRQUFRLEdBQUc7SUFDcEI7SUFDQSxJQUFJWSxPQUFPO1FBQ1AsT0FBTztJQUNYO0lBQ0EsTUFBTUMsS0FBS0MsT0FBTyxFQUFFO1FBQ2hCLElBQUksQ0FBQ2QsUUFBUSxHQUFHO1FBQ2hCLElBQUk7WUFDQSxJQUFLLElBQUllLElBQUksR0FBR0EsSUFBSUQsUUFBUUUsTUFBTSxFQUFFRCxJQUFLO2dCQUNyQyxNQUFNRSxTQUFTSCxPQUFPLENBQUNDLEVBQUU7Z0JBQ3pCLE1BQU0sSUFBSSxDQUFDYixNQUFNLENBQUNnQixLQUFLLENBQUNEO1lBQzVCO1FBQ0osRUFDQSxPQUFPVixHQUFHO1lBQ05wQixNQUFNLDJCQUEyQm9CLEVBQUVDLE9BQU87UUFDOUM7UUFDQSxJQUFJLENBQUNXLElBQUksQ0FBQztRQUNWLElBQUksQ0FBQ25CLFFBQVEsR0FBRztRQUNoQixJQUFJLENBQUNtQixJQUFJLENBQUM7SUFDZDtJQUNBQyxRQUFRQyxFQUFFLEVBQUU7UUFDUmxDLE1BQU07UUFDTixJQUFJLENBQUNJLE9BQU8sQ0FBQytCLEtBQUs7UUFDbEJELE1BQU1BO0lBQ1Y7QUFDSjtBQUNBekMsb0JBQW9CLEdBQUdFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZXhhbXJvc2gvLi9ub2RlX21vZHVsZXMvZW5naW5lLmlvL2J1aWxkL3RyYW5zcG9ydHMvd2VidHJhbnNwb3J0LmpzPzc0MTgiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLldlYlRyYW5zcG9ydCA9IHZvaWQgMDtcbmNvbnN0IHRyYW5zcG9ydF8xID0gcmVxdWlyZShcIi4uL3RyYW5zcG9ydFwiKTtcbmNvbnN0IGRlYnVnXzEgPSByZXF1aXJlKFwiZGVidWdcIik7XG5jb25zdCBlbmdpbmVfaW9fcGFyc2VyXzEgPSByZXF1aXJlKFwiZW5naW5lLmlvLXBhcnNlclwiKTtcbmNvbnN0IGRlYnVnID0gKDAsIGRlYnVnXzEuZGVmYXVsdCkoXCJlbmdpbmU6d2VidHJhbnNwb3J0XCIpO1xuLyoqXG4gKiBSZWZlcmVuY2U6IGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9XZWJUcmFuc3BvcnRfQVBJXG4gKi9cbmNsYXNzIFdlYlRyYW5zcG9ydCBleHRlbmRzIHRyYW5zcG9ydF8xLlRyYW5zcG9ydCB7XG4gICAgY29uc3RydWN0b3Ioc2Vzc2lvbiwgc3RyZWFtLCByZWFkZXIpIHtcbiAgICAgICAgc3VwZXIoeyBfcXVlcnk6IHsgRUlPOiBcIjRcIiB9IH0pO1xuICAgICAgICB0aGlzLnNlc3Npb24gPSBzZXNzaW9uO1xuICAgICAgICBjb25zdCB0cmFuc2Zvcm1TdHJlYW0gPSAoMCwgZW5naW5lX2lvX3BhcnNlcl8xLmNyZWF0ZVBhY2tldEVuY29kZXJTdHJlYW0pKCk7XG4gICAgICAgIHRyYW5zZm9ybVN0cmVhbS5yZWFkYWJsZS5waXBlVG8oc3RyZWFtLndyaXRhYmxlKS5jYXRjaCgoKSA9PiB7XG4gICAgICAgICAgICBkZWJ1ZyhcInRoZSBzdHJlYW0gd2FzIGNsb3NlZFwiKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMud3JpdGVyID0gdHJhbnNmb3JtU3RyZWFtLndyaXRhYmxlLmdldFdyaXRlcigpO1xuICAgICAgICAoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IHZhbHVlLCBkb25lIH0gPSBhd2FpdCByZWFkZXIucmVhZCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVidWcoXCJzZXNzaW9uIGlzIGNsb3NlZFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGRlYnVnKFwicmVjZWl2ZWQgY2h1bms6ICVvXCIsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vblBhY2tldCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBkZWJ1ZyhcImVycm9yIHdoaWxlIHJlYWRpbmc6ICVzXCIsIGUubWVzc2FnZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pKCk7XG4gICAgICAgIHNlc3Npb24uY2xvc2VkLnRoZW4oKCkgPT4gdGhpcy5vbkNsb3NlKCkpO1xuICAgICAgICB0aGlzLndyaXRhYmxlID0gdHJ1ZTtcbiAgICB9XG4gICAgZ2V0IG5hbWUoKSB7XG4gICAgICAgIHJldHVybiBcIndlYnRyYW5zcG9ydFwiO1xuICAgIH1cbiAgICBhc3luYyBzZW5kKHBhY2tldHMpIHtcbiAgICAgICAgdGhpcy53cml0YWJsZSA9IGZhbHNlO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYWNrZXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcGFja2V0ID0gcGFja2V0c1tpXTtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLndyaXRlci53cml0ZShwYWNrZXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBkZWJ1ZyhcImVycm9yIHdoaWxlIHdyaXRpbmc6ICVzXCIsIGUubWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lbWl0KFwiZHJhaW5cIik7XG4gICAgICAgIHRoaXMud3JpdGFibGUgPSB0cnVlO1xuICAgICAgICB0aGlzLmVtaXQoXCJyZWFkeVwiKTtcbiAgICB9XG4gICAgZG9DbG9zZShmbikge1xuICAgICAgICBkZWJ1ZyhcImNsb3NpbmcgV2ViVHJhbnNwb3J0IHNlc3Npb25cIik7XG4gICAgICAgIHRoaXMuc2Vzc2lvbi5jbG9zZSgpO1xuICAgICAgICBmbiAmJiBmbigpO1xuICAgIH1cbn1cbmV4cG9ydHMuV2ViVHJhbnNwb3J0ID0gV2ViVHJhbnNwb3J0O1xuIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiV2ViVHJhbnNwb3J0IiwidHJhbnNwb3J0XzEiLCJyZXF1aXJlIiwiZGVidWdfMSIsImVuZ2luZV9pb19wYXJzZXJfMSIsImRlYnVnIiwiZGVmYXVsdCIsIlRyYW5zcG9ydCIsImNvbnN0cnVjdG9yIiwic2Vzc2lvbiIsInN0cmVhbSIsInJlYWRlciIsIl9xdWVyeSIsIkVJTyIsInRyYW5zZm9ybVN0cmVhbSIsImNyZWF0ZVBhY2tldEVuY29kZXJTdHJlYW0iLCJyZWFkYWJsZSIsInBpcGVUbyIsIndyaXRhYmxlIiwiY2F0Y2giLCJ3cml0ZXIiLCJnZXRXcml0ZXIiLCJkb25lIiwicmVhZCIsIm9uUGFja2V0IiwiZSIsIm1lc3NhZ2UiLCJjbG9zZWQiLCJ0aGVuIiwib25DbG9zZSIsIm5hbWUiLCJzZW5kIiwicGFja2V0cyIsImkiLCJsZW5ndGgiLCJwYWNrZXQiLCJ3cml0ZSIsImVtaXQiLCJkb0Nsb3NlIiwiZm4iLCJjbG9zZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/engine.io/build/transports/webtransport.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/engine.io/build/userver.js":
/*!*************************************************!*\
  !*** ./node_modules/engine.io/build/userver.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.uServer = void 0;\nconst debug_1 = __webpack_require__(/*! debug */ \"(rsc)/./node_modules/engine.io/node_modules/debug/src/index.js\");\nconst server_1 = __webpack_require__(/*! ./server */ \"(rsc)/./node_modules/engine.io/build/server.js\");\nconst transports_uws_1 = __webpack_require__(/*! ./transports-uws */ \"(rsc)/./node_modules/engine.io/build/transports-uws/index.js\");\nconst debug = (0, debug_1.default)(\"engine:uws\");\n/**\n * An Engine.IO server based on the `uWebSockets.js` package.\n */ // TODO export it into its own package\nclass uServer extends server_1.BaseServer {\n    init() {}\n    cleanup() {}\n    /**\n     * Prepares a request by processing the query string.\n     *\n     * @private\n     */ prepare(req, res) {\n        req.method = req.getMethod().toUpperCase();\n        req.url = req.getUrl();\n        const params = new URLSearchParams(req.getQuery());\n        req._query = Object.fromEntries(params.entries());\n        req.headers = {};\n        req.forEach((key, value)=>{\n            req.headers[key] = value;\n        });\n        req.connection = {\n            remoteAddress: Buffer.from(res.getRemoteAddressAsText()).toString()\n        };\n        res.onAborted(()=>{\n            debug(\"response has been aborted\");\n        });\n    }\n    createTransport(transportName, req) {\n        return new transports_uws_1.default[transportName](req);\n    }\n    /**\n     * Attach the engine to a WebSockets.js server\n     * @param app\n     * @param options\n     */ attach(app /* : TemplatedApp */ , options = {}) {\n        const path = this._computePath(options);\n        app.any(path, this.handleRequest.bind(this))//\n        .ws(path, {\n            compression: options.compression,\n            idleTimeout: options.idleTimeout,\n            maxBackpressure: options.maxBackpressure,\n            maxPayloadLength: this.opts.maxHttpBufferSize,\n            upgrade: this.handleUpgrade.bind(this),\n            open: (ws)=>{\n                const transport = ws.getUserData().transport;\n                transport.socket = ws;\n                transport.writable = true;\n                transport.emit(\"ready\");\n            },\n            message: (ws, message, isBinary)=>{\n                ws.getUserData().transport.onData(isBinary ? message : Buffer.from(message).toString());\n            },\n            close: (ws, code, message)=>{\n                ws.getUserData().transport.onClose(code, message);\n            }\n        });\n    }\n    _applyMiddlewares(req, res, callback) {\n        if (this.middlewares.length === 0) {\n            return callback();\n        }\n        // needed to buffer headers until the status is computed\n        req.res = new ResponseWrapper(res);\n        super._applyMiddlewares(req, req.res, (err)=>{\n            // some middlewares (like express-session) wait for the writeHead() call to flush their headers\n            // see https://github.com/expressjs/session/blob/1010fadc2f071ddf2add94235d72224cf65159c6/index.js#L220-L244\n            req.res.writeHead();\n            callback(err);\n        });\n    }\n    handleRequest(res, req) {\n        debug('handling \"%s\" http request \"%s\"', req.getMethod(), req.getUrl());\n        this.prepare(req, res);\n        req.res = res;\n        const callback = (errorCode, errorContext)=>{\n            if (errorCode !== undefined) {\n                this.emit(\"connection_error\", {\n                    req,\n                    code: errorCode,\n                    message: server_1.Server.errorMessages[errorCode],\n                    context: errorContext\n                });\n                this.abortRequest(req.res, errorCode, errorContext);\n                return;\n            }\n            if (req._query.sid) {\n                debug(\"setting new request for existing client\");\n                // @ts-ignore\n                this.clients[req._query.sid].transport.onRequest(req);\n            } else {\n                const closeConnection = (errorCode, errorContext)=>this.abortRequest(res, errorCode, errorContext);\n                this.handshake(req._query.transport, req, closeConnection);\n            }\n        };\n        this._applyMiddlewares(req, res, (err)=>{\n            if (err) {\n                callback(server_1.Server.errors.BAD_REQUEST, {\n                    name: \"MIDDLEWARE_FAILURE\"\n                });\n            } else {\n                this.verify(req, false, callback);\n            }\n        });\n    }\n    handleUpgrade(res, req, context) {\n        debug(\"on upgrade\");\n        this.prepare(req, res);\n        req.res = res;\n        const callback = async (errorCode, errorContext)=>{\n            if (errorCode !== undefined) {\n                this.emit(\"connection_error\", {\n                    req,\n                    code: errorCode,\n                    message: server_1.Server.errorMessages[errorCode],\n                    context: errorContext\n                });\n                this.abortRequest(res, errorCode, errorContext);\n                return;\n            }\n            const id = req._query.sid;\n            let transport;\n            if (id) {\n                const client = this.clients[id];\n                if (!client) {\n                    debug(\"upgrade attempt for closed client\");\n                    return res.close();\n                } else if (client.upgrading) {\n                    debug(\"transport has already been trying to upgrade\");\n                    return res.close();\n                } else if (client.upgraded) {\n                    debug(\"transport had already been upgraded\");\n                    return res.close();\n                } else {\n                    debug(\"upgrading existing transport\");\n                    transport = this.createTransport(req._query.transport, req);\n                    client._maybeUpgrade(transport);\n                }\n            } else {\n                transport = await this.handshake(req._query.transport, req, (errorCode, errorContext)=>this.abortRequest(res, errorCode, errorContext));\n                if (!transport) {\n                    return;\n                }\n            }\n            // calling writeStatus() triggers the flushing of any header added in a middleware\n            req.res.writeStatus(\"101 Switching Protocols\");\n            res.upgrade({\n                transport\n            }, req.getHeader(\"sec-websocket-key\"), req.getHeader(\"sec-websocket-protocol\"), req.getHeader(\"sec-websocket-extensions\"), context);\n        };\n        this._applyMiddlewares(req, res, (err)=>{\n            if (err) {\n                callback(server_1.Server.errors.BAD_REQUEST, {\n                    name: \"MIDDLEWARE_FAILURE\"\n                });\n            } else {\n                this.verify(req, true, callback);\n            }\n        });\n    }\n    abortRequest(res, errorCode, errorContext) {\n        const statusCode = errorCode === server_1.Server.errors.FORBIDDEN ? \"403 Forbidden\" : \"400 Bad Request\";\n        const message = errorContext && errorContext.message ? errorContext.message : server_1.Server.errorMessages[errorCode];\n        res.writeStatus(statusCode);\n        res.writeHeader(\"Content-Type\", \"application/json\");\n        res.end(JSON.stringify({\n            code: errorCode,\n            message\n        }));\n    }\n}\nexports.uServer = uServer;\nclass ResponseWrapper {\n    constructor(res){\n        this.res = res;\n        this.statusWritten = false;\n        this.headers = [];\n        this.isAborted = false;\n    }\n    set statusCode(status) {\n        if (!status) {\n            return;\n        }\n        // FIXME: handle all status codes?\n        this.writeStatus(status === 200 ? \"200 OK\" : \"204 No Content\");\n    }\n    writeHead(status) {\n        this.statusCode = status;\n    }\n    setHeader(key, value) {\n        if (Array.isArray(value)) {\n            value.forEach((val)=>{\n                this.writeHeader(key, val);\n            });\n        } else {\n            this.writeHeader(key, value);\n        }\n    }\n    removeHeader() {\n    // FIXME: not implemented\n    }\n    // needed by vary: https://github.com/jshttp/vary/blob/5d725d059b3871025cf753e9dfa08924d0bcfa8f/index.js#L134\n    getHeader() {}\n    writeStatus(status) {\n        if (this.isAborted) return;\n        this.res.writeStatus(status);\n        this.statusWritten = true;\n        this.writeBufferedHeaders();\n        return this;\n    }\n    writeHeader(key, value) {\n        if (this.isAborted) return;\n        if (key === \"Content-Length\") {\n            // the content length is automatically added by uWebSockets.js\n            return;\n        }\n        if (this.statusWritten) {\n            this.res.writeHeader(key, value);\n        } else {\n            this.headers.push([\n                key,\n                value\n            ]);\n        }\n    }\n    writeBufferedHeaders() {\n        this.headers.forEach(([key, value])=>{\n            this.res.writeHeader(key, value);\n        });\n    }\n    end(data) {\n        if (this.isAborted) return;\n        this.res.cork(()=>{\n            if (!this.statusWritten) {\n                // status will be inferred as \"200 OK\"\n                this.writeBufferedHeaders();\n            }\n            this.res.end(data);\n        });\n    }\n    onData(fn) {\n        if (this.isAborted) return;\n        this.res.onData(fn);\n    }\n    onAborted(fn) {\n        if (this.isAborted) return;\n        this.res.onAborted(()=>{\n            // Any attempt to use the UWS response object after abort will throw!\n            this.isAborted = true;\n            fn();\n        });\n    }\n    cork(fn) {\n        if (this.isAborted) return;\n        this.res.cork(fn);\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZW5naW5lLmlvL2J1aWxkL3VzZXJ2ZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELGVBQWUsR0FBRyxLQUFLO0FBQ3ZCLE1BQU1HLFVBQVVDLG1CQUFPQSxDQUFDLDZFQUFPO0FBQy9CLE1BQU1DLFdBQVdELG1CQUFPQSxDQUFDLGdFQUFVO0FBQ25DLE1BQU1FLG1CQUFtQkYsbUJBQU9BLENBQUMsc0ZBQWtCO0FBQ25ELE1BQU1HLFFBQVEsQ0FBQyxHQUFHSixRQUFRSyxPQUFPLEVBQUU7QUFDbkM7O0NBRUMsR0FDRCxzQ0FBc0M7QUFDdEMsTUFBTU4sZ0JBQWdCRyxTQUFTSSxVQUFVO0lBQ3JDQyxPQUFPLENBQUU7SUFDVEMsVUFBVSxDQUFFO0lBQ1o7Ozs7S0FJQyxHQUNEQyxRQUFRQyxHQUFHLEVBQUVDLEdBQUcsRUFBRTtRQUNkRCxJQUFJRSxNQUFNLEdBQUdGLElBQUlHLFNBQVMsR0FBR0MsV0FBVztRQUN4Q0osSUFBSUssR0FBRyxHQUFHTCxJQUFJTSxNQUFNO1FBQ3BCLE1BQU1DLFNBQVMsSUFBSUMsZ0JBQWdCUixJQUFJUyxRQUFRO1FBQy9DVCxJQUFJVSxNQUFNLEdBQUd6QixPQUFPMEIsV0FBVyxDQUFDSixPQUFPSyxPQUFPO1FBQzlDWixJQUFJYSxPQUFPLEdBQUcsQ0FBQztRQUNmYixJQUFJYyxPQUFPLENBQUMsQ0FBQ0MsS0FBSzNCO1lBQ2RZLElBQUlhLE9BQU8sQ0FBQ0UsSUFBSSxHQUFHM0I7UUFDdkI7UUFDQVksSUFBSWdCLFVBQVUsR0FBRztZQUNiQyxlQUFlQyxPQUFPQyxJQUFJLENBQUNsQixJQUFJbUIsc0JBQXNCLElBQUlDLFFBQVE7UUFDckU7UUFDQXBCLElBQUlxQixTQUFTLENBQUM7WUFDVjVCLE1BQU07UUFDVjtJQUNKO0lBQ0E2QixnQkFBZ0JDLGFBQWEsRUFBRXhCLEdBQUcsRUFBRTtRQUNoQyxPQUFPLElBQUlQ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SSxDQUFDWCxTQUFTLEVBQ2Q7UUFDSixJQUFJLENBQUMzRixHQUFHLENBQUNxRyxJQUFJLENBQUNDO0lBQ2xCO0FBQ0oiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9leGFtcm9zaC8uL25vZGVfbW9kdWxlcy9lbmdpbmUuaW8vYnVpbGQvdXNlcnZlci5qcz9lYjkyIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy51U2VydmVyID0gdm9pZCAwO1xuY29uc3QgZGVidWdfMSA9IHJlcXVpcmUoXCJkZWJ1Z1wiKTtcbmNvbnN0IHNlcnZlcl8xID0gcmVxdWlyZShcIi4vc2VydmVyXCIpO1xuY29uc3QgdHJhbnNwb3J0c191d3NfMSA9IHJlcXVpcmUoXCIuL3RyYW5zcG9ydHMtdXdzXCIpO1xuY29uc3QgZGVidWcgPSAoMCwgZGVidWdfMS5kZWZhdWx0KShcImVuZ2luZTp1d3NcIik7XG4vKipcbiAqIEFuIEVuZ2luZS5JTyBzZXJ2ZXIgYmFzZWQgb24gdGhlIGB1V2ViU29ja2V0cy5qc2AgcGFja2FnZS5cbiAqL1xuLy8gVE9ETyBleHBvcnQgaXQgaW50byBpdHMgb3duIHBhY2thZ2VcbmNsYXNzIHVTZXJ2ZXIgZXh0ZW5kcyBzZXJ2ZXJfMS5CYXNlU2VydmVyIHtcbiAgICBpbml0KCkgeyB9XG4gICAgY2xlYW51cCgpIHsgfVxuICAgIC8qKlxuICAgICAqIFByZXBhcmVzIGEgcmVxdWVzdCBieSBwcm9jZXNzaW5nIHRoZSBxdWVyeSBzdHJpbmcuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHByZXBhcmUocmVxLCByZXMpIHtcbiAgICAgICAgcmVxLm1ldGhvZCA9IHJlcS5nZXRNZXRob2QoKS50b1VwcGVyQ2FzZSgpO1xuICAgICAgICByZXEudXJsID0gcmVxLmdldFVybCgpO1xuICAgICAgICBjb25zdCBwYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKHJlcS5nZXRRdWVyeSgpKTtcbiAgICAgICAgcmVxLl9xdWVyeSA9IE9iamVjdC5mcm9tRW50cmllcyhwYXJhbXMuZW50cmllcygpKTtcbiAgICAgICAgcmVxLmhlYWRlcnMgPSB7fTtcbiAgICAgICAgcmVxLmZvckVhY2goKGtleSwgdmFsdWUpID0+IHtcbiAgICAgICAgICAgIHJlcS5oZWFkZXJzW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJlcS5jb25uZWN0aW9uID0ge1xuICAgICAgICAgICAgcmVtb3RlQWRkcmVzczogQnVmZmVyLmZyb20ocmVzLmdldFJlbW90ZUFkZHJlc3NBc1RleHQoKSkudG9TdHJpbmcoKSxcbiAgICAgICAgfTtcbiAgICAgICAgcmVzLm9uQWJvcnRlZCgoKSA9PiB7XG4gICAgICAgICAgICBkZWJ1ZyhcInJlc3BvbnNlIGhhcyBiZWVuIGFib3J0ZWRcIik7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjcmVhdGVUcmFuc3BvcnQodHJhbnNwb3J0TmFtZSwgcmVxKSB7XG4gICAgICAgIHJldHVybiBuZXcgdHJhbnNwb3J0c191d3NfMS5kZWZhdWx0W3RyYW5zcG9ydE5hbWVdKHJlcSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEF0dGFjaCB0aGUgZW5naW5lIHRvIGEgwrVXZWJTb2NrZXRzLmpzIHNlcnZlclxuICAgICAqIEBwYXJhbSBhcHBcbiAgICAgKiBAcGFyYW0gb3B0aW9uc1xuICAgICAqL1xuICAgIGF0dGFjaChhcHAgLyogOiBUZW1wbGF0ZWRBcHAgKi8sIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICBjb25zdCBwYXRoID0gdGhpcy5fY29tcHV0ZVBhdGgob3B0aW9ucyk7XG4gICAgICAgIGFwcFxuICAgICAgICAgICAgLmFueShwYXRoLCB0aGlzLmhhbmRsZVJlcXVlc3QuYmluZCh0aGlzKSlcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAud3MocGF0aCwge1xuICAgICAgICAgICAgY29tcHJlc3Npb246IG9wdGlvbnMuY29tcHJlc3Npb24sXG4gICAgICAgICAgICBpZGxlVGltZW91dDogb3B0aW9ucy5pZGxlVGltZW91dCxcbiAgICAgICAgICAgIG1heEJhY2twcmVzc3VyZTogb3B0aW9ucy5tYXhCYWNrcHJlc3N1cmUsXG4gICAgICAgICAgICBtYXhQYXlsb2FkTGVuZ3RoOiB0aGlzLm9wdHMubWF4SHR0cEJ1ZmZlclNpemUsXG4gICAgICAgICAgICB1cGdyYWRlOiB0aGlzLmhhbmRsZVVwZ3JhZGUuYmluZCh0aGlzKSxcbiAgICAgICAgICAgIG9wZW46ICh3cykgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRyYW5zcG9ydCA9IHdzLmdldFVzZXJEYXRhKCkudHJhbnNwb3J0O1xuICAgICAgICAgICAgICAgIHRyYW5zcG9ydC5zb2NrZXQgPSB3cztcbiAgICAgICAgICAgICAgICB0cmFuc3BvcnQud3JpdGFibGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRyYW5zcG9ydC5lbWl0KFwicmVhZHlcIik7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbWVzc2FnZTogKHdzLCBtZXNzYWdlLCBpc0JpbmFyeSkgPT4ge1xuICAgICAgICAgICAgICAgIHdzLmdldFVzZXJEYXRhKCkudHJhbnNwb3J0Lm9uRGF0YShpc0JpbmFyeSA/IG1lc3NhZ2UgOiBCdWZmZXIuZnJvbShtZXNzYWdlKS50b1N0cmluZygpKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjbG9zZTogKHdzLCBjb2RlLCBtZXNzYWdlKSA9PiB7XG4gICAgICAgICAgICAgICAgd3MuZ2V0VXNlckRhdGEoKS50cmFuc3BvcnQub25DbG9zZShjb2RlLCBtZXNzYWdlKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBfYXBwbHlNaWRkbGV3YXJlcyhyZXEsIHJlcywgY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKHRoaXMubWlkZGxld2FyZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBuZWVkZWQgdG8gYnVmZmVyIGhlYWRlcnMgdW50aWwgdGhlIHN0YXR1cyBpcyBjb21wdXRlZFxuICAgICAgICByZXEucmVzID0gbmV3IFJlc3BvbnNlV3JhcHBlcihyZXMpO1xuICAgICAgICBzdXBlci5fYXBwbHlNaWRkbGV3YXJlcyhyZXEsIHJlcS5yZXMsIChlcnIpID0+IHtcbiAgICAgICAgICAgIC8vIHNvbWUgbWlkZGxld2FyZXMgKGxpa2UgZXhwcmVzcy1zZXNzaW9uKSB3YWl0IGZvciB0aGUgd3JpdGVIZWFkKCkgY2FsbCB0byBmbHVzaCB0aGVpciBoZWFkZXJzXG4gICAgICAgICAgICAvLyBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2V4cHJlc3Nqcy9zZXNzaW9uL2Jsb2IvMTAxMGZhZGMyZjA3MWRkZjJhZGQ5NDIzNWQ3MjIyNGNmNjUxNTljNi9pbmRleC5qcyNMMjIwLUwyNDRcbiAgICAgICAgICAgIHJlcS5yZXMud3JpdGVIZWFkKCk7XG4gICAgICAgICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgaGFuZGxlUmVxdWVzdChyZXMsIHJlcSkge1xuICAgICAgICBkZWJ1ZygnaGFuZGxpbmcgXCIlc1wiIGh0dHAgcmVxdWVzdCBcIiVzXCInLCByZXEuZ2V0TWV0aG9kKCksIHJlcS5nZXRVcmwoKSk7XG4gICAgICAgIHRoaXMucHJlcGFyZShyZXEsIHJlcyk7XG4gICAgICAgIHJlcS5yZXMgPSByZXM7XG4gICAgICAgIGNvbnN0IGNhbGxiYWNrID0gKGVycm9yQ29kZSwgZXJyb3JDb250ZXh0KSA9PiB7XG4gICAgICAgICAgICBpZiAoZXJyb3JDb2RlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJjb25uZWN0aW9uX2Vycm9yXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgcmVxLFxuICAgICAgICAgICAgICAgICAgICBjb2RlOiBlcnJvckNvZGUsXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IHNlcnZlcl8xLlNlcnZlci5lcnJvck1lc3NhZ2VzW2Vycm9yQ29kZV0sXG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQ6IGVycm9yQ29udGV4dCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLmFib3J0UmVxdWVzdChyZXEucmVzLCBlcnJvckNvZGUsIGVycm9yQ29udGV4dCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlcS5fcXVlcnkuc2lkKSB7XG4gICAgICAgICAgICAgICAgZGVidWcoXCJzZXR0aW5nIG5ldyByZXF1ZXN0IGZvciBleGlzdGluZyBjbGllbnRcIik7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgICAgIHRoaXMuY2xpZW50c1tyZXEuX3F1ZXJ5LnNpZF0udHJhbnNwb3J0Lm9uUmVxdWVzdChyZXEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2xvc2VDb25uZWN0aW9uID0gKGVycm9yQ29kZSwgZXJyb3JDb250ZXh0KSA9PiB0aGlzLmFib3J0UmVxdWVzdChyZXMsIGVycm9yQ29kZSwgZXJyb3JDb250ZXh0KTtcbiAgICAgICAgICAgICAgICB0aGlzLmhhbmRzaGFrZShyZXEuX3F1ZXJ5LnRyYW5zcG9ydCwgcmVxLCBjbG9zZUNvbm5lY3Rpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLl9hcHBseU1pZGRsZXdhcmVzKHJlcSwgcmVzLCAoZXJyKSA9PiB7XG4gICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soc2VydmVyXzEuU2VydmVyLmVycm9ycy5CQURfUkVRVUVTVCwgeyBuYW1lOiBcIk1JRERMRVdBUkVfRkFJTFVSRVwiIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy52ZXJpZnkocmVxLCBmYWxzZSwgY2FsbGJhY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgaGFuZGxlVXBncmFkZShyZXMsIHJlcSwgY29udGV4dCkge1xuICAgICAgICBkZWJ1ZyhcIm9uIHVwZ3JhZGVcIik7XG4gICAgICAgIHRoaXMucHJlcGFyZShyZXEsIHJlcyk7XG4gICAgICAgIHJlcS5yZXMgPSByZXM7XG4gICAgICAgIGNvbnN0IGNhbGxiYWNrID0gYXN5bmMgKGVycm9yQ29kZSwgZXJyb3JDb250ZXh0KSA9PiB7XG4gICAgICAgICAgICBpZiAoZXJyb3JDb2RlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJjb25uZWN0aW9uX2Vycm9yXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgcmVxLFxuICAgICAgICAgICAgICAgICAgICBjb2RlOiBlcnJvckNvZGUsXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IHNlcnZlcl8xLlNlcnZlci5lcnJvck1lc3NhZ2VzW2Vycm9yQ29kZV0sXG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQ6IGVycm9yQ29udGV4dCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLmFib3J0UmVxdWVzdChyZXMsIGVycm9yQ29kZSwgZXJyb3JDb250ZXh0KTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBpZCA9IHJlcS5fcXVlcnkuc2lkO1xuICAgICAgICAgICAgbGV0IHRyYW5zcG9ydDtcbiAgICAgICAgICAgIGlmIChpZCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNsaWVudCA9IHRoaXMuY2xpZW50c1tpZF07XG4gICAgICAgICAgICAgICAgaWYgKCFjbGllbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVidWcoXCJ1cGdyYWRlIGF0dGVtcHQgZm9yIGNsb3NlZCBjbGllbnRcIik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXMuY2xvc2UoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoY2xpZW50LnVwZ3JhZGluZykge1xuICAgICAgICAgICAgICAgICAgICBkZWJ1ZyhcInRyYW5zcG9ydCBoYXMgYWxyZWFkeSBiZWVuIHRyeWluZyB0byB1cGdyYWRlXCIpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzLmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNsaWVudC51cGdyYWRlZCkge1xuICAgICAgICAgICAgICAgICAgICBkZWJ1ZyhcInRyYW5zcG9ydCBoYWQgYWxyZWFkeSBiZWVuIHVwZ3JhZGVkXCIpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzLmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBkZWJ1ZyhcInVwZ3JhZGluZyBleGlzdGluZyB0cmFuc3BvcnRcIik7XG4gICAgICAgICAgICAgICAgICAgIHRyYW5zcG9ydCA9IHRoaXMuY3JlYXRlVHJhbnNwb3J0KHJlcS5fcXVlcnkudHJhbnNwb3J0LCByZXEpO1xuICAgICAgICAgICAgICAgICAgICBjbGllbnQuX21heWJlVXBncmFkZSh0cmFuc3BvcnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRyYW5zcG9ydCA9IGF3YWl0IHRoaXMuaGFuZHNoYWtlKHJlcS5fcXVlcnkudHJhbnNwb3J0LCByZXEsIChlcnJvckNvZGUsIGVycm9yQ29udGV4dCkgPT4gdGhpcy5hYm9ydFJlcXVlc3QocmVzLCBlcnJvckNvZGUsIGVycm9yQ29udGV4dCkpO1xuICAgICAgICAgICAgICAgIGlmICghdHJhbnNwb3J0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBjYWxsaW5nIHdyaXRlU3RhdHVzKCkgdHJpZ2dlcnMgdGhlIGZsdXNoaW5nIG9mIGFueSBoZWFkZXIgYWRkZWQgaW4gYSBtaWRkbGV3YXJlXG4gICAgICAgICAgICByZXEucmVzLndyaXRlU3RhdHVzKFwiMTAxIFN3aXRjaGluZyBQcm90b2NvbHNcIik7XG4gICAgICAgICAgICByZXMudXBncmFkZSh7XG4gICAgICAgICAgICAgICAgdHJhbnNwb3J0LFxuICAgICAgICAgICAgfSwgcmVxLmdldEhlYWRlcihcInNlYy13ZWJzb2NrZXQta2V5XCIpLCByZXEuZ2V0SGVhZGVyKFwic2VjLXdlYnNvY2tldC1wcm90b2NvbFwiKSwgcmVxLmdldEhlYWRlcihcInNlYy13ZWJzb2NrZXQtZXh0ZW5zaW9uc1wiKSwgY29udGV4dCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX2FwcGx5TWlkZGxld2FyZXMocmVxLCByZXMsIChlcnIpID0+IHtcbiAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhzZXJ2ZXJfMS5TZXJ2ZXIuZXJyb3JzLkJBRF9SRVFVRVNULCB7IG5hbWU6IFwiTUlERExFV0FSRV9GQUlMVVJFXCIgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnZlcmlmeShyZXEsIHRydWUsIGNhbGxiYWNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFib3J0UmVxdWVzdChyZXMsIGVycm9yQ29kZSwgZXJyb3JDb250ZXh0KSB7XG4gICAgICAgIGNvbnN0IHN0YXR1c0NvZGUgPSBlcnJvckNvZGUgPT09IHNlcnZlcl8xLlNlcnZlci5lcnJvcnMuRk9SQklEREVOXG4gICAgICAgICAgICA/IFwiNDAzIEZvcmJpZGRlblwiXG4gICAgICAgICAgICA6IFwiNDAwIEJhZCBSZXF1ZXN0XCI7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBlcnJvckNvbnRleHQgJiYgZXJyb3JDb250ZXh0Lm1lc3NhZ2VcbiAgICAgICAgICAgID8gZXJyb3JDb250ZXh0Lm1lc3NhZ2VcbiAgICAgICAgICAgIDogc2VydmVyXzEuU2VydmVyLmVycm9yTWVzc2FnZXNbZXJyb3JDb2RlXTtcbiAgICAgICAgcmVzLndyaXRlU3RhdHVzKHN0YXR1c0NvZGUpO1xuICAgICAgICByZXMud3JpdGVIZWFkZXIoXCJDb250ZW50LVR5cGVcIiwgXCJhcHBsaWNhdGlvbi9qc29uXCIpO1xuICAgICAgICByZXMuZW5kKEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgIGNvZGU6IGVycm9yQ29kZSxcbiAgICAgICAgICAgIG1lc3NhZ2UsXG4gICAgICAgIH0pKTtcbiAgICB9XG59XG5leHBvcnRzLnVTZXJ2ZXIgPSB1U2VydmVyO1xuY2xhc3MgUmVzcG9uc2VXcmFwcGVyIHtcbiAgICBjb25zdHJ1Y3RvcihyZXMpIHtcbiAgICAgICAgdGhpcy5yZXMgPSByZXM7XG4gICAgICAgIHRoaXMuc3RhdHVzV3JpdHRlbiA9IGZhbHNlO1xuICAgICAgICB0aGlzLmhlYWRlcnMgPSBbXTtcbiAgICAgICAgdGhpcy5pc0Fib3J0ZWQgPSBmYWxzZTtcbiAgICB9XG4gICAgc2V0IHN0YXR1c0NvZGUoc3RhdHVzKSB7XG4gICAgICAgIGlmICghc3RhdHVzKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gRklYTUU6IGhhbmRsZSBhbGwgc3RhdHVzIGNvZGVzP1xuICAgICAgICB0aGlzLndyaXRlU3RhdHVzKHN0YXR1cyA9PT0gMjAwID8gXCIyMDAgT0tcIiA6IFwiMjA0IE5vIENvbnRlbnRcIik7XG4gICAgfVxuICAgIHdyaXRlSGVhZChzdGF0dXMpIHtcbiAgICAgICAgdGhpcy5zdGF0dXNDb2RlID0gc3RhdHVzO1xuICAgIH1cbiAgICBzZXRIZWFkZXIoa2V5LCB2YWx1ZSkge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHZhbHVlLmZvckVhY2goKHZhbCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMud3JpdGVIZWFkZXIoa2V5LCB2YWwpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLndyaXRlSGVhZGVyKGtleSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlbW92ZUhlYWRlcigpIHtcbiAgICAgICAgLy8gRklYTUU6IG5vdCBpbXBsZW1lbnRlZFxuICAgIH1cbiAgICAvLyBuZWVkZWQgYnkgdmFyeTogaHR0cHM6Ly9naXRodWIuY29tL2pzaHR0cC92YXJ5L2Jsb2IvNWQ3MjVkMDU5YjM4NzEwMjVjZjc1M2U5ZGZhMDg5MjRkMGJjZmE4Zi9pbmRleC5qcyNMMTM0XG4gICAgZ2V0SGVhZGVyKCkgeyB9XG4gICAgd3JpdGVTdGF0dXMoc3RhdHVzKSB7XG4gICAgICAgIGlmICh0aGlzLmlzQWJvcnRlZClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy5yZXMud3JpdGVTdGF0dXMoc3RhdHVzKTtcbiAgICAgICAgdGhpcy5zdGF0dXNXcml0dGVuID0gdHJ1ZTtcbiAgICAgICAgdGhpcy53cml0ZUJ1ZmZlcmVkSGVhZGVycygpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgd3JpdGVIZWFkZXIoa2V5LCB2YWx1ZSkge1xuICAgICAgICBpZiAodGhpcy5pc0Fib3J0ZWQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmIChrZXkgPT09IFwiQ29udGVudC1MZW5ndGhcIikge1xuICAgICAgICAgICAgLy8gdGhlIGNvbnRlbnQgbGVuZ3RoIGlzIGF1dG9tYXRpY2FsbHkgYWRkZWQgYnkgdVdlYlNvY2tldHMuanNcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5zdGF0dXNXcml0dGVuKSB7XG4gICAgICAgICAgICB0aGlzLnJlcy53cml0ZUhlYWRlcihrZXksIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuaGVhZGVycy5wdXNoKFtrZXksIHZhbHVlXSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgd3JpdGVCdWZmZXJlZEhlYWRlcnMoKSB7XG4gICAgICAgIHRoaXMuaGVhZGVycy5mb3JFYWNoKChba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgICAgICAgIHRoaXMucmVzLndyaXRlSGVhZGVyKGtleSwgdmFsdWUpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZW5kKGRhdGEpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNBYm9ydGVkKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLnJlcy5jb3JrKCgpID0+IHtcbiAgICAgICAgICAgIGlmICghdGhpcy5zdGF0dXNXcml0dGVuKSB7XG4gICAgICAgICAgICAgICAgLy8gc3RhdHVzIHdpbGwgYmUgaW5mZXJyZWQgYXMgXCIyMDAgT0tcIlxuICAgICAgICAgICAgICAgIHRoaXMud3JpdGVCdWZmZXJlZEhlYWRlcnMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucmVzLmVuZChkYXRhKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIG9uRGF0YShmbikge1xuICAgICAgICBpZiAodGhpcy5pc0Fib3J0ZWQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMucmVzLm9uRGF0YShmbik7XG4gICAgfVxuICAgIG9uQWJvcnRlZChmbikge1xuICAgICAgICBpZiAodGhpcy5pc0Fib3J0ZWQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMucmVzLm9uQWJvcnRlZCgoKSA9PiB7XG4gICAgICAgICAgICAvLyBBbnkgYXR0ZW1wdCB0byB1c2UgdGhlIFVXUyByZXNwb25zZSBvYmplY3QgYWZ0ZXIgYWJvcnQgd2lsbCB0aHJvdyFcbiAgICAgICAgICAgIHRoaXMuaXNBYm9ydGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGZuKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjb3JrKGZuKSB7XG4gICAgICAgIGlmICh0aGlzLmlzQWJvcnRlZClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy5yZXMuY29yayhmbik7XG4gICAgfVxufVxuIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwidVNlcnZlciIsImRlYnVnXzEiLCJyZXF1aXJlIiwic2VydmVyXzEiLCJ0cmFuc3BvcnRzX3V3c18xIiwiZGVidWciLCJkZWZhdWx0IiwiQmFzZVNlcnZlciIsImluaXQiLCJjbGVhbnVwIiwicHJlcGFyZSIsInJlcSIsInJlcyIsIm1ldGhvZCIsImdldE1ldGhvZCIsInRvVXBwZXJDYXNlIiwidXJsIiwiZ2V0VXJsIiwicGFyYW1zIiwiVVJMU2VhcmNoUGFyYW1zIiwiZ2V0UXVlcnkiLCJfcXVlcnkiLCJmcm9tRW50cmllcyIsImVudHJpZXMiLCJoZWFkZXJzIiwiZm9yRWFjaCIsImtleSIsImNvbm5lY3Rpb24iLCJyZW1vdGVBZGRyZXNzIiwiQnVmZmVyIiwiZnJvbSIsImdldFJlbW90ZUFkZHJlc3NBc1RleHQiLCJ0b1N0cmluZyIsIm9uQWJvcnRlZCIsImNyZWF0ZVRyYW5zcG9ydCIsInRyYW5zcG9ydE5hbWUiLCJhdHRhY2giLCJhcHAiLCJvcHRpb25zIiwicGF0aCIsIl9jb21wdXRlUGF0aCIsImFueSIsImhhbmRsZVJlcXVlc3QiLCJiaW5kIiwid3MiLCJjb21wcmVzc2lvbiIsImlkbGVUaW1lb3V0IiwibWF4QmFja3ByZXNzdXJlIiwibWF4UGF5bG9hZExlbmd0aCIsIm9wdHMiLCJtYXhIdHRwQnVmZmVyU2l6ZSIsInVwZ3JhZGUiLCJoYW5kbGVVcGdyYWRlIiwib3BlbiIsInRyYW5zcG9ydCIsImdldFVzZXJEYXRhIiwic29ja2V0Iiwid3JpdGFibGUiLCJlbWl0IiwibWVzc2FnZSIsImlzQmluYXJ5Iiwib25EYXRhIiwiY2xvc2UiLCJjb2RlIiwib25DbG9zZSIsIl9hcHBseU1pZGRsZXdhcmVzIiwiY2FsbGJhY2siLCJtaWRkbGV3YXJlcyIsImxlbmd0aCIsIlJlc3BvbnNlV3JhcHBlciIsImVyciIsIndyaXRlSGVhZCIsImVycm9yQ29kZSIsImVycm9yQ29udGV4dCIsInVuZGVmaW5lZCIsIlNlcnZlciIsImVycm9yTWVzc2FnZXMiLCJjb250ZXh0IiwiYWJvcnRSZXF1ZXN0Iiwic2lkIiwiY2xpZW50cyIsIm9uUmVxdWVzdCIsImNsb3NlQ29ubmVjdGlvbiIsImhhbmRzaGFrZSIsImVycm9ycyIsIkJBRF9SRVFVRVNUIiwibmFtZSIsInZlcmlmeSIsImlkIiwiY2xpZW50IiwidXBncmFkaW5nIiwidXBncmFkZWQiLCJfbWF5YmVVcGdyYWRlIiwid3JpdGVTdGF0dXMiLCJnZXRIZWFkZXIiLCJzdGF0dXNDb2RlIiwiRk9SQklEREVOIiwid3JpdGVIZWFkZXIiLCJlbmQiLCJKU09OIiwic3RyaW5naWZ5IiwiY29uc3RydWN0b3IiLCJzdGF0dXNXcml0dGVuIiwiaXNBYm9ydGVkIiwic3RhdHVzIiwic2V0SGVhZGVyIiwiQXJyYXkiLCJpc0FycmF5IiwidmFsIiwicmVtb3ZlSGVhZGVyIiwid3JpdGVCdWZmZXJlZEhlYWRlcnMiLCJwdXNoIiwiZGF0YSIsImNvcmsiLCJmbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/engine.io/build/userver.js\n");

/***/ })

};
;